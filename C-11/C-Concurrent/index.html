<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/largeicon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/smallicon.jpg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leager-zju.github.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="C++ 11 新增了官方并发支持库，使得我们能够更好地在系统间移植程序，之前的 Boost 库等也就随之成为历史了。">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 11 の 并发支持(Concurrency)">
<meta property="og:url" content="http://leager-zju.github.com/C-11/C-Concurrent/index.html">
<meta property="og:site_name" content="没什么看头的地方">
<meta property="og:description" content="C++ 11 新增了官方并发支持库，使得我们能够更好地在系统间移植程序，之前的 Boost 库等也就随之成为历史了。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-29T14:44:35.000Z">
<meta property="article:modified_time" content="2023-02-04T12:15:52.404Z">
<meta property="article:author" content="Leager">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://leager-zju.github.com/C-11/C-Concurrent/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>C++ 11 の 并发支持(Concurrency) | 没什么看头的地方</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">没什么看头的地方</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里可能没有你想看的...</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>文章分类<span class="badge">7</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间轴<span class="badge">49</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://leager-zju.github.com/C-11/C-Concurrent/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.jpg">
      <meta itemprop="name" content="Leager">
      <meta itemprop="description" content="【数据删除】">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="没什么看头的地方">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          C++ 11 の 并发支持(Concurrency)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-01-29 22:44:35" itemprop="dateCreated datePublished" datetime="2023-01-29T22:44:35+08:00">2023-01-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-02-04 20:15:52" itemprop="dateModified" datetime="2023-02-04T20:15:52+08:00">2023-02-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C-11/" itemprop="url" rel="index"><span itemprop="name">C++ 11</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>C++ 11 新增了官方并发支持库，使得我们能够更好地在系统间移植程序，之前的 Boost 库等也就随之成为历史了。</p>
<span id="more"></span>
<h2 id="并发与并行">并发与并行</h2>
<p>多线程的世界中，常常会涉及这俩重要概念。</p>
<p>从定义的角度来说，在操作系统中，<strong>并发</strong>是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行；而<strong>并行</strong>指的是一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。 （抄自百科）</p>
<p>用自己的语言描述：</p>
<ul>
<li>只会先把饭吃完，再把菜吃完，这叫<strong>单线程</strong>行为；</li>
<li>先扒拉几口饭，再夹点菜，再吃饭，以这一时间段为单位，两个行为看似一起进行，但任意时刻却又不同时发生，存在资源（嘴巴）的调度，这叫<strong>并发</strong>；</li>
<li>嘴巴里既嚼饭又嚼菜的，即同时吃饭吃菜，有能力同时处理多件事，这叫<strong>并行</strong>；</li>
</ul>
<p>综上所述，<strong>并发</strong>与<strong>并行</strong>的最主要区别，就在于各个线程是否能够“同时”进行。</p>
<h2 id="并发支持库">并发支持库</h2>
<p>并发支持库与 boost 很像，主要包含以下 5 个头文件。</p>
<h3 id="thread">&lt;thread&gt;</h3>
<blockquote>
<p>此头文件中定义了 <code>std::thread</code> 以及访问当前执行线程的函数 <code>std::this_thread</code></p>
</blockquote>
<h4 id="stdthread">std::thread</h4>
<p>该类管理<strong>单个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_(computing)">执行线程</a></strong>，并对外提供 api。</p>
<p>首先讲下<strong>初始化方式</strong>。由于每个线程都是一个独立的执行单位，故不存在两个同样的执行线程，那么<strong>拷贝构造</strong>与<strong>拷贝赋值</strong>因此被<strong>弃置</strong>(<code>delete</code>)。除此之外，其初始化方式共有四种重载形式：</p>
<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">重载形式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;"><code>thread() noexcept</code></td>
<td style="text-align: center;"><strong>默认构造函数</strong>。构造<strong>不</strong>关联执行线程的新 thread 对象。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>thread( thread&amp;&amp; other ) noexcept</code></td>
<td style="text-align: center;"><strong>移动构造函数</strong>。将 <code>other</code> 所关联的执行线程的资源转移，此后 <code>other</code> <strong>不</strong>关联任何执行线程。</td>
</tr>
<tr class="odd">
<td style="text-align: center;"><code>thread&amp; operator=( thread&amp;&amp; other ) noexcept</code></td>
<td style="text-align: center;"><strong>移动赋值函数</strong>。若当前对象此时拥有关联的运行中线程（即 <code>joinable() == true</code> ），则调用 <code>std::terminate()</code>。</td>
</tr>
<tr class="even">
<td style="text-align: center;"><code>template&lt; class Func, class... Args &gt; explicit thread( Func&amp;&amp; f, Args&amp;&amp;... args )</code></td>
<td style="text-align: center;"><strong>初始化构造函数</strong>。thread 创建并关联一个新的执行线程，开始执行可调用对象 <code>f</code>，相应参数也一并给出。</td>
</tr>
</tbody>
</table>
<p>接下来是其<strong>成员函数</strong>：</p>
<ol type="1">
<li><p><code>get_id()</code>：任何关联执行线程的 thread 对象均有一个唯一标识线程的对象 <code>id</code>。若当前对象存在关联的执行线程，则返回其 <code>id</code>；反之，输出 “<strong>thread::id of a non-executing thread</strong>”。</p></li>
<li><p><code>join()</code>：阻塞当前线程直至 thread 对象关联的线程运行完毕。当前线程的 <code>id</code> 不能与 thread 的 <code>id</code> 相同，否则出现死锁（自己等自己）。并且，thread 自身不进行同步。同时从多个线程在同一 thread 对象上调用 <code>join()</code> 构成数据竞争，导致 <strong>UB</strong>。</p></li>
<li><p><code>joinable()</code>：判断当前 thread 是否可以 join，即是否关联<strong>活跃</strong>的执行线程。简单来说，就是<strong>是否正在执行</strong>。结束执行但未 join 的 thread 也视为 <strong>joinable</strong>。由默认构造函数生成的 thread 对象 <code>joinable() == false</code>。</p></li>
<li><p><code>detach()</code>：从 thread 对象分离执行线程，允许其独立执行。线程结束后，才释放资源。分离后，thread 也就不再关联任何执行对象了，既无法 <code>get_id()</code>，也无法 <code>join()</code>。</p>
<blockquote>
<p>考虑这样一种情况：</p>
<p>若 thread 关联的线程执行周期比 thread 对象生命周期还长，则当 thread 周期结束后调用析构函数删除资源时，如果没有调用 <code>join()</code> 或 <code>detach()</code>，此时线程仍在运行，则会出大问题。</p>
<p>所以要么用 <code>join()</code> 来阻塞当前线程防止过早结束，要么用 <code>detach()</code> 进行线程与 thread 对象的分离。</p>
<p>当然，也可以进一步封装 thread，在析构函数中调用 <code>join()</code> / <code>detach()</code> 操作，就不会出现上述情况了。</p>
</blockquote></li>
<li><p><code>native_handler()</code>：返回实现线程句柄，实现实时调度。</p></li>
<li><p><code>[static] hardware_concurrency()</code>：静态方法，返回实现支持的并发线程数。</p></li>
</ol>
<p>下面用具体代码进行演示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="string">&quot;Thread &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; executing\n&quot;</span>;</span><br><span class="line">  this_thread::<span class="built_in">sleep_for</span>(chrono::<span class="built_in">seconds</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  thread t1;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(foo, <span class="number">2</span>)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t3</span><span class="params">(foo, <span class="number">3</span>)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t4</span><span class="params">(std::move(t3))</span></span>;</span><br><span class="line"></span><br><span class="line">  cout &lt;&lt; boolalpha</span><br><span class="line">       &lt;&lt; <span class="string">&quot;t1 id: &quot;</span> &lt;&lt; t1.<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, joinable: &quot;</span> &lt;&lt; t1.<span class="built_in">joinable</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;t2 id: &quot;</span> &lt;&lt; t2.<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, joinable: &quot;</span> &lt;&lt; t2.<span class="built_in">joinable</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;t3 id: &quot;</span> &lt;&lt; t3.<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, joinable: &quot;</span> &lt;&lt; t3.<span class="built_in">joinable</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">       &lt;&lt; <span class="string">&quot;t4 id: &quot;</span> &lt;&lt; t4.<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;, joinable: &quot;</span> &lt;&lt; t4.<span class="built_in">joinable</span>() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t4.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * output:</span></span><br><span class="line"><span class="comment"> * Thread 3 executing</span></span><br><span class="line"><span class="comment"> * Thread 2 executing</span></span><br><span class="line"><span class="comment"> * t1 id: thread::id of a non-executing thread, joinable: false</span></span><br><span class="line"><span class="comment"> * t2 id: 2, joinable: true</span></span><br><span class="line"><span class="comment"> * t3 id: thread::id of a non-executing thread, joinable: false</span></span><br><span class="line"><span class="comment"> * t4 id: 3, joinable: true</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="stdthis_thread">std::this_thread</h4>
<p>这实际上是 <code>std</code> 下的一个命名空间，用来表示当前线程。</p>
<p>该命名空间下有以下常用成员函数：</p>
<ol type="1">
<li><p><code>get_id()</code>：获取当前线程 <code>id</code>。</p></li>
<li><p><code>yield()</code>：让出 CPU 资源；</p></li>
<li><p><code>sleep_for()</code>：当前线程主动睡眠指定时间后醒来。<strong>函数原型</strong>为</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sleep_for</span><span class="params">(<span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; time)</span></span></span><br></pre></td></tr></table></figure></p></li>
<li><p><code>sleep_until()</code>：当前线程主动睡眠，直至指定时刻。<strong>函数原型</strong>为</p>
<p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration &gt;</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">sleep_until</span><span class="params">(<span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; time)</span></span></span><br></pre></td></tr></table></figure></p></li>
</ol>
<h3 id="mutex">&lt;mutex&gt;</h3>
<blockquote>
<p>此头文件中定义了各种互斥锁如 <code>std::mutex</code>，<code>std::lock_guard</code>，<code>std::unique_lock</code> 等</p>
</blockquote>
<h4 id="stdmutex">std::mutex</h4>
<p>mutex，全称 <strong>mutual exclusion</strong>(互斥体)，用于保护共享数据的<strong>互斥</strong>访问，也就是常说的<strong>锁</strong>。mutex 相当于一种独占性的资源，仅有 <code>lock</code> / <code>try_lock</code>（获取该资源）与 <code>unlock</code>（释放该资源）两种操作，其余各种锁都是围绕 mutex 进行封装与变形，故这些锁的<strong>拷贝构造函数</strong>与<strong>拷贝赋值函数</strong>被<strong>弃置</strong>。其<strong>主要特性</strong>如下：</p>
<ul>
<li><strong>调用方</strong>线程从它成功调用 <code>lock</code> / <code>try_lock</code> 开始，到它调用 unlock 为止占有 mutex；</li>
<li>任一其它线程占有 mutex 时，当前线程若试图通过 <code>lock</code> / <code>try_lock</code> 要求获得 mutex 的所有权，则阻塞，直至<strong>占有方</strong>通过 <code>unlock</code> 释放 mutex；</li>
<li>调用方线程在 <code>lock</code> / <code>try_lock</code> 前必须不占有 mutex，否则为 <strong>UB</strong>；</li>
</ul>
<p>就<strong>初始化方式</strong>而言，直接通过<strong>默认构造函数</strong>进行创建互斥锁对象，创建后锁处于<strong>未锁定</strong>状态。</p>
<p>mutex 类是所有锁的基础，其<strong>成员函数</strong>只有三个，都是基于之前讨论的特性：</p>
<ol type="1">
<li><code>lock()</code>：尝试锁定 mutex；</li>
<li><code>try_lock()</code>：尝试锁定 mutex，成功获得锁时返回 <code>true</code> ，否则返回 <code>false</code> 。</li>
<li><code>unlock()</code>：释放 mutex；</li>
</ol>
<h4 id="stdtimed_mutex">std::timed_mutex</h4>
<p>在 mutex 基础上，timedMutex 添加了<strong>超时语义</strong>，相关成员函数为：</p>
<ol type="1">
<li><code>try_lock_for( time )</code>：尝试获取锁，若一段时间 time 后超时未获得锁则放弃；</li>
<li><code>try_lock_until( time )</code>：尝试获取锁，若指定时刻 time 后超时未获得锁则放弃；</li>
</ol>
<p>以上两个函数都会在成功时返回 <code>true</code>，失败时返回 <code>false</code>。</p>
<h4 id="stdrecursively_mutex">std::recursively_mutex</h4>
<p>以上两种锁都无法重复获取，即已占有 mutex 的线程继续 <code>lock</code> / <code>try_lock</code> 会发生 UB。在 mutex 基础上，recursivelyMutex 添加了<strong>递归语义</strong>，即允许线程多次上锁，并在释放相等次数的锁后结束（好比左右括号匹配）。其成员函数与 mutex 一致。</p>
<h4 id="stdrecursively_timed_mutex">std::recursively_timed_mutex</h4>
<p><strong>省流</strong>：recursivelyMutex + timedMutex</p>
<h4 id="stdlock-stdtry_lock">std::lock() &amp; std::try_lock()</h4>
<p>除了各个锁类以外，&lt;mutex&gt; 头文件下还定义了两个全局函数 <code>std::lock()</code> 与 <code>std::try_lock()</code>，提供了通用的<strong>一次性加多个锁</strong>的方法。<strong>函数原型</strong>如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Lockable1, <span class="keyword">class</span> Lockable2, <span class="keyword">class</span>... LockableN &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">lock</span><span class="params">( Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Lockable1, <span class="keyword">class</span> Lockable2, <span class="keyword">class</span>... LockableN &gt;</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">try_lock</span><span class="params">( Lockable1&amp; lock1, Lockable2&amp; lock2, LockableN&amp;... lockn )</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>std::lock()</code> 为阻塞式加锁，<code>std::try_lock()</code> 为异步式加锁，它俩其实是去调用每种 lockable 对象，即 mutex 自身的方法，然后加锁，并且不会因为不同线程上锁顺序不同而死锁，这是因为一旦上锁失败，则不再推进，而对所有已上锁的 mutex 调用 <code>unlock()</code>，然后再次重复尝试，直至所有 mutex 都已上锁。</p>
<h4 id="stdlock_guard">std::lock_guard</h4>
<p>对于不加超时语义的 mutex 而言，需要程序员主动上锁解锁，但如果某线程在 unlock 之前就因为抛出异常而被迫终止，那么其持有的 mutex 就永远无法释放，所有等待该资源的线程也就陷入了无尽的阻塞中，这显然是不可用的。并且这样的手动释放要求我们在所有执行体的出口都要解锁，也增加了不必要的代码量。</p>
<p><code>lock_guard</code> 应用了 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/language/raii">RAII 技术</a>，其将 mutex 进一步封装，并在构造/析构函数中进行资源的分配/释放，这样就不会出现上述问题——因为一旦线程退出，其所有资源都会被释放，那么必然会调用析构函数，进行解锁，防止线程由于编码失误导致一直持有锁。</p>
<blockquote>
<p>这样一来，就不能用同一个 mutex 对象来初始化两个不同的 lock_guard 对象了，否则会出现<strong>死锁</strong>，下面几个锁也是如此。</p>
</blockquote>
<p>其类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">lock_guard</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> mutex_type = Mutex;</span><br><span class="line">    </span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">lock_guard</span><span class="params">(mutex_type&amp; m)</span>: m_(m) &#123;</span> m_.<span class="built_in">lock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">lock_guard</span>(mutex_type&amp; m, <span class="type">adopt_lock_t</span>) <span class="keyword">noexcept</span>: <span class="built_in">m_</span>(m) &#123;&#125; <span class="comment">// 线程拥有锁时调用此构造函数</span></span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">lock_guard</span>() &#123; m_.<span class="built_in">unlock</span>(); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">lock_guard</span>(<span class="type">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  lock_guard&amp; <span class="keyword">operator</span>=(<span class="type">const</span> lock_guard&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  mutex_type&amp;  m_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>两种构造函数区别在于：第一种在构造时上锁；而第二种重载形式形参中的 <code>adopt_lock_t</code> 为空结构体类型，表示<strong>构造模式</strong>，即<strong>假设调用方线程已拥有 mutex 的所有权</strong>，以此种方式进行构造时不会上锁。<code>std</code> 命名空间下已为我们实现了名为 <code>adopt_lock</code> 的全局变量，故可以用以下方式进行初始化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::mutex a;</span><br><span class="line"><span class="function">std::lock_guard <span class="title">b</span><span class="params">(a)</span></span>;             <span class="comment">// 构造后 a 上锁</span></span><br><span class="line"></span><br><span class="line">a.<span class="built_in">lock</span>();                         <span class="comment">// 这句没有就报错</span></span><br><span class="line"><span class="function">std::lock_guard <span class="title">c</span><span class="params">(a, adopt_lock)</span></span>; <span class="comment">// 告知 a 已上锁，此时用这种初始化方式</span></span><br></pre></td></tr></table></figure>
<p>下面还会讲另外两种上锁模式，也是同理的。</p>
<h4 id="stdunique_lock">std::unique_lock</h4>
<p>顾名思义，unique_lock 是独占性的，故不存在两个 unique_lock 对应同一个 mutex 对象，故<strong>移动构造函数</strong>与<strong>移动赋值函数</strong>得到了实现，方便转移资源。</p>
<p>类定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Mutex&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">unique_lock</span> &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> mutex_type = Mutex;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">unique_lock</span>() <span class="keyword">noexcept</span>: <span class="built_in">m_</span>(<span class="literal">nullptr</span>), <span class="built_in">own_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">unique_lock</span><span class="params">(mutex_type &amp;m_)</span>: m_(std::__addressof(m_)), own_(false) &#123;</span></span><br><span class="line">    <span class="built_in">lock</span>();</span><br><span class="line">    own_ = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 支持三种上锁模式</span></span><br><span class="line">  <span class="built_in">unique_lock</span>(mutex_type &amp;m_, <span class="type">defer_lock_t</span>) <span class="keyword">noexcept</span>: <span class="built_in">m_</span>(std::__addressof(m_)), <span class="built_in">own_</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">unique_lock</span>(mutex_type &amp;m_, <span class="type">try_to_lock_t</span>): <span class="built_in">m_</span>(std::__addressof(m_)), <span class="built_in">own_</span>(m_-&gt;<span class="built_in">try_lock</span>()) &#123;&#125;</span><br><span class="line">  <span class="built_in">unique_lock</span>(mutex_type &amp;m_, <span class="type">adopt_lock_t</span>) <span class="keyword">noexcept</span>: <span class="built_in">m_</span>(std::__addressof(m_)), <span class="built_in">own_</span>(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 超时语义</span></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Clock, <span class="keyword">typename</span> Duration&gt;</span><br><span class="line">  <span class="built_in">unique_lock</span>(mutex_type &amp;m_, <span class="type">const</span> chrono::time_point&lt;Clock, Duration&gt; &amp;time): <span class="built_in">m_</span>(std::__addressof(m_)), <span class="built_in">own_</span>(m_-&gt;<span class="built_in">try_lock_until</span>(time)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Rep, <span class="keyword">typename</span> Period&gt;</span><br><span class="line">  <span class="built_in">unique_lock</span>(mutex_type &amp;m_, <span class="type">const</span> chrono::duration&lt;Rep, Period&gt; &amp;time): <span class="built_in">m_</span>(std::__addressof(m_)), <span class="built_in">own_</span>(m_-&gt;<span class="built_in">try_lock_for</span>(time)) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  ~<span class="built_in">unique_lock</span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (own_)</span><br><span class="line">      <span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 拷贝被弃置</span></span><br><span class="line">  <span class="built_in">unique_lock</span>(<span class="type">const</span> unique_lock &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  unique_lock &amp;<span class="keyword">operator</span>=(<span class="type">const</span> unique_lock &amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 移动被实现</span></span><br><span class="line">  <span class="built_in">unique_lock</span>(unique_lock &amp;&amp;u) <span class="keyword">noexcept</span>: <span class="built_in">m_</span>(u.m_), <span class="built_in">own_</span>(u.own_) &#123;</span><br><span class="line">    u.m_ = <span class="literal">nullptr</span>;</span><br><span class="line">    u.own_ = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  unique_lock &amp;<span class="keyword">operator</span>=(unique_lock &amp;&amp;u) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (own_)</span><br><span class="line">      <span class="built_in">unlock</span>();</span><br><span class="line">    <span class="built_in">unique_lock</span>(std::<span class="built_in">move</span>(u)).<span class="built_in">swap</span>(*<span class="keyword">this</span>);</span><br><span class="line">    u.m_ = <span class="literal">nullptr</span>;</span><br><span class="line">    u.own_ = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  mutex_type *m_;</span><br><span class="line">  <span class="type">bool</span> own_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>unique_lock 在 lock_guard 基础上添加了超时语义，并且支持另外两种<strong>上锁模式</strong>：</p>
<ol type="1">
<li><code>defer_lock_t</code>：不上锁；</li>
<li><code>try_lock_t</code>：尝试上锁，而不阻塞；</li>
</ol>
<p>除此以外，<code>unique_lock</code> 还提供了 <code>lock()</code>，<code>unlock()</code>，<code>try_lock()</code>，<code>try_lock_for()</code>，<code>try_lock_until()</code> 这几个 api，并能通过调用 <code>release()</code> 解绑所拥有的锁对象。</p>
<p>为了支持上述功能，类中新添加了变量 <code>own_</code> 来判断当前是否持有锁，并且 mutex 对象改为了指针类型，以便判断当前是否存在绑定的 mutex。</p>
<blockquote>
<p>lock_gurad 相比于 unique_lock 更轻量，但因为 unique_lock 类可以手动解锁，所以<strong>条件变量</strong>都搭配 unique_lock 一起使用，因为条件变量在 wait 时需要有手动解锁的能力。</p>
</blockquote>
<h4 id="stdcall_once">std::call_once()</h4>
<p>此函数保证某一函数在多线程环境中只调用一次，它需要配合 <code>std::once_flag</code> 使用。<strong>函数原型</strong>为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Callable, <span class="keyword">class</span>... Args &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">call_once</span><span class="params">( std::once_flag&amp; flag, Callable&amp;&amp; f, Args&amp;&amp;... args )</span></span>;</span><br></pre></td></tr></table></figure>
<p>若 <code>flag == true</code>，则直接返回；反之，利用 <code>std::forward</code> 调用 <code>f</code>，且仅当正常返回时将 <code>flag</code> 由 <code>false</code> 改为 <code>true</code>。具体代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">once_flag flag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">call_once</span>(flag, [i]() &#123;</span><br><span class="line">    cout &lt;&lt; i &lt;&lt; <span class="string">&quot; call\n&quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  thread threads[<span class="number">5</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">    threads[i] = <span class="built_in">thread</span>(func, i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : threads) &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: 0 call</span></span><br></pre></td></tr></table></figure>
<h3 id="atomic">&lt;atomic&gt;</h3>
<blockquote>
<p>此头文件中定义了原子变量 <code>std::atomic&lt;T&gt;</code>，以及其各种特化 <code>std::atomic_int</code>，<code>std::atomic_bool</code> 等</p>
</blockquote>
<h4 id="stdatomic">std::atomic</h4>
<p>考虑这样一个情况：存在一整型变量 <code>x = 0</code>，现在有两个线程 A, B 分别对其执行加 1 与 减 1 的操作，这些操作可以归结为两步原子操作：</p>
<ol type="1">
<li>读取变量值；</li>
<li>加/减该值，赋值给原变量；</li>
</ol>
<p>如果不加以限制，可能会出现 <strong>Write-After-Read</strong>, <strong>Write-After-Write</strong> 的情况，+则 x 最终的结果可能是 -1, 0, 1 这三种，这取决于线程每一步原子操作之间的执行顺序。</p>
<p>我们希望最终结果是<strong>确定性</strong>的，就需要严格控制线程同步，一个很好的考虑是使用前面提到的 mutex，代码可以写为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">std::mutex m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">lock_guard</span>(m);</span><br><span class="line">  x++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  std::<span class="built_in">lock_guard</span>(m);</span><br><span class="line">  x--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而如果使用<strong>原子变量</strong>，则代码可以简化为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="type">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// or std::atomic_int x(0)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123; x++; &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sub</span><span class="params">()</span> </span>&#123; x--; &#125;</span><br></pre></td></tr></table></figure>
<p>事实上，原子变量能帮助我们自动控制线程之间的同步，保证加/减等操作的原子性——若一个线程写入原子对象，同时另一线程从它读取，则行为良好定义。</p>
<h3 id="condition_variable">&lt;condition_variable&gt;</h3>
<h4 id="stdcondition_variable">std::condition_variable</h4>
<p><code>condition_variable</code> 是利用线程间共享的<strong>全局变量</strong>进行<strong>同步</strong>的一种机制，能用于阻塞一个或多个线程（或称使其等待(<strong>wait</strong>)），直至另一线程通知(<strong>notify</strong>)条件变量将等待的线程唤醒。相当于操作系统里的 <strong>P/V</strong> 操作。</p>
<blockquote>
<p>下面就用 P/V 代称 wait/notify。</p>
</blockquote>
<p>即使共享变量是原子的，也必须互斥地修改它，故尝试进行 P/V 的线程必须在持有锁时进行 P/V，这里的锁必须采用 <code>unique_lock</code>，因为需要 RAII 以及手动 lock/unlock。具体用法大致如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">std::condition_variable cond;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  std::mutex m;</span><br><span class="line">  <span class="function">std::unique_lock&lt;mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * predicate 为布尔类型表达式</span></span><br><span class="line"><span class="comment">   * 若 predicate == true，则 do something</span></span><br><span class="line"><span class="comment">   * 反之，进入休眠状态，直至被唤醒后检查到 predicate == true</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">while</span> (!predicate) &#123;</span><br><span class="line">    cond.<span class="built_in">wait</span>(lock);  <span class="comment">// 必须在持有锁的情况下调用 wait，会被其它线程通过 notify 唤醒</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">  cond.<span class="built_in">notify</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与互斥方式相比，条件变量的 P 操作以<strong>非竞争方式</strong>争夺资源，会进入一个等待队列，这样一来 CPU 的时间片就得到了充分利用，而不是耗费在无意义的等待上锁上。</p>
<p>接下来谈谈其<strong>成员函数</strong>。</p>
<p>首先是 <strong>wait</strong> 系列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. wait</span></span><br><span class="line"><span class="comment">// 原子地进行 unlock ，阻塞当前线程，并将它添加到等待队列。唤醒后，进行 lock 且 wait 退出。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock )</span></span>; </span><br><span class="line"><span class="comment">// 等价于 while(!pred()) &#123; wait(lock); &#125;，这里 pred 是一个返回 bool 值的可调用对象</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">wait</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock, Predicate pred )</span></span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. wait_until</span></span><br><span class="line"><span class="comment">// 等待至时刻 timeout_time 后若还未被唤醒，则强制唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration &gt;</span></span><br><span class="line"><span class="function">std::cv_status <span class="title">wait_until</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                           <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time )</span></span>;</span><br><span class="line"><span class="comment">// 等价于:</span></span><br><span class="line"><span class="comment">// while (!pred()) &#123;</span></span><br><span class="line"><span class="comment">//   if (wait_until(lock, timeout_time) == std::cv_status::timeout) &#123;</span></span><br><span class="line"><span class="comment">//     return pred();</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Clock, <span class="keyword">class</span> Duration, <span class="keyword">class</span> Pred &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_until</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                 <span class="type">const</span> std::chrono::time_point&lt;Clock, Duration&gt;&amp; timeout_time,</span></span></span><br><span class="line"><span class="params"><span class="function">                 Pred pred )</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. wait_for</span></span><br><span class="line"><span class="comment">// 等待 rel_time 后若还未被唤醒，则强制唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period &gt;</span></span><br><span class="line"><span class="function">std::cv_status <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">                         <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="comment">// return wait_until(lock,</span></span><br><span class="line"><span class="comment">//                   std::chrono::steady_clock::now() + rel_time,</span></span><br><span class="line"><span class="comment">//                   std::move(pred));</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt; <span class="keyword">class</span> Rep, <span class="keyword">class</span> Period, <span class="keyword">class</span> Predicate &gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">wait_for</span><span class="params">( std::unique_lock&lt;std::mutex&gt;&amp; lock,</span></span></span><br><span class="line"><span class="params"><span class="function">               <span class="type">const</span> std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time,</span></span></span><br><span class="line"><span class="params"><span class="function">               Predicate pred)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>其中 <code>cv_status</code> 是一个枚举型变量，描述定时等待是否因时限返回。其只包含两个枚举值：</p>
<ol type="1">
<li><code>no_timeout</code>：表示条件变量因 <code>notify_all</code> 、 <code>notify_one</code> 或虚假地被唤醒；</li>
<li><code>timeout</code>：表示条件变量因时限耗尽被唤醒；</li>
</ol>
</blockquote>
<p>接下来是 <strong>notify</strong> 系列：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 唤醒等待队列中的某一线程，一般只有两个线程的时候才会用 notify_one，因为非此即彼。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_one</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 唤醒等待队列中的所有线程</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all</span><span class="params">()</span> <span class="keyword">noexcept</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="stdcondition_variable_any">std::condition_variable_any</h4>
<p>与 <code>condition_variable</code> 相比，<code>condition_variable_any</code> 是 <code>condition_variable</code> 的泛化，其支持任一 Lockable 的锁，不一定非要用 <code>unique_lock</code>。除此以外与 <code>condition_variable</code> 几乎完全一致，就不聊了。</p>
<h4 id="stdnotify_all_at_thread_exit">std::notify_all_at_thread_exit()</h4>
<p>在此线程完全结束时调用 <code>notify_all()</code>。函数原型为：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">notify_all_at_thread_exit</span><span class="params">( std::condition_variable&amp; cond,</span></span></span><br><span class="line"><span class="params"><span class="function">                                std::unique_lock&lt;std::mutex&gt; lk )</span></span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，调用该函数之前，必须首先用与 cond 绑定的相同 mutex 来创建 unique_lock 对象，并且传参时需要用 <code>move()</code> 将先前获得的锁 <code>lk</code> 的所有权转移到内部存储。</p>
<h4 id="唤醒丢失">唤醒丢失</h4>
<p>上面讲条件变量用法时，我提到“<strong>尝试进行 P/V 的线程必须在持有锁时进行 P/V</strong>”，那么如果不上锁就 wait/notify 会怎样呢？不加锁便进行wait 操作的行为我们已经说过是 UB，而不加锁便进行 notify 的行为会导致<strong>唤醒丢失</strong>，且看：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case1 唤醒丢失</span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cond;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::unique_lock&lt;std::mutex&gt; lock(m);</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">while</span> (!flag) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cond.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::cout &lt;&lt; <span class="string">&quot;thread1 over\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread2</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  flag = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  cond.notify_all();</span></span></span><br><span class="line"><span class="params"><span class="function">  std::cout &lt;&lt; <span class="string">&quot;thread2 over\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line">thread2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<p>我们希望的是：thread1 首先上锁，然后 wait（此时会隐式地解锁），然后 thread2 上锁，修改 flag，唤醒 thread1，然后两个线程分别打印一条消息出来。</p>
<p>但线程是异步推进的，极有可能由于 thread2 未进行 <code>m</code> 的上锁操作，故其执行体不会被阻塞，从而出现 thread1 上锁，thread2 notify，thread1 再 wait 的执行顺序，显然会导致 thread1 无限阻塞。这便是<strong>不加锁导致唤醒丢失</strong>的经典案例。</p>
<p>为了解决这一问题，我们需要在 notify 前上锁，这样保证了在 thread1 的上锁与 wait 之间不会发生 notify 行为——thread2 会因竞争锁资源而被阻塞。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// OK</span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cond;</span><br><span class="line"><span class="type">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::unique_lock&lt;std::mutex&gt; lock(m);</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="keyword">while</span>(flag) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">    cond.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">  &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::cout &lt;&lt; <span class="string">&quot;thread1 over\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread2</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::unique_lock&lt;std::mutex&gt; lock(m);</span></span></span><br><span class="line"><span class="params"><span class="function">  flag = <span class="literal">true</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">  cond.notify_all();</span></span></span><br><span class="line"><span class="params"><span class="function">  std::cout &lt;&lt; <span class="string">&quot;thread2 over\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line">thread2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<p>上面这种情况中，我们只考虑了 notify 是否会发生在上锁与 wait 之间，但 notify 也有可能发生在上锁之前，这也可能导致唤醒丢失。考虑下面这种情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case2 唤醒丢失</span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cond;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread1</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::unique_lock&lt;std::mutex&gt; lock(m);</span></span></span><br><span class="line"><span class="params"><span class="function">  cond.wait(lock);</span></span></span><br><span class="line"><span class="params"><span class="function">  std::cout &lt;&lt; <span class="string">&quot;thread1 over\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">thread2</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  std::unique_lock&lt;std::mutex&gt; lock(m);</span></span></span><br><span class="line"><span class="params"><span class="function">  cond.notify_all();</span></span></span><br><span class="line"><span class="params"><span class="function">  std::cout &lt;&lt; <span class="string">&quot;thread2 over\n&quot;</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">thread1.<span class="built_in">join</span>();</span><br><span class="line">thread2.<span class="built_in">join</span>();</span><br></pre></td></tr></table></figure>
<p>thread2 先上锁然后 notify_all（此时会隐式地解锁），再是 thread1 上锁并进行 wait。由于没有其它线程执行唤醒的工作，thread1 将永远 wait 下去——thread2 的 notify 实际上丢失了！这便是<strong>不加条件导致唤醒丢失</strong>的经典案例。</p>
<p>为了解决这一问题，我们应当加上某些限制，使得 notify 确定性地位于 wait 之后。于是需要套上一层条件判断的语句（如 <code>while</code>），检测当前是否应当 wait，套上 <code>while</code> 后，即便 thread2 首先执行，但由于 thread2 中修改了 predicate，thread1 也就能够很快检测到，能够跳过 wait 阶段。当然也可以不用 <code>while</code>，而是写成下面这种样子，这两者是等价的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cond.<span class="built_in">wait</span>(lock, [] &#123; <span class="keyword">return</span> flag; &#125;);</span><br></pre></td></tr></table></figure>
<h4 id="虚假唤醒">虚假唤醒</h4>
<p>当上面的条件判断语句由 <code>while</code> 改为 <code>if</code> 时，便存在<strong>虚假唤醒</strong>的情况。</p>
<blockquote>
<p>当一个线程从等待一个已发出信号的条件变量中醒来，却发现它正在等待的条件不满足时，就会发生<strong>虚假唤醒</strong>。之所以称为虚假，是因为该线程似乎无缘无故地被唤醒了。但是虚假唤醒不会无缘无故地发生：它们通常会发生，因为在条件变量发出信号和等待线程最终运行之间，另一个线程运行并改变了条件。（抄自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spurious_wakeup">百科</a>）</p>
</blockquote>
<p>用一个例子来说明：在<strong>生产者消费者</strong>问题中，生产者每生产出一个产品，就通知所有消费者；当所有消费者被唤醒时，它们对产品的获取顺序为竞争关系，此时第一个赢得竞争的消费者取走了产品，而之后的消费者会发现并没有任何产品存在，又此时已经退出了 wait 阶段，也就继续推进下去直至消亡，最后就导致只有一个消费者进行了消费。比如下面这段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// case3 虚假唤醒</span></span><br><span class="line">std::mutex m;</span><br><span class="line">std::condition_variable cond;</span><br><span class="line"><span class="type">int</span> cnt = <span class="number">0</span>; <span class="comment">// 产品</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">consumer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">if</span> (cnt == <span class="number">0</span>) &#123;</span><br><span class="line">    cond.<span class="built_in">wait</span>(lock);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">producer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">  cnt++;</span><br><span class="line">  cond.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解决办法就是<strong>将 wait 放到条件判断循环中</strong>，即类似于上一节中第二段代码。</p>
<h3 id="future">&lt;future&gt;</h3>
<p>以后用到再学吧</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/C-11/C-Init/" rel="prev" title="C++ 11 の 列表初始化(List Initialize)">
      <i class="fa fa-chevron-left"></i> C++ 11 の 列表初始化(List Initialize)
    </a></div>
      <div class="post-nav-item">
    <a href="/C-11/C-SmartPtr/" rel="next" title="C++ 11 の 智能指针(Smart Pointer)">
      C++ 11 の 智能指针(Smart Pointer) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="nav-text">并发与并行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B9%B6%E5%8F%91%E6%94%AF%E6%8C%81%E5%BA%93"><span class="nav-text">并发支持库</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#thread"><span class="nav-text">&lt;thread&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stdthread"><span class="nav-text">std::thread</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdthis_thread"><span class="nav-text">std::this_thread</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#mutex"><span class="nav-text">&lt;mutex&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stdmutex"><span class="nav-text">std::mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdtimed_mutex"><span class="nav-text">std::timed_mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdrecursively_mutex"><span class="nav-text">std::recursively_mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdrecursively_timed_mutex"><span class="nav-text">std::recursively_timed_mutex</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdlock-stdtry_lock"><span class="nav-text">std::lock() &amp; std::try_lock()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdlock_guard"><span class="nav-text">std::lock_guard</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdunique_lock"><span class="nav-text">std::unique_lock</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdcall_once"><span class="nav-text">std::call_once()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#atomic"><span class="nav-text">&lt;atomic&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stdatomic"><span class="nav-text">std::atomic</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#condition_variable"><span class="nav-text">&lt;condition_variable&gt;</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#stdcondition_variable"><span class="nav-text">std::condition_variable</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdcondition_variable_any"><span class="nav-text">std::condition_variable_any</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#stdnotify_all_at_thread_exit"><span class="nav-text">std::notify_all_at_thread_exit()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%94%A4%E9%86%92%E4%B8%A2%E5%A4%B1"><span class="nav-text">唤醒丢失</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92"><span class="nav-text">虚假唤醒</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#future"><span class="nav-text">&lt;future&gt;</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Leager"
      src="/images/Avatar.jpg">
  <p class="site-author-name" itemprop="name">Leager</p>
  <div class="site-description" itemprop="description">【数据删除】</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">49</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Leager-zju" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leager-zju" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("09/25/2022 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已存活 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leager</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='160' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
