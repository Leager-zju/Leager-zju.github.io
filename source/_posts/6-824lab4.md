---
title: 6.824 Lab4 Sharded Key/Value Service
author: Leager
mathjax:
  - true
date: 2022-11-22 20:20:28
summary:
categories:
  - Lab
tags:
img:
---

å¯¹äºå•ä¸ªå‰¯æœ¬ç»„è€Œè¨€ï¼Œæ‰€æœ‰æœºå™¨å­˜å‚¨å…±äº«åŒä¸€å­˜å‚¨ç©ºé—´ï¼Œæœºå™¨æ•°é‡çš„å¢åŠ å¹¶ä¸ä¼šæ‰©å¤§å­˜å‚¨èƒ½åŠ›ã€‚è€Œå½“ kv å¯¹æ•°é‡ä¸æ–­å¢é•¿æ—¶ï¼Œå‰¯æœ¬ç»„çš„å­˜å‚¨èƒ½åŠ›æˆä¸ºç“¶é¢ˆã€‚

å‚è€ƒ [Aurora](https://leager-zju.github.io/6-824/aurora/) çš„åšæ³•ï¼Œä¸å¦¨å°†æ•°æ®åˆ’åˆ†ä¸ºå¤šä¸ªç‰‡æ®µï¼Œæ¯ä¸ªå‰¯æœ¬ç»„è´Ÿè´£**åˆ†ç‰‡**(Shard)çš„ä¸€ä¸ªå­é›†ã€‚ç»„å†…æœºå™¨ä½¿ç”¨ Raft æ¥å¤åˆ¶åˆ†ç‰‡ã€‚æ­¤å¤–è¿˜æœ‰ä¸€ä¸ª**åˆ†ç‰‡æ§åˆ¶å™¨**(Shardctrler)ï¼Œå†³å®šå“ªä¸ªå‰¯æœ¬ç»„åº”è¯¥ä¸ºæ¯ä¸ªåˆ†ç‰‡æœåŠ¡ï¼Œæ­¤ä¿¡æ¯ç§°ä¸º**é…ç½®**(Config)ã€‚æœ¬å®éªŒå°±æ˜¯å®ç°è¿™æ ·ä¸€ä¸ª multi-raft çš„ kv å­˜å‚¨ç³»ç»Ÿã€‚

<!--more-->

lab4 å’Œ lab3 éå¸¸åƒï¼Œä¸»è¦æµç¨‹æ˜¯è¿™æ ·çš„ï¼š

1. client é€šè¿‡ clerk å‘é€è¯·æ±‚ï¼›
2. clerk æ ¹æ® key æ‰€åœ¨çš„åˆ†ç‰‡ï¼Œå°†è¯·æ±‚è½¬å‘ç»™å¯¹åº” group çš„ Leaderï¼›
3. Leader é€šè¿‡ raft å±‚å¤åˆ¶æ“ä½œæ—¥å¿—ã€‚

## PART A-The Shard controller

è¿™ä¸€éƒ¨åˆ†æ˜¯æ¯”è¾ƒç®€å•çš„ï¼Œå»é‡æ£€æµ‹ã€å¤„ç†è¯·æ±‚ç­‰æ–¹é¢å‡ ä¹å¯ä»¥æŠŠ lab3 çš„ä»£ç æ¬è¿‡æ¥ã€‚å…³é”®åœ¨äºå¤„ç†ä¸Šå±‚è°ƒç”¨çš„ `Join`ã€`Leave`ã€`Move`ã€`Query` è¿™ 4 ä¸ªå‘½ä»¤ã€‚ç”±äº Shardctrler ç®¡ç†ä¸€ç³»åˆ—é…ç½®ï¼Œæ•…éœ€è¦åœ¨ç»“æ„ä½“ä¸­é¢å¤–è®¾ç½®ä¸€ä¸ª Config åˆ‡ç‰‡ã€‚ç»“æ„ä½“å¦‚ä¸‹ï¼š

```go
type ShardCtrler struct {
  mu    sync.RWMutex
  me    int
  applyCh chan raft.ApplyMsg
  rf    *raft.Raft

  lastRequestInfo map[int64]*RequestInfo // clerkID -> requestID
  configs []Config // indexed by config num
}
```

### æ–°å»ºé…ç½®

`Query` ç›¸å½“äºè¯»å‘½ä»¤ï¼Œä¸ä¼šå¯¹ Config æœ‰ä»»ä½•æ›´æ”¹ï¼Œæ˜¯å¯ä»¥ä¸ç»è¿‡å»é‡çš„ï¼Œç›´æ¥æ ¹æ®è§„åˆ™è¿”å›ç›¸åº” Config å³å¯ã€‚

å…¶å®ƒ 3 ä¸ªéœ€è¦ç»è¿‡å»é‡è¡¨ã€‚å…¶ä¸­ `Move` è¾ƒä¸ºç®€å•ï¼Œç›´æ¥ä¿®æ”¹ Config ä¸­ `Shards[]` å¯¹åº”çš„å€¼å³å¯ã€‚å¯¹äº `Join` å’Œ `Leave`ï¼Œåœ¨åº”ç”¨å‘½ä»¤æ—¶éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„ Configã€‚

> åœ¨ Go ä¸­ï¼Œmap æ˜¯å¼•ç”¨ç±»å‹ï¼Œä¸èƒ½ç›´æ¥æ‹·è´ï¼ˆæµ…æ‹·è´ï¼‰ï¼Œè€Œæ˜¯éœ€è¦åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡å¹¶å•ç‹¬å¤åˆ¶é”®å’Œå€¼ï¼ˆæ·±æ‹·è´ï¼‰ã€‚

```go
func (sc *ShardCtrler) makeNewConfig() *Config {
  lastconfig := sc.configs[len(sc.configs)-1]
  newconfig := Config{
    Num:  lastconfig.Num + 1,
    Shards: lastconfig.Shards,
    Groups: make(map[int][]string),
  }
  for gid, members := range lastconfig.Groups {
    newconfig.Groups[gid] = members
  }
  return &newconfig
}


func (sc *ShardCtrler) ApplyCommand(msg raft.ApplyMsg) {
  args := msg.Command.(Args)
  ch := args.Ch
  reply := new(Reply)

  if args.Op == Query {
    reply.Err = OK
    if args.Num == -1 || args.Num >= len(sc.configs) {
      reply.Config = sc.configs[len(sc.configs)-1]
    } else {
      reply.Config = sc.configs[args.Num]
    }
  } else if sc.isDuplicated(args.RequestId, args.ClerkId) {
    reply.Err = sc.lastRequestInfo[args.ClerkId].Err
  } else {
    newconfig := sc.makeNewConfig()
    switch args.Op {
      case Move:
      newconfig.Shards[args.Shard] = args.GIDs[0]
      case Join:
      for gid, members := range args.Servers {
        newconfig.Groups[gid] = members
      }
      sc.shuffleShard(newconfig)
      case Leave:
      for _, gid := range args.GIDs {
        delete(newconfig.Groups, gid)
      }
      sc.shuffleShard(newconfig)
    }
    sc.configs = append(sc.configs, *newconfig)
    sc.lastRequestInfo[args.ClerkId] = &RequestInfo{
      RequestID: args.RequestId,
      Err:     reply.Err,
    }
  }

  if sc.rf.GetRaftState() == raft.Leader && sc.rf.GetCurrentTerm() == msg.CommandTerm {
    go func(reply_ *Reply) { ch <- reply_ }(reply)
  }
}
```

### åˆ†ç‰‡å†åˆ†é…

lab è¦æ±‚**æ–° Config åº”å°½å¯èƒ½å°† Shard å‡åŒ€åœ°åˆ†é…åˆ° groups ä¸­ï¼Œå¹¶åº”ç§»åŠ¨å°½å¯èƒ½å°‘çš„ Shard**ã€‚è¿™æ ·åšä¹Ÿæ˜¯ä¸ºäº†å‡å°‘ä¸å¿…è¦çš„ç½‘ç»œèµ„æºæ¶ˆè€—ï¼Œæ¯•ç«Ÿåç»­ Shard çš„è¿ç§»æ˜¯éœ€è¦ RPC çš„ã€‚

è‹¥åˆ†é…å‰å­˜åœ¨åˆ†ç‰‡å¤„äº**æ— ä¸»**çŠ¶æ€ï¼ˆå³ Config.Shards[i] = 0ï¼‰ï¼Œåˆ™ä¼˜å…ˆ**å°†è¯¥åˆ†ç‰‡åˆ†é…ç»™æ‹¥æœ‰æœ€å°‘åˆ†ç‰‡çš„ group**ã€‚åä¹‹ï¼Œåˆ™**æ¯æ¬¡é€‰å–æ‹¥æœ‰æœ€å¤šåˆ†ç‰‡çš„ group ç»™æ‹¥æœ‰æœ€å°‘åˆ†ç‰‡çš„ group è¿ç§» Shardï¼Œç›´è‡³ä¸¤è€…æ‹¥æœ‰æ•°é‡ä¸è¶…è¿‡ 1**ã€‚

> åœ¨ Go ä¸­ï¼Œmap è¿­ä»£é¡ºåºæ˜¯[ä¸ç¡®å®šçš„](https://blog.golang.org/maps#TOC_7.)ã€‚

```go
func (sc *ShardCtrler) shuffleShard(config *Config) {
  N := len(config.Groups)
  if N == 0 {    // æ‰€æœ‰ group ç¦»å¼€ï¼Œå°†æ‰€æœ‰ Shard è®¾ä¸ºæ— ä¸»
    for i := 0; i < NShards; i++ {
      config.Shards[i] = 0
    }
    return
  }

  allocated := 0
  NumofShards := make(map[int]int)
  for gid := range config.Groups {
    NumofShards[gid] = 0
  }
  for _, gid := range config.Shards {
    if _, ok := config.Groups[gid]; ok {
      allocated++
      NumofShards[gid]++
    }
  }

  for {
    WhoHasTheMostShards, WhoHasTheLeastShards := -1, -1
    MaxmShards, MinmShards := -1, NShards+1

    for gid, num := range NumofShards {
      if num > MaxmShards {
        MaxmShards = num
        WhoHasTheMostShards = gid
      }
      if num < MinmShards {
        MinmShards = num
        WhoHasTheLeastShards = gid
      }
    }
    if allocated == NShards && MaxmShards < MinmShards+2 {  // allocated != NShards è¯´æ˜å­˜åœ¨æ— ä¸»åˆ†ç‰‡ï¼Œä¸èƒ½ç®€å•å‡­ MaxmShards < MinmShards+2 é€€å‡ºå¾ªç¯
      break
    }

    for sid, gid := range config.Shards {
      if _, ok := config.Groups[gid]; !ok { // gid å·²ç¦»å¼€ï¼Œç›´æ¥åˆ†ç»™æ‹¥æœ‰åˆ†ç‰‡æœ€å°‘çš„ group
        config.Shards[sid] = WhoHasTheLeastShards
        allocated++
        NumofShards[WhoHasTheLeastShards]++
        break
      } else if gid == WhoHasTheMostShards && allocated == NShards {
        config.Shards[sid] = WhoHasTheLeastShards
        NumofShards[WhoHasTheMostShards]--
        NumofShards[WhoHasTheLeastShards]++
        break
      }
    }
  }
}
```

## PART B-Shared Key/Value Server

è¿™ä¸€éƒ¨åˆ†æˆ‘è®¤ä¸ºæ˜¯æ•´ä¸ª 6.824 lab ä¸­æœ€éš¾çš„ä¸€ä¸ª Partã€‚å°½ç®¡ raft ç®—æ³•ä¹Ÿå¾ˆéš¾ï¼Œä½†åªè¦è®¤çœŸç ”è¯»è®ºæ–‡çš„å›¾ 2ï¼Œä¾ç„¶èƒ½å¤Ÿå†™å‡º bugfree çš„ä»£ç ã€‚è¿™éƒ¨åˆ†çš„éš¾ç‚¹åœ¨äºï¼Œéœ€è¦æˆ‘ä»¬ä»å¤´è®¾è®¡ä¸€ä¸ªåŸºäº Shard çš„ KV æœåŠ¡ï¼Œè€Œæ²¡æœ‰ä»»ä½•æ–‡çŒ®èµ„æ–™/Guide æ¥ä½œæŒ‡å¼•ï¼Œä¸€æ—¦æ²¡æœ‰çµæ„Ÿè¿¸å‘ï¼Œå°±ä¼šå¯¸æ­¥éš¾è¡Œã€‚

### å¼€å§‹ 4B ä¹‹å‰éœ€è¦æƒ³æ˜ç™½çš„ä¸€äº›äº‹

ç£¨è¹­å¤§åŠä¸ªæœˆ+ä»”ç»†é˜…è¯»å®éªŒè¦æ±‚åï¼Œæˆ‘å¾—å‡ºå¦‚ä¸‹æ€»ç»“ï¼š

è¯¥éƒ¨åˆ†ä¸ lab3 çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œgroup ä¼šä¸æ–­åŠ å…¥/ç¦»å¼€ç³»ç»Ÿï¼Œä¸ºäº†å¹³è¡¡è´Ÿè½½ï¼Œç³»ç»Ÿéœ€è¦åœ¨ group ä¹‹é—´è½¬ç§» Shardã€‚åŒæ—¶ï¼Œéšç€ groups çš„å˜åŒ–ï¼Œç³»ç»Ÿçš„ Config ä¹Ÿä¼šä¸æ–­å‘ç”Ÿå˜åŒ–ï¼Œä¸”éœ€è¦å‘ŠçŸ¥æ‰€æœ‰ groupã€‚ç®€è€Œè¨€ä¹‹ï¼Œè¯¥ lab çš„éš¾ç‚¹å¹¶ä¸åœ¨äºå¯¹ client æ“ä½œçš„å®ç°â€”â€”å®ƒå·²ç»åœ¨ lab3 ä¸­åšå®Œäº†ï¼Œç›´æ¥ç…§æŠ„å³å¯â€”â€”è€Œæ˜¯ï¼š

1. **å¦‚ä½• ReConfigï¼ŒConfig æœ‰æ›´æ–°åæ€ä¹ˆåš**ï¼›
2. **å¦‚ä½•è¿ç§» Shardï¼Œè¿ç§»åæ€ä¹ˆåš**ï¼›

èƒ½å¤Ÿæƒ³æ˜ç™½ä¸Šé¢ä¸¤ä¸ªé—®é¢˜ï¼Œ4B çš„æ‰€æœ‰éš¾ç‚¹éƒ½è¿åˆƒè€Œè§£ï¼ŒåŒ…æ‹¬ä¸¤ä¸ª Challengeã€‚

### Clerk

Clerk çš„å·¥ä½œå’Œ lab3 éå¸¸ç›¸ä¼¼ï¼Œæ ·ä¾‹ä»£ç çš„æ€è·¯ä¹Ÿå¾ˆæ¸…æ¥šâ€”â€”ä¸€æ—¦æ”¶åˆ° ErrWrongGroup å›å¤ï¼Œåˆ™è¯´æ˜è‡ªå·±ç¼“å­˜çš„ Config æœ‰è¯¯ï¼Œéœ€å‘ Shardctrler è¯·æ±‚æœ€æ–°çš„ Configã€‚å’Œ lab3 ç±»ä¼¼ï¼ŒClerk éœ€è¦ç¼“å­˜æ¯ä¸ª group çš„ Leaderã€‚

è¿™é‡Œæœ‰ä¸ªå¾ˆé‡è¦çš„ä¸€ç‚¹ï¼šå¦‚æœå¯¹æŸä¸ª group æ‰€æœ‰æˆå‘˜å‡å‘é€å¤±è´¥ï¼Œåˆ™è®¤ä¸ºè¯¥ group å…¨æŒ‚äº†ï¼Œç³»ç»Ÿå‘ç”Ÿæˆå‘˜å˜åŠ¨ï¼Œæ­¤æ—¶ Clerk ç¼“å­˜çš„ Config ä¸€å®šå·²è¿‡æ—¶ï¼Œå†ç»§ç»­å‘ä¸‹å»ææœ‰å¯èƒ½æ­»å¾ªç¯ï¼Œéœ€è¦å°è¯•è·å–æœ€æ–° Configã€‚

```go
func (ck *Clerk) SendRequest(Command *OperationCommand) string {
  Command.ClerkId, Command.RequestId = ck.ClerkId, ck.RequestId

  for {
    shard := key2shard(Command.Key)
    gid := ck.config.Shards[shard]

    if servers, ok := ck.config.Groups[gid]; ok { // è‹¥ gid åœ¨å½“å‰ config ä¸­
      if _, ok := ck.volatileLeader[gid]; !ok {
         ck.volatileLeader[gid] = 0
      }

      guard := ck.volatileLeader[gid]
      leader := guard

      for {
        // å¯»æ‰¾ Leader å‘é€è¯·æ±‚
      }
    }

    time.Sleep(100 * time.Millisecond)
    ck.config = ck.sm.Query(-1)
  }
}
```

### Server

é¦–å…ˆæ€è€ƒç¬¬ä¸€ä¸ªé—®é¢˜ï¼Œ**å¦‚ä½• ReConfigï¼ŒConfig æœ‰æ›´æ–°åæ€ä¹ˆåš**ã€‚è¿™ä¸ªé—®é¢˜è¿˜æ˜¯æ¯”è¾ƒå®¹æ˜“çš„ï¼Œåªéœ€è¦åœ¨å¯åŠ¨ server æ—¶å¼‚æ­¥å¼€å¯ä¸€ä¸ª **ConfigPuller** åç¨‹ï¼Œå®šæœŸå‘ Shardctrler è¯·æ±‚æœ€æ–°çš„ Config å³å¯ã€‚æ¯ä¸ª server è¿˜éœ€ç»´æŠ¤ä¸€ä¸ª `CurrentConfig` å˜é‡ï¼Œä¸€æ—¦è·å¾—è¾ƒæ–°çš„ Configï¼Œå°±å°†å…¶èµ‹ç»™ CurrentConfigã€‚

> è¿™ä¸ªå˜é‡ä¸»è¦ç”¨äºæ”¶åˆ°æ“ä½œè¯·æ±‚æ—¶åˆ¤æ–­æ˜¯å¦è¿”å› ErrWrongGroupï¼Œå³å¦‚æœ `CurrentConfig.Shards[key2shard(key)] != kv.gid`ï¼Œè¯´æ˜æœ¬ group ä¸è´Ÿè´£è¯¥åˆ†ç‰‡ï¼Œéœ€æŠ¥é”™ã€‚

è¿™é‡Œæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œgroup é‡Œçš„æ¯ä¸ªæˆå‘˜èƒ½å¤Ÿå•ç‹¬è¿›è¡Œ Config çš„æ‹‰å–å’Œæ›´æ–°å—ï¼Ÿå›ç­”æ˜¾ç„¶æ˜¯**ä¸èƒ½**çš„ï¼Œè¿™æ˜¯å¯¹ raft å±‚çš„ä¸å°Šé‡ï¼Œå•ç‹¬è¿›è¡Œ Config æ‹‰å–å¿…ç„¶ä¼šé€ æˆä¸åŒæ­¥ï¼Œåˆ™åç»­å¯¹ä¸åŒ server å­˜å‚¨çš„è¯»å†™ä¹Ÿä¼šäº§ç”Ÿç®¡è¾–èŒƒå›´ä¸ä¸€è‡´çš„é—®é¢˜ã€‚æ‰€ä»¥è¿™é‡Œéœ€è¦è¿›è¡Œæ˜¯å¦ä¸º Leader çš„åˆ¤æ–­ï¼Œå¦‚æœ Leader æ‹¿åˆ°äº†è¾ƒæ–°çš„Configï¼Œåˆ™å‘ä¸‹å±‚å‘ä¸€æ¡æ›´æ–°è®°å½•ï¼Œéšç€ raft å±‚çš„è¿ä½œï¼Œè¿™æ¡è®°å½•æœ€ç»ˆä¼šè¢«æ‰€æœ‰ server è·å¾—ï¼Œä¼ åˆ°ä¸Šå±‚è¿›è¡Œ Apply åæ›´æ–° CurrentConfigã€‚

éšç€ Config çš„æ›´æ–°ï¼ŒShard çš„è¿ç§»é—®é¢˜ä¹Ÿéšä¹‹è€Œæ¥ï¼Œè¿™é‡Œæˆ‘è®¾è®¡ä¸ºæ–° owner å‘æ—§ owner å‘é€ **pull** è¯·æ±‚ï¼ˆå½“ç„¶ push ä¹Ÿæ˜¯å¯ä»¥çš„ï¼‰ï¼šæ—§ owner æ”¶åˆ° pull RPC åå°†å±äºè¯¥ Shard çš„ kv å¯¹æ‰“åŒ…è¿› reply ä¸­å‘å›ç»™æ–° ownerã€‚

æœ€å¼€å§‹æˆ‘å°†èŠ‚ç‚¹çš„å­˜å‚¨ç®€å•çš„è®¾è®¡ä¸ºäº†å•ä¸ª mapï¼Œåæ¥å‘ç°è¿™æ ·åšä¸å¤Ÿä¼˜é›…â€”â€”æ‰€æœ‰æ•°æ®éƒ½å­˜åˆ°åŒä¸€å—åŒºåŸŸï¼Œæ¯æ¬¡è¿ç§» Shard æ—¶éœ€è¦å¯¹æ‰€æœ‰å…ƒç´ è¿›è¡Œéå†ï¼Œå°½ç®¡å¯¹ Config/Shard çš„æ“ä½œåªéœ€è¦å¯¹æœåŠ¡å™¨ä¸Šä¸€æŠŠå¤§é”ï¼Œä½† $O(n)$ çš„éå†æ— ç«¯å¢åŠ äº†æ—¶é—´æ¶ˆè€—ï¼Œæ˜¾ç„¶æ˜¯ç°å®ä¸å¯ç”¨çš„ã€‚

åœ¨é˜…è¯»äº† Aurora çš„è®ºæ–‡åæˆ‘æœ‰æ‰€å¯å‘ï¼šæˆ‘ä»¬å®Œå…¨å¯ä»¥å®šä¹‰ä¸€ä¸ªåä¸º `Shard` çš„ç»“æ„ä½“ï¼Œæ¯ä¸ª `Shard` æ‹¥æœ‰å•ç‹¬çš„ map å­˜å‚¨ï¼Œè¿™æ ·ä¸€æ¥è¿›è¡Œåˆ†ç‰‡è¿ç§»/åƒåœ¾å›æ”¶æ—¶ä¾¿èƒ½**ä»¥ Shard ä¸ºç²’åº¦**è¿›è¡Œæ“ä½œï¼Œè€Œä¸éœ€è¦éå†æ‰€æœ‰æ•°æ®ï¼Œè¿˜èƒ½å¯¹æ¯ä¸ª `Shard` è¿›è¡Œä¸€äº›é¢å¤–çš„å˜é‡è®¾ç½®ã€‚

é‚£ä¹ˆèƒ½ä¸èƒ½åœ¨ Apply æ›´æ–° Config æ—¥å¿—åç«‹é©¬è¿›è¡Œä¸€æ¬¡ pull Shard å‘¢ï¼Ÿæˆ‘æœ€å¼€å§‹å°è¯•é€šè¿‡æ¡ä»¶å˜é‡æ¥è¿›è¡Œåç¨‹ä¹‹é—´çš„é€šä¿¡ï¼Œæ›´æ–°å®Œ `CurrentConfig` åé€šçŸ¥å¦ä¸€ä¸ªåç¨‹å‘é€ pull Shard rpcã€‚ä½†è€ƒè™‘åˆ°ä¸€æ—¦è¿™ä¸ªç¯èŠ‚ group æŒ‚äº†ï¼Œserver é‡å¯åå¹¶ä¸èƒ½å¤ŸçŸ¥é“å½“å‰è¿›è¡Œåˆ°å“ªä¸€æ­¥ï¼Œå¹¶ä¸” Shard åœ¨ pull ä¹‹å‰æ˜¯ä¸èƒ½æä¾›æœåŠ¡çš„ã€‚æ‰€ä»¥è¿™ä¸ªæ–¹æ³•ç«‹å³è¢«æˆ‘å¼ƒç”¨äº†ã€‚

ä¸å¦¨æ¢ä¸ªæ€è·¯ã€‚ä»»æ„æ—¶åˆ»ï¼Œserver å¯èƒ½ä¼šæ‹¥æœ‰ä»¥ä¸‹å‡ ç±» Shardï¼š

1. ç»§ç»­æŒæœ‰çš„ï¼›
2. ä¸å†æŒæœ‰ï¼Œç­‰å¾…è¢«å…¶å®ƒ server pull çš„ï¼›
3. ä¸å†æŒæœ‰ï¼Œä½†å·²ç»è¢«å…¶å®ƒ server pull çš„ï¼›
4. æ–°æŒæœ‰ï¼Œç­‰å¾… server ä»å…¶ä»– group é‚£ pull çš„ï¼›
5. æ–°æŒæœ‰ï¼Œå·²ç» pull åˆ°äº†çš„ï¼›

> å¦‚æœè€ƒè™‘è¦åš Challenge1ï¼Œåˆèƒ½å¤ŸæŠŠ 3 å’Œ 5 è¿›ä¸€æ­¥ç»†åˆ†ä¸ºï¼š
>
> 1. ç»§ç»­æŒæœ‰çš„ï¼›
> 2. ä¸å†æŒæœ‰ï¼Œç­‰å¾…è¢«å…¶å®ƒ server pull çš„ï¼›
> 3. ä¸å†æŒæœ‰ï¼Œä½†
>   1. è¢« pullï¼Œç­‰å¾…æ¥å— GC é€šçŸ¥ï¼›
>   2. è¢« pullï¼Œå·²è¿›è¡Œ GCï¼›
> 4. æ–°æŒæœ‰ï¼Œç­‰å¾… server ä»å…¶ä»– group é‚£ pull çš„ï¼›
> 5. æ–°æŒæœ‰ï¼Œä¸”
>   1. pull åˆ°ï¼Œéœ€å‘é€ GC é€šçŸ¥ï¼›
>   2. pull åˆ°ï¼ŒGC å‘é€å®Œæ¯•ã€‚
>
> ä¹‹æ‰€ä»¥è®¾è®¡ä¸º**æ–° owner pull åˆ° Shard åå‘æ—§ owner å‘é€ GC é€šçŸ¥**è€Œä¸æ˜¯**æ—§ owner åœ¨æ”¶åˆ° pull Shard å¹¶ reply OK åè‡ªè¡Œ GC**ï¼Œè¿˜æ˜¯å› ä¸ºå¦‚æœ reply å‘è¿‡å»çš„é€”ä¸­æ–° owner æŒ‚äº†ï¼Œé‡å¯åå› ä¸ºæ²¡ pull åˆ°è¿˜å¾—é‡æ–°å‘ pull Shard è¯·æ±‚ï¼Œè€Œæ­¤æ—¶æ—§ owner GC å®Œæ¯•åå­˜å‚¨æ¸…ç©ºäº†ï¼Œå°±ä¼šäº§ç”Ÿé”™è¯¯â€”â€”ç³»ç»Ÿæ°¸ä¹…æ€§åœ°å¤±å»äº†è¯¥ Shard å¯¹åº”çš„æ•°æ®ã€‚
>
> æ”¶åˆ° GC é€šçŸ¥ä¹Ÿæ„å‘³ç€æ–° owner æ”¶åˆ°äº† reply å¹¶å®Œæˆäº† Shard çš„è¦†ç›–ï¼Œå¯ä»¥è¿›è¡Œæ•°æ®å›æ”¶è€Œä¸ç”¨æ‹…å¿ƒæ˜¯å¦æŒ‚æ‰ã€‚å½“ç„¶ï¼Œæ–° owner æ”¶åˆ° reply ä¹Ÿæ„å‘³ç€æ—§ owner å®Œæˆäº† GCï¼Œä¸ç”¨å†å‘é€ GC é€šçŸ¥äº†ã€‚

é‚£å½“ç„¶æ˜¯é€‰æ‹©å®Œæˆ Challenge å•¦ï¼ä¸ºäº†å¯¹è¿™äº›ä¸åŒç§ç±»çš„ Shard è¿›è¡ŒåŒºåˆ†ï¼Œæ¯”è¾ƒå¥½çš„æ€è·¯æ˜¯åœ¨ Shard ç»“æ„ä½“å†…è®¾ç½®ä¸€ä¸ª **ShardStatus** å˜é‡ï¼Œå¹¶ä¸”éœ€è¦å°†å…¶æŒä¹…åŒ–ã€‚è¿™æ ·æ— è®ºæ˜¯å¦æŒ‚æ‰ï¼Œgroup éƒ½èƒ½åœ¨**ä»»æ„æ—¶åˆ»**æ ¹æ® Shard å†…éƒ¨çš„ Status å˜é‡è¿›è¡Œç›¸åº”çš„æ“ä½œã€‚å¹¶ä¸”é™¤äº† ConfigPuller åç¨‹ï¼Œæˆ‘ä»¬è¿˜éœ€è¦å†å¯åŠ¨ä¸¤ä¸ª `ShardPuller` å’Œ `GarbageCollector` åç¨‹ï¼Œå¼‚æ­¥åœ°è¿›è¡Œ**éå† Shard å¹¶æ ¹æ® ShardStatus æ‰§è¡Œ RPC ç­‰æ“ä½œ**ã€‚å’Œä¹‹å‰æåˆ°çš„ä¸€æ ·ï¼Œæˆ‘ä»¬ä¾ç„¶éœ€è¦ Leader æ¥è¿›è¡Œä¸€ç³»åˆ—äº¤äº’è¡Œä¸ºï¼Œå¹¶åˆ©ç”¨ Raft å±‚è¿›è¡Œæ—¥å¿—åŒæ­¥ï¼Œæ‰€æœ‰ server æ”¶åˆ°ä¸‹å±‚ä¼ ä¸Šæ¥çš„ ApplyMsg åæ‰§è¡Œæœ€ç»ˆçš„ä¿®æ”¹æ“ä½œã€‚

> å…¶ä¸­ 1, 3.b, 5.b éƒ½æ„å‘³ç€æ— éœ€ä»»ä½•åç»­æ“ä½œï¼Œç»Ÿä¸€è®¾ç½®ä¸º Ready çŠ¶æ€

```go
type status int

const (
  // everyone
  Ready status = iota // ä¸€åˆ‡å°±ç»ª
  // new owner
  NeedPull       // è¡¨æ˜è¯¥åˆ†ç‰‡ç­‰å¾…ä»å…¶ä»– group å¤„æ‹‰å–
  ReadyButNeedSendGC // å°±ç»ªï¼Œä½†éœ€è¦é€šçŸ¥å…¶ä»– group è¿›è¡Œ GC
  // old owner
  Waiting // è¡¨æ˜è¯¥åˆ†ç‰‡ç­‰å¾…è¢«å…¶ä»– group æ‹‰å– + é€šçŸ¥ GC
)

type Shard struct {
  KVs     map[string]string
  ShardStatus status
}
```

ä¸€ä¸ª Shard èƒ½ä¸èƒ½æ­£ç¡®å¤„ç† client è¯·æ±‚ï¼Œä¸€æ˜¯çœ‹å®ƒæ˜¯å¦è¢«å½“å‰ server æŒæœ‰ï¼ŒäºŒæ˜¯çœ‹è¯¥ Shard çŠ¶æ€æ˜¯å¦ä¸º Ready/ReadyButNeedSendGCï¼Œä»»ä¸€æ¡ä»¶ä¸æ»¡è¶³ï¼Œéƒ½è¿”å› `ErrWrongGroup`ã€‚åœ¨ Apply å®¢æˆ·ç«¯æ“ä½œæ—¶ï¼Œéœ€è¦å°† lab3 çš„ä»£ç ä¿®æ”¹ä¸ºï¼š

```go
func (kv *ShardKV) ApplyCommand(msg raft.ApplyMsg) {
  // locked
  command := msg.Command.(OperationCommand)
  ch := command.Ch
  reply := new(Reply)

  shardId := key2shard(command.Key)

  if !kv.ReadyForServer(shardId) {
    reply.Err = ErrWrongGroup
  } else if command.Op == "Get" {
    // Get
  } else if kv.isDuplicated(command.RequestId, command.ClerkId) {
    reply.Err = kv.lastRequestInfo[command.ClerkId].Err
  } else {
    // Put or Append
    kv.lastRequestInfo[command.ClerkId] = &RequestInfo{
      RequestID: command.RequestId,
      Err:     reply.Err,
    }
  }

  if kv.rf.GetRaftState() == raft.Leader && kv.rf.GetCurrentTerm() == msg.CommandTerm {
    go func(reply_ *Reply) {
      ch <- reply_
    }(reply)
  }
}
```

è€ƒè™‘åˆ° group ä¼šæŒ‚æ‰è¿™ä¸ªæƒ…å†µï¼Œé‡å¯åæ‰¾è° pull Shard ä¹Ÿæ˜¯ä¸ªé—®é¢˜ï¼Œæ•…é™¤äº† CurrentConfigï¼Œserver å†…éƒ¨è¿˜éœ€è®¾ç½®ä¸€ä¸ª LastConfig å˜é‡ã€‚åœ¨ lab3 çš„åŸºç¡€ä¸Šï¼Œserver ç»“æ„ä½“åº”è¯¥ä¿®æ”¹ä¸ºè¿™æ ·ï¼š

```go
type ShardKV struct {
  mu     sync.RWMutex
  me     int
  mck    *shardctrler.Clerk
  rf     *raft.Raft
  applyCh  chan raft.ApplyMsg
  make_end func(string) *labrpc.ClientEnd
  gid    int
  ctrlers  []*labrpc.ClientEnd

  maxraftstate int // snapshot if log grows this big
  lastapplied  int

  Shards      [shardctrler.NShards]Shard
  lastRequestInfo map[int64]*RequestInfo

  lastConfig  shardctrler.Config // (!new)
  currentConfig shardctrler.Config
}
```

ğŸ‰è¿™æ ·ä¸€æ¥æ•´ä½“çš„å·¥ä½œæµç¨‹å°±å¾ˆæ˜æœ—äº†ï¼š

1. `ConfigPuller` è·å¾—è¾ƒæ–°çš„ Configï¼Œé€šè¿‡ Raft å±‚è¿›è¡Œ `UpdateConfig` æ—¥å¿—åŒæ­¥ï¼›
2. Apply åˆ° `UpdateConfig` æ—¥å¿—å
   - å¯¹äºä»æŒæœ‰çš„ Shardï¼Œä¸ä½œå˜åŠ¨ï¼›
   - å¯¹äºä¸å†æŒæœ‰çš„ï¼Œè®¾ç½®çŠ¶æ€ä¸º `Waiting`ï¼›
   - å¯¹äºæ–°æŒæœ‰çš„ï¼Œè®¾ç½®çŠ¶æ€ä¸º `NeedPull`ï¼›
3. `ShardPuller` å®šæœŸè¿›è¡Œæ£€æµ‹ï¼Œä¸€æ—¦å‘ç°å­˜åœ¨çŠ¶æ€ä¸º `NeedPull` çš„ Shardï¼Œæ ¹æ® LastConfig æ‰¾åˆ°æ—§ owner å¹¶å‘é€ pull Shard RPCï¼›
4. æ—§ owner æ— æ¡ä»¶å°† Shard å†™å…¥ reply å¹¶å›å¤ï¼Œä¸å¿…è€ƒè™‘æ˜¯å¦è¿‡æœŸï¼Œå› ä¸ºä¸ä¼šæ”¹å˜å…¶çŠ¶æ€ï¼›
5. æ–° owner æ”¶åˆ° reply åï¼Œç«‹å³ `rf.Start()` ä¸€æ¡ `InsertShard` æ—¥å¿—ï¼Œå¹¶åœ¨ Apply åè®¾ç½®ç›¸åº” Shard çš„çŠ¶æ€ä¸º `ReadyButNeedSendGC`ï¼›
6. `GarbageCollector` å®šæœŸè¿›è¡Œæ£€æµ‹ï¼Œä¸€æ—¦å‘ç°å­˜åœ¨çŠ¶æ€ä¸º `ReadyButNeedSendGC` çš„ Shardï¼Œæ ¹æ® LastConfig æ‰¾åˆ°æ—§ owner å¹¶å‘é€ garbage collector RPCï¼›
7. æ—§ owner æ”¶åˆ° GC é€šçŸ¥ï¼Œå°±å¯ä»¥è®¤ä¸ºä¸Šæ¬¡çš„ PullReply å·²ç»è¢«æ–° owner æ¥æ”¶ï¼Œç«‹å³ `rf.Start()` ä¸€æ¡ `GarbageCollect` æ—¥å¿—ï¼ŒApply åæ¸…ç†æ•°æ®ï¼Œå¹¶è®¾ç½®çŠ¶æ€ä¸º `Ready`ï¼›
8. æ–° owner æ”¶åˆ° GC çš„ reply åï¼Œå°±å¯ä»¥è®¤ä¸º GC é€šçŸ¥å·²ç»å‘åˆ°æ—§ owner æ‰‹ä¸Šï¼Œå¯ä»¥ä¿®æ”¹ ShardStatus é˜²æ­¢ GarbageCollector è¿›è¡Œé‡å¤ GC é€šçŸ¥ï¼Œå³ `rf.Start()` ä¸€æ¡ `GarbageCollect` æ—¥å¿—ï¼ŒApply åè®¾ç½®çŠ¶æ€ä¸º `Ready`ã€‚

> 7, 8 ä¸¤æ­¥çš„ä¸åŒä¹‹å¤„åœ¨äºï¼Œæ–°æ—§ owner Apply GC æ—¥å¿—æ—¶ï¼Œç›¸åº”çš„ Shard çŠ¶æ€ä¸åŒï¼Œå‰è€…ä¸º `ReadyButNeedSendGC`ï¼Œåè€…ä¸º `Waiting`ã€‚æ ¹æ®çŠ¶æ€ä¸åŒæ‰§è¡Œä¸åŒæ“ä½œå³å¯ï¼Œè€Œä¸éœ€è¦ä¸ºæ–° owner å†æ–°å®šä¹‰ä¸€ä¸ª `UpdateStatus` è¿™æ ·çš„æ—¥å¿—ç±»åˆ«ã€‚

**æ³¨æ„**ï¼šConfigPuller ä¸èƒ½æ— æ¡ä»¶è¿›è¡Œ Update Configï¼Œå¦åˆ™ä¼šç ´åå½“å‰ Shard çš„çŠ¶æ€ï¼Œç”šè‡³å¯èƒ½å­˜åœ¨éƒ¨åˆ† Shard ä»æœª pull åˆ°å°±éœ€è¦å›å¤å…¶å®ƒ group çš„ pull è¯·æ±‚ï¼Œç»“æœæ˜¯ä¸€éƒ¨åˆ†ä»»åŠ¡æ°¸è¿œæ— æ³•æ­£ç¡®å®Œæˆï¼Œä»è€Œç³»ç»Ÿé™·å…¥æ— å°½çš„é”™è¯¯ã€‚ç”±äºæˆ‘ä»¬å¼•å…¥äº† ShardStatus è¿™ä¸€æ¦‚å¿µï¼Œæ•…ä»¤**ä»…å½“æ‰€æœ‰ Shard éƒ½å˜ä¸º Ready åæ‰èƒ½æ›´æ–° Config**ã€‚è¿™æ˜¯ä¸€ç§æ›´å®‰å…¨çš„è¡Œä¸ºã€‚

**æ³¨æ„**ï¼šå¯èƒ½æŸäº› Shard åœ¨è¿ç§»å‰ä»ç„¶ç”±æ—§ owner å‘ client æä¾›æœåŠ¡ï¼Œæ•…å­˜åœ¨è¿™æ ·ä¸€ç§æƒ…å†µï¼šclient å‘ group1 å‘é€ shard1 å†™è¯·æ±‚åï¼Œgroup1 å®é™…ä¸Šæ‰§è¡Œäº†è¿™ä¸€æ“ä½œï¼Œä½†ç»™ client çš„ reply ä¸¢åŒ…äº†ï¼Œè€Œå…¶å®ƒ server ç”±äºä¸æ˜¯ Leader æ— æ³•åº”å¯¹è¯·æ±‚ï¼Œæ•…è®¤ä¸º group1 å…¨æŒ‚äº†ï¼Œæ­¤æ—¶æ°å¥½å‘ç° Config å­˜åœ¨æ›´æ–°ï¼Œä¸”æ–° Config ä¸‹ shard1 å½’å±äº group2ï¼Œclient è½¬è€Œå‘ group2 å‘é€åŒä¸€å†™è¯·æ±‚ã€‚group2 å‘ group1 pull äº†åº”ç”¨è¿‡è¯·æ±‚çš„ Shard åï¼Œæ”¶åˆ° client çš„åŒä¸€è¯·æ±‚ï¼Œåˆæ‰§è¡Œäº†ä¸€éã€‚ä¸ºäº†æ»¡è¶³å¹‚ç­‰æ€§ï¼Œpull Shard reply é‡Œè¿˜åº”è¯¥åŒ…æ‹¬æ—§ owner çš„**å»é‡è¡¨**æ¥åº”å¯¹è¿™ä¸€æƒ…å†µã€‚æ–° owner æ”¶åˆ°åä¼šå’Œè‡ªå·±çš„å»é‡è¡¨è¿›è¡Œæ¯”å¯¹ï¼Œå–åŒä¸€ clerkId ä¸‹çš„æœ€æ–° requestã€‚

å¦å¤–ï¼Œæˆ‘ä¹Ÿé‡åˆ°äº†[è°­ä½¬é‡åˆ°çš„åŒæ ·é—®é¢˜](https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md)ï¼š

> æœ€åï¼Œåœ¨ lab2 çš„æ–‡æ¡£ä¸­æˆ‘å°±æåˆ°äº† leader ä¸Šçº¿ååº”è¯¥ç«‹åˆ» append ä¸€æ¡ç©ºæ—¥å¿—ï¼Œè¿™æ ·æ‰å¯ä»¥ä¿è¯ leader çš„çŠ¶æ€æœºæœ€æ–°ï¼Œç„¶è€Œä¸å¹¸çš„æ˜¯ï¼Œlab2 çš„æµ‹è¯•åœ¨åŠ äº†ç©ºæ—¥å¿—åä¾¿ Fail äº†ï¼Œå› æ­¤æˆ‘ä¾¿æ²¡æœ‰å†å…³æ³¨ã€‚åœ¨å®ç° lab4 æ—¶ï¼Œæˆ‘æœ€å¼€å§‹å¹¶æ²¡æœ‰å…³æ³¨è¿™ä»¶äº‹ï¼Œæœ€åæˆäº†ä¸€ä¸ªå¤§å‘ï¼Œå¯¼è‡´æˆ‘èŠ±è´¹äº†ä¸€å¤©çš„æ—¶é—´æ‰æ‰¾åˆ°é—®é¢˜ã€‚è¯¥ bug ä¸€èˆ¬è·‘ 100 æ¬¡æµ‹è¯•èƒ½å¤Ÿå¤ç°ä¸€æ¬¡ï¼Œå¯¹å¤–çš„è¡¨ç°æ˜¯é›†ç¾¤å‡ºç°æ´»é”ï¼Œæ— æ³•å†æœåŠ¡è¯·æ±‚ç›´åˆ°è¶…æ—¶ï¼Œè€Œä¸”ä»…ä¼šåœ¨å‡ ä¸ªæ¶‰åŠåˆ°é‡å¯çš„æµ‹è¯•ä¸­å‡ºç°ã€‚ç»è¿‡ä¸€ç•ªæ¢ç´¢ï¼Œæœ€ç»ˆå‘ç°æ˜¯åœ¨èŠ‚ç‚¹é¢‘ç¹çš„é‡å¯è¿‡åï¼Œå‡ºç°äº† lab2 ä¸­æè¿°ç©ºæ—¥å¿—å¿…è¦æ€§çš„ä¾‹å­ã€‚è¿™å¯¼è‡´æŸä¸€ raft ç»„çš„çŠ¶æ€æœºæ— æ³•è¾¾åˆ°æœ€æ–°ä¸”ä¸å…¨æ˜¯é»˜è®¤çŠ¶æ€ï¼Œè¿™ä½¿å¾—é…ç½®æ›´æ–°åç¨‹ä¹Ÿæ— æ³•æäº¤æ–°çš„é…ç½®æ—¥å¿—ï¼Œæ­¤æ—¶å®¢æˆ·ç«¯ç¢°å·§æ²¡æœ‰å‘è¯¥ raft ç»„æ‰§è¡Œè¯»å†™è¯·æ±‚ï¼Œå› è€Œè¯¥ raft ç»„å§‹ç»ˆæ²¡æœ‰å½“å‰ term çš„æ—¥å¿—ï¼Œä»è€Œæ— æ³•æ¨è¿› commitIndexï¼Œå› æ­¤æ•´ä¸ªé›†ç¾¤ä¾¿å‡ºç°äº†æ´»é”ã€‚è¯¥ bug çš„è§£å†³æ–¹æ³•å¾ˆç®€å•ï¼Œå°±æ˜¯è®© raft å±‚çš„ leader åœ¨ kv å±‚å‘¨æœŸæ€§çš„å»æ£€æµ‹ä¸‹å±‚æ˜¯å¦åŒ…å«å½“å‰ term çš„æ—¥å¿—ï¼Œå¦‚æœæ²¡æœ‰ä¾¿ append ä¸€æ¡ç©ºæ—¥å¿—ï¼Œè¿™æ ·å³å¯ä¿è¯æ–°é€‰å‡ºçš„ leader çŠ¶æ€æœºèƒ½å¤Ÿè¿…é€Ÿè¾¾åˆ°æœ€æ–°ã€‚å…¶å®æˆ‘è®¤ä¸ºå°†ç©ºæ—¥å¿—æ£€æµ‹åšåˆ° KV å±‚å¹¶ä¸å¤Ÿä¼˜é›…ï¼ŒKV å±‚ä¸éœ€è¦å»äº†è§£ raft å±‚æœ‰æ— ç©ºæ—¥å¿—ä¼šæ€ä¹ˆæ ·ï¼Œæ›´ä¼˜é›…åœ°æ–¹å¼åº”è¯¥æ˜¯ raft å±‚çš„ leader ä¸€ä¸Šçº¿å°±æäº¤ä¸€ä¸ªç©ºæ—¥å¿—ã€‚ä½†æ€»ä¹‹ç›®å‰åœ¨ 6.824 çš„æ¡†æ¶ä¸‹ï¼Œä¹Ÿåªèƒ½åœ¨ KV å±‚åšæ£€æµ‹äº†ã€‚

æˆ‘å‚è€ƒäº†ä»–çš„åšæ³•ï¼ŒåŠ å…¥äº†**ç©ºæ—¥å¿—æ£€æµ‹æœºåˆ¶**ã€‚åŸæ–‡ä¸­æœ‰æåˆ°ï¼Œä¸å†èµ˜è¿°ã€‚

åŸºäºä»¥ä¸Šè®¨è®ºï¼Œæ•´ä½“æ¶æ„å°±èƒ½è¿›è¡Œå¦‚ä¸‹è®¾è®¡äº†ã€‚

#### StartServer

æ³¨æ„ Shard.KVs éœ€è¦å…ˆ make() å¯¹è±¡ã€‚

```go
func StartServer(servers []*labrpc.ClientEnd, me int, persister *raft.Persister, maxraftstate int, gid int, ctrlers []*labrpc.ClientEnd, make_end func(string) *labrpc.ClientEnd) *ShardKV {
  labgob.Register(OperationCommand{})
  labgob.Register(ConfigCommand{})
  labgob.Register(ShardCommand{})
  labgob.Register(EmptyCommand{})

  kv := &ShardKV{
    me:        me,
    mck:       shardctrler.MakeClerk(ctrlers),
    make_end:    make_end,
    gid:       gid,
    ctrlers:     ctrlers,
    maxraftstate:  maxraftstate,
    lastapplied:   0,
    lastRequestInfo: make(map[int64]*RequestInfo),
    lastConfig:    shardctrler.Config{Num: 0},
    currentConfig:   shardctrler.Config{Num: 0},
  }
  kv.applyCh = make(chan raft.ApplyMsg)
  kv.rf = raft.Make(servers, me, persister, kv.applyCh)

  for i := range kv.Shards {
    kv.Shards[i].KVs = make(map[string]string)
  }
  kv.ApplySnapshot(-1, -1, persister.ReadSnapshot())

  go kv.Applier()
  go kv.ConfigPuller()
  go kv.ShardPuller()
  go kv.GarbageCollector()
  go kv.EmptyEntryDetector()

  return kv
}
```

#### MsgStruct

ä¸ºä¸åŒæ“ä½œå‘½ä»¤å®šä¹‰äº†ä¸åŒç±»å‹ï¼Œè¿™æ ·å°±èƒ½é€šè¿‡ msg.Command.(type) è¿›è¡Œå¼ºè½¬ï¼Œå¹¶è¿›ä¸€æ­¥æ ¹æ® Command.Op æ‰§è¡Œä¸åŒæ“ä½œã€‚rpc çš„å‚æ•°ä¹Ÿç»Ÿä¸€é‡‡ç”¨ RPCArgs çš„æ ¼å¼â€”â€”pull Shard è¯·æ±‚å’Œ GC é€šçŸ¥éƒ½éœ€è¦ ShardId ä¸ ConfigNumã€‚

```go
// cmd
type OperationCommand struct {
  Op    string
  Key     string
  Value   string
  ClerkId   int64
  RequestId int
  Ch    chan *Reply
}

type Reply struct {
  Err   Err
  Value string
}

type ShardCommand struct {
  Op        string
  Shard       *Shard
  Sid       int
  ConfigNum     int
  LastRequestInfo map[int64]RequestInfo
}

type ConfigCommand struct {
  LastConfig shardctrler.Config
  NewConfig  shardctrler.Config
}

type EmptyCommand struct {
}

// RPC
type RPCArgs struct {
  Op    string
  ShardId   int
  ConfigNum int
}

type RPCReply struct {
  Err       Err
  Shard       Shard
  ConfigNum     int
  LastRequestInfo map[int64]RequestInfo
}
```

#### Applier

å’Œ lab3 å¤§åŒå°å¼‚ï¼Œåªæ˜¯å¤šåŠ äº†ä¸€äº› Command ç±»å‹çš„åˆ¤æ–­ã€‚

```go
func (kv *ShardKV) Applier() {
  // goroutine
  for !kv.killed() {
    for msg := range kv.applyCh {
      if msg.CommandValid {
        kv.mu.Lock()
        if msg.CommandIndex > kv.lastapplied {
          kv.lastapplied = msg.CommandIndex
          // åŸºäº msg.Command.type æ‰§è¡Œä¸åŒ Apply æ“ä½œ
          if kv.NeedSnapshot() {
            kv.MakeSnapshot(msg.CommandIndex)
          }
        }
        kv.mu.Unlock()
      } else if msg.SnapshotValid {
        kv.mu.Lock()
        kv.ApplySnapshot(msg.SnapshotIndex, msg.SnapshotTerm, msg.Snapshot)
        kv.mu.Unlock()
      }
    }
  }
}
```

#### ConfigPuller

```go
func (kv *ShardKV) ApplyUpdateConfigCommand(msg raft.ApplyMsg) {
  // locked
  Command := msg.Command.(ConfigCommand)
  lastconfig, newconfig := Command.LastConfig, Command.NewConfig
  if newconfig.Num == kv.currentConfig.Num+1 { // é€ç‰ˆæœ¬è¿›è¡Œæ›´æ–°
    kv.lastConfig = lastconfig
    kv.currentConfig = newconfig

    if newconfig.Num > 1 {
      // config å‘ç”Ÿå˜åŒ–ï¼š
      // 1. åˆ†é…ä¸”ä»æŒæœ‰çš„ä¿æŒ Ready
      // 2. åˆ†é…ä½†æœªæŒæœ‰çš„å˜ä¸º NeedPullï¼Œç­‰åˆ°æ‹‰å– shard å®Œæˆåå˜ä¸º Valid
      // 3. æŒæœ‰ä½†æœªåˆ†é…çš„å˜ä¸º Waitingï¼Œç­‰å¾…å…¶ä»–ç»„ pull åè¢«å›æ”¶
    }
  }
}

func (kv *ShardKV) ConfigPuller() {
  // goroutine
  for !kv.killed() {
    if kv.rf.GetRaftState() == raft.Leader {
      kv.mu.RLock()
      CanPullConfig := true
      // åªè¦æœ‰ä¸€ä¸ª Shard ä¸æ˜¯ Readyï¼Œå°±ä¸èƒ½ Pull New Config
      kv.mu.RUnlock()  // åŠæ—¶æ”¾é”

      if CanPullConfig {
        newconfig := kv.GetNewConfig()
        if newconfig.Num > configNum {
          if configNum == 0 && newconfig.Num > 1 { // ç¬¬ä¸€æ¬¡åŠ å…¥é›†ç¾¤ï¼Œéœ€åˆå§‹åŒ– lastconfig
            lastConfig = kv.mck.Query(newconfig.Num - 1)
          }
          kv.rf.Start(ConfigCommand{
            LastConfig: lastConfig,
            NewConfig:  newconfig,
          })
        }
      }
    }
    time.Sleep(NewConfigQueryTimeOut)
  }
}
```

#### ShardPuller & GarbageCollector

ä¸¤è€…å…¶å®éå¸¸ç›¸ä¼¼ã€‚

```go
func (kv *ShardKV) ApplyShardCommand(msg raft.ApplyMsg) {
  Command := msg.Command.(ShardCommand)
  switch Command.Op {
  case "InsertShard":
    kv.InsertShard(Command)
  case "GarbageCollect":
    kv.GarbageCollect(Command)
  default:
    panic("Undefined Command!")
  }
}
```

```go
func (kv *ShardKV) InsertShard(Command ShardCommand) {
  // locked
  configNum, newshard, sid := Command.ConfigNum, Command.Shard, Command.Sid
  if configNum == kv.currentConfig.Num && kv.Shards[sid].ShardStatus == NeedPull { // è¦†ç›– Shard å‰æ£€æŸ¥è¯¥å‘½ä»¤æ˜¯å¦è¿‡æœŸ
    // è¦†ç›– kv å¯¹ä¸å»é‡è¡¨ï¼Œå¹¶ä¿®æ”¹ ShardStatus ä¸º ReadyButNeedSendGC
  }
}

func (kv *ShardKV) ShardPuller() {
  // goroutine
  for !kv.killed() {
    if kv.rf.GetRaftState() == raft.Leader {
      kv.mu.RLock()
      configNum := kv.currentConfig.Num // æå¸¦å½“å‰ config.numï¼Œé˜²æ­¢æ”¶åˆ°è¿‡æœŸå›å¤
      var wg sync.WaitGroup
      for sid, gid := range kv.lastConfig.Shards {
        if kv.NeedPull(sid) {
          wg.Add(1)
          go func(sid, gid int, others []string) {
            defer wg.Done()
            // Send RPC and Pull Shard
          }(sid, gid, kv.lastConfig.Groups[gid])
        }
      }
      kv.mu.RUnlock()
      wg.Wait()
    }
    time.Sleep(ShardPullerTimeOut)
  }
}
```

```go
func (kv *ShardKV) GarbageCollect(Command ShardCommand) {
  // locked
  configNum, sid := Command.ConfigNum, Command.Sid
  if configNum == kv.currentConfig.Num {
    if kv.Shards[sid].ShardStatus == ReadyButNeedSendGC {
      kv.Shards[sid].ShardStatus = Ready
    } else if kv.Shards[sid].ShardStatus == Waiting {
      kv.Shards[sid].KVs = make(map[string]string)
      kv.Shards[sid].ShardStatus = Ready
    }
  }
}

func (kv *ShardKV) GarbageCollector() {
  // locked
  for !kv.killed() {
    if kv.rf.GetRaftState() == raft.Leader {
      kv.mu.RLock()
      configNum := kv.currentConfig.Num // æå¸¦å½“å‰ config.numï¼Œé˜²æ­¢æ”¶åˆ°è¿‡æœŸå›å¤
      var wg sync.WaitGroup
      for sid, gid := range kv.lastConfig.Shards {
        if kv.ReadyButNeedSendGC(sid) { // å‘å‰ä»»æŒæœ‰è€…å‘é€ GC è¯·æ±‚
          wg.Add(1)
          go func(sid, gid int, others []string) {
            defer wg.Done()
            // Send RPC and make GC
          }(sid, gid, kv.lastConfig.Groups[gid])
        }
      }
      kv.mu.RUnlock()
      wg.Wait()
    }
    time.Sleep(GarbageCollectorTimeOut)
  }
}
```

#### EmptyEntryDetector

```go
func (kv *ShardKV) ApplyEmptyCommand() {
  // "EMPTY COMMAND"
}
func (kv *ShardKV) EmptyEntryDetector() {
  for !kv.killed() {
    if kv.rf.GetRaftState() == raft.Leader {
      if !kv.rf.HasLogAtCurrentTerm() {
        kv.rf.Start(EmptyCommand{})
      }
    }
    time.Sleep(EmptyEntryDetectorTimeOut)
  }
}
```

#### ç»„é—´ RPC

```go
func (kv *ShardKV) HandleBetweenGroupRequest(args *RPCArgs, reply *RPCReply) {
  // RPC
  if kv.rf.GetRaftState() != raft.Leader {
    reply.Err = ErrWrongLeader
    return
  }

  kv.mu.RLock()
  defer kv.mu.RUnlock()

  sid, configNum := args.ShardId, args.ConfigNum
  if configNum > kv.currentConfig.Num {
    reply.ConfigNum, reply.Err = kv.currentConfig.Num, ErrNotReady
    return
  }

  // å…è®¸æ¥æ”¶è¿‡æœŸ RPCï¼Œä½† reply ä¼šæå¸¦ CurrentConfigNumï¼Œè¿™æ ·å°½ç®¡æ”¶åˆ°è¿‡æœŸ reply ä¹Ÿä¸ä¼šè¿›è¡Œä»»ä½•æ“ä½œ
  switch args.Op {
  case "PullShard":
    // æ— æ¡ä»¶å›å¤
  case "GarbageCollect":
    // æ— æ¡ä»¶ Start æ–°å‘½ä»¤ï¼Œå°†çŠ¶æ€åˆ¤æ–­ç•™ç»™ Apply é˜¶æ®µ
  }
  reply.ConfigNum, reply.Err = configNum, OK
}
```

## æ€»ç»“

è¿™ä¹ˆè®¾è®¡æœ‰ä»¥ä¸‹å¥½å¤„ï¼š

1. pull Shard åèƒ½ç«‹å³ä¸º client æä¾›æœåŠ¡ï¼Œè€Œæ— éœ€é˜»å¡ï¼›
2. ä¸åŒ group ä¹‹é—´ Shard çŠ¶æ€äº’ä¸ºåŒæ­¥å…³ç³»ï¼Œç½‘ç»œé¡ºç•…æ—¶ç³»ç»Ÿæ‰èƒ½å¤ŸæŒç»­è¿›è¡Œï¼›
3. ä¸åŒ ShardId çš„ Shard äº’ç›¸ç‹¬ç«‹ï¼Œå½“ä¸¤ç»„äº’ç›¸è¿ç§» Shard æ—¶å¹¶ä¸ä¼šé€ æˆæ­»é”ï¼›
4. group èƒ½å¤Ÿ step-by-step åœ°æ›´æ–° Configï¼Œæ‰€æœ‰ä»»åŠ¡éƒ½èƒ½ç¨³å®šæ‰§è¡Œï¼Œè€Œä¸ä¼šå‡ºç°æ­¥å­è·¨å¤ªå¤§æ‰¯ç€è›‹çš„æƒ…å†µï¼›
5. å¤±å» Shard æ‰€æœ‰æƒçš„ group èƒ½å¤Ÿå®šæœŸåˆ é™¤æ•°æ®ï¼Œè€Œä¸ä¼šä½¿å­˜å‚¨æ— çº¿å¢é•¿ï¼›
6. åŸºäº ShardStatus çš„ä»»åŠ¡æ‰§è¡Œå‡å°‘äº†ä¸å¿…è¦çš„é˜»å¡ï¼Œä½¿å¾—æ•´ä¸ªç³»ç»Ÿè®¾è®¡æ›´åŠ ä¼˜é›…ï¼›

æ€»ä¹‹ç³»ç»Ÿçš„è®¾è®¡è¿˜æ˜¯éœ€è¦çµæ„Ÿä¸æ— æ•°å‰äººçš„ç»éªŒæ€»ç»“ï¼Œè‡³å°‘ Aurora çš„è®ºæ–‡ç»™äº†æˆ‘å¾ˆå¤§å¯è¿ªã€‚è™½ç„¶å› ä¸ºç£•ç›åŸå›  4B ç£¨è¹­äº†å¾ˆä¹…ï¼Œæ•´ä¸ª lab å‰å‰ååç£¨è¹­äº†è¿‘ 3 ä¸ªæœˆï¼Œä½†æ€»å½’æ˜¯ solo && all passed äº†ï¼Œå¯¹ Distributed System ä¹Ÿæœ‰äº†æ›´è¿›ä¸€æ­¥çš„ç†è§£ã€‚å®Œç»“æ’’èŠ±~
