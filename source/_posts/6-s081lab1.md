---
title: 6.s081 lab system calls
author: Leager
mathjax: true
date: 2023-10-23 14:54:14
summary:
categories:
  - MIT6.s081
tags:
  - lab
img:
---

本 lab 要求我们进行系统调用代码的编写。

<!--more-->

## Preparation

切换到对应分支

```bash
$ git fetch
$ git checkout syscall
$ make clean
```

> 可以看到 `Makefile` 里内容都重置了，且测试脚本名也变成了 `grade-lab-syscall`

## 用户层是如何进行系统调用的

以 `sleep.c` 为例，在前一个 lab 中我们知道要修改 `Makefile` 中的 `UPROGS` 变量，并且 `user/user.h` 中也为我们提供了 `sleep()` 的函数声明，但有一件事一直让我们感到疑惑，只不过上一个 lab 中并没有影响，那就是 `sleep()` 的定义在哪里？

事实上，`Makefile` 在构建时，会首先调用 `user/usys.pl` 脚本文件，其作用是生成一个汇编语言文件 `usys.S`，这个文件会被解释成 `usys.o`，最后再和其它 `*.o` 文件一起链接成内核文件。那么这个脚本具体做了什么事呢？根据阅读我们发现，该文件就是利用 `entry()` 将用户层的各个函数注册成汇编语言，比如 `entry("sleep")` 会被注册为

```s
sleep:
li a7, SYS_sleep
ecall
ret
```

也就是调用用户层的 `sleep()` 时，将 `SYS_sleep` 加载到寄存器 `a7` 中，然后调用 `ecall` 指令。`user.h` 中的所有函数都在 `usys.pl` 中得到注册，所以它们的实现形式都是一样的。

那么这个 `SYS_sleep` 是个什么东西？在 `kernal/syscall.c` 中有个叫 `syscalls[]` 的数组，这就是系统调用表，记载了系统调用号 `SYS_xxx` 到系统调用函数指针 `sys_xxx` 的映射，那么 `SYS_sleep` 对应的就是系统调用 `sys_sleep` 了。

> 这些 `SYS_xxx` 的值都在 `kernal/syscall.h` 中定义。


往下看，看到一个 `void syscall(void)` 的函数，它取出当前进程 `trapframe` 下 `a7` 的值……这个值好熟悉，原来就是上面我们放入的那些 `SYS_xxx`。读取这个值后，从系统调用表中找到相应的系统调用函数指针并执行。

我们知道在调用 `sleep()` 时将 `SYS_sleep` 放进了 `a7`，但有一个问题：参数哪里去了？`sleep` 后面肯定要跟一个参数的啊？再看 `kernal/sysproc.c` 里的 `sys_sleep()` 函数，里面有个 `argint()` 操作，就是获取参数用的，原来这些参数依次被放到 `a0~a5` 寄存器中。这样一来基本都明朗了。

总结起来就是，对于任何一个用户层中允许调用的内核函数 `func()`，首先要在 `user/user.h` 中声明，还得在 `user/usys.pl` 中注册，在 `kernal/syscall.h` 定义新的系统调用号 `SYS_func`，以及在 `kernal/syscall.c` 的系统调用表中注册新的条目 `SYS_func => sys_func()`。当然不能忘了修改 `Makefile` 的 `UPROGS` 变量。

当调用 `func()` 时，会将 `SYS_func` 载入 `a7`，然后调用 `ecall` 指令，进入到 `syscall()` 函数中，取出 `a7` 的系统调用号，查表得到系统调用 `sys_func()` 并执行，将返回值存到进程的 `a0` 寄存器中，最后调用 `ret` 返回。这就是完整流程。

## Task1: System call tracing

### 实现系统调用

该任务要求我们实现 `trace` 命令，用于追踪特定命令的相应系统调用，并为其在 `kernal/` 文件夹下实现相应的系统调用。lab 已经为我们准备好了 `user/trace.c`。根据上面知识，我们修改完 `user/user.h`，`user/usys.pl`，`Makefile`，`kernal/syscall.h`，`kernal/syscall.c`，就可以正式编译了。

> `user/user.h`: int trace(int);
> `user/usys.pl`: entry("trace");
> `Makefile`: $U/_trace\
> `kernal/syscall.h`: #define SYS_trace 22
> `kernal/syscall.c`: [SYS_trace] sys_trace

但编译还不能通过，是因为我们还没有实现 `sys_trace()`。该函数在 `kernal/sys_proc.c` 中定义，作用就是令当前进程记住我们传入的参数 trace mask，这里需要在 `kernal/proc.h` 中为 `proc` 结构体新增一个变量 `int trae_mask`，然后在 `sys_trace()` 中利用 `argint()` 获取参数并赋值即可，函数如下：

```C
/* kernal/sysproc.c */
uint64
sys_trace(void)
{
  if (argint(0, &myproc()->trace_mask) < 0) {
    return -1;
  }
  return 0;
}
```

> 因为 exec 只会改变执行的代码段，进程还是同一个，`trace_mask` 变量并不会被修改，所以无需担心。

为了令 `trace` 在 `fork` 场景下也支持追踪功能，需要在 `fork()` 系统调用中追加子进程拷贝父进程的 `trace_mask`，实现略。

### 打印信息

现在我们已经让当前进程记住了 trace mask，接下来需要在执行命令时根据 mask 打印信息，格式为：

```bash
$ <pid>: syscall <syscall name> -> <return value>
```

我们需要每遇到一个**被跟踪的**系统调用都打印一遍信息，这就要在 `kernal/syscall.c` 中的 `syscall()` 函数中实现了，判断条件就是 `(trace_mask >> num) & 1` 非零.

```C
/* kernal/syscall.c */
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num](); // 系统调用返回值
    if ((p->trace_mask >> num) & 1) {
      printf("%d: syscall %s -> %d\n", p->pid, syscall_name[num], p->trapframe->a0);
    }
  }
  ...
}
```

最后进行测试：

```bash
$ ./grade-lab-syscall trace
...
== Test trace 32 grep == trace 32 grep: OK (1.1s) 
== Test trace all grep == trace all grep: OK (1.0s) 
== Test trace nothing == trace nothing: OK (1.0s) 
== Test trace children == trace children: OK (13.2s)
```

## Task2: Sysinfo

该任务要求我们实现 `sysinfo(sysinfo*)` 函数，并为传入的结构体填充字段，分别为：

1. `freemem`: 空闲内存字节数；
2. `nproc`: 当前进程数；

由于这也是一个新建的系统调用函数，所以我们需要像上一个任务一样修改以下文件 `user/user.h`，`user/usys.pl`，`Makefile`，`kernal/syscall.h`，`kernal/syscall.c`，并且在 `kernal/sysproc.c` 中添加并实现 `sys_sysinfo()` 函数。

> `user/user.h`: int sysinfo(struct sysinfo *);
> `user/usys.pl`: entry("sysinfo");
> `Makefile`: $U/_sysinfo\
> `kernal/syscall.h`: #define SYS_sysinfo 23
> `kernal/syscall.c`: [SYS_sysinfo] sys_sysinfo

然而，lab 并没有为我们提供现成的“获取空闲字节数”与“获取当前进程数”的 API，需要我们自己实现。这两个 API 可以分别在 `kernal/kalloc.c` 与 `kernal/proc.c` 中实现（需要在 `kernal/defs.h` 中添加声明）。

### 获取空闲内存字节数

`kernal/kalloc.c` 中有一个名为 `kmem` 的数据结构，它维护了一个空闲链表。

事实上，所有内存中未分配的页面都有一个 header，大小为 64 位（一个指针那么大），指向（逻辑上的）下一个未分配的页面，这个指针在软件层面用数据结构 `struct run` 表示。一旦有一个空闲页面 `page` 被分配，那么（逻辑上的）上一个页面 `prev` 的 `run` 就会指向 `page` 的（逻辑上的）下一个空闲页面 `next`；而有个物理页被 free 了，就让它成为空闲链表的表头。

> 这可以在 `kernal/kalloc.c` 中的 `kalloc()` 与 `kfree()` 中得知。

那空闲内存的字节数就很好计算了，就是**空闲页面数*页面大小**嘛。写成代码就是

```C
/* kernal/kalloc.c */
int
kfreemem(void)
{
  int npage = 0;
  acquire(&kmem.lock);
  struct run *r = kmem.freelist;
  while (r) {
    r = r->next;
    npage++;
  }
  release(&kmem.lock);
  return npage * PGSIZE;
}
```

### 获取当前进程数

`kernal/proc.c` 中为我们定义了一个名为 `proc` 的进程表（对的，和结构体 `struct proc` 同名），我们只需要遍历该表，检查进程状态即可。

```C
/* kernal/proc.c */
int
nproc(void)
{
  int cnt = 0;
  for (int i = 0; i < NPROC; i++) {
    if (proc[i].state != UNUSED) {
      cnt++;
    }
  }
  return cnt;
}
```

### 实现 sys_sysinfo()

接下来就是实现系统函数了。由于我们在用户层调用 `sysinfo()` 时传入的是一个指针，所以在读取该参数时不能用 `argint()`，而是 `argaddr()`。

值得注意的是，读取到的参数是一个用户态的虚拟地址，如果我们创建一个 `struct sysinfo*` 变量用于接收指针，然后再赋值，像下面这样：

```C
uint64 va;
argaddr(0, &va);
struct sysinfo* info = (struct sysinfo*)va;
info->freemem = kfreemem();
info->nproc = nproc();
```

那肯定是不行的。对于内核而言，如果直接访问地址，那访问的就是物理地址，可我们得到的却是一个用户态下的虚拟地址，这两者是完全不能等同的。要想访问到正确的物理地址，就需要通过页表进行地址转换。然而 lab 已经为我们提供了另一个实现方法，`kernal/vm.c` 中的 `copyout()` 函数，用于拷贝一段内存到虚拟地址。这正好是我们需要的，要用它，我们只需要在内核栈中新建一个 `struct sysinfo info` 变量，赋值后调用 `copyout()` 拷贝即可。完整的 `sys_sysinfo()` 如下：

```C
uint64
sys_sysinfo(void)
{
  uint64 va;
  if (argaddr(0, &va) < 0) {
    return -1;
  }

  // info is in kernal address space
  struct sysinfo info;
  info.freemem = kfreemem();
  info.nproc = nproc();

  // copy info to *va
  return copyout(myproc()->pagetable, va, (char*)&info, sizeof(info));
}
```

## 最后的工作

1. `git commit -am ""` 将所有修改提交到本地;
2. 执行 `make handin`。由于 lab0 保存了 APIKey，故直接成功提交；

可选的挑战再说吧，没有什么想做的欲望。