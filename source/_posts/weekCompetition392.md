---
title: weekCompetition392
author: Leager
mathjax: true
date: 2024-04-07 11:28:36
summary:
categories: LeetCode
tags: weekly
img:
---

[ç¬¬ 392 åœºå‘¨èµ›](https://leetcode.cn/contest/weekly-contest-392/)å¤ç›˜ã€‚

**æ’å** 367 / 3193

<!--more-->

## 1. [æœ€é•¿çš„ä¸¥æ ¼é€’å¢æˆ–é€’å‡å­æ•°ç»„](https://leetcode.cn/problems/longest-strictly-increasing-or-strictly-decreasing-subarray/description/)

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ã€‚
> 
> è¿”å›æ•°ç»„ `nums` ä¸­ **ä¸¥æ ¼é€’å¢** æˆ– **ä¸¥æ ¼é€’å‡** çš„æœ€é•¿éç©ºå­æ•°ç»„çš„é•¿åº¦ã€‚

### æ€è·¯

ç»´æŠ¤ä¸¤ä¸ªæ•°ç»„ï¼Œåˆ†åˆ«æ˜¯ä»¥å½“å‰å…ƒç´ ä¸ºæœ«å°¾çš„æœ€é•¿ä¸¥æ ¼é€’å¢/é€’å‡å­æ•°ç»„çš„é•¿åº¦ã€‚**åŠ¨æ€è§„åˆ’**åå–ä¸¤ä¸ªæ•°ç»„ä¸­çš„æœ€å¤§å€¼å³å¯ã€‚

### code

```C++
// C++
class Solution {
public:
    int longestMonotonicSubarray(vector<int>& nums) {
        int n = nums.size();
        vector<int> inc(n, 1); // æœ€é•¿ä¸¥æ ¼é€’å¢å­æ•°ç»„çš„é•¿åº¦
        vector<int> dec(n, 1); // æœ€é•¿ä¸¥æ ¼é€’å‡å­æ•°ç»„çš„é•¿åº¦
        for (int i = 1; i < n; i++) {
            if (nums[i] > nums[i - 1]) {
                inc[i] = inc[i - 1] + 1;
            } else if (nums[i] < nums[i - 1]) {
                dec[i] = dec[i - 1] + 1;
            }
        }
        return max(*max_element(inc.begin(), inc.end()),
                   *max_element(dec.begin(), dec.end()));
    }
};
```

## 2. [æ»¡è¶³è·ç¦»çº¦æŸä¸”å­—å…¸åºæœ€å°çš„å­—ç¬¦ä¸²](https://leetcode.cn/problems/lexicographically-smallest-string-after-operations-with-constraint/description/)

> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s` å’Œä¸€ä¸ªæ•´æ•° `k` ã€‚
> 
> å®šä¹‰å‡½æ•° `distance(s1, s2)` ï¼Œç”¨äºè¡¡é‡ä¸¤ä¸ªé•¿åº¦ä¸º `n` çš„å­—ç¬¦ä¸² `s1` å’Œ `s2` ä¹‹é—´çš„è·ç¦»ï¼Œå³ï¼š
> 
> - å­—ç¬¦ `'a'` åˆ° `'z'` æŒ‰ **å¾ªç¯** é¡ºåºæ’åˆ—ï¼Œå¯¹äºåŒºé—´ `[0, n - 1]` ä¸­çš„ `i` ï¼Œè®¡ç®—æ‰€æœ‰ã€Œ `s1[i]` å’Œ `s2[i]` ä¹‹é—´ **æœ€å°è·ç¦»**ã€çš„ å’Œ ã€‚
> 
> ä¾‹å¦‚ï¼Œ`distance("ab", "cd") == 4` ï¼Œä¸” `distance("a", "z") == 1` ã€‚
> 
> ä½ å¯ä»¥å¯¹å­—ç¬¦ä¸² `s` æ‰§è¡Œ **ä»»æ„æ¬¡** æ“ä½œã€‚åœ¨æ¯æ¬¡æ“ä½œä¸­ï¼Œå¯ä»¥å°† `s` ä¸­çš„ä¸€ä¸ªå­—æ¯ **æ”¹å˜** ä¸º **ä»»æ„** å…¶ä»–å°å†™è‹±æ–‡å­—æ¯ã€‚
> 
> è¿”å›ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¡¨ç¤ºåœ¨æ‰§è¡Œä¸€äº›æ“ä½œåä½ å¯ä»¥å¾—åˆ°çš„ **å­—å…¸åºæœ€å°** çš„å­—ç¬¦ä¸² `t` ï¼Œä¸”æ»¡è¶³ `distance(s, t) <= k` ã€‚

### æ€è·¯

ä½¿ç”¨**è´ªå¿ƒ**çš„ç­–ç•¥ï¼Œä»å­—ç¬¦ä¸²ç¬¬ä¸€ä¸ªå­—æ¯å¼€å§‹ï¼Œå¯¹äºé å‰çš„æ¯ä¸ªå­—æ¯ï¼Œæˆ‘ä»¬å¸Œæœ›æ‰§è¡Œæ“ä½œåå…¶å˜å¾—å°½å¯èƒ½â€œå°â€ï¼Œè¿™æ ·æ“ä½œåå¾—åˆ°çš„å­—ç¬¦ä¸²çš„å­—å…¸åºå¿…ç„¶æ˜¯æœ€å°çš„ã€‚

æˆ‘ä»¬å¯ä»¥æ±‚å‡ºæ¯ä¸ªå­—æ¯å˜æˆ `'a'` çš„è·ç¦»ï¼Œå¦‚æœå½“å‰æ“ä½œæ¬¡æ•°å…è®¸ï¼Œé‚£ä¹ˆå°±å°†å…¶å˜ä¸º `'a'`ï¼›åä¹‹å°½å¯èƒ½å˜æˆæ›´å°çš„å­—æ¯ã€‚

### code

```C++
// C++
class Solution {
public:
    int disToA(char ch) { return min(ch - 'a', 'a' + 26 - ch); }

    string getSmallestString(string s, int k) {
        for (int i = 0; i < s.length() && k > 0; i++) {
            if (s[i] != 'a') { // å¦‚æœå·²ç»æ˜¯ 'a' äº†å°±ä¸æ“ä½œ
                int d = disToA(s[i]);
                if (k >= d) {
                    s[i] = 'a';
                    k -= d;
                } else {
                    s[i] -= k;
                    k = 0;
                }
            }
        }
        return s;
    }
};
```

## 3. [ä½¿æ•°ç»„ä¸­ä½æ•°ç­‰äº K çš„æœ€å°‘æ“ä½œæ•°](https://leetcode.cn/problems/minimum-operations-to-make-median-of-array-equal-to-k/description/)

> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` å’Œä¸€ä¸ª **éè´Ÿ** æ•´æ•° `k` ã€‚
> 
> ä¸€æ¬¡æ“ä½œä¸­ï¼Œä½ å¯ä»¥é€‰æ‹©ä»»ä¸€ä¸‹æ ‡ `i` ï¼Œç„¶åå°† `nums[i]` åŠ  `1` æˆ–è€…å‡ `1` ã€‚
> 
> è¯·ä½ è¿”å›å°† `nums` **ä¸­ä½æ•°** å˜ä¸º `k` æ‰€éœ€è¦çš„ **æœ€å°‘** æ“ä½œæ¬¡æ•°ã€‚
> 
> ä¸€ä¸ªæ•°ç»„çš„ **ä¸­ä½æ•°** æŒ‡çš„æ˜¯æ•°ç»„æŒ‰ **éé€’å‡** é¡ºåºæ’åºåæœ€ä¸­é—´çš„å…ƒç´ ã€‚å¦‚æœæ•°ç»„é•¿åº¦ä¸ºå¶æ•°ï¼Œæˆ‘ä»¬é€‰æ‹©ä¸­é—´ä¸¤ä¸ªæ•°çš„è¾ƒå¤§å€¼ä¸ºä¸­ä½æ•°ã€‚

### æ€è·¯

å› ä¸ºæ˜¯ä¿®æ”¹ä»»æ„å…ƒç´ ï¼Œæ•…ä¿®æ”¹å‰åç»“æœä¸åˆå§‹é¡ºåºæ— å…³ï¼Œé‚£ä¹ˆå¯ä»¥å…ˆå°†æ•°ç»„æ’åºï¼Œå°†é—®é¢˜è½¬æ¢ä¸ºï¼šä½¿å¾— `nums[nums.size()/2] == k`ã€‚

æ­¤æ—¶æˆ‘ä»¬å¯ä»¥æ‰¾ `k` çš„å·¦å³è¾¹ç•Œã€‚

- **å·¦è¾¹ç•Œ**ï¼šç¬¬ä¸€ä¸ª**å°äºç­‰äº** k çš„æ•°ï¼›
- **å³è¾¹ç•Œ**ï¼šç¬¬ä¸€ä¸ª**å¤§äº** k çš„æ•°ï¼›

å¦‚æœå³è¾¹ç•Œå°äºç­‰äº `nums.size()/2`ï¼Œè¯´æ˜ä¸­é—´è¿™éƒ¨åˆ†æ•°å¤ªå¤§äº†ï¼Œåº”å½“å°†å…¶å‡è‡³ `k`ï¼Œä½¿å¾—æœ€ç»ˆå³è¾¹ç•Œä¸º `nums.size()/2 + 1`ã€‚

å¦‚æœå·¦è¾¹ç•Œå¤§äº `nums.size()/2`ï¼Œè¯´æ˜ä¸­é—´è¿™éƒ¨åˆ†æ•°å¤ªå°äº†ï¼Œåº”å½“å°†å…¶å¢è‡³ `k`ï¼Œä½¿å¾—æœ€ç»ˆå·¦è¾¹ç•Œä¸º `nums.size()/2`ã€‚

å…¶ä»–æƒ…å†µéƒ½æ˜¯ä½¿å¾—æ•´ä¸ªæ•°ç»„çš„ä¸­ä½æ•°ä¸º `k` çš„ï¼Œæ­¤æ—¶æ— éœ€ä»»ä½•æ“ä½œã€‚

> WA äº†ä¸€æ¬¡ï¼Œå‘ç°è¿”å›å€¼æ˜¯ `long long`ï¼Œè€Œæˆ‘è¿”å›äº†ä¸€ä¸ª `int`ğŸ¤£ã€‚

### code

```C++
// C++
class Solution {
public:
    long long minOperationsToMakeMedianK(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int lb = nums.size(), rb = nums.size();

        for (int i = 0; i < nums.size(); i++) {
            if (nums[i] >= k) {
                lb = i;
                break;
            }
        }
        for (int i = lb; i < nums.size(); i++) {
            if (nums[i] > k) {
                rb = i;
                break;
            }
        }

        long long res = 0;
        while (rb < nums.size() / 2 + 1) {
            res += nums[rb++] - k;
        }
        while (lb > nums.size() / 2) {
            res += k - nums[--lb];
        }
        return res;
    }
};
```

## 4. [å¸¦æƒå›¾é‡Œæ—…é€”çš„æœ€å°ä»£ä»·](https://leetcode.cn/problems/minimum-cost-walk-in-weighted-graph/)

> ç»™ä½ ä¸€ä¸ª `n` ä¸ªèŠ‚ç‚¹çš„å¸¦æƒæ— å‘å›¾ï¼ŒèŠ‚ç‚¹ç¼–å·ä¸º `0` åˆ° `n - 1` ã€‚
> 
> ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` å’Œä¸€ä¸ªæ•°ç»„ `edges` ï¼Œå…¶ä¸­ `edges[i] = [u_i, v_i, w_i]` è¡¨ç¤ºèŠ‚ç‚¹ `u_i` å’Œ `v_i` ä¹‹é—´æœ‰ä¸€æ¡æƒå€¼ä¸º `w_i` çš„æ— å‘è¾¹ã€‚
> 
> åœ¨å›¾ä¸­ï¼Œä¸€è¶Ÿæ—…é€”åŒ…å«ä¸€ç³»åˆ—èŠ‚ç‚¹å’Œè¾¹ã€‚æ—…é€”å¼€å§‹å’Œç»“æŸç‚¹éƒ½æ˜¯å›¾ä¸­çš„èŠ‚ç‚¹ï¼Œä¸”å›¾ä¸­å­˜åœ¨è¿æ¥æ—…é€”ä¸­ç›¸é‚»èŠ‚ç‚¹çš„è¾¹ã€‚æ³¨æ„ï¼Œä¸€è¶Ÿæ—…é€”å¯èƒ½è®¿é—®åŒä¸€æ¡è¾¹æˆ–è€…åŒä¸€ä¸ªèŠ‚ç‚¹å¤šæ¬¡ã€‚
> 
> å¦‚æœæ—…é€”å¼€å§‹äºèŠ‚ç‚¹ `u` ï¼Œç»“æŸäºèŠ‚ç‚¹ `v` ï¼Œæˆ‘ä»¬å®šä¹‰è¿™ä¸€è¶Ÿæ—…é€”çš„ **ä»£ä»·** æ˜¯ç»è¿‡çš„è¾¹æƒæŒ‰ä½ä¸ `AND` çš„ç»“æœã€‚æ¢å¥è¯è¯´ï¼Œå¦‚æœç»è¿‡çš„è¾¹å¯¹åº”çš„è¾¹æƒä¸º `w0, w1, w2, ..., wk` ï¼Œé‚£ä¹ˆä»£ä»·ä¸º `w0 & w1 & w2 & ... & wk` ï¼Œå…¶ä¸­ `&` è¡¨ç¤ºæŒ‰ä½ä¸ `AND` æ“ä½œã€‚
> 
> ç»™ä½ ä¸€ä¸ªäºŒç»´æ•°ç»„ `query` ï¼Œå…¶ä¸­ `query[i] = [s_i, t_i]` ã€‚å¯¹äºæ¯ä¸€ä¸ªæŸ¥è¯¢ï¼Œä½ éœ€è¦æ‰¾å‡ºä»èŠ‚ç‚¹å¼€å§‹ `s_i` ï¼Œåœ¨èŠ‚ç‚¹ `t_i` å¤„ç»“æŸçš„æ—…é€”çš„æœ€å°ä»£ä»·ã€‚å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„æ—…é€”ï¼Œç­”æ¡ˆä¸º `-1` ã€‚
> 
> è¿”å›æ•°ç»„ `answer` ï¼Œå…¶ä¸­ `answer[i]` è¡¨ç¤ºå¯¹äºæŸ¥è¯¢ `i` çš„ **æœ€å°** æ—…é€”ä»£ä»·ã€‚

### æ€è·¯

å¯¹äºæŒ‰ä½ä¸è€Œè¨€ï¼Œ`a AND b` çš„ç»“æœå¿…ç„¶å°äºç­‰äº `a, b` ä¸¤è€…ï¼Œå¹¶ä¸”å›¾ä¸­ç‚¹å’Œè¾¹å¯ä»¥è®¿é—®ä»»æ„æ¬¡æ•°ï¼Œé‚£ä¹ˆæˆ‘ä»¬éœ€è¦å°½å¯èƒ½å¤šåœ°è®¿é—®è¾¹ï¼Œè¿™æ ·å°±èƒ½ä½¿å¾—ç»“æœæœ€å°ã€‚

å¯¹äºä¸€ä¸ªè¿é€šåˆ†é‡æ¥è¯´ï¼Œå°†æ‰€æœ‰è¾¹éƒ½è®¿é—®ä¸€éå°±å·²ç»èƒ½è¾¾åˆ°æœ€å°å€¼äº†ï¼Œå› ä¸ºç›¸åŒçš„æ•°åš `AND` è®¡ç®—ç»“æœä¸å˜ï¼Œæ‰€ä»¥è®¿é—®å†å¤šæ¬¡ä¹Ÿæ²¡æœ‰æ„ä¹‰ã€‚é‚£æ€è·¯å°±å¾ˆç®€å•äº†ï¼Œç”¨**å¹¶æŸ¥é›†**ï¼Œå°†æ‰€æœ‰äº’è¾¾çš„ç‚¹çº³å…¥åŒä¸€ä¸ªé›†åˆã€‚å¦‚æœæŸ¥è¯¢ä¸­çš„ä¸¤ä¸ªç‚¹åœ¨åŒä¸€ä¸ªè¿é€šåˆ†é‡é‡Œï¼Œæˆ‘ä»¬å¯ä»¥éå†è¿™ä¸ªè¿é€šåˆ†é‡æ‰€æœ‰çš„è¾¹ï¼Œä¸æ–­åš `AND` è®¡ç®—å³å¯ï¼›åä¹‹è¯´æ˜ä¸¤ç‚¹ä¸å¯è¾¾ï¼Œç›´æ¥è¿”å› `-1`ã€‚

ç»è¿‡ä¸Šé¢çš„è®¨è®ºæˆ‘ä»¬å‘ç°ï¼ŒåŒä¸€ä¸ªè¿é€šåˆ†é‡é‡Œä»»æ„ä¸¤å¯¹ä¸åŒçš„ç‚¹ï¼Œå…¶è·¯å¾„ä»£ä»·éƒ½æ˜¯ä¸€æ ·çš„ï¼Œéƒ½æ˜¯è¿™ä¸ªè¿é€šåˆ†é‡é‡Œæ‰€æœ‰çš„è¾¹çš„ `AND` æ“ä½œå’Œï¼Œè¿™å¯ä»¥çœ‹ä½œæ˜¯**æ•´ä¸ªè¿é€šåˆ†é‡çš„ä»£ä»·**ã€‚é‚£ä¹ˆæˆ‘ä»¬å¯ä»¥åœ¨æŸ¥è¯¢å‰é¢„å…ˆå°†æ‰€æœ‰è¿é€šåˆ†é‡çš„ä»£ä»·è®¡ç®—å¥½ï¼Œç­‰åˆ°æŸ¥è¯¢æ—¶ç›´æ¥è¿›å…¥å“ˆå¸Œè¡¨ä¸­æŸ¥è¯¢å³å¯ï¼Œæ— éœ€ä½œé‡å¤è®¡ç®—ã€‚

æœ‰ä¸€ç‚¹éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå› ä¸ºæ˜¯æ— å‘å›¾ï¼Œå¹¶ä¸”ä¸¤ç‚¹ä¹‹é—´å¯èƒ½ä¼šæœ‰å¤šæ¡è¾¹ï¼Œé‚£ä¹ˆä¹Ÿéœ€è¦å°†è¿™äº›è¾¹åšä¸€ä¸ªä»£ä»·ç»Ÿè®¡ï¼Œæœ€åç•™ä¸‹çš„ç»“æœå°±ç›´æ¥æ˜¯ `AND` çš„ç»“æœã€‚

> ğŸ˜­ corner caseï¼šå½“ `query[0] == query[1]` æ—¶ï¼Œä»£ä»·ä¸º `0`ã€‚å¥½å¤šäººéƒ½ WA äº†ï¼Œä¼°è®¡æ˜¯å› ä¸ºè¿™ä¸ª case æ²¡è€ƒè™‘åˆ°ã€‚

### code

```C++
// C++
class Solution {
public:
    vector<int> minimumCost(int n, vector<vector<int>>& edges,
                            vector<vector<int>>& query) {
        // åˆå§‹åŒ–å¹¶æŸ¥é›†
        vector<int> father(n);
        auto findfather = [&](int x) {
            int a = x, b = x;
            while (x != father[x]) {
                x = father[x];
            }
            while (a != x) {
                a = father[a];
                father[b] = x;
                b = a;
            }
            return x;
        };
        auto merge = [&](int x, int y) {
            int fx = findfather(x);
            int fy = findfather(y);
            if (fx != fy) {
                father[fx] = fy;
            }
        };
        for (int i = 0; i < n; i++) {
            father[i] = i;
        }

        // åˆå§‹åŒ–å›¾
        vector<unordered_map<int, int>> g(n);
        for (auto&& e : edges) {
            int u = e[0];
            int v = e[1];
            int w = e[2];
            if (g[u].count(v) == 0) {
                g[u][v] = w;
            } else {
                g[u][v] &= w;
            }
            if (g[v].count(u) == 0) {
                g[v][u] = w;
            } else {
                g[v][u] &= w;
            }
            merge(u, v);
        }

        // é¢„å…ˆè®¡ç®—è¿é€šåˆ†é‡çš„ä»£ä»·
        unordered_map<int, int> cache;
        for (int i = 0; i < n; i++) {
            int f = findfather(i);

            int tmp = -1;
            for (auto&& next : g[i]) {
                // è¿™é‡Œå°±ç®—é‡å¤è®¡ç®— (u, v) å’Œ (v, u) ä¹Ÿæ²¡å…³ç³»ï¼ŒAND ç»“æœæ˜¯ä¸å˜çš„
                if (tmp == -1) {
                    tmp = next.second;
                } else {
                    tmp &= next.second;
                }
            }

            if (cache.count(f)) {
                cache[f] &= tmp;
            } else {
                cache[f] = tmp;
            }
        }

        // ç»“æœæŸ¥è¯¢
        vector<int> res;
        for (auto&& q : query) {
            if (q[0] == q[1]) {
                res.push_back(0); // !!! corner case
            } else if (findfather(q[0]) != findfather(q[1])) {
                res.push_back(-1);
            } else {
                res.push_back(cache[findfather(q[0])]);
            }
        }
        return res;
    }
};
```