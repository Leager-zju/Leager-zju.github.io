<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/largeicon.jpg">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/smallicon.jpg">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"leager-zju.github.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"b2t":true},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="对于单个副本组而言，所有机器存储共享同一存储空间，机器数量的增加并不会扩大存储能力。而当 kv 对数量不断增长时，副本组的存储能力成为瓶颈。 参考 Aurora 的做法，不妨将数据划分为多个片段，每个副本组负责分片(Shard)的一个子集。组内机器使用 Raft 来复制分片。此外还有一个分片控制器(Shardctrler)，决定哪个副本组应该为每个分片服务，此信息称为配置(Config)。本实验">
<meta property="og:type" content="article">
<meta property="og:title" content="6.824 Lab4 Sharded Key&#x2F;Value Service">
<meta property="og:url" content="http://leager-zju.github.com/6-824/6-824lab4/index.html">
<meta property="og:site_name" content="没什么看头的地方">
<meta property="og:description" content="对于单个副本组而言，所有机器存储共享同一存储空间，机器数量的增加并不会扩大存储能力。而当 kv 对数量不断增长时，副本组的存储能力成为瓶颈。 参考 Aurora 的做法，不妨将数据划分为多个片段，每个副本组负责分片(Shard)的一个子集。组内机器使用 Raft 来复制分片。此外还有一个分片控制器(Shardctrler)，决定哪个副本组应该为每个分片服务，此信息称为配置(Config)。本实验">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-22T12:20:28.000Z">
<meta property="article:modified_time" content="2022-11-24T07:03:05.316Z">
<meta property="article:author" content="Leager">
<meta property="article:tag" content="lab">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://leager-zju.github.com/6-824/6-824lab4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>6.824 Lab4 Sharded Key/Value Service | 没什么看头的地方</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">没什么看头的地方</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">这里可能没有你想看的...</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于我</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>文章分类<span class="badge">6</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>时间轴<span class="badge">37</span></a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://leager-zju.github.com/6-824/6-824lab4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/Avatar.jpg">
      <meta itemprop="name" content="Leager">
      <meta itemprop="description" content="【数据删除】">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="没什么看头的地方">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          6.824 Lab4 Sharded Key/Value Service
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-11-22 20:20:28" itemprop="dateCreated datePublished" datetime="2022-11-22T20:20:28+08:00">2022-11-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-11-24 15:03:05" itemprop="dateModified" datetime="2022-11-24T15:03:05+08:00">2022-11-24</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/6-824/" itemprop="url" rel="index"><span itemprop="name">6.824</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>对于单个副本组而言，所有机器存储共享同一存储空间，机器数量的增加并不会扩大存储能力。而当 kv 对数量不断增长时，副本组的存储能力成为瓶颈。</p>
<p>参考 <a target="_blank" rel="noopener" href="https://leager-zju.github.io/6-824/aurora/">Aurora</a> 的做法，不妨将数据划分为多个片段，每个副本组负责<strong>分片</strong>(Shard)的一个子集。组内机器使用 Raft 来复制分片。此外还有一个<strong>分片控制器</strong>(Shardctrler)，决定哪个副本组应该为每个分片服务，此信息称为<strong>配置</strong>(Config)。本实验就是实现这样一个 multi-raft 的 kv 存储系统。</p>
<span id="more"></span>
<p>lab4 和 lab3 非常像，主要流程是这样的：</p>
<ol type="1">
<li>client 通过 clerk 发送请求；</li>
<li>clerk 根据 key 所在的分片，将请求转发给对应 group 的 Leader；</li>
<li>Leader 通过 raft 层复制操作日志。</li>
</ol>
<h3 id="part-a-the-shard-controller">PART A-The Shard controller</h3>
<p>这一部分是比较简单的，去重检测、处理请求等方面几乎可以把 lab3 的代码搬过来。关键在于处理上层调用的 <code>Join</code>、<code>Leave</code>、<code>Move</code>、<code>Query</code> 这 4 个命令。由于 Shardctrler 管理一系列配置，故需要在结构体中额外设置一个 Config 切片。结构体如下：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardCtrler <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu      sync.RWMutex</span><br><span class="line">    me      <span class="type">int</span></span><br><span class="line">    applyCh <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    rf      *raft.Raft</span><br><span class="line"></span><br><span class="line">    lastRequestInfo <span class="keyword">map</span>[<span class="type">int64</span>]*RequestInfo <span class="comment">// clerkID -&gt; requestID</span></span><br><span class="line">    configs []Config <span class="comment">// indexed by config num</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="新建配置">新建配置</h4>
<p><code>Query</code> 相当于读命令，不会对 Config 有任何更改，是可以不经过去重的，直接根据规则返回相应 Config 即可。</p>
<p>其它 3 个需要经过去重表。其中 <code>Move</code> 较为简单，直接修改 Config 中 <code>Shards[]</code> 对应的值即可。对于 <code>Join</code> 和 <code>Leave</code>，在应用命令时需要创建一个新的 Config。</p>
<blockquote>
<p>在 Go 中，map 是引用类型，不能直接拷贝（浅拷贝），而是需要创建一个新的对象并单独复制键和值（深拷贝）。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> makeNewConfig() *Config &#123;</span><br><span class="line">    lastconfig := sc.configs[<span class="built_in">len</span>(sc.configs)<span class="number">-1</span>]</span><br><span class="line">    newconfig := Config&#123;</span><br><span class="line">        Num:    lastconfig.Num + <span class="number">1</span>,</span><br><span class="line">        Shards: lastconfig.Shards,</span><br><span class="line">        Groups: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>][]<span class="type">string</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> gid, members := <span class="keyword">range</span> lastconfig.Groups &#123;</span><br><span class="line">        newconfig.Groups[gid] = members</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &amp;newconfig</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> ApplyCommand(msg raft.ApplyMsg) &#123;</span><br><span class="line">    args := msg.Command.(Args)</span><br><span class="line">    ch := args.Ch</span><br><span class="line">    reply := <span class="built_in">new</span>(Reply)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.Op == Query &#123;</span><br><span class="line">        reply.Err = OK</span><br><span class="line">        <span class="keyword">if</span> args.Num == <span class="number">-1</span> || args.Num &gt;= <span class="built_in">len</span>(sc.configs) &#123;</span><br><span class="line">            reply.Config = sc.configs[<span class="built_in">len</span>(sc.configs)<span class="number">-1</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reply.Config = sc.configs[args.Num]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> sc.isDuplicated(args.RequestId, args.ClerkId) &#123;</span><br><span class="line">        reply.Err = sc.lastRequestInfo[args.ClerkId].Err</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newconfig := sc.makeNewConfig()</span><br><span class="line">        <span class="keyword">switch</span> args.Op &#123;</span><br><span class="line">            <span class="keyword">case</span> Move:</span><br><span class="line">            newconfig.Shards[args.Shard] = args.GIDs[<span class="number">0</span>]</span><br><span class="line">            <span class="keyword">case</span> Join:</span><br><span class="line">            <span class="keyword">for</span> gid, members := <span class="keyword">range</span> args.Servers &#123;</span><br><span class="line">                newconfig.Groups[gid] = members</span><br><span class="line">            &#125;</span><br><span class="line">            sc.shuffleShard(newconfig)</span><br><span class="line">            <span class="keyword">case</span> Leave:</span><br><span class="line">            <span class="keyword">for</span> _, gid := <span class="keyword">range</span> args.GIDs &#123;</span><br><span class="line">                <span class="built_in">delete</span>(newconfig.Groups, gid)</span><br><span class="line">            &#125;</span><br><span class="line">            sc.shuffleShard(newconfig)</span><br><span class="line">        &#125;</span><br><span class="line">        DPrintf(<span class="string">&quot;[ShardCtrler]: NewConfig %+v&quot;</span>, newconfig)</span><br><span class="line">        sc.configs = <span class="built_in">append</span>(sc.configs, *newconfig)</span><br><span class="line">        sc.lastRequestInfo[args.ClerkId] = &amp;RequestInfo&#123;</span><br><span class="line">            RequestID: args.RequestId,</span><br><span class="line">            Err:       reply.Err,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> sc.rf.GetRaftState() == raft.Leader &amp;&amp; sc.rf.GetCurrentTerm() == msg.CommandTerm &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reply_ *Reply)</span></span> &#123; ch &lt;- reply_ &#125;(reply)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分片再分配">分片再分配</h4>
<p>lab 要求<strong>新 Config 应尽可能将 Shard 均匀地分配到 groups 中，并应移动尽可能少的 Shard</strong>。这样做也是为了减少不必要的网络资源消耗，毕竟后续 Shard 的迁移是需要 rpc 的。</p>
<p>若分配前存在分片处于<strong>无主</strong>状态（即 Config.Shards[i] = 0），则优先<strong>将该分片分配给拥有最少分片的 group</strong>。反之，则<strong>每次选取拥有最多分片的 group 给拥有最少分片的 group 迁移 Shard，直至两者拥有数量不超过 1</strong>。</p>
<blockquote>
<p>在 Go 中，map 迭代顺序是<a target="_blank" rel="noopener" href="https://blog.golang.org/maps#TOC_7.">不确定的</a>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(sc *ShardCtrler)</span></span> shuffleShard(config *Config) &#123;</span><br><span class="line">    N := <span class="built_in">len</span>(config.Groups)</span><br><span class="line">    <span class="keyword">if</span> N == <span class="number">0</span> &#123;        <span class="comment">// 所有 group 离开，将所有 Shard 设为无主</span></span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; NShards; i++ &#123;</span><br><span class="line">            config.Shards[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    allocated := <span class="number">0</span></span><br><span class="line">    NumofShards := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">    <span class="keyword">for</span> gid := <span class="keyword">range</span> config.Groups &#123;</span><br><span class="line">        NumofShards[gid] = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, gid := <span class="keyword">range</span> config.Shards &#123;</span><br><span class="line">        <span class="keyword">if</span> _, ok := config.Groups[gid]; ok &#123;</span><br><span class="line">            allocated++</span><br><span class="line">            NumofShards[gid]++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        WhoHasTheMostShards, WhoHasTheLeastShards := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        MaxmShards, MinmShards := <span class="number">-1</span>, NShards+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> gid, num := <span class="keyword">range</span> NumofShards &#123;</span><br><span class="line">            <span class="keyword">if</span> num &gt; MaxmShards &#123;</span><br><span class="line">                MaxmShards = num</span><br><span class="line">                WhoHasTheMostShards = gid</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> num &lt; MinmShards &#123;</span><br><span class="line">                MinmShards = num</span><br><span class="line">                WhoHasTheLeastShards = gid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> allocated == NShards &amp;&amp; MaxmShards &lt; MinmShards+<span class="number">2</span> &#123;    <span class="comment">// allocated != NShards 说明存在无主分片，不能简单凭 MaxmShards &lt; MinmShards+2 退出循环</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> sid, gid := <span class="keyword">range</span> config.Shards &#123;</span><br><span class="line">            <span class="keyword">if</span> _, ok := config.Groups[gid]; !ok &#123; <span class="comment">// gid 已离开，直接分给拥有分片最少的 group</span></span><br><span class="line">                config.Shards[sid] = WhoHasTheLeastShards</span><br><span class="line">                allocated++</span><br><span class="line">                NumofShards[WhoHasTheLeastShards]++</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> gid == WhoHasTheMostShards &amp;&amp; allocated == NShards &#123;</span><br><span class="line">                config.Shards[sid] = WhoHasTheLeastShards</span><br><span class="line">                NumofShards[WhoHasTheMostShards]--</span><br><span class="line">                NumofShards[WhoHasTheLeastShards]++</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="part-b-shared-keyvalue-server">PART B-Shared Key/Value Server</h3>
<p>这一部分我认为是整个 6.824 lab 中最难的一个 Part。尽管 raft 算法也很难，但只要认真研读论文的图 2，依然能够写出 bugfree 的代码。这部分的难点在于，需要我们从头设计一个基于 Shard 的 KV 服务，而没有任何文献资料/Guide 来作指引，一旦没有灵感迸发，就会寸步难行。</p>
<h4 id="开始-4b-之前需要想明白的一些事">开始 4B 之前需要想明白的一些事</h4>
<p>磨蹭大半个月+仔细阅读实验要求后，我得出如下总结：</p>
<p>该部分与 lab3 的不同之处在于，group 会不断加入/离开系统，为了平衡负载，系统需要在 group 之间转移 Shard。同时，随着 groups 的变化，系统的 Config 也会不断发生变化，且需要告知所有 group。简而言之，该 lab 的难点并不在于对 client 操作的实现——它已经在 lab3 中做完了，直接照抄即可——而是</p>
<ol type="1">
<li><strong>如何 ReConfig，Config 有更新后怎么做</strong>；</li>
<li><strong>如何迁移 Shard，迁移后怎么做</strong>。</li>
</ol>
<p>能够想明白上面两个问题，4B 的所有难点都迎刃而解，包括两个 Challenge。</p>
<h4 id="clerk">Clerk</h4>
<p>clerk 的工作和 lab3 非常相似，样例代码的思路也很清楚——一旦收到 ErrWrongGroup 回复，则说明自己缓存的 Config 有误，需向 Shardctrler 请求最新的 Config。和 lab3 类似，Clerk 需要缓存每个 group 的 Leader。</p>
<p>这里有个很重要的一点：如果对某个 group 所有成员均发送失败，则认为该 group 全挂了，系统发生成员变动，此时 clerk 缓存的 Config 一定已过时，再继续发下去极有可能死循环，需要尝试获取最新 Config。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> SendRequest(Command *OperationCommand) <span class="type">string</span> &#123;</span><br><span class="line">    Command.ClerkId, Command.RequestId = ck.ClerkId, ck.RequestId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        shard := key2shard(Command.Key)</span><br><span class="line">        gid := ck.config.Shards[shard]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> servers, ok := ck.config.Groups[gid]; ok &#123; <span class="comment">// 若 gid 在当前 config 中</span></span><br><span class="line">            <span class="keyword">if</span> _, ok := ck.volatileLeader[gid]; !ok &#123;</span><br><span class="line">               ck.volatileLeader[gid] = <span class="number">0</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            guard := ck.volatileLeader[gid]</span><br><span class="line">            leader := guard</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                reply := <span class="built_in">new</span>(Reply)</span><br><span class="line">                srv := ck.make_end(servers[leader])</span><br><span class="line">                ok := srv.Call(<span class="string">&quot;ShardKV.HandleRequest&quot;</span>, Command, reply)</span><br><span class="line">                DPrintf(<span class="string">&quot;[client] %s %s, %s -&gt; %d send to %s and get reply %+v&quot;</span>, Command.Op, Command.Key, Command.Value, shard, servers[leader], reply)</span><br><span class="line">                <span class="keyword">if</span> ok &amp;&amp; (reply.Err == OK || reply.Err == ErrNoKey) &#123; <span class="comment">// OK</span></span><br><span class="line">                    ck.volatileLeader[gid] = leader</span><br><span class="line">                    ck.RequestId++</span><br><span class="line">                    <span class="keyword">return</span> reply.Value</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> ok &amp;&amp; reply.Err == ErrWrongGroup &#123; <span class="comment">// arrive but WrongGroup</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// not arrive / arrive but WrongLeader</span></span><br><span class="line">                    leader = (leader + <span class="number">1</span>) % <span class="built_in">len</span>(ck.config.Groups[gid])</span><br><span class="line">                    <span class="keyword">if</span> leader == guard &#123; <span class="comment">// all members failed</span></span><br><span class="line">                        <span class="keyword">break</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        time.Sleep(<span class="number">100</span> * time.Millisecond)</span><br><span class="line">        ck.config = ck.sm.Query(<span class="number">-1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="server">Server</h4>
<p>首先思考第一个问题，<strong>如何 ReConfig，Config 有更新后怎么做</strong>。这个问题还是比较容易的，只需要在启动 server 时异步开启一个 <strong>ConfigPuller</strong> 协程，定期向 Shardctrler 请求最新的 Config 即可。每个 server 还需维护一个 CurrentConfig 变量，一旦获得较新的 Config，就将其赋给 CurrentConfig。</p>
<blockquote>
<p>这个变量主要用于收到操作请求时判断是否返回 ErrWrongGroup，即如果 CurrentConfig.Shards[key2shard(key)] != kv.gid，说明本 group 不负责该分片，需报错。</p>
</blockquote>
<p>这里有一个问题，group 里的每个成员能够单独进行 Config 的拉取和更新吗？回答显然是<strong>不能</strong>的，这是对 raft 层的不尊重，单独进行 Config 拉取必然会造成不同步，则后续对不同 server 存储的读写也会产生管辖范围不一致的问题。所以这里需要进行是否为 Leader 的判断，如果 Leader 拿到了较新的Config，则向下层发一条更新记录，随着 raft 层的运作，这条记录最终会被所有 server 获得，传到上层进行 Apply 后更新 CurrentConfig。</p>
<p>随着 Config 的更新，Shard 的迁移问题也随之而来，这里我设计为新 owner 向旧 owner 发送 <strong>pull</strong> 请求：旧 owner 收到 rpc 后将属于该 Shard 的 kv 对打包进 reply 中发回给新 owner。</p>
<blockquote>
<p>当然 push 也是可以的。</p>
</blockquote>
<p>最开始我将节点的存储简单的设计为了单个 map，后来发现这样做不够优雅——所有数据都存到同一块区域，每次迁移 Shard 时需要对所有元素进行遍历，尽管对 Config/Shard 的操作只需要对服务器上一把大锁，但 O(n) 的遍历无端增加了时间消耗，显然是现实不可用的。</p>
<p>在阅读了 Aurora 的论文后我有所启发：我们完全可以定义一个名为 Shard 的结构体，每个 Shard 拥有单独的 map 存储，这样一来进行分片迁移/垃圾回收时便能<strong>以 Shard 为粒度</strong>进行操作，而不需要遍历所有数据，还能对每个 Shard 进行一些额外的变量设置。</p>
<p>那么能不能在 Apply 更新 Config 日志后立马进行一次 pull Shard 呢？我最开始尝试通过条件变量来进行协程之间的通信，更新完 CurrentConfig 后通知另一个协程发送 pull Shard rpc。但考虑到一旦这个环节 group 挂了，server 重启后并不能够知道当前进行到哪一步，并且 Shard 在 pull 之前是不能提供服务的。所以这个方法立即被我弃用了。</p>
<p>不妨换个思路。任意时刻，server 可能会拥有以下几类 Shard：</p>
<ol type="1">
<li>继续持有的；</li>
<li>不再持有，等待被其它 server pull 的；</li>
<li>不再持有，但已经被其它 server pull 的；</li>
<li>新持有，等待 server 从其他 group 那 pull 的；</li>
<li>新持有，已经 pull 到了的；</li>
</ol>
<blockquote>
<p>如果考虑要做 Challenge1，又能够把 3 和 5 进一步细分为：</p>
<ol type="1">
<li>继续持有的；</li>
<li>不再持有，等待被其它 server pull 的；</li>
<li>不再持有，但
<ol type="1">
<li>被 pull，等待接受 GC 通知；</li>
<li>被 pull，已进行 GC；</li>
</ol></li>
<li>新持有，等待 server 从其他 group 那 pull 的；</li>
<li>新持有，且
<ol type="1">
<li>pull 到，需发送 GC 通知；</li>
<li>pull 到，GC 发送完毕。</li>
</ol></li>
</ol>
<p>之所以设计为<strong>新 owner pull 到 Shard 后向旧 owner 发送 GC 通知</strong>而不是<strong>旧 owner 在收到 pull Shard 并 reply OK 后自行 GC</strong>，还是因为如果 reply 发过去的途中新 owner 挂了，重启后因为没 pull 到还得重新发 pull Shard 请求，而此时旧 owner GC 完毕后存储清空了，就会产生错误——系统永久性地失去了该 Shard 对应的数据。</p>
<p>收到 GC 通知也意味着新 owner 收到了 reply 并完成了 Shard 的覆盖，可以进行数据回收而不用担心是否挂掉。当然，新 owner 收到 reply 也意味着旧 owner 完成了 GC，不用再发送 GC 通知了。</p>
</blockquote>
<p>我选择了完成 Challenge。为了对这些不同种类的 Shard 进行区分，最优雅的做法是在 Shard 结构体内设置一个 <strong>ShardStatus</strong> 变量，这样无论是否挂掉，group 都能在<strong>任意时刻</strong>根据 Shard 内部的 Status 变量进行相应的操作。那么其实思路很简单了，除了 ConfigPuller 协程，我们再启动两个 ShardPuller 和 GarbageCollector 协程，异步地进行<strong>遍历 Shard 并根据 ShardStatus 执行 rpc 等操作</strong>。和之前提到的一样，我们依然需要 Leader 来进行一系列交互行为，并利用 raft 层进行日志同步，所有 server 收到下层传上来的 ApplyMsg 后执行最终的修改操作。</p>
<blockquote>
<p>其中 1, 3.b, 5.b 都意味着无需任何后续操作，统一设置为 Ready 状态</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> status <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// everyone</span></span><br><span class="line">    Ready status = <span class="literal">iota</span> <span class="comment">// 一切就绪</span></span><br><span class="line">    <span class="comment">// new owner</span></span><br><span class="line">    NeedPull           <span class="comment">// 表明该分片等待从其他 group 处拉取</span></span><br><span class="line">    ReadyButNeedSendGC <span class="comment">// 就绪，但需要通知其他 group 进行 GC</span></span><br><span class="line">    <span class="comment">// old owner</span></span><br><span class="line">    Waiting <span class="comment">// 表明该分片等待被其他 group 拉取 + 通知 GC</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Shard <span class="keyword">struct</span> &#123;</span><br><span class="line">    KVs         <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span></span><br><span class="line">    ShardStatus status</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个 Shard 能不能正确处理 client 请求，一是看它是否被当前 server 持有，二是看该 Shard 状态是否为 Ready/ReadyButNeedSendGC，任一条件不满足，都返回 <code>ErrWrongGroup</code>。在 Apply 客户端操作时，需要将 lab3 的代码修改为：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ApplyCommand(msg raft.ApplyMsg) &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    command := msg.Command.(OperationCommand)</span><br><span class="line">    ch := command.Ch</span><br><span class="line">    reply := <span class="built_in">new</span>(Reply)</span><br><span class="line"></span><br><span class="line">    shardId := key2shard(command.Key)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> !kv.ReadyForServer(shardId) &#123;</span><br><span class="line">        reply.Err = ErrWrongGroup</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> command.Op == <span class="string">&quot;Get&quot;</span> &#123;</span><br><span class="line">        val, ok := kv.Shards[shardId].KVs[command.Key]</span><br><span class="line">        <span class="keyword">if</span> ok &#123;</span><br><span class="line">            reply.Value, reply.Err = val, OK</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            reply.Value, reply.Err = <span class="string">&quot;&quot;</span>, ErrNoKey</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> kv.isDuplicated(command.RequestId, command.ClerkId) &#123;</span><br><span class="line">        reply.Err = kv.lastRequestInfo[command.ClerkId].Err</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> command.Op == <span class="string">&quot;Put&quot;</span> &#123;</span><br><span class="line">            kv.Shards[shardId].KVs[command.Key] = command.Value</span><br><span class="line">            reply.Err = OK</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> command.Op == <span class="string">&quot;Append&quot;</span> &#123;</span><br><span class="line">            _, ok := kv.Shards[shardId].KVs[command.Key]</span><br><span class="line">            <span class="keyword">if</span> ok &#123;</span><br><span class="line">                kv.Shards[shardId].KVs[command.Key] += command.Value</span><br><span class="line">                reply.Err = OK</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                kv.Shards[shardId].KVs[command.Key] = command.Value</span><br><span class="line">                reply.Err = ErrNoKey</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Fatalf(<span class="string">&quot;command.op error!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPrintf(<span class="string">&quot;[%d %d] %s (%s, %s) success and the value become %s&quot;</span>, kv.gid, kv.me, command.Op, command.Key, command.Value, kv.Shards[shardId].KVs[command.Key])</span><br><span class="line"></span><br><span class="line">        kv.lastRequestInfo[command.ClerkId] = &amp;RequestInfo&#123;</span><br><span class="line">            RequestID: command.RequestId,</span><br><span class="line">            Err:       reply.Err,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    DPrintf(<span class="string">&quot;[%d %d] Apply Command #%d %s (%s, %s) and reply %+v&quot;</span>, kv.gid, kv.me, msg.CommandIndex, command.Op, command.Key, command.Value, reply)</span><br><span class="line">    <span class="keyword">if</span> kv.rf.GetRaftState() == raft.Leader &amp;&amp; kv.rf.GetCurrentTerm() == msg.CommandTerm &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(reply_ *Reply)</span></span> &#123;</span><br><span class="line">            ch &lt;- reply_</span><br><span class="line">        &#125;(reply)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>考虑到 group 会挂掉这个情况，重启后找谁 pull Shard 也是个问题，故除了 CurrentConfig，server 内部还需设置一个 LastConfig 变量。在 lab3 的基础上，server 结构体应该修改为这样：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> ShardKV <span class="keyword">struct</span> &#123;</span><br><span class="line">    mu       sync.RWMutex</span><br><span class="line">    me       <span class="type">int</span></span><br><span class="line">    mck      *shardctrler.Clerk</span><br><span class="line">    rf       *raft.Raft</span><br><span class="line">    applyCh  <span class="keyword">chan</span> raft.ApplyMsg</span><br><span class="line">    make_end <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">string</span>)</span></span> *labrpc.ClientEnd</span><br><span class="line">    gid      <span class="type">int</span></span><br><span class="line">    ctrlers  []*labrpc.ClientEnd</span><br><span class="line"></span><br><span class="line">    maxraftstate <span class="type">int</span> <span class="comment">// snapshot if log grows this big</span></span><br><span class="line">    lastapplied  <span class="type">int</span></span><br><span class="line"></span><br><span class="line">    Shards          [shardctrler.NShards]Shard</span><br><span class="line">    lastRequestInfo <span class="keyword">map</span>[<span class="type">int64</span>]*RequestInfo</span><br><span class="line"></span><br><span class="line">    lastConfig    shardctrler.Config</span><br><span class="line">    currentConfig shardctrler.Config</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样一来整体的工作流程就很明朗了：</p>
<ol type="1">
<li>ConfigPuller 获得较新的 Config，通过 rf.Start 进行 <code>UpdateConfig</code> 日志同步；</li>
<li>Apply 到 <code>UpdateConfig</code> 日志后，对于仍持有的 Shard，不作变动；对于不再持有的，设置状态为 Waiting；对于新持有的，设置状态为 <code>NeedPull</code>；</li>
<li>Leader 的 ShardPuller 检测到存在状态为 <code>NeedPull</code> 的 Shard 后，根据 LastConfig 找到旧 owner 并发送 pull Shard rpc；</li>
<li>旧 owner 打包 Shard 发回 reply；</li>
<li>新 owner 收到 reply 后，立即 rf.Start 一个 <code>InsertShard</code> 日志，并在 Apply 后设置相应 Shard 的状态为 <code>ReadyButNeedSendGC</code>；</li>
<li>GarbageCollector 检测到存在状态为 <code>ReadyButNeedSendGC</code> 的 Shard 后，根据 LastConfig 找到旧 owner 并发送 garbage collector rpc；</li>
<li>旧 owner 收到 GC 通知，立即 rf.Start 一个 <code>GarbageCollect</code> 日志，Apply 后清理数据，并设置状态为 <code>Ready</code>；</li>
<li>新 owner 收到 GC 的 reply 后，也 rf.Start 一个 <code>GarbageCollect</code> 日志，Apply 后设置状态为 <code>Ready</code>。</li>
</ol>
<blockquote>
<p>7, 8 两步的不同之处在于，新旧 owner Apply GC 日志时，相应的 Shard 状态不同，前者为 <code>ReadyButNeedSendGC</code>，后者为 <code>Waiting</code>。根据状态不同执行不同操作即可，而不需要为新 owner 再新定义一个 <code>UpdateStatus</code> 这样的日志类别。</p>
</blockquote>
<p>然而，ConfigPuller 也不能无条件进行 UpdateConfig，否则会破坏当前 Shard 的状态，甚至可能存在部分 Shard 仍未 pull 到就需要回复其它 group 的 pull 请求，结果是一部分任务永远无法正确完成，从而系统陷入无尽的错误。由于我们引入了 ShardStatus 这一概念，故令<strong>仅当所有 Shard 都变为 Ready 后才能更新 Config</strong> 是一种更安全的行为。</p>
<p>另外，可能某些 Shard 在迁移前仍然由旧 owner 向 client 提供服务，故存在这样一种情况：client 向 group1 发送 shard1 写请求后，group1 实际上执行了这一操作，但给 client 的 reply 丢包了，而其它 server 由于不是 Leader 无法应对请求，故认为 group1 全挂了，此时恰好发现 Config 存在更新，且新 Config 下 shard1 归属于 group2，client 转而向 group2 发送同一写请求。group2 向 group1 pull 了应用过请求的 Shard 后，收到 client 的同一请求，又执行了一遍。为了满足幂等性，pull Shard reply 里还应该包括旧 owner 的去重表来应对这一情况。新 owner 收到后会和自己的去重表进行比对，取同一 clerkId 下的最新 request。</p>
<p>另外，我也遇到了<a target="_blank" rel="noopener" href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md">谭佬遇到的同样问题</a>：</p>
<blockquote>
<p>最后，在 lab2 的文档中我就提到了 leader 上线后应该立刻 append 一条空日志，这样才可以保证 leader 的状态机最新，然而不幸的是，lab2 的测试在加了空日志后便 Fail 了，因此我便没有再关注。在实现 lab4 时，我最开始并没有关注这件事，最后成了一个大坑，导致我花费了一天的时间才找到问题。该 bug 一般跑 100 次测试能够复现一次，对外的表现是集群出现活锁，无法再服务请求直到超时，而且仅会在几个涉及到重启的测试中出现。经过一番探索，最终发现是在节点频繁的重启过后，出现了 lab2 中描述空日志必要性的例子。这导致某一 raft 组的状态机无法达到最新且不全是默认状态，这使得配置更新协程也无法提交新的配置日志，此时客户端碰巧没有向该 raft 组执行读写请求，因而该 raft 组始终没有当前 term 的日志，从而无法推进 commitIndex，因此整个集群便出现了活锁。该 bug 的解决方法很简单，就是让 raft 层的 leader 在 kv 层周期性的去检测下层是否包含当前 term 的日志，如果没有便 append 一条空日志，这样即可保证新选出的 leader 状态机能够迅速达到最新。其实我认为将空日志检测做到 KV 层并不够优雅，KV 层不需要去了解 raft 层有无空日志会怎么样，更优雅地方式应该是 raft 层的 leader 一上线就提交一个空日志。但总之目前在 6.824 的框架下，也只能在 KV 层做检测了。</p>
</blockquote>
<p>我参考了他的做法，加入了<strong>空日志检测机制</strong>。原文中有提到，不再赘述。</p>
<p>基于以上讨论，整体架构就能进行如下设计了。</p>
<h5 id="startserver">StartServer</h5>
<p>注意 Shard.KVs 需要先 make() 对象。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">StartServer</span><span class="params">(servers []*labrpc.ClientEnd, me <span class="type">int</span>, persister *raft.Persister, maxraftstate <span class="type">int</span>, gid <span class="type">int</span>, ctrlers []*labrpc.ClientEnd, make_end <span class="keyword">func</span>(<span class="type">string</span>)</span></span> *labrpc.ClientEnd) *ShardKV &#123;</span><br><span class="line">    labgob.Register(OperationCommand&#123;&#125;)</span><br><span class="line">    labgob.Register(ConfigCommand&#123;&#125;)</span><br><span class="line">    labgob.Register(ShardCommand&#123;&#125;)</span><br><span class="line">    labgob.Register(EmptyCommand&#123;&#125;)</span><br><span class="line"></span><br><span class="line">    kv := &amp;ShardKV&#123;</span><br><span class="line">        me:              me,</span><br><span class="line">        mck:             shardctrler.MakeClerk(ctrlers),</span><br><span class="line">        make_end:        make_end,</span><br><span class="line">        gid:             gid,</span><br><span class="line">        ctrlers:         ctrlers,</span><br><span class="line">        maxraftstate:    maxraftstate,</span><br><span class="line">        lastapplied:     <span class="number">0</span>,</span><br><span class="line">        lastRequestInfo: <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]*RequestInfo),</span><br><span class="line">        lastConfig:      shardctrler.Config&#123;Num: <span class="number">0</span>&#125;,</span><br><span class="line">        currentConfig:   shardctrler.Config&#123;Num: <span class="number">0</span>&#125;,</span><br><span class="line">    &#125;</span><br><span class="line">    kv.applyCh = <span class="built_in">make</span>(<span class="keyword">chan</span> raft.ApplyMsg)</span><br><span class="line">    kv.rf = raft.Make(servers, me, persister, kv.applyCh)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> kv.Shards &#123;</span><br><span class="line">        kv.Shards[i].KVs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    kv.ApplySnapshot(<span class="number">-1</span>, <span class="number">-1</span>, persister.ReadSnapshot())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> kv.Applier()</span><br><span class="line">    <span class="keyword">go</span> kv.ConfigPuller()</span><br><span class="line">    <span class="keyword">go</span> kv.ShardPuller()</span><br><span class="line">    <span class="keyword">go</span> kv.GarbageCollector()</span><br><span class="line">    <span class="keyword">go</span> kv.EmptyEntryDetector()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> kv</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="msgstruct">MsgStruct</h5>
<p>为不同操作命令定义了不同类型，这样就能通过 msg.Command.(type) 进行强转，并进一步根据 Command.Op 执行不同操作。rpc 的参数也统一采用 RPCArgs 的格式——pull Shard 请求和 GC 通知都需要 ShardId 与 ConfigNum。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cmd</span></span><br><span class="line"><span class="keyword">type</span> OperationCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op        <span class="type">string</span></span><br><span class="line">    Key       <span class="type">string</span></span><br><span class="line">    Value     <span class="type">string</span></span><br><span class="line">    ClerkId   <span class="type">int64</span></span><br><span class="line">    RequestId <span class="type">int</span></span><br><span class="line">    Ch        <span class="keyword">chan</span> *Reply</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Reply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Err   Err</span><br><span class="line">    Value <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ShardCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op              <span class="type">string</span></span><br><span class="line">    Shard           *Shard</span><br><span class="line">    Sid             <span class="type">int</span></span><br><span class="line">    ConfigNum       <span class="type">int</span></span><br><span class="line">    LastRequestInfo <span class="keyword">map</span>[<span class="type">int64</span>]RequestInfo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> ConfigCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">    LastConfig shardctrler.Config</span><br><span class="line">    NewConfig  shardctrler.Config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> EmptyCommand <span class="keyword">struct</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rpc</span></span><br><span class="line"><span class="keyword">type</span> RPCArgs <span class="keyword">struct</span> &#123;</span><br><span class="line">    Op        <span class="type">string</span></span><br><span class="line">    ShardId   <span class="type">int</span></span><br><span class="line">    ConfigNum <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> RPCReply <span class="keyword">struct</span> &#123;</span><br><span class="line">    Err             Err</span><br><span class="line">    Shard           Shard</span><br><span class="line">    ConfigNum       <span class="type">int</span></span><br><span class="line">    LastRequestInfo <span class="keyword">map</span>[<span class="type">int64</span>]RequestInfo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="applier">Applier</h5>
<p>和 lab3 大同小异，只是多加了一些 Command 类型的判断。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> Applier() &#123;</span><br><span class="line">    <span class="comment">// goroutine</span></span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">for</span> msg := <span class="keyword">range</span> kv.applyCh &#123;</span><br><span class="line">            <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">                kv.mu.Lock()</span><br><span class="line">                <span class="keyword">if</span> msg.CommandIndex &gt; kv.lastapplied &#123;</span><br><span class="line">                    kv.lastapplied = msg.CommandIndex</span><br><span class="line">                    DPrintf(<span class="string">&quot;[%d %d] Get Command %+v&quot;</span>, kv.gid, kv.me, msg.Command)</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">switch</span> msg.Command.(<span class="keyword">type</span>) &#123;</span><br><span class="line">                    <span class="keyword">case</span> OperationCommand:</span><br><span class="line">                        kv.ApplyCommand(msg)</span><br><span class="line">                    <span class="keyword">case</span> ConfigCommand:</span><br><span class="line">                        kv.ApplyUpdateConfigCommand(msg)</span><br><span class="line">                    <span class="keyword">case</span> ShardCommand:</span><br><span class="line">                        kv.ApplyShardCommand(msg)</span><br><span class="line">                    <span class="keyword">case</span> EmptyCommand:</span><br><span class="line">                        kv.ApplyEmptyCommand()</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="built_in">panic</span>(<span class="string">&quot;Undefined Command Type!&quot;</span>)</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> kv.NeedSnapshot() &#123;</span><br><span class="line">                        kv.MakeSnapshot(msg.CommandIndex)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                kv.mu.Unlock()</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">                kv.mu.Lock()</span><br><span class="line">                kv.ApplySnapshot(msg.SnapshotIndex, msg.SnapshotTerm, msg.Snapshot)</span><br><span class="line">                kv.mu.Unlock()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="configpuller">ConfigPuller</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ApplyUpdateConfigCommand(msg raft.ApplyMsg) &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    Command := msg.Command.(ConfigCommand)</span><br><span class="line">    lastconfig, newconfig := Command.LastConfig, Command.NewConfig</span><br><span class="line">    <span class="keyword">if</span> newconfig.Num == kv.currentConfig.Num+<span class="number">1</span> &#123;</span><br><span class="line">        kv.lastConfig = lastconfig</span><br><span class="line">        kv.currentConfig = newconfig</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> newconfig.Num &gt; <span class="number">1</span> &#123;</span><br><span class="line">            <span class="comment">// config 发生变化：</span></span><br><span class="line">            <span class="comment">// 1. 分配且仍持有的保持 Ready</span></span><br><span class="line">            <span class="comment">// 2. 分配但未持有的变为 NeedPull，等到拉取 shard 完成后变为 Valid</span></span><br><span class="line">            <span class="comment">// 3. 持有但未分配的变为 Waiting，等待其他组 pull 后被回收</span></span><br><span class="line">            <span class="keyword">for</span> sid, gid := <span class="keyword">range</span> kv.lastConfig.Shards &#123;</span><br><span class="line">                <span class="keyword">if</span> gid != kv.gid &amp;&amp; kv.OwnShard(sid) &#123;</span><br><span class="line">                    kv.Shards[sid].ShardStatus = NeedPull</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> gid == kv.gid &amp;&amp; !kv.OwnShard(sid) &#123;</span><br><span class="line">                    kv.Shards[sid].ShardStatus = Waiting</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        DPrintf(<span class="string">&quot;[%d %d] Apply Config: last %+v, new %+v&quot;</span>, kv.gid, kv.me, lastconfig, newconfig)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ConfigPuller() &#123;</span><br><span class="line">    <span class="comment">// goroutine</span></span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">if</span> kv.rf.GetRaftState() == raft.Leader &#123;</span><br><span class="line">            kv.mu.RLock()</span><br><span class="line">            CanPullConfig := <span class="literal">true</span></span><br><span class="line">            lastConfig, configNum := kv.currentConfig, kv.currentConfig.Num    <span class="comment">// CurrentConfig 未来将变为 LastConfig</span></span><br><span class="line">            <span class="keyword">for</span> sid := <span class="keyword">range</span> kv.currentConfig.Shards &#123;</span><br><span class="line">                <span class="keyword">if</span> !kv.ReadyForConfigPuller(sid) &#123;</span><br><span class="line">                    CanPullConfig = <span class="literal">false</span></span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.RUnlock()    <span class="comment">// 及时放锁</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> CanPullConfig &#123;</span><br><span class="line">                newconfig := kv.GetNewConfig()</span><br><span class="line">                <span class="keyword">if</span> newconfig.Num &gt; configNum &#123;</span><br><span class="line">                    <span class="keyword">if</span> configNum == <span class="number">0</span> &amp;&amp; newconfig.Num &gt; <span class="number">1</span> &#123; <span class="comment">// 第一次加入集群，需初始化 lastconfig</span></span><br><span class="line">                        lastConfig = kv.mck.Query(newconfig.Num - <span class="number">1</span>)</span><br><span class="line">                    &#125;</span><br><span class="line">                    kv.rf.Start(ConfigCommand&#123;</span><br><span class="line">                        LastConfig: lastConfig,</span><br><span class="line">                        NewConfig:  newconfig,</span><br><span class="line">                    &#125;)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(NewConfigQueryTimeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="shardpuller-garbagecollector">ShardPuller &amp; GarbageCollector</h5>
<p>两者其实非常相似。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ApplyShardCommand(msg raft.ApplyMsg) &#123;</span><br><span class="line">    Command := msg.Command.(ShardCommand)</span><br><span class="line">    <span class="keyword">switch</span> Command.Op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;InsertShard&quot;</span>:</span><br><span class="line">        kv.InsertShard(Command)</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;GarbageCollect&quot;</span>:</span><br><span class="line">        kv.GarbageCollect(Command)</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(<span class="string">&quot;Undefined Command!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> InsertShard(Command ShardCommand) &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    configNum, newshard, sid := Command.ConfigNum, Command.Shard, Command.Sid</span><br><span class="line">    <span class="keyword">if</span> configNum == kv.currentConfig.Num &amp;&amp; kv.Shards[sid].ShardStatus == NeedPull &#123;</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> newshard.KVs &#123;</span><br><span class="line">            kv.Shards[sid].KVs[k] = v</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> clientId, lastrequestInfo := <span class="keyword">range</span> Command.LastRequestInfo &#123;</span><br><span class="line">            Rinfo, ok := kv.lastRequestInfo[clientId]</span><br><span class="line">            <span class="keyword">if</span> !ok || Rinfo.RequestID &lt; lastrequestInfo.RequestID &#123;</span><br><span class="line">                kv.lastRequestInfo[clientId] = &amp;RequestInfo&#123;</span><br><span class="line">                    lastrequestInfo.RequestID,</span><br><span class="line">                    lastrequestInfo.Err,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        kv.Shards[sid].ShardStatus = ReadyButNeedSendGC</span><br><span class="line">        DPrintf(<span class="string">&quot;[%d %d] insert %d-th Shard %+v&quot;</span>, kv.gid, kv.me, Command.Sid, Command.Shard)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> GarbageCollect(Command ShardCommand) &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    configNum, sid := Command.ConfigNum, Command.Sid</span><br><span class="line">    <span class="keyword">if</span> configNum == kv.currentConfig.Num &#123;</span><br><span class="line">        <span class="keyword">if</span> kv.Shards[sid].ShardStatus == ReadyButNeedSendGC &#123;</span><br><span class="line">            kv.Shards[sid].ShardStatus = Ready</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> kv.Shards[sid].ShardStatus == Waiting &#123;</span><br><span class="line">            kv.Shards[sid].KVs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">            kv.Shards[sid].ShardStatus = Ready</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ShardPuller() &#123;</span><br><span class="line">    <span class="comment">// goroutine</span></span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">if</span> kv.rf.GetRaftState() == raft.Leader &#123;</span><br><span class="line">            kv.mu.RLock()</span><br><span class="line">            configNum := kv.currentConfig.Num <span class="comment">// 捎带当前 config.num，防止收到过期回复</span></span><br><span class="line">            <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">            <span class="keyword">for</span> sid, gid := <span class="keyword">range</span> kv.lastConfig.Shards &#123;</span><br><span class="line">                <span class="keyword">if</span> kv.NeedPull(sid) &#123; <span class="comment">// 向前任持有者拉取 shard</span></span><br><span class="line">                    wg.Add(<span class="number">1</span>)</span><br><span class="line">                    <span class="comment">// Send RPC and Pull Shard</span></span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(sid, gid <span class="type">int</span>, others []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        index := <span class="number">0</span></span><br><span class="line">                        args := &amp;RPCArgs&#123;</span><br><span class="line">                            Op:        <span class="string">&quot;PullShard&quot;</span>,</span><br><span class="line">                            ShardId:   sid,</span><br><span class="line">                            ConfigNum: configNum,</span><br><span class="line">                        &#125;</span><br><span class="line">                        DPrintf(<span class="string">&quot;[%d %d] pull shard %d from %d with args %+v&quot;</span>, kv.gid, kv.me, sid, gid, args)</span><br><span class="line">                        <span class="keyword">for</span> &#123;</span><br><span class="line">                            end := kv.make_end(others[index])</span><br><span class="line">                            reply := &amp;RPCReply&#123;&#125;</span><br><span class="line">                            ok := end.Call(<span class="string">&quot;ShardKV.HandleBetweenGroupRequest&quot;</span>, args, reply)</span><br><span class="line">                            <span class="keyword">if</span> ok &amp;&amp; reply.Err == OK &#123;</span><br><span class="line">                                DPrintf(<span class="string">&quot;[%d %d] pull shard %d from %d and get KVs: %+v&quot;</span>, kv.gid, kv.me, sid, gid, reply.Shard.KVs)</span><br><span class="line">                                kv.rf.Start(ShardCommand&#123;</span><br><span class="line">                                    Op:              <span class="string">&quot;InsertShard&quot;</span>,</span><br><span class="line">                                    Shard:           &amp;reply.Shard,</span><br><span class="line">                                    ConfigNum:       configNum,</span><br><span class="line">                                    Sid:             sid,</span><br><span class="line">                                    LastRequestInfo: reply.LastRequestInfo,</span><br><span class="line">                                &#125;)</span><br><span class="line">                                <span class="keyword">return</span></span><br><span class="line">                            &#125; <span class="comment">// else: FailSend / ErrWrongLeader / ErrNotReady</span></span><br><span class="line">                            index = (index + <span class="number">1</span>) % <span class="built_in">len</span>(others)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;(sid, gid, kv.lastConfig.Groups[gid])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.RUnlock()</span><br><span class="line">            wg.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(ShardPullerTimeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> GarbageCollector() &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">if</span> kv.rf.GetRaftState() == raft.Leader &#123;</span><br><span class="line">            kv.mu.RLock()</span><br><span class="line">            configNum := kv.currentConfig.Num <span class="comment">// 捎带当前 config.num，防止收到过期回复</span></span><br><span class="line">            <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">            <span class="keyword">for</span> sid, gid := <span class="keyword">range</span> kv.lastConfig.Shards &#123;</span><br><span class="line">                <span class="keyword">if</span> kv.ReadyButNeedSendGC(sid) &#123; <span class="comment">// 向前任持有者发送 GC 请求</span></span><br><span class="line">                    wg.Add(<span class="number">1</span>)</span><br><span class="line">                    <span class="comment">// Send RPC and make GC</span></span><br><span class="line">                    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(sid, gid <span class="type">int</span>, others []<span class="type">string</span>)</span></span> &#123;</span><br><span class="line">                        <span class="keyword">defer</span> wg.Done()</span><br><span class="line">                        index := <span class="number">0</span></span><br><span class="line">                        args := &amp;RPCArgs&#123;</span><br><span class="line">                            Op:        <span class="string">&quot;GarbageCollect&quot;</span>,</span><br><span class="line">                            ShardId:   sid,</span><br><span class="line">                            ConfigNum: configNum,</span><br><span class="line">                        &#125;</span><br><span class="line">                        DPrintf(<span class="string">&quot;[%d %d] send GC %d to %d at Config %d&quot;</span>, kv.gid, kv.me, sid, gid, configNum)</span><br><span class="line">                        <span class="keyword">for</span> &#123;</span><br><span class="line">                            end := kv.make_end(others[index])</span><br><span class="line">                            reply := &amp;RPCReply&#123;&#125;</span><br><span class="line">                            ok := end.Call(<span class="string">&quot;ShardKV.HandleBetweenGroupRequest&quot;</span>, args, reply)</span><br><span class="line">                            <span class="keyword">if</span> ok &amp;&amp; reply.Err == OK &#123;</span><br><span class="line">                                DPrintf(<span class="string">&quot;[%d %d] send GC %d to %d success&quot;</span>, kv.gid, kv.me, sid, gid)</span><br><span class="line">                                kv.rf.Start(ShardCommand&#123;</span><br><span class="line">                                    Op:              <span class="string">&quot;GarbageCollect&quot;</span>,</span><br><span class="line">                                    Shard:           <span class="literal">nil</span>,</span><br><span class="line">                                    ConfigNum:       configNum,</span><br><span class="line">                                    Sid:             sid,</span><br><span class="line">                                    LastRequestInfo: <span class="literal">nil</span>,</span><br><span class="line">                                &#125;)</span><br><span class="line">                                <span class="keyword">return</span></span><br><span class="line">                            &#125; <span class="comment">// else: FailSend / ErrWrongLeader / ErrNotReady</span></span><br><span class="line">                            index = (index + <span class="number">1</span>) % <span class="built_in">len</span>(others)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;(sid, gid, kv.lastConfig.Groups[gid])</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            kv.mu.RUnlock()</span><br><span class="line">            wg.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(GarbageCollectorTimeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="emptyentrydetector">EmptyEntryDetector</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> ApplyEmptyCommand() &#123;</span><br><span class="line">    <span class="comment">// DPrintf(&quot;EMPTY COMMAND&quot;)</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> EmptyEntryDetector() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        <span class="keyword">if</span> kv.rf.GetRaftState() == raft.Leader &#123;</span><br><span class="line">            <span class="keyword">if</span> !kv.rf.HasLogAtCurrentTerm() &#123;</span><br><span class="line">                kv.rf.Start(EmptyCommand&#123;&#125;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        time.Sleep(EmptyEntryDetectorTimeOut)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="组间-rpc">组间 RPC</h5>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *ShardKV)</span></span> HandleBetweenGroupRequest(args *RPCArgs, reply *RPCReply) &#123;</span><br><span class="line">    <span class="comment">// RPC</span></span><br><span class="line">    <span class="keyword">if</span> kv.rf.GetRaftState() != raft.Leader &#123;</span><br><span class="line">        reply.Err = ErrWrongLeader</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    kv.mu.RLock()</span><br><span class="line">    <span class="keyword">defer</span> kv.mu.RUnlock()</span><br><span class="line">    <span class="keyword">defer</span> DPrintf(<span class="string">&quot;[%d %d] get %+v and reply %+v&quot;</span>, kv.gid, kv.me, args, reply)</span><br><span class="line"></span><br><span class="line">    sid, configNum := args.ShardId, args.ConfigNum</span><br><span class="line">    <span class="keyword">if</span> configNum &gt; kv.currentConfig.Num &#123;</span><br><span class="line">        reply.ConfigNum, reply.Err = kv.currentConfig.Num, ErrNotReady</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 允许接收过期 rpc，但 reply 会捎带 CurrentConfigNum，这样尽管收到过期 reply 也不会进行任何操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> args.Op &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;PullShard&quot;</span>:</span><br><span class="line">        reply.Shard.KVs = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>)</span><br><span class="line">        <span class="keyword">for</span> k, v := <span class="keyword">range</span> kv.Shards[sid].KVs &#123;</span><br><span class="line">            reply.Shard.KVs[k] = v</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        reply.LastRequestInfo = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int64</span>]RequestInfo)</span><br><span class="line">        <span class="keyword">for</span> clerkId, lastrequestInfo := <span class="keyword">range</span> kv.lastRequestInfo &#123;</span><br><span class="line">            reply.LastRequestInfo[clerkId] = *lastrequestInfo</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;GarbageCollect&quot;</span>:</span><br><span class="line">        kv.rf.Start(ShardCommand&#123;</span><br><span class="line">            Op:              <span class="string">&quot;GarbageCollect&quot;</span>,</span><br><span class="line">            Shard:           <span class="literal">nil</span>,</span><br><span class="line">            ConfigNum:       configNum,</span><br><span class="line">            Sid:             sid,</span><br><span class="line">            LastRequestInfo: <span class="literal">nil</span>,</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reply.ConfigNum, reply.Err = configNum, OK</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="总结">总结</h3>
<p>这么设计有以下好处：</p>
<ol type="1">
<li>pull Shard 后能立即为 client 提供服务，而无需阻塞；</li>
<li>不同 group 之间 Shard 状态互为同步关系，网络顺畅时系统才能够持续进行；</li>
<li>不同 ShardId 的 Shard 互相独立，当两组互相迁移 Shard 时并不会造成死锁；</li>
<li>group 能够 step-by-step 地更新 Config，所有任务都能稳定执行，而不会出现步子跨太大扯着蛋的情况；</li>
<li>失去 Shard 所有权的 group 能够定期删除数据，而不会使存储无线增长；</li>
<li>基于 ShardStatus 的任务执行减少了不必要的阻塞，使得整个系统设计更加优雅；</li>
</ol>
<p>总之系统的设计还是需要灵感与无数前人的经验总结，至少 Aurora 的论文给了我很大启迪。虽然因为磕盐原因 4B 磨蹭了很久，整个 lab 前前后后磨蹭了近 3 个月，但总归是 solo &amp;&amp; all passed 了，对 Distributed System 也有了更进一步的理解。完结撒花~</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/lab/" rel="tag"># lab</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/ZJU-CLASS/CProgramGuide/" rel="prev" title="C Program Guide">
      <i class="fa fa-chevron-left"></i> C Program Guide
    </a></div>
      <div class="post-nav-item">
    <a href="/6-824/COPS/" rel="next" title="COPS 论文阅读">
      COPS 论文阅读 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#part-a-the-shard-controller"><span class="nav-text">PART A-The Shard controller</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%96%B0%E5%BB%BA%E9%85%8D%E7%BD%AE"><span class="nav-text">新建配置</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%86%E7%89%87%E5%86%8D%E5%88%86%E9%85%8D"><span class="nav-text">分片再分配</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#part-b-shared-keyvalue-server"><span class="nav-text">PART B-Shared Key&#x2F;Value Server</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%BC%80%E5%A7%8B-4b-%E4%B9%8B%E5%89%8D%E9%9C%80%E8%A6%81%E6%83%B3%E6%98%8E%E7%99%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BA%8B"><span class="nav-text">开始 4B 之前需要想明白的一些事</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#clerk"><span class="nav-text">Clerk</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#server"><span class="nav-text">Server</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#startserver"><span class="nav-text">StartServer</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#msgstruct"><span class="nav-text">MsgStruct</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#applier"><span class="nav-text">Applier</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#configpuller"><span class="nav-text">ConfigPuller</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#shardpuller-garbagecollector"><span class="nav-text">ShardPuller &amp; GarbageCollector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#emptyentrydetector"><span class="nav-text">EmptyEntryDetector</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%84%E9%97%B4-rpc"><span class="nav-text">组间 RPC</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Leager"
      src="/images/Avatar.jpg">
  <p class="site-author-name" itemprop="name">Leager</p>
  <div class="site-description" itemprop="description">【数据删除】</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">37</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Leager-zju" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Leager-zju" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div>
<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
    var now = new Date();
    function createtime() {
        var grt= new Date("09/25/2022 00:00:00");
        now.setTime(now.getTime()+250);
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;}
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;}
        document.getElementById("timeDate").innerHTML = "本站已存活 "+dnum+" 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
setInterval("createtime()",250);
</script>
</div>

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Leager</span>
</div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  
  <script color='0,0,0' opacity='0.5' zIndex='-1' count='160' src="//cdn.jsdelivr.net/gh/theme-next/theme-next-canvas-nest@1.0.0/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
