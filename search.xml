<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CRAQ</title>
    <url>/6-824/CRAQ/</url>
    <content><![CDATA[<p>6.824 的第五篇论文是 CRAQ(<strong>Chain Replication with Apportioned Queries</strong>)——一种以读取为主的工作负载的高吞吐量链式复制。它对原先的 Chain Replication 进行了一定的改进，在保持强一致性的同时大大提高了读取吞吐量。通过在所有对象副本之间分配负载，CRAQ 随链大小线性扩展，而不会增加一致性协调。</p>
<span id="more"></span>
<h4 id="chain-replication">Chain Replication</h4>
<p>在传统的 CR 策略中，所有服务器按照链排列，第一个服务器称为 <strong>HEAD</strong>，最后一个服务器称为 <strong>TAIL</strong>。HEAD 处理所有写请求，TAIL 处理所有读请求。写请求沿链传播，TAIL 收到后会返回 ack。</p>
<p><img src="image-20221009141338449.png" alt="image-20221009141338449" style="zoom:67%;" /></p>
<p>CR 本身是线性一致的，在没有故障时，从一致性的角度来说，整个系统就像只有 TAIL 一台服务器一样，TAIL 可以看到所有的写请求，也可以看到所有的读请求，它一次只处理一个请求，读请求可以看到最新写入的数据。</p>
<h5 id="与-raft-相比">与 Raft 相比</h5>
<ul>
<li>Raft 的 Leader 在处理写请求时，会将该请求广播给其他所有 raft node，而 CR 的 HEAD 只会将请求发送给链中的下一个服务器。同等条件下，CR 的网络负担更小，单位时间内也能处理更多请求。</li>
<li>对于读请求，Raft 中也是只有 Leader 一人承担，而 CR 中则由 TAIL 处理，相当于 CR 的 HEAD 和 TAIL 各自分担了读写负载。</li>
<li>CR 的<strong>故障恢复</strong>相对而言更简单：
<ol type="1">
<li>如果 HEAD 崩溃了，则由下一个服务器成为 HEAD。没发出去的请求就不管了，发出去的请求照样沿链传播。</li>
<li>如果 TAIL 崩溃了，其前一个服务器成为 TAIL。这是很自然的，因为前一个服务器知道的信息必然不少于挂掉的 TAIL。</li>
<li>如果中间的服务器崩溃了，则需要将其移除，就像在链表中移除一样，并且可能需要有消息的重发。</li>
</ol></li>
</ul>
<h5 id="缺陷">缺陷</h5>
<ol type="1">
<li>所有的读请求都会被发到 TAIL，从而导致潜在的 <strong>hotspot</strong> 以及负载不平衡，且并不能通过增加节点数量来提高读吞吐量。</li>
<li>存在脑裂(<strong>split-brain</strong> 问题。</li>
</ol>
<p>第二个问题很好解决，可以通过设置一个 <strong>Configuration Manager</strong> 来安排 chain 的配置。该配置中描述了链的定义，包括所有节点，HEAD 和 TAIL。Configuration Manager 监测节点活性，一旦有节点挂了，则会重新生成并发送新的配置。它不能否认自己，从而解决脑裂问题。</p>
<h4 id="craq">CRAQ</h4>
<h5 id="一致性模型">一致性模型</h5>
<ul>
<li><strong>强一致性</strong>：对对象的所有读写操作都以某种顺序执行，且对对象的读取总是看到最新的写入值。</li>
<li><strong>最终一致性</strong>：虽然对不同节点的读取可能会在一段时间内返回旧数据，但一旦所有副本都收到写请求，则读操作永远不会返回比最新提交的写入更旧的版本。</li>
<li><strong>具有最大有界不一致性</strong>：允许读操作在提交之前返回新写入的对象，但仅限于某个点。</li>
</ul>
<h5 id="改进">改进</h5>
<p>CRAQ 对传统 CR 的改进之处在以下几点：</p>
<ol type="1">
<li>节点存放对象的多个版本，每个版本都包含一个单调增的版本号和该版本是否 dirty 的附加属性；</li>
<li>当节点收到对象新版本的写入时，节点会将这个版本附加到其对象列表中，并且：
<ul>
<li>若该节点不是 TAIL，将此版本标记为 <code>dirty = true</code>；</li>
<li>反之，将此版本标记为 <code>dirty = false</code>，此时将对象的版本称为 <strong>committed</strong>，然后向前发送 ack 通知其它节点。与此同时，该节点也可以在本地处理读取操作。</li>
</ul></li>
<li>当返回的 ack 到达节点时，节点将该版本标记为 <code>dirty = false</code>，然后可以删除该对象的所有先前版本。</li>
<li>当一个节点收到对象的读请求时：
<ul>
<li>若最新版本号并不 dirty，则返回；</li>
<li>反之，联系 TAIL 并查询该对象最后提交的版本号并返回。</li>
</ul></li>
</ol>
<p><img src="image-20221009142355628.png" alt="image-20221009142355628" style="zoom:80%;" /></p>
<p>在这样的策略下，无论写请求是否到该节点，以及 ack 是否传回该节点，对对象的读操作也能表现地像 CR 那样——因为读请求总是 <strong>serialized with respect to the TAIL.</strong></p>
<blockquote>
<p>也可以隐式确定对象的 <code>dirty</code> 属性，即对象列表中不止一个版本，则必然是脏的，反之同理。</p>
<p>前提是收到 ack 后立即删除旧版本。</p>
</blockquote>
<p>CRAQ 对 CR 的吞吐量改进体现在以下两个场景：</p>
<ol type="1">
<li><strong>Read-Mostly Workloads</strong>：大部分读请求由 <span class="math inline">\(C-1\)</span> 个非 TAIL 节点处理，故这些场景中的吞吐量与链长 <span class="math inline">\(C\)</span> 呈线性关系。</li>
<li><strong>Write-Heavy Workloads</strong>：对非 TAIL 节点的大多数读请求都是脏的，因此需要对 TAIL 进行版本查询，而这种查询比读取完整的数据对象更加轻量，故总吞吐量仍然高于 CR。</li>
</ol>
<h4 id="craq-布局">CRAQ 布局</h4>
<h5 id="链布局策略">链布局策略</h5>
<p>使用分布式存储服务的应用程序的需求可能多种多样，可能有以下常见情况：</p>
<ul>
<li>对对象的大部分或全部写入可能源自单个数据中心。</li>
<li>某些对象可能只与数据中心的子集相关。</li>
<li>热对象可能需要大量复制，而冷对象可能很少。</li>
</ul>
<p>CRAQ 通过使用对象的<strong>两级命名层次结构</strong>来满足这些要求，对象标识符由<strong>链标识符</strong>和<strong>键标识符</strong>组成。</p>
<h6 id="隐式数据中心-全局链长">隐式数据中心 &amp; 全局链长</h6>
<p><span class="math inline">\(\{num\_datacenters,\ chain\_size\}\)</span></p>
<p>这种方法中仅定义了数据中心是数量，并未实际指明。为确定哪些数据中心存储了链，还需要用到一致性哈希。</p>
<h6 id="显式数据中心-全局链长">显式数据中心 &amp; 全局链长</h6>
<p><span class="math inline">\(\{chain\_size,\ dc_1,\ dc_2,\ \dots, dc_N\}\)</span></p>
<p>每个数据中心都使用相同链长，链头位于 <span class="math inline">\(dc_1\)</span> 内，链尾位于 <span class="math inline">\(dc_N\)</span> 内，并且根据提供的数据中心列表对链排序。若 <code>chain_size = 0</code>，说明链应该使用数据中心内的所有节点。</p>
<h6 id="显式数据中心链长">显式数据中心链长</h6>
<p><span class="math inline">\(\{dc_1,\ chain\_size_1,\ \dots, dc_N,\ chain\_size_N\}\)</span></p>
<p>每个数据中心的链长单独指定，允许链负载不均衡。<code>chain_size i</code> 也可以设为 0。</p>
<h5 id="数据中心内的-craq">数据中心内的 CRAQ</h5>
<p>目前，CRAQ 使用一致性哈希将链放在数据中心内，将尽可能多的链标识符映射到单个 HEAD。</p>
<h5 id="跨数据中心的-craq">跨数据中心的 CRAQ</h5>
<p>当链跨域时，CRAQ 从任何节点读的特性能够降低其延迟——client 可以就近读取，而无需发送跨域网络请求。</p>
<p>尽管随着数据中心数量的增加，写延迟也会增加，但 CRAQ 允许写入沿链<strong>流水线化</strong>，故与 primary/backup 方法相比，还是能够极大提高写入吞吐量。应用程序可能进一步优化链的选择，从而最大限度减少写入延迟和网络成本。</p>
<h5 id="zookeeper-协调服务">ZooKeeper 协调服务</h5>
<p>目前的 CRAQ 利用 ZooKeeper 来跟踪组成员身份与存储链数据。通过 ZooKeeper，可以保证 CRAQ 节点在有节点加入/退出链，或某些数据发生变化时收到通知。</p>
<h4 id="总结">总结</h4>
<p>CRAQ 通过串行的方法提供了另一种有趣的复制方式，且提供了与 Raft 不一样的属性，它也给 Aurora 提供了一定的策略支持。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Frangipani</title>
    <url>/6-824/Frangipani/</url>
    <content><![CDATA[<p>6.824 的第六篇论文是 Frangipani——一种建立在 Petal（一种可扩展、高可用性、自动管理的分布式存储服务）上的可扩展的分布式文件系统，并使用分布式锁来确保一致性。</p>
<span id="more"></span>
<h4 id="frangipani-初探">Frangipani 初探</h4>
<h5 id="特点">特点</h5>
<p>Frangipani 有一个显著特点，就是它采用<strong>一组协作机器使用一个公共存储</strong> Petal 的内部结构，使用锁进行访问同步，同时具备以下特性：</p>
<ol type="1">
<li>为所有用户提供同一组文件的一致视图，即对于同一个文件，所有用户在访问时都能看到相同的数据；</li>
<li>可以任意添加服务器到 Frangipani 架构中以增加存储容量和吞吐量，而无需更改现有服务器的配置或中断其运行；</li>
<li>系统管理员可以添加新用户，而无需担心哪些机器将管理他们的数据或哪些磁盘存这些数据；</li>
<li>系统管理员可以对整个文件系统进行完整且一致的备份，而无需将其关闭，同时允许用户快速访问意外删除的文件；</li>
<li>文件系统能容忍并从故障中恢复而无需人工干预。</li>
</ol>
<h5 id="系统结构">系统结构</h5>
<p>如下图所示，Petal 表现得就像一块被所有用户使用的，基于网络的共享虚拟磁盘，它会运行在一些不同的服务器上。当 Frangipani 需要读写数据时，它会向正确的 <strong>Petal server</strong> 发送 RPC。</p>
<p><img src="image-20221010155347871.png" alt="image-20221010155347871" style="zoom:80%;" /></p>
<p>用户通过标准操作系统调用借口访问 Frangipani，对一台机器上的文件或目录进行的修改会立即对其他人可见。</p>
<p>Frangipani 采用 <strong>Cache</strong> 来缓存文件，这样在一段时间内对文件的修改只需要在本地进行，而无需耗费更高的时间成本进行 RPC 的调用。同时，在下一个用户访问该文件前，不会将修改后的数据持久化到 Petal，但会将元数据的修改操作记录到 <strong>WAL</strong> 中。WAL 保存在 Petal 中，这样当 Frangipani 崩溃时，其它服务器可以访问 WAL 并进行故障恢复。</p>
<p>每个 Petal server 持有一个 <strong>lock manager</strong>，它有一个表单，存放文件对应的锁以及持有锁的用户，来协调对 Petal 的访问以及保持多个 Frangipani 之间的缓冲区的<strong>缓存一致性</strong>。两个 <strong>Frangipani server</strong> 间无需直接通信，而是通过 LM 通信，这也简化了成员的变化操作。</p>
<h4 id="锁服务">锁服务</h4>
<p>Frangipani 中的锁服务提供<strong>共享读锁</strong>与<strong>排他写锁</strong>。当一个 Fserver 访问文件时，它会向对应的 Pserver 中的 LM 发起 <strong>Request</strong> 请求该文件合适的锁，并在得到 LM 的 <strong>Grant</strong> 回复后才获得锁，从而正式读取文件或修改文件。之后，Fserver 会<strong>一直持有文件锁</strong>（但可能不使用它）而不主动释放，这种惰性释放锁的策略也一定程度上提高了性能——在没有其它 Fserver 请求访问的前提下，后续对相同文件的修改不用再次请求锁。</p>
<p>若有其它的 Fserver 发起了冲突的锁请求，LM 检查当前有一个 Fserver 正持有锁，它会向该 Fserver 发起一个 <strong>Revoke</strong> 请求，持有文件锁的 Fserver 等到当前没有对该文件进行的任何操作，<u>它会将对该文件的所有修改应用到 Pserver 上</u>，这一步完成后才释放锁，向 LM 发出 <strong>Release</strong> 请求。LM 随后删除表单中原先该锁对应的条目，再重新执行一次锁分配的操作。</p>
<p>通过 LM 的协调服务，我们可以实现良好的 <strong>缓存一致性 Cache Consistency</strong>——A 对本地缓存进行的修改，能够被 B 感知到。同时，只要保证 Fserver 在操作期间一致持有锁，就能保证对文件操作的<strong>原子性 atomicity</strong>。</p>
<h4 id="故障处理">故障处理</h4>
<h5 id="日志">日志</h5>
<p>如前文所述，每个 Frangipani server 都会在 Petal 的某个地方存放自己那部分 WAL。当 Frangipani 需要对文件元数据进行修改时，它首先创建一个修改记录并 append 到本地内存的日志中，这些日志被定期（大概 30s）写入 Petal，只有在日志完整写入 Petal 后，Petal 才会永久修改实际的元数据。<strong>事实上，在 Release 锁前，Fserver 会先将日志写入 Pserver，再传输脏数据</strong>。</p>
<h5 id="恢复">恢复</h5>
<p>LM 使用 <strong>lease</strong> 来处理故障，也就是说，当对一个锁进行 Revoke 时，过了 lease 规定的时间没有得到 Release 回复，它会认为这个 Fserver 发生了故障，从而进行故障处理。</p>
<p><strong>dead</strong> 发生故障后，Pserver 会让另一个 Frangipani（称为 <strong>demon</strong>）读取其日志并进行恢复。demon 会隐式接管 dead 挂前持有的锁，并从日志开始按顺序进行重做，执行完成后，释放 dead 的锁，之后整个系统按正常状态运行。</p>
<p>这里有可能的几个发生故障的时刻：</p>
<ol type="1">
<li><strong>还没发送日志就挂了</strong>：此时文件系统会和 Fserver 开始修改前保持一致，故不用进行任何操作。</li>
<li><strong>日志发送到一半挂了</strong>：说明 Fserver 尚未发送脏数据，只需执行已发送的那部分日志即可。</li>
<li><strong>脏数据传到一半挂了</strong>：说明 Fserver 必然已经发完了所有日志，那么对所有日志重做就好了。</li>
</ol>
<p>无论是哪种情况，都有一个共同点：<strong>只需要执行已写到 Pserver 内的日志</strong>。</p>
<p>为了防止 demon 在进行故障恢复时其它 Fserver 对 Petal 的干扰，在日志条目中增加<strong>版本号</strong>的属性：当且仅当日志中元数据的版本号高于 Petal 中存储的数据的版本时，才执行日志。如果是 Petal 中的版本更高，那说明已经有 Fserver 在 dead 修改之后对元数据进行了修改，不能进行回退。</p>
<p>且 demon 无需关心元数据上是否持有锁。如果有锁，那大可以放心读取；如果锁已经被释放了，那脏数据肯定已经被写进去了，不用执行也没时。</p>
<h4 id="总结">总结</h4>
<p>Frangipani 提供了实现 Cache Consistency 的新思路，但由于时代的限制，它并没有对存储系统的演进产生任何影响，也无法应用到分布式系统的主要应用场景中。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>GFS</title>
    <url>/6-824/GFS/</url>
    <content><![CDATA[<p>6.824 的第一篇论文是 Google “<strong>三驾马车</strong>”之一的 <strong>GFS</strong>(Google File System)——一个用于大型分布式数据密集型应用程序的可扩展分布式文件系统。</p>
<span id="more"></span>
<h3 id="问题的提出背景">问题的提出背景</h3>
<ol type="1">
<li>系统时常发生组件故障，其成因有许多：应用程序故障、操作系统故障、人为因素等。因此系统需要一定的持续监控、错误检测、容错和自动恢复能力。</li>
<li>多 GB 文件很常见，然而传统系统在管理海量小文件时显得比较笨拙，必须重新对 I/O 操作和文件块大小等进行参数的设计。</li>
<li>大多数文件是通过<strong>追加</strong>(append)新数据而不是<strong>重写</strong>(overwrite)现有数据来改变的，不存在对文件的随机写入。一旦写入，文件就只能被读取，而且通常只能按顺序读取。这与在<strong>客户端</strong>(client)缓存数据块相性不合。</li>
<li>统一应用程序和文件系统的 API 能够增加系统的灵活性。放宽 GFS 的一致性模型以极大地简化文件系统，而不会给应用程序带来繁重的负担。</li>
</ol>
<h3 id="设计总览">设计总览</h3>
<h4 id="系统的应用场景假设">系统的应用场景假设</h4>
<ol type="1">
<li>该系统由许多经常发生故障的廉价商品组件构建而成。它必须不断地自我监控，并定期检测、容忍组件故障并迅速从组件故障中恢复。</li>
<li>系统应有效管理大文件存储。同时必须支持小文件，但不需要针对它们进行优化。</li>
<li>工作负载主要包括两种读取：大型流式读取和小型随机读取。在大型流式读取中，单个操作通常读取数百 KB，更常见的是 1 MB 或更多。来自同一 client 的连续操作通常会读取文件的连续区域；小型随机读取通常会在某个任意偏移量处读取几个 KB，注重性能的应用程序经常对这些小读取进行批处理和排序，以稳定地遍历文件而不是来回移动。</li>
<li>系统必须为多个 client 同时对同一文件进行 append 定义良好的语义。我们的文件通常使用生产者-消费者队列或多路合并。可能同时会有数百个生产者将数据追加到一个文件中，故具有最小同步开销的原子性是必不可少的。</li>
<li>高持续带宽比低延迟更重要。大多数目标应用程序都非常重视以高速率批量处理数据，而少数目标应用程序对单个读取或写入具有严格的响应时间要求。</li>
</ol>
<h4 id="接口">接口</h4>
<p>GFS 提供并支持常规的文件系统接口：create、delete、open、close、read 和 write （尽管它没有实现诸如 POSIX 之类的标准 API），且文件在目录中分层组织由路径名标识。</p>
<p>此外，GFS 具有<strong>快照</strong>(snapshot)和<strong>记录追加</strong>(record append)操作。snapshot 以低成本创建文件或目录树的副本。record append 允许多个 client 同时向同一个文件追加数据，并保证每个 client 追加的原子性，而无需额外的锁策略。</p>
<h4 id="系统结构">系统结构</h4>
<p>GFS 集群(cluster)由单个<strong>主服务器</strong>(master server)和多个<strong>块服务器</strong>(chunk server)组成，并由多个 client 访问。其中每一个 client 通常都是运行用户级服务器进程的 Linux 机器。</p>
<blockquote>
<p>只要机器资源允许，并能够容忍由于运行可能不稳定的应用程序代码而导致较低的可靠性，也可以在同一台机器上同时运行 chunk server 和 client。</p>
</blockquote>
<p><img src="image-20220925142136479.png" alt="image-20220925142136479" style="zoom:80%;" /></p>
<p>GFS 将文件分成固定大小的<strong>块</strong>(chunk)，并以 <strong>Linux 文件</strong>的形式存放在多个 chunk server 的本地磁盘上。</p>
<blockquote>
<p>这样读写操作自然就会变得很快。因为可以从多个服务器上同时读取同一个文件，进而获得更高的聚合吞吐量。将文件分割存储还可以在存储系统中保存比单个磁盘还要大的文件。</p>
</blockquote>
<p>每个 chunk 由 master 在创建时分配的不变且全局唯一的 64 位<strong>块句柄</strong>(chunk handle)标识。chunk server 读取或写入由 chunk handle 和字节范围指定的 chunk data。每个 chunk 都在多个 chunk server 上复制以实现可靠性。</p>
<blockquote>
<p>默认存储三个副本，尽管用户可以为文件命名空间的不同区域指定不同的复制级别。</p>
</blockquote>
<p>client 实现文件系统 API，并与 master 和 chunk server 通信来读取或写入数据。client 与 master 交互进行元数据操作，但所有承载数据的通信都直接进入 chunk server。以一次<strong>读文件操作</strong>为例：</p>
<ol type="1">
<li>client 向 master 发出文件请求，该请求包含了 file name 与操作范围在文件中的偏移量 offset。</li>
<li>master 在 table 中寻找 file name 到 chunk ID 的映射（一个 file 对应若干 chunk）。</li>
<li>之后，master 再根据 offset % chunk size = chunk index 找到对应的 chunk，向 client 发回 chunk handle 和 chunk location。</li>
<li>client 收到回复后，根据 chunk location 寻找 chunk server，使用 chunk handle 进行文件操作。</li>
</ol>
<p>client 和 chunk server 都不缓存文件数据。大多数应用程序要么工作集太大，要么通过大文件流式传输，client 无法缓存。chunk server 不需要缓存文件数据，因为 chunk 存储为本地文件，Linux 的缓冲区缓存已经将频繁访问的数据保存在内存中。</p>
<blockquote>
<p>但 client 会缓存元数据，也会缓存一定的 chunk server 信息，以避免与 master 的重复交互。</p>
</blockquote>
<h4 id="块大小chunk-size">块大小(chunk size)</h4>
<p>论文中选取的是 <strong>64 MB</strong>，并且仅在需要时进行扩展。其优势如下：</p>
<ol type="1">
<li><p>减少了 client 与 master 的交互次数，对同一个 chunk 的读取和写入只需要向 master 发出一个初始请求以获取 chunk location。</p>
<blockquote>
<p>这对于那些主要是按顺序读取和写入大文件的应用程序而言很有帮助。即使对于小的随机读取，client 也可以轻松地缓存多 TB 工作集的所有 chunk location。</p>
</blockquote></li>
<li><p>当增大 chunk size 时，client 更有可能将操作集中在同一 chunk 上，从而可以通过在较长时间内保持与 chunk server 的持久 TCP 连接来减少网络开销。</p></li>
<li><p>它减少了存储在 master 上的元数据的大小（chunk size 越小，同一 file name 映射到的 chunk set 容量也会越大），这允许我们将元数据保存在内存中。</p></li>
</ol>
<p>另一方面，如果许多 client 访问同一个文件，存储其 chunk 的 chunk server 可能会成为<strong>热点</strong>(hotspot)。</p>
<blockquote>
<p>现实中，hotspot 并不是一个主要问题，因为应用程序大多是按顺序读取大型多块文件。而当批处理队列系统使用 GFS 时，出现 hotspot 的问题：少数 chunk server 被数百个 client 同时请求，从而超载。可以通过以更高的复制因子存储此类文件，或者使批处理队列系统错开应用程序启动时间来解决此问题。另一个长期解决方案是允许 client 在这种情况下从其他 client 中读取数据。</p>
</blockquote>
<h4 id="元数据metadata">元数据(metadata)</h4>
<p>master 维护以下三种类型的 metadata：命名空间、从 file name 到 chunk ID 的映射以及 <strong>chunk 的当前位置</strong>(chunk location)。所有 metadata 都保存在 master 的内存中。前两种类型（名称和文件到块的映射）也通过将<strong>操作记录</strong>(operation log)存储到 master 的本地磁盘上并在远程机器上复制 log 来保证持久性。</p>
<blockquote>
<p>使用 log 可以简单、可靠地更新 master 状态，并且不会在 master 崩溃时遭遇不一致的风险。</p>
</blockquote>
<p>由于 metadata 存储在内存中，master 能实现很快的操作速度。而这种存储策略的一个潜在问题是，chunk 的数量以及整个系统的容量受到 master 内存大小的限制（然而这并不是一个严重的瓶颈）。master 为每个 64 MB chunk 维护少于 64 B 的 metadata。大多数 chunk 已满，只有最后一个可能未被完全使用。同样，每个文件的命名空间数据通常需要少于 64 B，因为它使用前缀压缩技术存储文件名。</p>
<blockquote>
<p>如果需要支持更大的文件系统，则需要向 master 添加额外内存，这与获得的好处相比代价非常小。</p>
</blockquote>
<h5 id="块位置chunk-location">块位置(chunk location)</h5>
<p>master 不会将哪些 chunk server 具有给定 chunk 的副本这一信息给持久化存储，而是在启动时轮询 chunk server 以获取该信息，之后定期通过 HeartBeat 请求数据，这使得 master 始终保持自己处于最新状态，且消除了在 chunk server 加入和离开集群、修改名称、失败、重新启动等时保持 master 和 chunk server 同步的问题——这要比将数据持久化到本地磁盘简单得多。</p>
<blockquote>
<p>在拥有大量服务器的集群中，这些事件经常发生。</p>
</blockquote>
<p>另一种理解思路是，chunk server 对它在本地磁盘上拥有哪些 chunk 拥有最终决定权。尝试在 master 上持久化此信息没有意义，因为 chunk server 上的一些故障可能会导致 chunk 失效（e.g，磁盘可能会损坏并被禁用）或者 chunk server 被重命名。</p>
<h5 id="操作日志operation-log">操作日志(operation log)</h5>
<p>operation log 存储对 metadata 修改的持久的历史记录，还用作定义并发操作顺序的逻辑时间线。它是 GFS 的核心。因此，需要对 operation log 进行可靠存储，并且在对 metadata 的修改被持久化之前不让修改对 client 可见。否则，即使 chunk 本身不发生故障，也会丢失整个文件系统或最近的 client 操作。</p>
<p>这一可靠存储的方法为，<strong>将其复制到多台远程机器上</strong>，并且只有在将相应的日志记录更新到本地和远程磁盘后才能响应 client 操作。master 在更新前将多个日志记录进行批处理，从而减少了更新和复制对整个系统吞吐量的影响。</p>
<p>重启后，master 可以通过重新实施 operation log 来恢复其文件系统状态。为了最小化启动时间，必须保持 log 很小。每当 log 超过一定大小时，master 都会检查其状态，以便它可以通过从本地磁盘加载最新的<strong>检查点</strong>(checkpoint)并仅重新实施之后有限数量的 log 记录。</p>
<blockquote>
<p>checkpoint 采用紧凑的 B 树形式，可以直接映射到内存并用于命名空间查找，无需额外解析。这进一步加快了恢复并提高了可用性。</p>
</blockquote>
<p>建立一个 checkpoint 需要一段时间，为了避免延缓传入的修改，master 可以通过切换到一个新的 log 文件并在一个单独的线程中创建新的 checkpoint。新的 checkpoint 包括切换之前的所有修改。完成后，它会同时写入本地和远程的磁盘。</p>
<p>只需要最新的完整 checkpoint 和存放后续 log 记录的文件即可进行系统恢复。旧的 checkpoint 和 log 文件可以删除，但也会保留一些以防止灾难发生。checkpoint 期间的失败不会影响正确性，因为恢复代码会检测并跳过不完整的 checkpoint。</p>
<h4 id="持久化模型">持久化模型</h4>
<p>GFS 有一个宽松的一致性模型，可以很好地支持这一高度分布式应用程序，且实现起来相对简单且高效。</p>
<h5 id="一致性保证">一致性保证</h5>
<p>文件命名空间的修改（如文件创建）是原子的，它们由 master 专门处理，并通过给命名空间加锁来保证原子性和正确性。master 的操作日志决定了这些操作的全局总顺序。数据修改后文件域的状态取决于修改的类型、成功或失败以及是否存在并发修改。下表总结了结果：</p>
<ol type="1">
<li>如果所有 client 能够始终看到相同的数据，无论他们从哪个副本中读取，则文件域是 <strong>consistent</strong> 的。</li>
<li>如果在文件数据修改之后是 consistent 的，并且 client 将看到该次修改完整写入的内容，则文件域是 <strong>defined</strong> 的。</li>
<li>当修改成功且不受并发写入者的干扰时，那么受影响的文件域是 <strong>defined</strong> 的（同时也为 consistent）。因为所有 client 将始终看到修改写入的内容。</li>
<li>并发成功的修改使文件域 <strong>undefined but consistent</strong>。虽然所有 client 都看到相同的数据，但它可能无法反映任何一个修改写入的内容，通常，它由来自多个修改的混合片段组成。</li>
<li>失败的修改使文件域变得 <strong>inconsistent</strong>（因此也 undefined）：不同的 client 可能在不同的时间看到不同的数据。</li>
</ol>
<p><img src="image-20220925205531561.png" alt="image-20220925205531561" style="zoom: 80%;" /></p>
<p>数据修改可能是 write（将数据写入应用程序指定的文件偏移处）或 record append（将数据在 GFS 选择的偏移处原子性地 append 至少一次，即便在存在并发修改的情况下，相反，常规追加只是在 client 认为是当前文件结尾的偏移处写入）。偏移量会被返回给 client 并在包含该记录的 defined 文件域的开始处做上标记。此外，GFS 可能会在其间插入填充或记录重复项。它们占据 inconsistent 的文件域，并且通常少于用户数据量。</p>
<p>在一系列成功的修改之后，经修改的文件域一定是 defined 的，并包含最后一个写入的数据。 GFS 通过</p>
<ol type="1">
<li>在 chunk 的所有副本上以相同的顺序对其应用修改；</li>
<li>使用 chunk 版本号</li>
</ol>
<p>来检测任何已经过时的副本——它在它的副本中因 chunk server 的关闭而错过了修改。过时的副本永远不会参与修改，也不会被提供给向 master 询问 chunk location 的 client，它们会马上被 garbage collect。</p>
<p>由于 client 会缓存 chunk location，故它们可能会在更新这一信息前从过时的副本中读取数据。这个窗口受限于缓存条目的超时和文件的下一次打开（这会从缓存中清除该文件所有 chunk 的信息）。</p>
<p>成功修改后，组件故障仍然会破坏数据。 GFS 通过 master 和所有 chunk server 之间的定期握手来识别失败的 chunk server，并通过校验和检测数据损坏。一旦出现问题，数据会尽快从有效的副本中恢复。只有在 GFS 能够做出反应之前（通常在几分钟内）丢失所有副本时，一个 chunk 才会不可逆地丢失。即使在这种情况下，它也变得不可用，而不是损坏——应用程序将收到明确的错误而不是损坏的数据。</p>
<h5 id="对应用的影响">对应用的影响</h5>
<p>GFS 应用程序可以通过一些已经被应用于其他目的的简单技术来适应宽松的一致性模型：依赖 append 而不是 overwrite 、checkpoint 和编写自我验证、自我识别的记录。</p>
<blockquote>
<p>在一个典型的应用场景中，Writer 自始至终只生成一个文件。它在写入所有数据后自动将文件重命名为永久名称，或者定期检查已成功写入的数据量。checkpoint 还可能包括应用程序级校验和。Reader 仅验证和处理直到最后一个 checkpoint 的文件域，该检查点已知处于 defined 状态。无论一致性和并发性问题如何，这种方法都很好地为我们服务。与随机写入相比，append 更有效且对应用程序故障更具弹性。checkpoint 允许 Writer 以增量方式重新启动，并阻止 Reader 处理成功写入的文件数据，这些数据从应用程序的角度来看仍然不完整。</p>
</blockquote>
<blockquote>
<p>在另一种典型应用场景中，许多 Writers 同时将数据 append 到文件以获取合并结果或作为生产者-消费者队列。record append 的 “append-at-least-once” 语义保留了每个 Writer 的输出。Reader 按如下方式处理偶尔的填充和重复：Writer 准备的每条记录都包含额外的信息（如校验和），以便验证其有效性。Reader 可以使用校验和识别和丢弃冗余的填充和记录片段。如果 Reader 不能容忍偶尔的重复（例如如果它们会触发非幂等操作），它可以使用记录中的唯一标识符将它们过滤掉，这通常是命名相应的应用程序实体（例如 Web 文档）所必需的。这些用于记录 I/O 的功能（重复 delete 除外）位于应用程序共享的库代码中，适用于 Google 的其他文件接口实现。这样，相同的记录序列（与偶尔的重复），总会被传递给 Reader 并做好记录。</p>
</blockquote>
<h3 id="系统交互">系统交互</h3>
<p>设计系统以尽量减少 master 在所有操作中的参与。</p>
<h4 id="租约和修改顺序">租约和修改顺序</h4>
<p>每个修改在所有块的副本上执行。我们使用<strong>租约</strong>(lease)来保持副本之间一致的修改顺序。master 向其中一个副本授予 lease，我们将其称为 primary。primary 指定对 chunk 的所有修改的序列顺序。应用修改时，所有副本都遵循此顺序。</p>
<blockquote>
<p>全局修改顺序首先由 master 选择的 lease 授予顺序决定；而对于每段 lease 时间，则由相应 primary 分配的序列号定义。</p>
</blockquote>
<p>lease 机制旨在最大限度地减少 master 的管理开销。lease 的初始超时时间为 60 s。然而，只要 chunk 被改变，primary 就可以无限期地向 master 请求并得到续期授予。这些续期请求和授权被搭载在 master 和所有 chunk server 之间定期交换的 HeartBeat 消息上。 master 有时可能会在 lease 到期之前尝试撤销 lease（例如，当 master 想要禁用正在重命名的文件上的修改时）。即使 master 失去与 primary 的通信，它也可以在旧 lease 到期后将新 lease 授予另一个副本。这一机制总体流程如下：</p>
<ol type="1">
<li>client 询问 master 哪个 chunk server 持有该 chunk 的当前 lease 以及其他副本的位置。如果没有 server 拥有 lease，则 master 将 lease 授予它选择的副本；</li>
<li>master 回复 primary 的身份和其他副本(secondary)的位置。client 缓存此数据以备未来可能的修改。只有在 primary 变得无法访问或回复它不再持有 lease 的时候才需要再次联系 master；</li>
<li>client 将数据按任何顺序推送到所有副本。每个 chunk server 都会将数据存储在内部 LRU 缓冲区缓存中，直到数据被使用或过期。通过将数据流与控制流解耦，可以通过基于网络拓扑调度昂贵的数据流来提高性能，而不用管 primary 是谁；</li>
<li>一旦所有副本都确认接收到数据，client 向 primary 发送请求。该请求标识了之前推送的数据。primary 将连续的序列号分配给它接收到的所有修改，可能来自多个 client，这提供了必要的序列化。它按序列号顺序将修改应用于自己的本地状态；</li>
<li>primary 将写请求转发给所有 secondary。每个 secondary 按照 primary 分配的相同序列号顺序应用修改；</li>
<li>secondary 回复 primary 操作完成；</li>
<li>primary 回复 client。在任何副本中遇到的任何错误都会报告给 client。如果出现错误，写入可能在 primary 和 secondary 的任意子集上成功（如果在 primary 上失败，则不会分配序列号并转发），client 请求被认为失败，修改区域处于 inconsistent 状态。client 通过重试失败的修改来处理此类错误。它重复进行步骤 (3) 到 (7)，然后从写入开始重新尝试。</li>
</ol>
<p><img src="image-20220926105829428.png" alt="image-20220926105829428" style="zoom:80%;" /></p>
<blockquote>
<p>如果应用程序单次写入的数据量很大甚至跨越多个 chunk，client 会将其分解为多个写入操作。它们都遵循上述控制流程，但可能与来自其他 client 的并发操作交错而被覆盖。因此，共享文件域最终可能包含来自不同 client 的片段（尽管副本因各个操作在所有副本上以相同的顺序成功完成而最终一致），这使文件域处于 consistent but undefined 的状态。</p>
</blockquote>
<h4 id="数据流">数据流</h4>
<p>我们的目标是充分利用每台机器的网络带宽，避免网络瓶颈和高延迟链接，并最大限度地减少推送所有数据的延迟。</p>
<ol type="1">
<li><p>将数据流与控制流分离，以有效地使用网络。虽然控制从 client 流向 primary，然后流向所有 secondary，但数据以流水线方式沿 chunk server 链线性推送，因此，每台机器的全部出站带宽都用于尽可能快地传输数据，而不是在多个接收者之间分配。</p></li>
<li><p>为了尽可能避免网络瓶颈和高延迟链路（例如，交换机间链路通常两者兼有），每台机器将数据转发到网络拓扑中尚未收到数据的“最近”机器。</p>
<blockquote>
<p>假设 client 正在将数据推送到 chunk server S1 到 S4。它将数据发送到最近的 chunk server，比如 S1。S1 通过最接近 S1 的 S4 将其转发到最近的 chunk server S2，例如 S2。同样，S2 将其转发到 S3 或 S4，以更接近 S2 的为准，依此类推。GFS 的网络拓扑结构非常简单，可以根据 IP 地址准确估计“距离”。</p>
</blockquote></li>
<li><p>通过 TCP 连接上的数据传输流水线来最小化延迟。一旦 chunk server 接收到一些数据，它就会立即开始转发。流水线对我们特别有帮助，因为我们使用具有全双工链路的交换网络，立即发送数据不会降低接收速率。</p>
<blockquote>
<p>在没有网络拥塞的情况下，将 B 个字节传输到 R 个副本的理想经过时间是 B/T + RL，其中 T 是网络吞吐量，L 是在两台机器之间传输字节的延迟。我们的网络链接通常为 100 Mbps (T)，而 L 远低于 1 ms。因此，理想情况下，1 MB 可以在大约 80 毫秒内分配。</p>
</blockquote></li>
</ol>
<h4 id="原子性的-record-append">原子性的 record append</h4>
<p>GFS 提供了一种称为 record append 的原子性的追加操作。在传统的写入中，client 指定要写入数据的位置。对同一文件域的并发写入不可序列化：该区域最终可能包含来自多个 client 的数据片段。然而，在记录追加中，client 仅指定数据， GFS 在其选择的一组偏移处原子性地（即作为一个连续的字节序列）将其 append 到文件中至少一次，并将偏移返回给 client。</p>
<p>GFS 的分布式应用程序会大量使用 record append，可能有许多 client 同时将数据 append 到同一个文件。如果此时 client 使用传统写入的策略，将需要额外的复杂且昂贵的同步（例如通过分布式锁管理器）。</p>
<p>record append 是一种修改，故遵循之前提到的控制流程。client 将数据推送到文件最后一个 chunk 的所有副本，然后，它将请求发送到 primary。primary 检查将记录附加到当前 chunk 是否会导致其超过最大大小（64 MB）。</p>
<ol type="1">
<li>如果是这样，它将当前 chunk 填充到最大大小，告诉 secondary 也这样做，并回复 client 指示应该在下一个 chunk 上重试该操作 （记录追加被限制为最大块大小的四分之一，以将最坏情况的碎片保持在可接受的水平）；</li>
<li>如果 append 后不超过最大大小，primary 将数据追加到它的副本，并告诉 secondary 在相应偏移处写入数据，最后向 client 回复成功。</li>
</ol>
<p>如果任何副本的操作失败，client 会重试该操作。最终，同一 chunk 的副本可能包含不同的数据，可能包括全部或部分相同记录的副本。 GFS 不保证所有副本在字节上都是相同的。它只保证数据作为一个原子单元至少被写入一次，且为了报告成功的操作，数据必须在某个 chunk 的所有副本上以相同的偏移量写入。此外，所有副本至少与记录结尾一样长，因此任何未来的记录都将被分配更高的偏移或不同的 chunk（即使不同的副本后来成为 primary）。就一致性保证而言，成功的记录追加操作写入数据的区域是 defined 的，而中间区域是 undefined 的（该 chunk 在某一偏移量处并未写入，此时向 client 返回失败，client 重试该操作）。</p>
<h4 id="快照snapshot">快照(snapshot)</h4>
<p>snapshot 操作能够快速生成文件或目录树的副本，同时最大限度地减少正在进行的修改的任何中断。可以使用它来快速创建庞大数据集的分支副本，或者在尝试（未来会被提交或回滚的）更改之前检查当前状态。</p>
<p>与 AFS 一样，GFS 使用标准的<strong>写时复制技术</strong>来实现 snapshot。当 master 收到一个 snapshot 请求时，它首先撤销它要执行 snapshot 的文件中的 chunks 的所有未到期的 lease。这确保了对这些 chunks 的任何后续写入都需要先与 master 交互以找到 lease 持有者。从而 master 能首先创建 chunk 的新副本。</p>
<p>在 lease 被撤销或到期后，master 将操作记录到磁盘。然后，它通过复制源文件或目录树的元数据将此日志记录应用于其内存状态。新创建的 snapshot 文件指向与源文件相同的 chunk。</p>
<p>client 在 snapshot 操作后第一次想要写入 chunk C 时，它会向 master 发送请求以查找当前的 lease 持有者。primary 注意到 C 的引用计数大于 1。它将推迟回复 client 请求，转而选择一个新的 chunk handle C'。然后它要求每个拥有 C 的当前副本的 chunk server 创建一个名为 C' 的新 chunk。通过在与原始 chunk server 相同数据的 chunk server 上创建新 chunk，我们确保数据可以在本地复制，而不是通过网络复制（我们的磁盘大约是 100 Mb 以太网链路的三倍）。从这一点来看，请求处理与任何 chunk 的处理没有什么不同：master 授予其中一个副本对 C' 的 lease 并回复 client，client 接着正常写入 C'。</p>
<h3 id="master-操作">master 操作</h3>
<p>master 执行所有的命名空间操作。此外，它管理整个系统的 chunk 副本：如做出 chunk 副本放置决策、创建新 chunk 与其副本、协调各种系统范围的活动以保持 chunk 完全复制、平衡 chunk server 的负载、回收未使用的存储空间。</p>
<h4 id="命名空间管理和锁定">命名空间管理和锁定</h4>
<p>许多 master 操作可能需要很长时间：例如，snapshot 操作必须撤销该 snapshot 覆盖的所有 chunk 上的 lease。我们不想在其他 master 操作运行时延迟它们。因此，我们允许多个操作处于活动状态，并在命名空间的区域上使用锁以确保正确的序列化。</p>
<p>与许多传统文件系统不同，GFS 没有列出该目录中所有文件的逐目录数据结构，也不支持同一文件或目录的别名（有点像 Unix 中的硬链接或符号链接）。 GFS 在逻辑上将其命名空间表示为将完整路径名映射到 metadata 的查找表，并采用前缀压缩技术。命名空间树中的每个节点（绝对文件名或绝对目录名）都有一个关联的读写锁。</p>
<p>每个 master 操作在运行之前都会获取一组锁。通常，如果它涉及 /d1/d2/.../dn/leaf ，它将获取 leaf 路径上所有目录的读锁，以及其上的读锁或写锁（leaf 可能是文件或目录，具体取决于操作）。</p>
<blockquote>
<p>接下来说明这种锁定策略如何防止在 /home/user 被 snapshot 到 /save/user 时创建文件 /home/user/foo：snapshot 操作在 /home 和 /save 上获取读锁，并在 /home/user 和 /save/user 上获取写锁；文件创建在 /home 和 /home/user 上获得读锁，在 /home/user/foo 上获得写锁。这两个操作将被正确序列化，因为它们试图在 /home/user 上获得冲突的锁。文件创建不需要父目录上的写锁，因为没有“目录”或类似 inode 的数据结构可以防止修改，其上的读锁足以保护父目录不被删除。</p>
</blockquote>
<p>这种锁定策略的一个很好的特性是它允许在同一目录中进行并发修改。例如，可以在同一个目录中同时执行多个文件创建：每个文件都获取路径上父目录的读锁和该文件上的写锁。目录路径上的读锁足以防止目录被 delete、rename 或 snapshot；文件上的写锁对重复创建同名文件的操作进行序列化（从而避免这种操作的实现）。</p>
<p>命名空间可以有很多节点，读写锁对象被延迟分配，一旦不使用就被删除。此外，为防止死锁，锁以一定顺序获取：首先按命名空间树中的级别排序，若级别相同，则按字典序。</p>
<h4 id="副本放置">副本放置</h4>
<p>GFS 集群为多级别的高度分布，这要求分布数据具有良好的可扩展性、可靠性与可用性。副本放置策略应最大化数据可靠性和可用性，以及最大化网络带宽利用率，为做到这一点，必须跨机架分布 chunk 副本，这能确保在整个机架损坏或脱机的情况下，chunk 的某些副本仍在其它机架上存活并保持可用，同时读取 chunk 可以利用多个机架的聚合带宽。同样的，对 chunk 的写入也必须流经多个机架——这是一种 trade-off。</p>
<h4 id="创建create">创建(create)</h4>
<p>当 master 创建一个 chunk 时，会这样考虑：</p>
<ol type="1">
<li>为了均衡跨 chunk server 的磁盘利用率，希望将新副本放置在磁盘空间利用率低于平均水平的 chunk server 上；</li>
<li>希望限制每个 chunk server 上“最近”创建的副本数量，因为 chunk 是在写入需要时创建的，而在 append-once-read-many 工作负载中，其通常在完全写入后就变为只读；</li>
<li>希望将 chunk 副本分布在不同机架上。</li>
</ol>
<h4 id="再复制re-replicate">再复制(re-Replicate)</h4>
<p>当 chunk server 不可用、报告其副本可能已损坏、其中一个磁盘由于错误而变得不可用、复制目标增加时，都可能会导致可用副本的数量低于用户指定的数量，此时 master 会再复制一个 chunk。每个需要再复制的 chunk 都会根据几个因素进行优先级排序：</p>
<ol type="1">
<li>一是它离复制目标的距离有多远，比如丢失两个副本的 chunk 比只丢失一个副本的 chunk 拥有更高优先级；</li>
<li>二是 chunk 的活跃程度，我们更愿意再复制活跃文件的 chunk 而非最近被删除的文件的 chunk；</li>
<li>三是对于任何阻塞 client 进度的 chunk，其再复制优先级都会得到提升，以最大程度减少故障对应用程序的影响。</li>
</ol>
<p>在分配完优先级后，master 选择最高优先级的 chunk 并指示那些 chunk server 从有效的副本上进行复制，新副本的放置目标与创建目标相似：均衡磁盘利用率、限制单个 chunk server 上的操作以及跨机架分布副本。</p>
<h4 id="再平衡re-balance">再平衡(re-Balance)</h4>
<p>master 周期性地再平衡副本：检查当前副本分布并将其移动，以获得更好的磁盘空间和负载均衡。master 通过这一流程来逐渐填满新的 chunk server，而非用新的 chunk 和后续的写入。新副本的放置目标同上。此外，master 必须选择一些现有副本进行删除——它更偏向选择在可用空间低于平均水平的 chunk server 上的那些副本，以均衡磁盘空间利用率。</p>
<h4 id="垃圾回收garbage-collection">垃圾回收(garbage collection)</h4>
<p>文件被删除后，GFS 并<strong>不会立即回收内存</strong>，而是在文件和 chunk 级别的常规 gc 期间懒惰地回收。这样做的优点在于：</p>
<ol type="1">
<li>它在组件故障很常见的大规模分布式系统中简单可靠。chunk 的创建不一定在所有 chunk server 上成功，留下 master 不知道其存在的副本。而 gc 策略能够有效清理任何不知道是否有用的副本。</li>
<li>它将存储回收合并到 master 的常规后台活动中，如定期扫描命名空间和与 chunk server 的握手，因此它是分批完成的，能够摊销成本。而且这些活动仅在 master 空闲时进行——master 能更迅速响应需要及时关注的 client 请求。</li>
<li>存储回收的延迟提供了防止意外与不可逆删除的安全网。</li>
</ol>
<p>而其主要缺点是该延迟有时会阻碍用户在磁盘空间紧张时的使用。重复创建和删除临时文件的应用程序可能无法立即对原先空间进行重用。</p>
<p>如果删除的文件再次被显示删除，GFS 可以通过加快存储回收来解决这一问题。同时，GFS 允许用户对命名空间的不同部分应用不同的复制和回收策略。</p>
<h5 id="机制">机制</h5>
<p>应用程序删除文件后，master 会立即记录下来，但不立即回收资源，而是将其重命名为包含删除时间戳的隐藏名称。在 master 对命名空间定期扫描期间，若这些文件已存在超过一定时间，则会将其删除（在此之前其仍然可以在新的特殊名称下读取，并且可以通过将其重命名为正常名称来取消删除）。删除文件时，其内存中的 metadata 也将被删除。master 定期扫描期间，也会识别那些无法从任何文件访问的 chunk 并将其 metadata 擦除。在与 master 定期交换的 HeartBeat 消息中，每个 chunk server 报告其拥有的 chunk 的一个子集，并且 master 回复子集中所有不再存在于其 metadata 中的 chunk（根据文件到 chunk 的映射表），以便 chunk server 自由删除这些 chunk 的副本。</p>
<h4 id="旧副本检测">旧副本检测</h4>
<p>如果 chunk server 发生故障，并且在 chunk 关闭前未能及时对其进行修改，该 chunk 副本可能会变旧。master 为每个 chunk 维护一个版本号来区分是新副本还是旧副本。</p>
<p>每当 master 授予 lease 时，它会增加对应 chunk 的版本号并通知最新的副本。master 和这些副本都将最新的版本号持久化记录下来。如果一个副本不可用，则其版本号不会增加（也就是会变旧）。当 chunk server 重启并报告 master 其 chunk 子集及其版本号时，master 能够检测出旧的副本，并将更高的版本作为最新版本，这些旧的副本会在 gc 期间被删除。而当回复 client 的请求时，会将旧副本视为不存在。</p>
<p>当 master 通知 client 哪个 chunk server 拥有 lease 时，或当其只是一个 chunk server 在复制操作中从另一个 chunk server 读取该 chunk 时，会包含该 chunk 的版本号，client 或 chunk server 在执行操作时验证版本号，以便始终访问最新数据。</p>
<h3 id="容错与诊断">容错与诊断</h3>
<h4 id="高可用性">高可用性</h4>
<p>在 GFS 集群的服务器中，在任意给定时间内必然存在一些服务器不可用。以下两种策略来保证系统的高可用性。</p>
<h5 id="快速恢复">快速恢复</h5>
<p>master 和 chunk server 都会恢复其状态并在几秒钟内启动，无论它们是如何终止的。</p>
<h5 id="chunk-复制">chunk 复制</h5>
<p>每个 chunk 被复制到不同机架的多个 chunk server 上。master 根据需要复制副本，以在 chunk server 离线或通过校验和验证检测损坏的副本时保持每个 chunk 的完全复制。</p>
<h5 id="master-复制">master 复制</h5>
<p>为了可靠性，需要进行 master 状态的复制。其操作日志和 checkpoint 被复制到多台机器上，只有将其日志记录更新到本地磁盘和所有 master 副本上后，才会认为状态的修改已提交。简单起见，master 通过一个主进程负责所有修改以及后台活动，当其失败时也能立即重启。若机器或磁盘发生故障，GFS 的外部设备会在其他地方启动一个新的主进程。</p>
<p>此外，“shadow” master 提供对文件系统的只读访问，即便在 master 关闭期间。它们并非 master 的完全镜像，因为这些 shadow 的状态可能会稍微滞后于 master。事实上，client 读取的是存放在 chunk server 上的 chunk 内容，因此这一滞后并不会对结果产生多大影响。在这短时间内过时的可能是文件 metadata，如目录内容或访问控制信息。</p>
<p>为了让自己了解情况，shadow 读取操作日志的副本，并将其以与 master 完全相同的顺序执行应用。与 master 一样，它在启动时轮询 chunk server 以定位 chunk 副本并频繁与它们交换握手信息以监视其状态。shadow 对副本位置的更新仅依赖于 master 执行创建或删除副本决策所产生的结果。</p>
<h4 id="数据完整性">数据完整性</h4>
<p>每个 chunk server 使用校验和来检测存储数据的损坏与否。我们可以利用其他 chunk 副本从损坏中恢复，但不能通过与其它 chunk server 的副本进行对比来检测损坏。比如前文提到的原子 record append 并不能保证两个 chunk 副本完全相同。因此，每个 chunk server 必须通过维护校验和来独立验证自己副本的完整性。</p>
<blockquote>
<p>一个 chunk 会被分为若干 64 KB 大小的 block，每个 block 都有 32 位校验和，保存在内存中，并与日志记录一起持久化存储。</p>
</blockquote>
<p>对于读取，chunk server 会在返回数据前，验证与读取范围重叠的 block 的校验和，故不会讲损坏传播到其它机器。若一个 block 与记录的校验和不匹配，chunk server 会向请求者返回一个 error，并将不匹配的情况报告给 master。同时，请求者将从其他副本读取，而 master 从另一个副本处克隆该 block。在一个有效的新副本就位后，master 命令报告不匹配的 chunk server 删除其副本。</p>
<p>事实上，校验和几乎不会对读取性能产生影响。我们只需要读取并对少量额外数据的校验和进行验证。GFS client 通过尝试在校验和 block 边界对齐读取来进一步减少开销。并且校验和计算通常可以和 I/O 重叠。</p>
<p>对于 append，只是增量更新了最后一个 block 部分的校验和，并为新的 block 计算了新的校验和。即使最后一个 block 已损坏且无法被检测，新的校验和值也不会和存储的数据匹配，并且在下次读取时也会被检测到。</p>
<p>对于写入，如果覆盖了 chunk 的现有范围，则必须读取并验证被覆盖范围的第一个和最后一个 chunk，然后执行写入，最后计算并记录新的校验和。如果不验证被覆盖范围的第一个和最后一个 chunk，新的校验和可能会将未覆盖区域中存在的损坏给隐藏。</p>
<p>chunk server 会在空闲期间扫描和验证不活跃 chunk 的内容，一旦检测到损坏，master 可以创建新副本并删除损坏副本。</p>
<h3 id="诊断工具">诊断工具</h3>
<p>GFS 会生成诊断日志，记录重要事件以及所有 RPC 请求和恢复。这些日志可以任意删除且不会影响系统正确性，但应尽量保留。</p>
<p>RPC 日志包括请求和响应，但不包括正在读取或写入的文件数据。通过整理 RPC 日志，可以重建整个交互历史，从而进行问题诊断。日志也可以用于负载测试和性能分析。</p>
<p>由于这些日志是按顺序异步写入，因此性能影响很小。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Aurora</title>
    <url>/6-824/aurora/</url>
    <content><![CDATA[<p>6.824 的第六篇论文是 Aurora——一个高性能，高可靠的关系数据库服务。在处理事务的速度上，Aurora 宣称比其他数据库快 35 倍。同时，其完全抛弃了通用存储，转而构建了自己<strong>应用定制的存储</strong>。</p>
<span id="more"></span>
<h4 id="aurora-产生背景">Aurora 产生背景</h4>
<h5 id="ec2elastic-cloud-2">EC2(Elastic Cloud 2)</h5>
<p>这是 Amazon 最早的云产品。Amazon 有装满了服务器的数据中心，并且每个服务器上都会运行一个 VMM(<strong>Virtual Machine Monitor</strong>)，以及一些 EC2 实例。每个实例在运行一个标准的操作系统的同时，出租给不同的用户。每个 EC2 的操作系统之上运行着 Web 服务或数据库等应用程序。这种方式成本低，且相对容易配置，在早期是一个成功的服务模式。</p>
<p>最早的时候，EC2 使用的都是服务器上的硬盘，每个 EC2 实例都会分到硬盘的一部分空间。</p>
<p>对于无状态的 Web 应用，如果客户数量增加了，可以通过租用更多 EC2 实例来对 Web 服务扩容，尽管服务器崩溃了，只需要在另一台服务器上启动一个新的 EC2 实例就好了。而对于数据库而言，一旦服务器崩溃了，其本地硬盘将无法访问，运行在服务器上的数据库 EC2 实例也将失效——因为数据丢失了。</p>
<p>Amazon 本身有实现块存储的服务，叫 S3。可以定期对数据库做快照，然后存到 S3 上，并基于快照来实现故障恢复。但也有可能失去两次快照之间的数据，</p>
<h5 id="ebselastic-block-store">EBS(Elastic Block Store)</h5>
<p>它表现得像个硬盘，具有容错性，且支持持久化存储的服务，其底层是一对互为副本的存储服务器。当用户要使用数据库 EC2 时，可以将一个 EBS 挂载为自己的硬盘。</p>
<p>当数据库执行写操作时，数据会通过网络传输到 EBS 服务器，之后，那一对存储服务器会使用 <strong>Chain Replication</strong> 进行数据复制。</p>
<blockquote>
<p>第一个服务器处理写，第二个服务器处理读。</p>
</blockquote>
<p>虽然 EBS 的出现能够在一定程度上避免因服务器崩溃而导致的数据丢失，但却会产生大量的网络流量，并且容错性并没有得到很好的保障——两个存储服务器会放在同个数据中心（在 paper 中称为 <strong>AZ, Available Zone</strong>）中，也就意味着一旦数据中心崩溃了，那就没辙了。</p>
<h5 id="rdsrelational-database-service">RDS(Relational Database Service)</h5>
<p>RDS 尝试将数据进行跨 AZ 复制，这样就算整个 AZ 挂了，用户还可以从另一个 AZ 中获取数据。</p>
<p>对于 RDS 而言，有且仅有一个 EC2 实例作为<strong>主数据库</strong>，这个数据库将其 data page 和 WAL log 存在 EBS，EC2 和 EBS 都在同一个 AZ <span class="math inline">\(AZ_1\)</span> 中。每次数据库执行写操作时，RDS 会自动将写操作拷贝到另一个 AZ <span class="math inline">\(AZ_2\)</span> 中的<strong>副数据库</strong> EC2 实例上，这个 EC2 的工作就是执行和主数据库相同的操作，写入成功后，会发一个 ack 给主数据库，主数据库看到了这个 ack 后才会认为真正意义上的写入成功。</p>
<p>但实际上，这样还是会通过网络传输相当大量的数据。</p>
<h4 id="aurora">Aurora</h4>
<p>在 Aurora 的架构中，会有 <span class="math inline">\(V\)</span> 个数据副本代替 EBS 的位置，分别存放在 <span class="math inline">\(z\)</span> 个不同的 AZ 中。与此同时，Aurora 通过网络传输的是 <strong>log 条目</strong>而非 data page，这也大大提高了网络性能。当然，这也就导致了 Aurora 的存储系统不再是只能理解 data 的通用存储了，变成了<strong>能够理解 log 的应用定制存储系统</strong>。</p>
<h5 id="复制与相关故障">复制与相关故障</h5>
<p>Aurora 采用<strong>基于仲裁的投票协议</strong>来保证容错，即不需要所有副本都确认了读/写操作后才能继续执行。这个协议是这样的：</p>
<ol type="1">
<li>每次读操作都需要获得 <span class="math inline">\(V_r\)</span> 个确认；</li>
<li>每次写操作都需要获得 <span class="math inline">\(V_w\)</span> 个确认；</li>
<li><span class="math inline">\(V_r + V_w &gt; V\)</span>，保证每次读都能知道最近的写入；</li>
<li><span class="math inline">\(V_w &gt; V/2\)</span>，保证每次写入必须知道最近的写入从而避免写入冲突；</li>
</ol>
<p>这样一来，Aurora 可以有更多的副本和 AZ，而不需要付出过大的性能代价——因为它无需等待所有副本，只需要等待最快的 <span class="math inline">\(V_r/V_w\)</span> 个副本就好了。这也容忍了少数副本的 crash 或是偶尔的慢响应。</p>
<p>这里又会出现一个问题，客户端读请求可能会得到 <span class="math inline">\(V_r\)</span> 个不同的结果，却并不知道哪个结果是正确的。解决这一问题的方法就是设置<strong>版本号</strong>，每次写请求都会将新的数值与一个递增的版本号绑定，于是读请求便可以从所有结果中取版本号最高的那个结果。</p>
<h5 id="容错目标">容错目标</h5>
<p>在 Aurora 中，我们希望</p>
<ul>
<li>在整个 AZ 和一个额外的副本崩溃后而不丢失数据；</li>
<li>整个 AZ 崩溃后不会影响写入数据；</li>
</ul>
<p>于是设置 <span class="math inline">\(V = 6,\ V_w = 4,\ V_r = 3,\ z = 3\)</span>，这样每个 AZ 存放 2 个副本。在这样的设置下，一个 AZ 和一个副本崩溃不会影响读性能，且任意两个副本崩溃后也能保持写入可用性。</p>
<h5 id="数据分片sharding">数据分片(Sharding)</h5>
<p>对于 Aurora 而言，每个副本都是一个计算机，其内存是有限的，且尽管我们有 6 个副本，我们并没有得到 6 倍大小的内存——每个副本上存放的数据都是一致的。对于数百 TB 甚至更多的数据，需要找一个明智的策略进行存储。</p>
<p>这一策略是：将数据库的数据，分割到多组(<strong>PG, Protection Group</strong>)存储服务器上，每一个 PG 都包含若干存储服务器作为副本，存该 data page 10GB 的数据。</p>
<blockquote>
<p>这里的 PG 是个<strong>逻辑概念</strong>。</p>
</blockquote>
<p>Sharding 后，如果要进行 log 处理，则会查看 log 所修改的数据，并找到存储该数据的 PG，并将 log 只发送给该 PG 的副本。这也就意味着，每个 PG 只存储部分 data page 和所有与这些 data page 相关的 log 条目。</p>
<p>如果某个副本挂了，希望能尽快生成新的副本。事实上，尽管每个 PG 存了某个数据库的 10GB 数据，但一个副本所拥有的存储容量可能高达 10TB，也就是说该副本可能存了成百上千个 PG 的“10GB”，一旦该副本挂了，会牵连到与之相关的所有数据库。一个简单的策略是找到另一台存储服务器，通过拷贝的形式将该副本的所有数据都通过网络传输到新的副本中，但对于 10Gb/s 的网络来说，需要的时间还是太久了。</p>
<p>Aurora 是这么做的：若某个副本保存了 <span class="math inline">\(PG_1,\ PG_2,\ \dots,\ PG_n\)</span> 的数据，则将这 <span class="math inline">\(n\)</span> 个 PG 的数据并行传输到 <span class="math inline">\(n\)</span> 个新的存储服务器上。也就是说这 <span class="math inline">\(n\)</span> 个存储服务器，每个都会加入到一个新的 PG 中。比起上面的策略，我们获得了 <span class="math inline">\(n\)</span> 倍的性能提升。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Spanner</title>
    <url>/6-824/Spanner/</url>
    <content><![CDATA[<p>6.824 的第七篇论文是 <strong>Spanner</strong>—— Google 的可扩展、多版本、全球分布和同步复制的数据库。它是第一个在全球范围内分发数据并支持外部一致的分布式事务的系统。</p>
<span id="more"></span>
<h4 id="简介">简介</h4>
<p>Spanner 中的数据是<strong>多时间版本化</strong>的，每个版本都会自动加上其提交时间的<strong>时间戳</strong>(timestamp)。ts 反映序列化顺序，即：如果事务 <span class="math inline">\(T_1\)</span> 在另一个事务 <span class="math inline">\(T_2\)</span> 开始之前提交，则 <span class="math inline">\(T_1\)</span> 的 commit ts 小于 <span class="math inline">\(T_2\)</span>。 这一机制归功于 <strong>TrueTime API </strong> 设计，通过使用多个现代时钟参考（GPS 和原子钟）来保持较小的不确定性。</p>
<blockquote>
<p>Spanner 是第一个在全球范围内提供此类保证的系统。</p>
</blockquote>
<p>作为一个全球分布的数据库，Spanner 不仅提供了以下特性：</p>
<ol type="1">
<li>数据的复制配置可以由应用程序动态控制；</li>
<li>应用程序可以指定哪些 data center 包含哪些数据、数据与用户之间的距离（以控制读取延迟）、副本之间的距离（以控制写入延迟）以及维护的副本数量（以控制持久性、可用性和读取性能）</li>
<li>Spanner 支持跨机器重新<strong>分片</strong>(Sharding)数据，并且能在 data center 之间动态移动数据，以平衡负载。</li>
</ol>
<p>还提供了两个在分布式数据库中难以实现的特性：</p>
<ol type="1">
<li>满足<strong>外部一致性</strong>的读取和写入；</li>
<li>利用 <strong>TrueTime</strong> 实现基于 ts 的跨数据库的全局一致读取。</li>
</ol>
<h4 id="实现">实现</h4>
<p>Spanner 部署称之为 <strong>universe</strong>，它由一系列<strong>区域</strong>(zones)组成，每个 zone 都是管理部署的单位。一个 zone 有一个 <strong>zonemaster</strong> 和若干 <strong>spanservers</strong>，前者负责将数据分配给后者，后者负责向客户提供数据。其结构如图所示：</p>
<p><img src="image-20221015173114863.png" alt="image-20221015173114863" style="zoom:80%;" /></p>
<h5 id="spanserver-软件栈结构">SpanServer 软件栈结构</h5>
<p>每个 spanserver 在底层负责若干个称为 <strong>tablet</strong> 的数据结构实例，每个 tablet 是表中的部分数据。</p>
<p>spanserver 采用 <strong>Paxos</strong> 协议来实现复制。为了提高 Paxos 算法的性能，他们并不是将整个机器作为 Paxos 的处理单位，而是将 spanserver 上的数据进行划分，并分配到不同的 Paxos Group，每次运行 Paxos 都仅由相关的 Paxos Group 参与。写操作必须发给 Leader，而读操作可以发给任意足够 up-to-date 的 replica 然后从其 tablet 中读取。</p>
<p><img src="image-20221016231043963.png" alt="image-20221016231043963" style="zoom:50%;" /></p>
<p>所有这些都在一个名为 <strong>Colossus</strong> 的分布式文件系统上。如图所示：</p>
<p><img src="image-20221016161752140.png" alt="image-20221016161752140" style="zoom:67%;" /></p>
<blockquote>
<p>当前的 Spanner 实现会对每个 Paxos 写入进行两次记录：一次在 tablet 的日志中，一次在 Paxos 日志中。</p>
</blockquote>
<p>spanserver 中会有一个 longlive 的 <strong>Leader</strong>，它拥有</p>
<ol type="1">
<li>一个<strong>锁表</strong>(lock table)来实现并发控制。锁表用于<strong>两阶段锁定</strong>(2PL)。只有需要同步的操作才会获取锁。</li>
<li>一个<strong>事务管理器</strong>(transaction manager)来支持分布式事务。只有当一个事务涉及多个 Paxos Group 时，事务管理器才参与其中，其中一个 Paxos Group 被选为<strong>协调者</strong>(coordinator)，该组的 <strong>participant Leader</strong> 将成为 <strong>coordinate Leader</strong>。每个事务管理器的状态存储在底层 Paxos Group 中（因此也会被复制）。</li>
</ol>
<h5 id="目录">目录</h5>
<p>为了进一步提高性能，将 Paxos Group 进一步划分为<strong>目录</strong>(Directory)——它是一组<strong>共享公共连续前缀</strong>的键。Directory 是数据迁移和负载均衡的基本单位，其所有数据都具有相同的复制配置。如下图所示。</p>
<blockquote>
<p>事实上，Spanner 会将一个过大的目录分片成多个<strong>片段</strong>（片段可能来自不同的 Paxos 组）。 Movedir 在组间移动片段，而不是整个目录。</p>
</blockquote>
<p><img src="image-20221016170724711.png" alt="image-20221016170724711" style="zoom:70%;" /></p>
<p><strong>Movedir</strong> 是用于在 Paxos 组之间移动目录以及向 Paxos 组添加或删除副本的后台任务。Movedir 并不作为单个事务实现，操作的时候是先将实际数据移动到指定位置，然后再用一个原子的操作更新元数据，完成整个移动过程。故 Movdir 不会阻塞当前 client 的操作。</p>
<h5 id="数据模型">数据模型</h5>
<p>Spanner 从原先 BigTable 的类关系型数据库变成了采用以下键值映射的类 KV 型数据库： <span class="math display">\[
(key:string,\quad timestamp:int64) \rightarrow string
\]</span> 同时 Spanner 向应用程序提供</p>
<ul>
<li>基于模式化半关系表的数据模型</li>
<li>查询语言</li>
<li>通用事务</li>
</ul>
<p><strong>Megastore</strong>支持模式化半关系表和同步复制的需求，它的数据模型更易于管理，而且支持跨 data center 的同步复制，Bigtable 仅支持跨 data center 的最终一致性复制。</p>
<p>Spanner 的数据模型是<strong>半关系</strong>的原因在于，每个表都需要有一组有序的 primary key。这使得 Spanner 仍然看起来像 KV 存储。</p>
<p>下图包含一个示例 Spanner 模式。客户端应用程序通过 <code>INTERLEAVE IN</code> 声明层次结构。<code>ON DELETE CASCADE</code> 表示删除目录表中的行会删除任何关联的子行。这种将表交错形成目录的设计允许客户端描述存在于多个表之间的局部关系，这能够提升分片分布式数据库的性能。</p>
<p><img src="image-20221017112002830.png" alt="image-20221017112002830" style="zoom:67%;" /></p>
<h4 id="truetime">TrueTime</h4>
<p>考虑到时间不确定性（如通信延迟），<strong>TrueTime</strong>并不表示某一特定时刻，而是将时间表示为一个具有有限时间不确定性的时间区间 <strong>TTinterval: [earliest, latest]</strong>。 TTinterval 的端点是 <strong>TTstamp</strong> 类型。 TrueTime API 包括以下方法：</p>
<ol type="1">
<li><strong>TT.now()</strong>：返回 TTinterval，并保证调用该方法的绝对时刻属于该区间；</li>
<li><strong>TT.after(t)</strong>：若时刻 <span class="math inline">\(t\)</span> 已过去，则返回 true；</li>
<li><strong>TT.before(t)</strong>：若时刻 <span class="math inline">\(t\)</span> 还未到，则返回 true。</li>
</ol>
<p>TrueTime 利用 GPS 和原子钟两种策略进行时钟参考，因为它们会以和彼此无关的方式出现故障，故其中一个方法发生故障后，可以立刻采用另一种方法。每个 data center 都有一组 <strong>time master</strong>，大多数使用 GPS，剩下的配备了原子钟。通过定期综合比较两种 master 得到一个时间点。</p>
<h4 id="并发控制">并发控制</h4>
<h5 id="timestamp-管理">timestamp 管理</h5>
<p>Spanner 支持 <strong>read-write 事务</strong>、<strong>read-only 事务</strong>和 <strong>snapshot read</strong>，单独写入为 RW 事务；非快照单独读取为 RO 事务。如下表所示：</p>
<p><img src="image-20221017132537748.png" alt="image-20221017132537748" style="zoom:67%;" /></p>
<p>RO 事务是一种具有快照隔离性能优势的事务，其以系统指定的 ts 执行，而无需锁定。</p>
<p>client 可以为 snapshot read 指定 ts，或指定时间边界并让 Spanner 选择合适的 ts。无论是 snapshot read 还是 read-only，都会在足够 up-to-date 的 replica 上直接读取。</p>
<p>无论是 RO 事务还是 snapshot read，一旦指定了 ts，就必然会 commit，除非该 ts 处的数据已被 garbage collection。当服务器发生故障时，客户端可以继续在不同服务器上通过 ts 和当前读取位置进行查询。</p>
<h5 id="paxos-leader-lease">Paxos Leader Lease</h5>
<p>Spanner 中 Paxos 的 <strong>lease</strong> 默认为 10 秒。如果租约到期，Leader 会请求延长 lease 投票。同时，Spanner 允许 Paxos Leader 主动退位。</p>
<p>每个 Paxos Group 中不同 Leader 的 lease 互不相交。为了保持这一 <strong>lease 不相交性</strong>，定义 <span class="math inline">\(s_{max}\)</span> 为旧 Leader 的最大 ts，新 Leader 必须等到 <span class="math inline">\(TT.after ( s_{max} ) = true\)</span> 才能开始工作。</p>
<h5 id="rw-事务">RW 事务</h5>
<p>RW 事务使用 2PL，故只能在获取所有锁之后与释放所有锁之前的任意时刻分配 ts。对于给定的写事务，Spanner 会选择 Paxos 为提交事务的那次 Paxos Write 分配的时间戳。</p>
<p>在每个 Paxos Group 内，Spanner 以单调递增的顺序为 Paxos Write 分配 ts。这一约束通过 <strong>lease 不相交性</strong>在不同 Leader 之间进行约束：Leader 只在其 lease 内分配 ts。</p>
<p>Spanner 使用 2PC 提交事务，为保证<strong>外部一致性</strong>，Spanner 作出以下约束：如果事务 <span class="math inline">\(T_2\)</span> 的 start 发生在事务 <span class="math inline">\(T_1\)</span> commit 之后，则 <span class="math inline">\(T_2\)</span> 的 commit ts 必须大于 <span class="math inline">\(T_1\)</span> 的 commit ts。并且执行事务和分配 ts 的协议遵循以下两条规则：</p>
<ul>
<li><strong>START</strong>：写事务 <span class="math inline">\(T_i\)</span> 分配的 commit ts <span class="math inline">\(s_i\)</span> 满足 <span class="math inline">\(s_i \geq TT.now().latest\)</span> 且 <span class="math inline">\(s_i &gt; t_{abs}(e^{server}_i)\)</span>；</li>
<li><strong>COMMIT WAIT</strong>：client 在 <span class="math inline">\(TT.after ( s_i ) = true\)</span> 之前无法看到 <span class="math inline">\(T_i\)</span> 提交的任何数据且 <span class="math inline">\(s_i &lt; t_{abs}(e^{commit}_i)\)</span>。</li>
</ul>
<p>证明如下：</p>
<p><img src="image-20221017142509253.png" alt="image-20221017142509253" style="zoom:80%;" /></p>
<p>其中 <span class="math inline">\(e^{start}_i\)</span> 和 <span class="math inline">\(e^{commit}_i\)</span> 为事务启动和提交事件，<span class="math inline">\(e^{server}_i\)</span> 为事务 commit 请求到达 coordinate Leader 的事件。</p>
<p>同时，为了保证任意读取都是可靠且安全的，每个 replica 都会跟踪一个称为<strong>安全时间</strong>的值 <span class="math inline">\(t_{safe}\)</span>。replica 可以满足任意 <span class="math inline">\(ts \leq t_{safe}\)</span> 的读取。</p>
<p><span class="math inline">\(t_{safe}\)</span> 定义为 <span class="math inline">\(\min (t^{Paxos}_{safe},\ t^{TM}_{safe})\)</span></p>
<p><span class="math inline">\(t^{Paxos}_{safe}\)</span> 是最新已应用的 Paxos 写入的 ts。因为 ts 单调增加并且写入是按顺序应用的，对于 Paxos 而言，不会有 ts 小于等于 <span class="math inline">\(t^{Paxos}_{safe}\)</span> 的写入。</p>
<p>如果不存在 prepared 但未 commit 的事务，则 <span class="math inline">\(t^{TM}_{safe}\)</span> 为 <span class="math inline">\(\infty\)</span>；反之，replicas 还不知道该事务是否会提交，每个 Paxos Group <span class="math inline">\(g\)</span> 的 Leader 为其分配一个 prepare ts <span class="math inline">\(s^{prepare}_{i,g}\)</span> 并确保 <span class="math inline">\(s_i \geq s^{prepare}_{i,g}\)</span>。有 <span class="math inline">\(t^{TM}_{safe} = \min_i ( s^{prepare}_{i,g} ) - 1\)</span>。</p>
<p>事务中发生的 write 会在客户端缓存直至提交，这使得事务中的 read 看不到事务 write 的影响。这种设计在 Spanner 中运行良好，因为读取返回任何数据读取的时间戳，而未提交的写入尚未分配时间戳。整个事务的具体流程如下：</p>
<ol type="1">
<li><p>client 发出 read 请求，Spanner 找到合适的 replica 并获取 read lock，然后读取最新数据。当 client 保持 open 时，它会发送 keep-alive 消息以防止 Leader 超时；</p></li>
<li><p>当 client 完成所有 read 并缓存所有 write 时，它开始 2PC；</p></li>
<li><p>client 在 Paxos Group 间选出 coordinate Group 并向其它 Group 的 Leader 发送 commit 消息；</p></li>
<li><p>participant Leader 首先获得 write lock，然后它选择一个 prepare ts，并通过 Paxos 作好 prepare 记录，之后每个 participants 将其 prepare ts 通知 coordinate；</p>
<p>coordinate Leader 也首先获取 write lock，但跳过 prepare 阶段。在收到所有其他 participant Leader 的消息后，它会为整个事务选择一个大于所有 prepare ts 的 commit ts <span class="math inline">\(s\)</span>。然后 coordinate Leader 通过 Paxos 记录进行 commit；</p></li>
<li><p>coordinate Leader 等待直到 <span class="math inline">\(TT.after(s)\)</span> 后，允许 coordinate replica 应用 commit 记录（保证 COMMIT WAIT）；</p></li>
<li><p>coordinate 将 <span class="math inline">\(s\)</span> 发送给 client 和所有其他 participant Leader，每个 participant Leader 都通过 Paxos 记录事务的结果。所有 participants 在相同的 ts 处应用该结果，然后释放锁。</p></li>
</ol>
<blockquote>
<p>read-write 事务中的 read 使用 <strong>wound-wait</strong> 来避免死锁。</p>
</blockquote>
<h5 id="ro-事务">RO 事务</h5>
<p>RO 事务分两个阶段执行：</p>
<ul>
<li>先分配一个时间戳 <span class="math inline">\(s_{read}\)</span>；</li>
<li>在 <span class="math inline">\(s_{read}\)</span> 处将事务的读取按照 snapshot read 执行。</li>
</ul>
<p>在事务开始后的任何时间进行 <span class="math inline">\(s_{read} = TT.now().latest\)</span> 的赋值，通过类似于 RW 事务中的参数来保持<strong>外部一致性</strong>。如果 <span class="math inline">\(t_{safe}\)</span> 没有充分推进，可能需要阻塞在 <span class="math inline">\(s_{read}\)</span> 处执行的读取。为了避免阻塞的发生，Spanner 应该分配能够保持外部一致性的最老的 ts。</p>
<p>整个事务的具体流程如下：</p>
<ol type="1">
<li>如果事务只涉及一个 Paxos Group，则 client 直接向该 Group 的 Leader 发出 RO 事务。将 <span class="math inline">\(LastTS()\)</span> 定义为 Paxos Group 中最后 commit 的 write 的 ts。如果没有事务 prepared，则令 <span class="math inline">\(s_{read} = LastTS()\)</span> 即可满足外部一致性：事务将看到最后一次 write 的结果；</li>
<li>反之，需要所有参与 read 的 Paxos Group 之间进行协商来决定 ts。Spanner 目前避免了一轮沟通，而是令 client 只在 <span class="math inline">\(s_{read} = TT.now().latest\)</span> 处执行 read（可能会等待 <span class="math inline">\(t_{safe}\)</span>）。事务中的所有 read 都可以发送到足够 up-to-date 的 replica。</li>
</ol>
<h4 id="总结">总结</h4>
<p>Spanner 优雅地利用了 TrueTime 实现了外部一致性以及其它强大特性，这是前所未有的创新设计。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>使序列递增的最小操作次数</title>
    <url>/LeetCode/leetcode801/</url>
    <content><![CDATA[<p>链接 <a href="https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/submissions/">&gt;&gt;&gt; 2022.10.10 每日一题 LeetCode801(hard) &lt;&lt;&lt;</a></p>
<span id="more"></span>
<blockquote>
<p>我们有两个长度相等且不为空的整型数组 <code>nums1</code> 和 <code>nums2</code>。在一次操作中，我们可以交换 <code>nums1[i]</code> 和 <code>nums2[i]</code> 的元素。</p>
<p>例如，如果 <code>nums1 = [1,2,3,8], nums2 =[5,6,7,4]</code> ，你可以交换 <code>i = 3</code> 处的元素，得到 <code>nums1 =[1,2,3,4]</code> 和 <code>nums2 =[5,6,7,8]</code> 。 返回 使 <code>nums1</code> 和 <code>nums2</code> <strong>严格递增</strong> 所需操作的最小次数 。</p>
<p>数组 <code>arr</code> <strong>严格递增</strong> 是指 <code>arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]</code></p>
<p><strong>注意</strong>：用例保证可以实现操作。</p>
</blockquote>
<h5 id="最初的想法">最初的想法</h5>
<p>首先，对于任意 <code>i</code>，我们有两种选择，交换 or 不交换。那么最开始，我们可以考虑定义一个数组 <code>dp[n]</code>，其中 <code>dp[i]</code> 表示前 <code>i+1</code> 个元素的子数组中<strong>使序列递增的最小操作次数</strong>。那么可以得到以下状态转移方程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> num1[i] &lt;= nums1[i<span class="number">-1</span>] || nums2[i] &lt;= nums2[i<span class="number">-1</span>] &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种考虑存在一个漏洞：我们的考虑范围局限在了相邻两个元素之间的关系，却没有考虑到之前的元素。</p>
<p>比如当 <code>nums1 = [0,2,2], nums2 = [1,1,3]</code> 时，我们只需交换 <code>i = 1</code> 处的元素。而在上面的状态转移过程中，我们却得到了 <code>dp = [0, 1, 2]</code>——这显然不是我们想要的。而这一结果的成因在于，忽略了之前是否有交换。</p>
<h5 id="改进">改进</h5>
<p>于是需要将 <code>dp[n]</code> 扩展到二维数组 <code>dp[n][2]</code>，<code>dp[i][0]</code> 表示对 <code>i</code> 处<strong>不进行交换</strong>时，前 <code>i+1</code> 个元素的子数组中使序列递增的最小操作次数；<code>dp[i][1]</code> 表示<strong>进行交换</strong>时的最小操作次数。这样一来，我们就能够对之前的交换情况进行考虑了。</p>
<p>既然题目保证最终能够实现操作，那么对任意 <code>i &gt; 1</code>，必然存在以下情况：</p>
<ol type="1">
<li><p><code>nums1[i] &lt;= num1[i-1] || nums2[i] &lt;= nums2[i-1]</code></p>
<p>这种情况下，<code>i</code> 处的交换情况必须与 <code>i-1</code> 处的交换情况相反，如果 <code>i-1</code> 换了，则 <code>i</code> 处无需交换；反之同理。有： <span class="math display">\[
 \begin{align}
 dp[i][0] &amp;= dp[i-1][1] \\[2ex] dp[i][1] &amp;= dp[i-1][0] + 1
 \end{align}
 \]</span></p></li>
<li><p><code>(nums1[i] &gt; num1[i-1] &amp;&amp; nums2[i] &gt; nums2[i-1]) &amp;&amp; (nums1[i] &lt;= nums2[i-1] || nums2[i] &lt;= nums1[i-1])</code></p>
<p>这种情况下，<code>i</code> 处的交换情况必须与 <code>i-1</code> 处的交换情况保持一致，也就是要么都交换，要么都不交换，则有： <span class="math display">\[
 \begin{align}
 dp[i][0] &amp;= dp[i-1][0] \\[2ex] dp[i][1] &amp;= dp[i-1][1] + 1
 \end{align}
 \]</span></p></li>
<li><p><code>(nums1[i] &gt; num1[i-1] &amp;&amp; nums2[i] &gt; nums2[i-1]) &amp;&amp; (nums1[i] &gt; nums2[i-1] &amp;&amp; nums2[i] &gt; nums1[i-1])</code></p>
<p>这种情况下，<code>i</code> 处交不交换都无所谓，既然我们要最小操作，则有： <span class="math display">\[
 \begin{align}
 dp[i][0] &amp;= \min(dp[i-1][0], dp[i-1][1])\\[2ex] dp[i][1] &amp;= dp[i][0] + 1
 \end{align}
 \]</span></p></li>
</ol>
<p>于是代码就很清晰了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSwap</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums1)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums1[i<span class="number">-1</span>] || nums2[i] &lt;= nums2[i<span class="number">-1</span>] &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i] &lt;= nums2[i<span class="number">-1</span>] || nums2[i] &lt;= nums1[i<span class="number">-1</span>] &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一看提交结果，看来还得优化。</p>
<blockquote>
<p>执行用时：144 ms, 在所有 Go 提交中击败了 18.18% 的用户</p>
<p>内存消耗：19.7 MB, 在所有 Go 提交中击败了 9.09% 的用户</p>
</blockquote>
<h5 id="优化">优化</h5>
<p>注意到，每个 <code>dp[i]</code> 的状态只与 <code>dp[i-1]</code> 有关，之前的信息就被淘汰了，于是可以采用<strong>滚动数组</strong>的技巧优化空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSwap</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums1)</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums1[i<span class="number">-1</span>] || nums2[i] &lt;= nums2[i<span class="number">-1</span>] &#123;</span><br><span class="line">            a, b = b, a + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i] &lt;= nums2[i<span class="number">-1</span>] || nums2[i] &lt;= nums1[i<span class="number">-1</span>] &#123;</span><br><span class="line">            b++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = min(a, b)</span><br><span class="line">            b = a + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后，比较满意了。</p>
<blockquote>
<p>执行用时：120 ms, 在所有 Go 提交中击败了68.18%的用户</p>
<p>内存消耗：9.6 MB, 在所有 Go 提交中击败了90.91%的用户</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear-Algebra(1)</title>
    <url>/math/linear-algebra(1)/</url>
    <content><![CDATA[<p>如果本科线代能有这样的教育方式和路线，我何苦现在还要来听这门公开课(</p>
<p>记录一下听的过程中觉得有用的信息好了。</p>
<span id="more"></span>
<h4 id="从线性方程组开始">从线性方程组开始</h4>
<p>教授（下简称 GS）认为线性代数的基本用途是解<strong>线性方程组</strong>，比如有这样一个方程组： <span class="math display">\[
\begin{cases}
2x-y = 0
\\[2ex]
-x+2y=3
\end{cases}
\]</span> 我们可以从以下三个角度考虑其解法。</p>
<ol type="1">
<li><p><strong>行图像</strong>：对于每个方程，我们都可以在二维平面上画出一条直线，这些直线的交点就是我们想要的解。</p></li>
<li><p><strong>列图像</strong>：对于每个变量的参数，我们都可以把方程组写成若干向量线性组合的形式（本例中是 <span class="math inline">\(x\left[\begin{matrix}2 \\ -1\end{matrix}\right] + y\left[\begin{matrix}-1 \\ 2\end{matrix}\right] = \left[\begin{matrix}0 \\ 3\end{matrix}\right]\)</span>）。只要找到一个合适的组合，方程组得解。</p>
<blockquote>
<p>此处如果如果每次取任意的 x 与 y，则等式左侧的向量的组合能布满整个二维平面。</p>
<p>拓展到多元方程组也是同理。</p>
</blockquote></li>
</ol>
<p>我们构造一个系数矩阵 <span class="math inline">\({A} = \left[\begin{matrix}2 &amp; -1 \\ -1 &amp; 2\end{matrix}\right]\)</span>，令 <span class="math inline">\(\vec{x} = \left[\begin{matrix}x \\ y\end{matrix}\right], \vec{b} = \left[\begin{matrix}0 \\ 3\end{matrix}\right]\)</span>，然后方程组可以写成这样子： <span class="math display">\[
A\vec{x} = \vec{b}
\]</span></p>
<h5 id="是否有解">是否有解？</h5>
<p>这时要考虑一个问题：是否任意 <span class="math inline">\(\vec{b}\)</span> 都能让上面那个方程有解呢？</p>
<p>从<strong>行图像</strong>的角度来讲，如果方程组有解，则所有方程在坐标系上对应的图像（直线、平面、体积）存在交集。如果某一个 <span class="math inline">\(\vec{b}\)</span> 不能满足上面条件，则无解（反之有解）。</p>
<p>从<strong>列图像</strong>的角度来讲，如果某一个 <span class="math inline">\(\vec{b}\)</span> 不能成为 <span class="math inline">\({A}\)</span> 列向量的线性组合，则无解（反之有解）。</p>
<h5 id="如何求解">如何求解？</h5>
<p>计算机软件（以及人类）计算时最常用的方法是<strong>高斯消元法</strong>，将原方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 转换为新的方程 <span class="math inline">\({U}\vec{x}=\vec{c}\)</span>。</p>
<blockquote>
<p>其中 <span class="math inline">\({U}\)</span> 为行阶梯最简型矩阵。</p>
</blockquote>
<h5 id="消元过程">消元过程</h5>
<p>每一步消元都可以视为将原矩阵乘上一个<strong>置换矩阵</strong>。左乘置换矩阵可以完成原矩阵的行变换，右乘置换矩阵则为列变换。</p>
<h5 id="逆矩阵">逆矩阵</h5>
<p>对于消元过程，每一步都是可逆的。对于一个置换矩阵 $ E_1$，我做了其相反的操作即可得到原矩阵，若这一相反的操作用 $ E_1^{'}$ 表示，则有 $ E_1^{'} E_1 A = A$ 。</p>
<p>得到 $ E_1^{'} E_1 = {I}$，从而可以用 $ E_1^{'} = { E_1}^{-1}$ 表示逆矩阵。第一个式子代表了逆矩阵的定义与性质。同样也有 <span class="math inline">\(( E_1^{&#39;})^{-1} = { E_1}\)</span> 且 $ E_1 E_1^{'} = {I}$ 。</p>
<blockquote>
<p>其中 $ I$ 是<strong>单位矩阵</strong>（对角线元素全为 1，其它元素全为 0 的方阵）</p>
</blockquote>
<h5 id="怎么求逆矩阵">怎么求逆矩阵？</h5>
<p><strong>高斯-若尔当消元法</strong>(Gauss-Jordan Elimination)告诉我们，通过构造 <span class="math inline">\(\left[\begin{matrix}\ {A}\ |\ {I}\ \end{matrix}\right]\)</span>，再通过消元法将左侧矩阵变为单位矩阵 <span class="math inline">\({I}\)</span>，易得这一系列行变换操作对应的矩阵是 <span class="math inline">\({A}^{-1}\)</span>，相当于左乘了一个矩阵 <span class="math inline">\({A}^{-1}\)</span>，则右侧矩阵乘完后自然就变为了 <span class="math inline">\({A}^{-1}\)</span>。</p>
<h4 id="接下来引入拓展到向量空间">接下来引入拓展到向量空间</h4>
<h5 id="向量空间">向量空间</h5>
<p>一个向量空间应该满足这样一个<strong>封闭性</strong>条件：对于空间中的任意向量 <span class="math inline">\(\vec{u}, \vec{v}\)</span>，其任意线性组合 <span class="math inline">\(a\vec{u}+b\vec{v}(a, b\in R)\)</span> 必然存在于空间中。显然，所有向量空间必须包括零向量。</p>
<h5 id="子空间">子空间</h5>
<p>包含于向量空间之内的一个向量空间称为原向量空间的一个子空间。</p>
<p>以 <span class="math inline">\({R}^3\)</span> 为例（它代表具有三个实数分量的所有向量的集合），其子空间包括：</p>
<ul>
<li>其本身（三维）</li>
<li>任一过原点的平面（二维）</li>
<li>任一过原点的直线（一维）</li>
<li>零向量</li>
</ul>
<h5 id="列空间">列空间</h5>
<p>矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的所有列向量张成的空间称为其列空间，以 <span class="math inline">\(C({A})\)</span> 表示。<span class="math inline">\(C({A})\subset R^m\)</span></p>
<h5 id="零空间">零空间</h5>
<p>所有满足方程 <span class="math inline">\({A}\vec{x} = \vec{0}\)</span> 的解的集合称为矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的零空间，以 <span class="math inline">\(N({A})\)</span> 表示。<span class="math inline">\(N({A})\subset R^n\)</span></p>
<h5 id="计算零空间">计算零空间</h5>
<p>相当于求方程 <span class="math inline">\({A}\vec{x} = \vec{0}\)</span> 的所有解。通过<strong>消元法与列交换</strong>构造出新的方程 <span class="math inline">\({U}\vec{x}=\vec{0}\)</span>，其中 <span class="math inline">\({U}\)</span> 是由 <span class="math inline">\(r\)</span> 个<strong>主元列</strong>与 <span class="math inline">\(n-r\)</span> 个<strong>自由列</strong>组成的形如下式的行阶梯型矩阵： <span class="math display">\[
U =
\left[
\begin{matrix}
\quad I_{r\times r} &amp; F_{r\times n-r} \quad
\\
\quad 0 &amp; 0 \quad
\end{matrix}
\right]
\]</span></p>
<blockquote>
<p>自由列可以表示为其左侧主元列的线性组合。</p>
</blockquote>
<p>原方程变为 <span class="math inline">\({U}\)</span> 的主元行乘以 <span class="math inline">\(\vec{x}\)</span>，即 <span class="math inline">\(\left[\begin{matrix}\ {I}\ |\ {F}\ \end{matrix}\right] \left[\begin{matrix}\  \vec x_{pivot} \\ \  \vec x_{free} \ \end{matrix}\right] = 0\)</span>。如果对 <span class="math inline">\(\vec x_{free}\)</span> 中 <span class="math inline">\(n-r\)</span> 的变量自由取值，我们能得到 <span class="math inline">\(n-r\)</span> 个线性无关的特解，<span class="math inline">\(N({A})\)</span> 则是由这些特解张成的向量空间（<strong>维度</strong>为 <span class="math inline">\(n-r\)</span>）。若把这些特解作为列向量写到一个矩阵 <span class="math inline">\({N}\)</span> 中，则有 <span class="math inline">\({U}{N} = {0}\)</span>，易得： <span class="math display">\[
N =
\left[\begin{matrix}\ {-F}_{r\times n-r} \ \\ \ I_{n-r\times n-r} \ \end{matrix}\right]
\]</span> 其中 <span class="math inline">\({-F}\)</span> 对应 <span class="math inline">\(\vec{x}_{pivot}\)</span>，<span class="math inline">\({I}\)</span> 对应 <span class="math inline">\(\vec{x}_{free}\)</span></p>
<h5 id="如果方程右侧不为零向量">如果方程右侧不为零向量</h5>
<p>首先抛出结论：若 <span class="math inline">\(\vec{b} \in C({A})\)</span>，则方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 有解。</p>
<p>当方程有解时，可以先找到方程一个特解，再与 <span class="math inline">\(N({A})\)</span> 进行线性组合，即可得到最后的解。</p>
<h5 id="秩">秩</h5>
<p>矩阵的<strong>秩</strong>等于矩阵的主元数。若 <span class="math inline">\(rank({A}_{m\times n}) = r\)</span>，则必有 <span class="math inline">\(r\leq m, r\leq n\)</span> 。</p>
<ol type="1">
<li><strong>列满秩</strong>：即 <span class="math inline">\(r=n&lt;m\)</span>，每一列都是主元列，矩阵没有自由列，<span class="math inline">\(N({A})\)</span> 中只有零向量，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 要么无解，要么有唯一解。</li>
<li><strong>行满秩</strong>：即 <span class="math inline">\(r=m\leq n\)</span>，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 有无穷多解。</li>
<li><strong>方阵满秩</strong>：即 <span class="math inline">\(r=m=n\)</span>，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 总有唯一解。</li>
<li><strong>行列均不满秩</strong>：即 <span class="math inline">\(r&lt;m, r&lt;n\)</span>，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 要么无解，要么有无穷多解。</li>
</ol>
<h5 id="线性相关性">线性相关性</h5>
<p>若一组向量的非零线性组合可以得到零向量，则称这组向量<strong>线性相关</strong>；反之，则称其<strong>线性无关</strong>。</p>
<h5 id="基">基</h5>
<p>向量空间的<strong>基</strong>是一组<strong>线性无关的向量</strong>，且这些向量能够张成该向量空间。</p>
<h5 id="维数">维数</h5>
<p>空间中的每一组基都有相同的向量数，这个数值就是空间的<strong>维数</strong>，通常用 <span class="math inline">\(dim\)</span> 表示。</p>
<h5 id="基本子空间">基本子空间</h5>
<p>除了列空间和零空间，还有</p>
<ol type="1">
<li><strong>行空间</strong>：矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的所有行向量张成的空间称为其列空间，以 <span class="math inline">\(R({A})\)</span> 表示。<span class="math inline">\(R({A})\subset R^n\)</span></li>
<li><strong>左零空间</strong>：所有满足方程 <span class="math inline">\({A^T}{x} = {0}\)</span> 的解的集合称为矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的左零空间，以 <span class="math inline">\(L({A})\)</span> 表示。<span class="math inline">\(L({A})\subset R^m\)</span></li>
</ol>
<p><span class="math inline">\({A}\)</span> 的 <span class="math inline">\(r\)</span> 个主元列构成了 <span class="math inline">\(C({A})\)</span> 的一组基。</p>
<p><span class="math inline">\({A}\vec{x}=\vec{0}\)</span> 的一组特解对应于 <span class="math inline">\({A}\)</span> 的 <span class="math inline">\(n-r\)</span> 个自由列，并构成了 <span class="math inline">\(N({A})\)</span> 的一组基。</p>
<p>则得到这样一个结论： <span class="math display">\[
rank(A) = \# C_{pivot} = dim(C(A)) = r = dim(R(A))
\]</span> 同样的： <span class="math display">\[
\#C_{free} = dim(N(A)) = n - r
\\[2ex]
dim(L(A)) = m-r
\]</span> 不妨用下图来表示这一切</p>
<p><img src="image-20220929160748771.png" alt="image-20220929160748771" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>MIT18.06</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 Lab2 RAFT</title>
    <url>/6-824/raft1/</url>
    <content><![CDATA[<p>对于 Raft，官网的说法是这样的：</p>
<blockquote>
<p>Raft 是一个易于理解的共识算法。在容错性和性能方面，它相当于 Paxos。不同之处在于，它被分解成相对独立的子问题，并且清楚地解决了实际系统所需的所有主要部分。我们希望 Raft 将向更广泛的受众提供共识，并希望这些更广泛的受众将能够开发出比现在更高质量的基于共识的系统。</p>
</blockquote>
<p>之前参加了 pingcap 组织的训练营，lab2 也是 raft，但由于零基础，很快就被干碎了。故本次前来尝试教学级别的 raft code，希望6.824 善待我。</p>
<span id="more"></span>
<h4 id="part-a-raft-leader-election">PART A-Raft Leader Election</h4>
<p>关于 Raft，有一个<a href="http://thesecretlivesofdata.com/raft/#home">非常通俗易懂的Raft 可视化网站</a>，以及<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">描述 Raft 算法的论文</a>。我只能说这个算法很复杂，很有挑战性。</p>
<p>part A 是 code 出 Raft 节点在启动后，超过一定时间间隔自动发起选举并当上领导者的过程。我把这一过程描述为以下步骤：</p>
<ol type="1">
<li><p>节点自身包含一个定时器，自动增长，在 timeout 时间间隔内满足以下条件</p>
<ul>
<li>未投票给其它节点</li>
<li>未收到当前 leader 的RPC</li>
<li>未发起选举</li>
</ul>
<p>则将自身状态变为 Candidate，CurrentTerm 加一，并请求其它各个节点（下称 Peers）给自己投票</p></li>
<li><p>Peers 收到 requestVote 消息后，对该消息进行处理，并按照一定规则判断是否能够同意其成为 leader</p></li>
<li><p>如果 Candidate 收到了超过半数的赞成票（自己也算一票），则成为当前 Term 的 leader</p></li>
</ol>
<p>至此，一个完整的选举过程就结束了。另外，节点成为 leader 后，需要定期向其它 Peers 发送不带任何 log 的特殊 AppendEntriesRPC，也就是所谓的 <strong>HeartBeat</strong>。</p>
<p>这一部分并不难，只需修改 Raft.go 即可，而解决它的关键在于 paper 中的 Figure2，为本实验提供了非常有用的结构体定义以及规则。同时，goroutines 也为我们解决某些问题提供了很重要的一个手段。</p>
<h5 id="结构体定义">结构体定义</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个日志条目存相应的索引、term 以及操作</span></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	Index   <span class="type">int</span></span><br><span class="line">	Term    <span class="type">int</span></span><br><span class="line">	Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 RaftState 与 persister 里的不一样</span></span><br><span class="line"><span class="keyword">type</span> RaftState <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Follower  RaftState = <span class="string">&quot;Follower&quot;</span></span><br><span class="line">	Candidate RaftState = <span class="string">&quot;Candidate&quot;</span></span><br><span class="line">	Leader    RaftState = <span class="string">&quot;Leader&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.RWMutex</span><br><span class="line">	peers     []*labrpc.ClientEnd</span><br><span class="line">	persister *Persister</span><br><span class="line">	me        <span class="type">int</span></span><br><span class="line">	dead      <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">	CurrentTerm <span class="type">int</span></span><br><span class="line">	VoteFor     <span class="type">int</span></span><br><span class="line">	Entry       []LogEntry</span><br><span class="line">	raftState   RaftState</span><br><span class="line"></span><br><span class="line">	commitIndex <span class="type">int</span></span><br><span class="line">	lastApplied <span class="type">int</span></span><br><span class="line">	nextIndex   []<span class="type">int</span></span><br><span class="line">	matchIndex  []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	applyChannel <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	applyCond    *sync.Cond</span><br><span class="line"></span><br><span class="line">	electionTimer  *time.Timer</span><br><span class="line">	heartbeatTimer *time.Timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="timer">Timer</h5>
<p>尽管 6.824 提了一嘴不要用 go time 库里的 timer，但感觉应该是怕学生不会用用错(</p>
<p>根据算法要求，需要<strong>选举定时器</strong>和<strong>心跳定时器</strong>各一个，每个定时器到点了都要触发一次事件，并且根据节点的 raftState 不同，进行不同的重置定时器操作。</p>
<blockquote>
<p>由于 lab 要求 1s 内最多发十次心跳，所以 HeartBeatTimeOut 设置为 100ms</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ResetTimer(isleader <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> isleader &#123;</span><br><span class="line">        rf.heartbeatTimer.Reset(rf.HeartBeatTimeOut())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.electionTimer.Reset(rf.ElectionTimeOut())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Ticker() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-rf.electionTimer.C:</span><br><span class="line">            <span class="comment">// 选举投票超时，发起选举</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-rf.heartbeatTimer.C:</span><br><span class="line">            <span class="comment">// 心跳超时，发送心跳</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="candidate-发送投票请求">Candidate 发送投票请求</h5>
<p>关键点在于如何应对过期的 reply。这里在每次收到 reply 时，都对整个节点上读写锁，获取当前状态是否为 Candidate 并检查 reply 的 term 是否与节点当前 term 一致。一旦有一个条件不满足，则认为该消息已过时。</p>
<blockquote>
<p>由于每个 goroutine 在对 reply 的处理是互斥的，所以这是判断消息是否过期的最有效的办法。</p>
</blockquote>
<p>若 Candidate 成功当选（破坏条件1）或收到了一个更高 term 节点的回复而更新自己的状态（破坏条件1, 2），说明这次选举已经可以结束了，再进行下去没有意义了，后续收到所有的该次选举产生的 reply 都作废。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartElection() &#123;</span><br><span class="line">    voteCnt := <span class="number">1</span>	<span class="comment">// 赞成票数</span></span><br><span class="line">    args := rf.GetRequestVoteArg()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                    reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">                    <span class="keyword">if</span> rf.peers[peer].Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, args, reply) &#123;	<span class="comment">// 发送成功了</span></span><br><span class="line">                        rf.mu.Lock()</span><br><span class="line">                        <span class="keyword">if</span> rf.raftState == Candidate &amp;&amp; rf.CurrentTerm == args.Term &#123;	<span class="comment">// 处理过时 reply</span></span><br><span class="line">                            <span class="keyword">if</span> reply.Grant &#123;</span><br><span class="line">                                voteCnt++</span><br><span class="line">                                <span class="keyword">if</span> voteCnt &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                                    <span class="comment">// 成为 Leader</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">                                <span class="comment">// 当前 term 已过时，需要更新并转为 Follower</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.mu.Unlock()</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对投票请求进行回复">对投票请求进行回复</h5>
<p>因为 2A 部分没有 AppendEntries，所以暂时不用考虑 paper 中各种和 Log 有关的变量。</p>
<blockquote>
<p>这里给 reply 加了个变量 Err，为了在打 log 的时候能够知道是因为什么而拒绝了该次投票，从而更快定位 bug。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到过时 rpc</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">        reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">false</span>, ErrOldTerm</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 term 内已给其他节点投过票</span></span><br><span class="line">    <span class="keyword">if</span> args.Term == rf.CurrentTerm &amp;&amp; (rf.VoteFor != null &amp;&amp; rf.VoteFor != args.CandidateId) &#123;</span><br><span class="line">        reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">false</span>, ErrVoted</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 term 已过时，需要更新并转为 Follower</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">        rf.VoteFor, rf.CurrentTerm = null, args.Term</span><br><span class="line">        rf.ChangeState(Follower)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LastLogTerm := rf.GetLastLog().Term</span><br><span class="line">    LastLogIndex := rf.GetLastLog().Index</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没问题了，就给它投赞成票</span></span><br><span class="line">    reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">true</span>, OK</span><br><span class="line">    rf.VoteFor = args.CandidateId</span><br><span class="line">    rf.ResetTimer(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="成为-leader">成为 leader</h5>
<p>当选后需<strong>立即</strong>广播一次 <strong>HeartBeat</strong>，以巩固地位。</p>
<blockquote>
<p>否则，考虑这种情况：A 和 B 同时发起投票，C 因为先收到 B 的请求而给 B 投了赞成票，之后收到 A 的请求，因为已经投了票故没有投给 A，也就没有更新选举定时器。最后 A 当选了，如果不马上广播 HeartBeat 而是等心跳定时器超时，则有可能在这段时间内 C 触发了选举超时，进行新的一轮选举。<strong>而事实上我们并不需要这一次多余的选举</strong>。</p>
<p><strong>尽量避免不必要的流程</strong>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartHeartbeat() &#123;</span><br><span class="line">    <span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> peer != rf.me &#123;</span><br><span class="line">            <span class="keyword">go</span> rf.SendHeartBeat(peer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2A 中，<code>SendHeartBeat()</code>不需要发送多余的信息，只要告诉其它节点“我”的当前 term 即可。其它节点收到 rpc 后，根据收到的 term 进行相应操作。</p>
<h4 id="part-b-log-replication">PART B-Log Replication</h4>
<p>这一 part 要求我们实现 Log 的发送、接受与提交，选举约束与快速恢复。</p>
<h5 id="appendentry">AppendEntry</h5>
<p>上层通过调用 Start() 函数向 Leader 发送一个 command，我们需要将这一 command 以日志的形式记录下来，并告知其他 raft node。按照实验要求，我们需要立刻返回这一 command 在日志中的索引与相应 term，同时如果上层调用的结点是 Leader ，则返回 true。</p>
<p>Leader 结点还是会每隔一定时间发送 Heartbeat，但此时在每个心跳期间，我们可能是有日志要发送的。通过阅读论文发现，有这样一个变量：</p>
<ul>
<li>nextIndex[]：for each server, index of the next log entry to send to that server (initialized to leader last log index + 1)</li>
</ul>
<p>所以我们对当前是发 HB 是否要捎带日志，只需要判断 next[server] 是否 ≤ LastLogIndex 即可，且要求：</p>
<ul>
<li>If last log index ≥ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex。</li>
</ul>
<p>上面是发送侧，下面说接收侧。</p>
<p>paper 中提到了以下规则：</p>
<ol type="1">
<li>Reply false if term &lt; currentTerm (§5.1)</li>
<li>Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</li>
<li>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it (§5.3)</li>
<li>Append any new entries not already in the log</li>
<li>If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</li>
</ol>
<p>逐个 adapt 到代码里即可。</p>
<p>另外，paper 中还提到了：</p>
<ul>
<li>If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm: set commitIndex = N (§5.3, §5.4).</li>
</ul>
<p>这条规则就是让我们更新 commitIndex 用的。在每次处理 AE 的 reply 时，都对当前其它 peers 的 matchIndex 进行遍历，找到第二大的 matchIndex 即可，该值必然满足 <strong>a majority of matchIndex[i] ≥ N</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> FindN() &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    matchIndexSet := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> peer != rf.me &#123;</span><br><span class="line">            matchindex, _ := rf.GetMatchNextIndex(peer)</span><br><span class="line">            matchIndexSet = <span class="built_in">append</span>(matchIndexSet, matchindex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(matchIndexSet)</span><br><span class="line">    N := matchIndexSet[<span class="built_in">len</span>(rf.peers)/<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> N &gt; rf.commitIndex &amp;&amp; rf.Entry[N].Term == rf.CurrentTerm &#123;</span><br><span class="line">        rf.UpdateCommitAndApply(N)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个我一开始没搞清楚的坑在于：每次更新 Applied 不能用 Goroutine，否则会报 "out of order xxx" 的错，也就是未按序 apply。</p>
<h5 id="选举约束">选举约束</h5>
<p>这其实很好理解，Follwer 只 Grant 最后一个日志比它更 up-to-date 的 VoteRequest，也就是说要满足以下两点：</p>
<ol type="1">
<li>Candidate.LastLogTerm &gt; Follwer.LastLogTerm</li>
<li>if Candidate.LastLogTerm == Follwer.LastLogTerm, Candidate.len(Entry) &gt; Follwer.len(Entry)</li>
</ol>
<p>如果不满足，就拒绝。</p>
<p>需要加上这样一个条件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己有的 LogEntry 条目更 up-to-date</span></span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm &lt; LastLogTerm || (args.LastLogTerm == LastLogTerm &amp;&amp; args.LastLogIndex &lt; LastLogIndex) &#123;</span><br><span class="line">    reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">false</span>, ErrLogNotMatch</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速恢复">快速恢复</h5>
<p>Guide 上面讲的还挺清楚的，conflictIndex 是发生冲突时 <strong>Follwer 日志里的 Index</strong>，conflictTerm 就是那个索引下对应日志的 Term。</p>
<p><strong>接受侧：</strong></p>
<ul>
<li>If a follower does not have prevLogIndex in its log, it should return with <strong>conflictIndex = len(log)</strong> and <strong>conflictTerm = None</strong>.</li>
<li>If a follower does have prevLogIndex in its log, but the term does not match, it should return <strong>conflictTerm = log[prevLogIndex].Term</strong>, and then search its log for <strong>the first index whose entry has term equal to conflictTerm</strong>.</li>
</ul>
<p><strong>发送侧：</strong></p>
<ul>
<li>Upon receiving a conflict response, the leader should first search its log for conflictTerm. If it finds an entry in its log with that term, it should <strong>set nextIndex to be the one beyond the index of the last entry in that term in its log</strong>.</li>
<li>If it does not find an entry with that term, it should <strong>set nextIndex = conflictIndex</strong>.</li>
</ul>
<p>这样做有助于快速修改 next[]，而不用每次都只是减一。这里我用了 binarysearch 来找对应的 index。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> FindNextIndex(ConflictIndex, ConflictTerm <span class="type">int</span>) (next <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ConflictTerm == <span class="number">0</span> || rf.Entry[ConflictIndex].Term == ConflictTerm &#123;</span><br><span class="line">        next = ConflictIndex</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, right := BaseIndex, rf.Entry[<span class="built_in">len</span>(rf.Entry)<span class="number">-1</span>].Index</span><br><span class="line">    <span class="keyword">for</span> left &lt; right<span class="number">-1</span> &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> rf.Entry[mid-BaseIndex].Term &lt;= ConflictTerm &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rf.Entry[right-BaseIndex].Term == ConflictTerm &#123;</span><br><span class="line">        next = right + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.Entry[left-BaseIndex].Term == ConflictTerm &#123;</span><br><span class="line">        next = left + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = ConflictIndex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="其他">其他</h5>
<ol type="1">
<li>在生成 raft node 的时候我把一个 index:0 term:0 的日志塞到里面，这样就能让它每一个 index 都能直接对应，而不需要考虑数组从 0 开始，PrevLogTerm 也就不需要考虑 PrevLogIndex 是否大于零了。</li>
<li>AppendEntryRPC 成功和失败都返回 ConflictIndex 和 ConflictTerm，而 AE 成功时我们就认为 ConflictIndex 是 Follwer 的最后一个索引，HB 成功时则设置为 args.PrevLogIndex（这是参考了 Raft 官网的设定），就能正确更新到 next[server]</li>
</ol>
<h4 id="part-c-persistence">PART C-Persistence</h4>
<p>这块虽然标了 hard，但实际代码量可以忽略不计。总的来说要我们实现一致性，即能保证节点 crash 后能恢复到原来的状态。</p>
<p>Paper 中已经为我们标出了哪些变量（VoteFor、Term、Entry）是需要保持一致性的，所以 Persist() 和 ReadPersist() 没什么好聊的，直接 uncomment 掉，稍微改改就好了。</p>
<p>我们需要在这三个变量被修改的时候，及时调用 Persist() 函数以保存到 rf.Persist 里。</p>
<ul>
<li><strong>VoteFor</strong>：这个变量只有在两种情况下会变：
<ol type="1">
<li>收到投票申请，同意投票。 这个直接在 RequestVote 里改就好了。</li>
<li>任期改变，重置投票。 收到任一 Term 大于 CurrentTerm 的 Message 都会导致任期改变，同时也会使节点“convert to Follwer（Rules For Servers）”。</li>
</ol></li>
<li><strong>Term</strong>：同上。</li>
<li><strong>Entry</strong>：直接在 AppendEntries() 里加。</li>
</ul>
<p>由于系统的高并发性与网络的不可靠性，我们还需要在合适的位置及时上锁，尽可能保证线性一致（善用 rf.mu）。</p>
<p>以及测试中有两个是 unreliable network ，意味着会丢包，我在 log 的时候发现这会导致选举的赞成票迟迟发不到 candidate 手上（被网络丢弃了），就是出现 Term 不断增加而没有 Leader 出现。于是在 sendRequestVote 里把 Call 改成了循环发送直至返回 true。</p>
<blockquote>
<p>不需要在 SendHeartBeat 里应用这一修改，因为心跳的发送是周期性的，很有可能上一个心跳时刻由于没收到 reply 而重复发，发着发着就到下一个心跳时刻了，这是我们不能接受的。</p>
</blockquote>
<h4 id="part-d-log-compaction">PART D-Log Compaction</h4>
<p>由于日志会无限增长，如果不采取某些措施，内存则会被大大浪费。Paper 第七节提出了“日志压缩”这一机制，也就是 Leader 节点定期在 Raft 层调用 Snapshot() 将当前 Application 层的状态以快照的形式保存，并丢弃那些已经被 Applied 的日志——这些日志在之后的时间不会再被用到。如下图所示</p>
<p><img src="raf1ukdq.jpg" style="zoom:80%;" /></p>
<p>原理就如 Paper 中说的那样。 在这一 part 中我们需要做这些事情：</p>
<ol start="0" type="1">
<li>改变 Entry 的索引方式</li>
<li>实现 Snapshot() 函数</li>
<li>实现 InstallSnapshotRPC() 以及相应的 args、reply</li>
<li>实现 crash 后恢复所需的持久状态</li>
</ol>
<h5 id="索引">索引</h5>
<p>因为节点的日志里存的 Index 不一定和数组下标一一对应了，前面我将每个 rf.Entry[0] 都设为一个 {Index:0, Term: 0} 的哨兵来防止越界，在这里由于进行了日志压缩，哨兵可以改为 {Index: LastIncludedIndex, Term: LastIncludedTerm}，这样一来日志索引 index 到数组里的位置就变成了 index - rf.Entry[0].Index</p>
<p>⚠ 每个涉及到<strong>索引</strong>的地方都要进行修改</p>
<h5 id="snapshotindex-int-snapshot-byte">Snapshot(index int, snapshot []byte)</h5>
<p>这里的 index 其实就是 LastIncludedIndex，snapshot 其实就是上层告诉我们的状态，需要保存到 persist 里。 我们对 index 进行一个范围的判断，如果不越界，则进行日志的截断，并进行一个 persist.SaveSnapshot 的操作。</p>
<blockquote>
<p>因为 persist.go 里没有单独保存 snapshot 的函数，我就自己加了一个。 （根据观察，测试里好像会隐式对所有节点调用 Snapshot，当然我也不确定、、）</p>
</blockquote>
<h5 id="installsnapshotrpc">InstallSnapShotRPC</h5>
<p>args 和 reply 要的变量都直接在 6.824 lab 网页的 hint 里和 paper 里找就行。 唯一要解决的问题是发送端要怎么处理这个 RPC—— 我的处理方法是，如果某个要发送的 AppendEntries 的 PrevLogIndex 比 Leader 当前存的第一个日志的 Index 还要小，说明这个 peer 已经落后太多，Leader 没有更早的日志能发过去了，那就直接告诉它要采用这个快照，一步到位，然后更新 Leader 里这个 peer 对应的 nextIndex。 那么接收侧如果收到了这一 RPC，先按照 paper 里说的检查一下，无误后自己截断日志，并更新 lastapplied 和 commitindex（snapshot 里没有这一步）</p>
<blockquote>
<p>考虑到并发性，我选择让这一 RPC 和 AE RPC 有同等地位——每个心跳时刻只发送其中的一个，否则会出现上一个心跳时刻的 goroutine 和下一个心跳时刻的 goroutine 时间上起冲突</p>
</blockquote>
<p>BTW，2D 测试一开始会出现 <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">RAFT GUIDE</a> 里最后提到的“四向死锁”这一糟糕的情况，解决方案是在建立 raft 节点时，开一个新线程让其 Apply 日志，每次 CommitIndex 更新时，都通过 raft 里的某个条件变量唤醒线程，让其工作，然后再次进入 Wait()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Applier() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> !(rf.lastApplied &lt; rf.commitIndex) &#123;</span><br><span class="line">            rf.applyCond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        CommitIndex := rf.commitIndex</span><br><span class="line">        BaseIndex := rf.GetBaseLog().Index</span><br><span class="line">        Entries := <span class="built_in">make</span>([]LogEntry, rf.commitIndex-rf.lastApplied)</span><br><span class="line">        <span class="built_in">copy</span>(Entries, rf.Entry[rf.lastApplied+<span class="number">1</span>-BaseIndex:rf.commitIndex+<span class="number">1</span>-BaseIndex])</span><br><span class="line">        </span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">for</span> _, Entry := <span class="keyword">range</span> Entries &#123;</span><br><span class="line">            rf.applyChannel &lt;- ApplyMsg&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      Entry.Command,</span><br><span class="line">                CommandTerm:  Entry.Term,</span><br><span class="line">                CommandIndex: Entry.Index,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.lastApplied = max(rf.lastApplied, CommitIndex)</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 Lab3 FTkvserver</title>
    <url>/6-824/raft2/</url>
    <content><![CDATA[<p>本实验要求在每一个 raft 节点上实现一个 K/V 服务器(server)，向上接受客户端(client)的请求并返回请求结果，向下生成日志应用到 raft 节点中。</p>
<p>整个模式大概长<a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf">这样</a>。</p>
<p>主要流程是这样的：</p>
<ol type="1">
<li>client 寻找对应 raft 节点是 leader 的 server，并发起一个请求(Put/Append/Get)；</li>
<li>server 收到请求后，调用 raft 的 Start() 函数；</li>
<li>raft 节点间互相 AppendEntries 之后，将消息 apply 到 applyChannel 里；</li>
<li>server 从 applyChannel 中取出消息，之后正式将命令应用到数据库中。</li>
</ol>
<span id="more"></span>
<h4 id="part-a-keyvalue-service-without-snapshots">PART A-Key/value service without snapshots</h4>
<h5 id="发送请求">发送请求</h5>
<p>由于 Start() 函数会立即返回 isleader 信息，所以如果一个 server 节点调用了 Start() 后发现不是 leader，则返回一个 <strong>ErrWrongLeader</strong></p>
<p>当且仅当 client RPC 成功并且发送给正确的 leader 后，才算成功；否则：</p>
<ol type="1">
<li>If the Clerk sends an RPC to the wrong kvserver, or if it cannot reach the kvserver, the Clerk should re-try by sending to a different kvserver.</li>
<li>If the operation failed to commit (for example, if the leader was replaced), the server reports an error, and the Clerk retries with a different server.</li>
</ol>
<h5 id="server-向下调用">server 向下调用</h5>
<p>首先是根据 Start() 返回的 isleader 来确定是否需要返回 ErrWrongLeader 错误。若成功，则等待流程 4。</p>
<p>注意到，在等待的过程中 server 是上了锁的，那必然被阻塞，此时就需要在 startKVserver 的时候额外开启一个叫 Applier() 的 goroutine 来进行 applyChannel 的读取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Applier() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        msg := &lt;-kv.applyCh</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            <span class="comment">// 应用操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">            <span class="comment">// 应用快照</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时遇到这样一个问题： 有一个网络分区 [1] | [2，3，4，5]，1 是分区前的 leader，分区后 1 仍然是 leader。第二个分区由于选主导致其 term 大于 1 的 term。 有一个 client A 一直给 [1] 发送请求，某一个请求 （requestID：x，clientID：A）发过去调用 1 的 start 并返回日志所在索引 index 后，网络恢复，[1] 收到新的 leader 消息后执行 appendEntries 并将原先 index 处的日志覆盖，更新 commitindex 后将覆盖后的日志传回 applyCh，而我采用的是 map[commandIndex] chan 的形式，由于同一索引处的日志被覆盖了，导致 server Applier 处理管道发回的错误请求，比如 get 到错误的值 or 未进行 append</p>
<p>解决方法为：在 arg 中开一个 channel，当 applier 处理完消息时通过该 channel 返回处理结果，同时判断当前 msg 中的 term 和 kv.rf.currentTerm 是否匹配，如果不匹配，说明可能被其他日志覆盖，返回一个 ErrWrongLeader 让上层重发。</p>
<blockquote>
<p>发现 6.824 labrpc 的 call 函数在传的时候会把 chan 给弄没掉。于是只能在 server 里 args.ch = make(chan int)，同时为了防止遇到的 chan 是 nil，还要加个判断当前是否为 leader，因为只有 leader 的 chan 是有效的，用 call 发给 follower 后会 arg 里的 chan 会变成 nil</p>
</blockquote>
<h5 id="应用到状态机">应用到状态机</h5>
<p>Applier() 对 applyChannel 进行一个 for 的等待，收到消息后，根据收到消息的命令类型的不同，执行不同的应用操作。</p>
<blockquote>
<p>Put(key, value) replaces the value for a particular key in the database, Append(key, arg) appends arg to key's value, and Get(key) fetches the current value for the key. A Get for a non-existent key should return an empty string. An Append to a non-existent key should act like Put.</p>
</blockquote>
<p>执行完后，返回消息到 waitchannel[index]，唤醒 server。</p>
<h5 id="other">Other</h5>
<ol type="1">
<li><p>刚开始想到和 Raft 里发送请求投票一样的手段，为每一个 server 开一个 goroutine 去发送 RPC，后来发现最后成功发送的只有一个，其它 goroutine 都是在占 cpu，遂放弃，直接用 for 循环。另外，有时候 leader 会在相当一段时间内保持不变，我们可以保存上一次发送请求成功时的 serverId，认为这是 leader，每次发请求时都可以利用这一信息，避免了不必要的 RPC，加快速度。当 RPC 失败，或发生了 ErrWrongLeader，只需要简单的令 leader 切换到下一个即可（0-&gt;1-&gt;...-&gt;n-1-&gt;0-&gt;...）</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> SendRequest(args *Args) <span class="type">string</span> &#123;</span><br><span class="line">    ck.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ck.mu.Unlock()</span><br><span class="line">    args.RequestId, args.ClerkId = ck.RequestId, ck.ClerkId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := &amp;Reply&#123;&#125;</span><br><span class="line">        ok := ck.servers[ck.volatileLeader].Call(<span class="string">&quot;KVServer.HandleRequest&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">if</span> ok &amp;&amp; reply.Err != ErrWrongLeader &#123;</span><br><span class="line">            ck.RequestId++</span><br><span class="line">            <span class="keyword">return</span> reply.Value</span><br><span class="line">        &#125;</span><br><span class="line">        ck.volatileLeader = (ck.volatileLeader + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在分区测试中，有可能发生 leader 超时未 apply 的情况（即一个 leader 被分到了 minority 的网络区），此时需要在 server 等待环节加一个 &lt;-time.After() 的信号接受判断，若超时，则直接返回，并且认为超时也是一种“WrongLeader”。</p></li>
<li><p>lab3A 还要求我们不能执行同一个 client 的重复请求，那么需要在每个 server 上放一个 clientID 到其最近一次命令序号 requestID 的映射，如果 Worker 收到的这个命令序号已经被执行过了，那么就不再执行，直接返回 ErrDuplicated。Get 是否重复执行无所谓，因为它并不会对数据库产生实质性的影响，主要是防止多次 Put/Append 同一个值。</p></li>
</ol>
<p>总体代码量比 raft 少太多，但因为论文中并没有给出很详细的指示，就走了很多弯路，以至于绝大多数时间都在 debug...</p>
<h4 id="part-b-keyvalue-service-with-snapshots">PART B-Key/value service with snapshots</h4>
<p>本实验要求在 3A 的基础上加上 snapshot 功能。</p>
<blockquote>
<p>虽然标的是hard，但代码量更少了</p>
</blockquote>
<p>server 不断检测 raftStateSize，如果过大，即当 persist.RaftStateSize() &gt;= kv.maxRaftState 时，将当前 db 状态保存下来，调用 raft 层的 snapshot() 并将 db 状态传入。</p>
<p>要实现有两个函数：</p>
<ol type="1">
<li><strong>MakeSnapshot()</strong> ：当 raftStateSize 过大时保存 db 状态。</li>
<li><strong>ApplySnapshot()</strong> ：raft 层将 snapshotValid 发到 applyCh，被 server 接收到后执行的操作。</li>
</ol>
<blockquote>
<p>persist 里的 raftstate 和 index 没有直接关系，所以不能用在 snapshot 里的 index 参数。</p>
</blockquote>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware-FT</title>
    <url>/6-824/vmware-ft/</url>
    <content><![CDATA[<p>6.824 的第二篇论文是 VMware-FaultTolerance(VMware-FT)，其描述了一个提供容错虚拟机的商业企业级系统——如果主服务器(<strong>primary</strong>)发生故障，备份服务器(<strong>backup</strong>)始终可以接管。backup 的状态必须始终保持与 primary 几乎相同，以便在其发生故障时，backup 可以立即接管，并且外部客户端看来并未发生故障且没有数据丢失。</p>
<span id="more"></span>
<h4 id="两种容错方式">两种容错方式</h4>
<h5 id="状态转移">状态转移</h5>
<p>在 backup 上复制状态的一种方法是每次同步时，primary 将其<strong>所有状态</strong>（包括 CPU、内存和 I/O 设备）<strong>变化</strong>进行完整地拷贝，并发送到 backup。但发送此状态所需的带宽会非常大。为了提升效率，可以优化为：每次同步只发送上次同步之后改变了的状态。</p>
<h5 id="操作转移">操作转移</h5>
<p>将服务器建模为<strong>确定性状态机</strong>，并实现以下两个条件：</p>
<ol type="1">
<li>从相同的初始状态开始</li>
<li>以相同的顺序执行相同的操作</li>
</ol>
<p>如果能确保以上两个条件，那么它们会一直互为副本，并且一直保持一致。由于大多数服务器或服务都有一些不确定的操作，因此必须使用额外的协调来确保 primary 和 backup 保持同步，而这一协调所需的额外信息量远远少于 primary 中正在更改的状态量。</p>
<h4 id="总结">总结</h4>
<p>操作 Log 的复制与状态机的思路给后续以启迪。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition314</title>
    <url>/LeetCode/weekCompetition314/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-314/">第 314 场周赛</a>复盘。</p>
<p><strong>排名</strong> 1130 / 4838</p>
<span id="more"></span>
<h4 id="处理用时最长的那个任务的员工">1. <a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/">处理用时最长的那个任务的员工</a></h4>
<blockquote>
<p>共有 n 位员工，每位员工都有一个从 0 到 n - 1 的唯一 id。</p>
<p>给你一个二维整数数组 <code>logs</code>，其中 <code>logs[i] = [id_i, leaveTime_i]</code>：</p>
<p><code>id_i</code> 是处理第 i 个任务的员工的 id，且 <code>leaveTime_i</code> 是员工完成第 i 个任务的时刻。所有 <code>leaveTime_i</code> 的值都是 <strong>唯一</strong> 的。</p>
<p>注意，第 i 个任务在第 i - 1 个任务结束后立即开始，且第 0 个任务从时刻 0 开始。</p>
<p>返回处理用时最长的那个任务的员工的 id。如果存在两个或多个员工同时满足，则返回几人中 <strong>最小</strong> 的 id。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>找使得 <code>log[i][1] - log[i-1][1]</code> 最大的 <code>log[i]</code>，并取其中最小的那个 <code>log[i][0]</code></p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hardestWorker</span><span class="params">(n <span class="type">int</span>, logs [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res, max := logs[<span class="number">0</span>][<span class="number">0</span>], logs[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(logs); i++ &#123;</span><br><span class="line">        diff := logs[i][<span class="number">1</span>] - logs[i<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> diff &gt; max &#123;</span><br><span class="line">            max = diff</span><br><span class="line">            res = logs[i][<span class="number">0</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> diff == max &amp;&amp; res &gt; logs[i][<span class="number">0</span>] &#123;</span><br><span class="line">            res = logs[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找出前缀异或的原始数组">2. <a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">找出前缀异或的原始数组</a></h4>
<blockquote>
<p>给你一个长度为 n 的 <strong>整数</strong> 数组 <code>pref</code> 。找出并返回满足下述条件且长度为 n 的数组 <code>arr</code>：</p>
<p><code>pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]</code></p>
<p>注意 ^ 表示 按位异或运算。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p><code>pref[i+1] = pref[i] ^ arr[i]</code>，两边同时异或 <code>pref[i]</code>，得到 <code>arr[i] = pref[i] ^ pref[i+1]</code></p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findArray</span><span class="params">(p []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(p))</span><br><span class="line">    res[<span class="number">0</span>] = p[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">        res[i] = p[i] ^ p[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用机器人打印字典序最小的字符串">3. <a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/">使用机器人打印字典序最小的字符串</a></h4>
<blockquote>
<p>给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t。执行以下操作之一，直到 s 和 t 都变成空字符串：</p>
<p>删除字符串 s 的 <strong>第一个</strong> 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。</p>
<p>删除字符串 t 的 <strong>最后一个</strong> 字符，并将该字符给机器人。机器人将该字符写到纸上。</p>
<p>请你返回纸上能写出的字典序最小的字符串。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>题目可以转为，给定一个字符串的入栈顺序，求所有出栈顺序中字典序最小的那个。所以需要把 t 等效为栈。</p>
<p>我们需要遍历 s，同时，在任意时刻，对于 t 栈顶（尾部）的字符而言：</p>
<ol type="1">
<li><p>如果 s 中尚存的字符中没有比它更小的，则将其 append 到结果字符串的末尾（写到纸上）；</p>
<blockquote>
<p>不难证明，这样贪心的做法一定会使字典序最小。</p>
</blockquote></li>
<li><p>反之，先将其加入栈中（添加到 t 的尾部），最后一并写出。</p></li>
</ol>
<p>可以用一个数组 <code>minm[]</code> 来表示 s 的当前 index 到末尾这一子串中 ASSIC 码最小的字符，那么 (1) 中的比较就变成了 <code>t.top()</code> 与 <code>minm[i]</code> 之间的比较。</p>
<h5 id="code-2">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">robotWithString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">minm</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; t;</span><br><span class="line">        string res;</span><br><span class="line">        </span><br><span class="line">        minm[n<span class="number">-1</span>] = s[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minm[i] = s[i] &lt; minm[i+<span class="number">1</span>] ? s[i] : minm[i+<span class="number">1</span>];</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            t.<span class="built_in">push</span>(s[i]);	<span class="comment">// 删除 s 的第一个字符并添加到 t 的尾部</span></span><br><span class="line">            <span class="keyword">while</span> (!t.<span class="built_in">empty</span>() &amp;&amp; t.<span class="built_in">top</span>() &lt;= minm[i+<span class="number">1</span>]) &#123;	<span class="comment">// 若后面没有比 t 尾部字符更小的，写到纸上</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                t.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 t 中所有字符写到纸上</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(s[n<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (!t.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(t.<span class="built_in">top</span>());</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中和能被-k-整除的路径">4. <a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">矩阵中和能被 K 整除的路径</a></h4>
<blockquote>
<p>给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k 。你从起点 (0, 0) 出发，每一步只能往 <strong>下</strong> 或者往 <strong>右</strong> ，你想要到达终点 (m - 1, n - 1) 。</p>
<p>请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 <span class="math inline">\(10^9 + 7\)</span> 取余 的结果。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p><em>知道用动态规划，但没想出来，下面参考了别人的</em></p>
<p>定义 <code>dp[i][j][v]</code> 表示从 <code>(0, 0)</code> 走到 <code>(i, j)</code>，且路径和模 k 的结果为 v 时的路径数。</p>
<p>要使得从 <code>(0, 0)</code> 处走到 <code>(i, j)</code> 且路径和模 k 的结果为 v，前一个点只能是 <code>(i-1, j)</code> 或 <code>(i, j-1)</code>，且有</p>
<ul>
<li><code>(pathsum(i-1, j) + grid[i][j]) % k = pathsum(i, j) = v</code></li>
<li><code>(pathsum(i, j-1) + grid[i][j]) % k = pathsum(i, j) = v</code></li>
</ul>
<p>那么有如下状态转移方程：<code>dp[i][j][v] = dp[i-1][j][(v - grid[i][j]) % k] + dp[i][j-1][(v - grid[i][j]) % k]</code></p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfPaths</span><span class="params">(grid [][]<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mod := <span class="number">1000000007</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>] % k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> v := <span class="number">0</span>; v &lt; k; v++ &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j][v] += dp[i<span class="number">-1</span>][j][(v - grid[i][j] + <span class="number">100</span>*k) % k]</span><br><span class="line">                    dp[i][j][v] %= mod</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j][v] += dp[i][j<span class="number">-1</span>][(v - grid[i][j] + <span class="number">100</span>*k) % k]</span><br><span class="line">                    dp[i][j][v] %= mod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/6-824/zookeeper/</url>
    <content><![CDATA[<p>6.824 的第四篇论文是 ZooKeeper——用于协调分布式应用程序进程，同时提供消息群发、共享寄存器和分布式锁等集中式服务。</p>
<blockquote>
<p>关于“ZooKeeper”这个项目的名字，考虑到之前内部很多项目都是使用动物的名字来命名的，Yahoo 的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说：“再这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，Yahoo 的整个分布式系统看上去就像一个大型的动物园了，而 Zookeeper 正好要用来进行分布式环境的协调一一于是，Zookeeper 的名字也就由此诞生了。</p>
</blockquote>
<span id="more"></span>
<h5 id="协调服务">协调服务</h5>
<p>ZooKeeper 采用的协调形式有：配置、组成员、领导者选举和锁。由于实现了更强大的原语的服务可以用来实现不那么强大的原语，ZooKeeper 不再在服务端实现特定原语，而是公开一个 API，令开发者实现自己的原语，为协调提供灵活性。</p>
<p>ZooKeeper 在设计 API 时避免了阻塞原语，转而实现简单的<strong>无等待数据对象</strong>，同时也需要保证所有操作按客户端顺序 <strong>FIFO</strong> 以及<strong>可线性化的写入</strong>。</p>
<p>ZooKeeper 服务由一组使用 <strong>Replicate</strong> 的服务器组成（实际上有点像 Raft），同时利用简单的<strong>管道</strong>架构来实现高吞吐和低延迟——既能以 FIFO 顺序从单个客户端执行操作，又能使其能够异步提交操作。</p>
<p>为了保证更新操作满足<strong>线性化</strong>，ZooKeeper 采用基于领导者的原子广播协议 <strong>Zab</strong>；读取操作在本地处理，无需排序。</p>
<p>ZooKeeper 使用<strong>监视机制</strong>使客户端能够缓存数据，同时在给定数据对象更新时得到通知。</p>
<h5 id="znode">Znode</h5>
<p>ZooKeeper 向其客户端提供一组数据节点(<strong>znode</strong>)的抽象，这些节点根据分层名称空间进行组织。如下图：</p>
<p><img src="image-20221008155321613.png" alt="image-20221008155321613" style="zoom:70%;" /></p>
<p>所有 znode 都存储数据，且除了临时节点(<strong>ephemeral znode</strong>)外的所有 znode 都可以有子节点。</p>
<p>有以下两种 znode：</p>
<ol type="1">
<li><strong>Regular</strong>：显式创建和删除。</li>
<li><strong>Ephemeral</strong>：创建后，或显示删除，或在会话终止时自动删除。</li>
</ol>
<p>创建 znode 时，客户端可以设置一个 <code>SEQUENTIAL</code> 标志，这种 znode 具有全局单调增的值。</p>
<p>ZooKeeper 实现监视(<strong>watch</strong>)机制允许 client 及时接收数据更改通知，这个通知是一次性的，一旦触发或会话关闭，它们就会失效。</p>
<p><strong>数据模型</strong>：本质上是一个具有简化 api 且只有完整数据读写的文件系统，或是具有分层 key 的 key-value 表。<strong>分层命名空间</strong>对于为不同应用程序的命名空间分配子树以及分配访问权限很有用。事实上，znode 的设计并非为了一般的数据存储，而是提供一个到客户端应用程序映射的抽象，通常对应于用于协调目的的元数据，如一些可用于元数据或分布式计算中的配置信息。</p>
<p><strong>会话</strong>：client 连接到 ZooKeeper 并启动会话，用于标识 client。</p>
<h5 id="客户端-api">客户端 API</h5>
<h6 id="createpath-data-flags">create(path, data, flags)</h6>
<p>创建一个路径名为 <code>path</code> 的 znode，并将 <code>data</code> 存储在其中，返回该 znode 的名称。<code>flag</code> 代表 znode 类型。</p>
<h6 id="deletepath-version">delete(path, version)</h6>
<p>若 <code>path</code> 上的 znode 版本号等于 <code>version</code>，则将其删除。</p>
<h6 id="existspath-watch">exists(path, watch)</h6>
<p>若 <code>path</code> 上的 znode 存在，则返回 true；反之返回 false。<code>watch</code> 使得客户端在该 znode 上设置一个监视器。</p>
<h6 id="getdatapath-watch">getData(path, watch)</h6>
<p>返回 <code>path</code> 上 znode 关联的数据和元数据。若 znode 不存在，则不设置监视器。</p>
<h6 id="setdatapath-data-version">setData(path, data, version)</h6>
<p>若 <code>path</code> 上的 znode 版本号等于 <code>version</code>，则将 <code>data</code> 写入。</p>
<h6 id="getchildrenpath-watch">getChildren(path, watch)</h6>
<p>返回 <code>path</code> 上 znode 的子节点集合。</p>
<h6 id="sycnpath">sycn(path)</h6>
<p>等待所有未完成的更新，<code>path</code> 没啥用。</p>
<blockquote>
<p>以上 api 都提供了同步和异步版本，若 <code>version = -1</code>，则不进行版本检查。</p>
</blockquote>
<h5 id="zookeeper-保证">ZooKeeper 保证</h5>
<ul>
<li><p><strong>线性化写入</strong>：所有更新 ZooKeeper 状态的请求都是可序列化的，并且服从优先级。</p></li>
<li><p><strong>FIFO 客户端顺序</strong>：所有请求都按照客户端发送的顺序执行。</p></li>
</ul>
<p>要实现这两个保证，需要选出一个领导者来指挥工作进程。而当一个新的领导者接管系统时，它必须修改配置，然后通知其它进程。这样的话，需要满足以下两点：</p>
<ol type="1">
<li>领导者在修改配置时，其它进程无法使用正在被修改的配置；</li>
<li>若领导者在完全修改完配置前崩溃，则其他进程无法使用这一未完全更新的配置。</li>
</ol>
<p>ZooKeeper 使用 <strong>ready znode</strong> 来满足上述约束，其他进程仅在 ready 存在期间使用配置。领导者通过删除 ready、更新配置 znode 和创建 ready 来更改配置。若一个进程看到了 ready znode，它必能看到新领导者所做的所有配置修改；若领导者在创建 ready 前崩溃，则其他进程就知道配置尚未完全更新完毕，也不会使用该配置。</p>
<p>如果一个进程在新领导者修改配置前看到 ready，而在更改配置时读取配置，则会产生问题。为了解决这一问题，采用 <strong>watch</strong> 机制，即客户端会在读取任何新配置前收到更新通知。</p>
<blockquote>
<p>ZooKeeper 放弃了线性一致读，使得读请求能够分布在副本上，以提高性能。但由于写请求是线性化的，而且任何一个客户端的请求都会按照其指定的顺序进行，故所有写请求都是按客户端确定的顺序执行的，且每个读请求必然要在某个特定的 Log 点执行，即如果日志没有到这个点，它不会执行读请求，同时后续读请求必须在不早于当前读请求的位置进行。从而ZooKeeper 也能保证它（定义）的一致性。</p>
</blockquote>
<p>ZooKeeper 还有以下两个保证：</p>
<ul>
<li><strong>活跃性</strong>：若大多数 ZooKeeper Server 处于活跃状态，则服务可用。</li>
<li><strong>持久性</strong>：若 ZooKeeper Server 成功响应了更改请求，只要多数服务器最终能恢复，则该更改就会持续存在。</li>
</ul>
<h5 id="原语">原语</h5>
<h6 id="配置管理">配置管理</h6>
<p>配置存储在 znode <span class="math inline">\(z_c\)</span> 中，进程通过读取 <span class="math inline">\(z_c\)</span> 并通过 watch 标志来获取配置更新通知。</p>
<h6 id="会合">会合</h6>
<p>将 master 信息放在 zonode <span class="math inline">\(z_r\)</span> 中，以便 worker 寻找。</p>
<h6 id="组成员关系">组成员关系</h6>
<p>当组成员进程启动时，会在一个指定的 znode <span class="math inline">\(z_g\)</span> （用以表示组）下创建一个临时子 znode，该子 znode 存放进程信息。若进程结束，则该子 znode 自动删除。故可通过 <span class="math inline">\(z_g\)</span> 来获取该组的所有组成员信息。</p>
<h6 id="简单锁">简单锁</h6>
<ol type="1">
<li><p><strong>锁文件</strong>——最简单的实现：为了获取锁，client 会尝试创建 ephemeral znode，若成功则持有锁；若 znode 存在，则说明有其它 client 正在持有锁，设置 watch 后进入等待状态，一旦该 znode 删除，则会再次尝试获得锁。</p>
<blockquote>
<p>这个策略会受到<strong>羊群效应</strong>(Herd Effect)的影响：若有很多客户端在等待获取锁，即便只有一个客户端可以获取锁，当锁被释放时，所有客户端都会尝试获得锁，就像羊群一样阻塞着。当有 <span class="math inline">\(n\)</span> 个客户端在等待时，最坏情况下需要 <span class="math inline">\(O(n^2)\)</span> 的尝试。</p>
</blockquote></li>
<li><p><strong>无羊群效应的简单锁</strong>：所有请求锁的 client 排成一排，按请求到达的顺序<strong>链式</strong>获得锁。每个 client 按照 <code>SEQUENTIAL</code> 在 <span class="math inline">\(z_l\)</span> 下创建 ephemeral znode，并获取 <span class="math inline">\(z_l\)</span> 所有子节点的信息。当且仅当其序号为 <span class="math inline">\(z_l\)</span> 所有子节点的序号中最低时，获得锁；否则，client 会 watch 前一个 znode。释放锁时只需要删除对应 znode 即可。</p>
<p><code>Lock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = create(l + &#x27;/lock-&#x27;, EPHEMERAL | SEQUENTIAL)</span><br><span class="line">C = getChildren(l, false)</span><br><span class="line">if n is lowest znode in C, exit</span><br><span class="line">p = znode in C ordered just before n</span><br><span class="line">if exists(p, true), wait for watch event</span><br><span class="line">goto 2</span><br></pre></td></tr></table></figure></p>
<p><code>Unlock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(n)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>前一个 znode 消失后还需要获取 <span class="math inline">\(z_l\)</span> 所有子节点的信息，并检查自己的序号是否为最小，因为有可能只是前一个 znode 崩溃，而有更小的 znode 持有锁。</p>
<p>这样一来，每次释放锁时只会唤醒一个进程，从而将复杂度降为 <span class="math inline">\(O(n)\)</span></p>
</blockquote></li>
<li><p><strong>读写锁</strong>：写锁同上。读锁需要等待前面的写锁全部结束后才能持有。</p>
<p><code>Write Lock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = create(l + &#x27;/write-&#x27;, EPHEMERAL | SEQUENTIAL)</span><br><span class="line">C = getChildren(l, false)</span><br><span class="line">if n is lowest znode in C, exit</span><br><span class="line">p = znode in C ordered just before n</span><br><span class="line">if exists(p, true), wait for watch event</span><br><span class="line">goto 2</span><br></pre></td></tr></table></figure></p>
<p><code>Read Lock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = create(l + &#x27;/read-&#x27;, EPHEMERAL | SEQUENTIAL)</span><br><span class="line">C = getChildren(l, false)</span><br><span class="line">if no write znodes lower than n in C, exit</span><br><span class="line">p = write znode in C ordered just before n</span><br><span class="line">if exists(p, true), wait for watch event</span><br><span class="line">goto 3</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>双屏障</strong>：使客户端能够同步计算的开始与结束。用 znode <span class="math inline">\(b\)</span> 表示 ZooKeeper 中的屏障。每个进程在准备开始时，会在 <span class="math inline">\(b\)</span> 下注册——创建一个子 znode，而在准备退出时注销——删除该子 znode。当 <span class="math inline">\(b\)</span> 的子节点数超过一定数量后，所有注册的进程都会真正开始计算，只有当 <span class="math inline">\(b\)</span> 的所有子节点都被删除时，进程才会真正退出。这两点都可通过 ready 来实现。</p></li>
</ol>
<h5 id="总结">总结</h5>
<p>ZooKeeper 是一个容错的，通用的协调服务。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition315</title>
    <url>/LeetCode/weekCompetition315/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-315/">第 315 场周赛</a>复盘。</p>
<p><strong>排名</strong> 2768 / 6490</p>
<span id="more"></span>
<h4 id="与对应负数同时存在的最大正整数">1. <a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">与对应负数同时存在的最大正整数</a></h4>
<blockquote>
<p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code>，找出自身与对应的负数都在数组中存在的最大正整数 k 。</p>
<p>返回正整数 k ，如果不存在这样的整数，返回 -1 。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>遍历数组，对于负数，加入 set；对于正数，判断其对应的负数是否存在于 set 中，若存在则更新最大值。</p>
<p>遍历一遍是不够的，比如遇到 <code>nums = [1, -1]</code> 的情况就挂了，所以需要遍历两遍，第一遍建 set，第二遍查询，时间复杂度 <span class="math inline">\(O(nlogn)\)</span></p>
<p>也可以先对数组进行升序排序，这样负数就集中在左侧，正数集中在右侧，只需一次遍历即可。</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxK</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> null <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">            mp[num] = null</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := mp[-num]; ok &amp;&amp; num &gt; res &#123;</span><br><span class="line">            res = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转之后不同整数的数目">2. <a href="https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/">反转之后不同整数的数目</a></h4>
<blockquote>
<p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code>。</p>
<p>你必须取出数组中的每个整数，<strong>反转其中每个数位</strong>，并将反转后得到的数字添加到数组的末尾。这一操作只针对 <code>nums</code> 中原有的整数执行。</p>
<p>返回结果数组中 <strong>不同</strong> 整数的数目。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>对原始数组中每一个值，将其和其反转后的数字加入 set，最后返回 set 大小即可。</p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + (num % <span class="number">10</span>)</span><br><span class="line">        num /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDistinctIntegers</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> null <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mp[num] = null</span><br><span class="line">        mp[reverse(num)] = null</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转之后的数字和">3. <a href="https://leetcode.cn/problems/sum-of-number-and-its-reverse/">反转之后的数字和</a></h4>
<blockquote>
<p>给你一个 <strong>非负</strong> 整数 <code>num</code>。如果存在某个 <strong>非负</strong> 整数 <code>k</code> 满足 <code>k + reverse(k) = num</code> ，则返回 true ；否则，返回 false 。</p>
<p><code>reverse(k)</code> 表示 <code>k</code> 反转每个数位后得到的数字。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>直接无脑枚举即可。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + (num % <span class="number">10</span>)</span><br><span class="line">        num /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfNumberAndReverse</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= num; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i + reverse(i) == num &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计定界子数组的数目">4. <a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">统计定界子数组的数目</a></h4>
<blockquote>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code> 。</p>
<p><code>nums</code> 的定界子数组是满足下述条件的一个子数组：</p>
<ul>
<li>子数组中的 <strong>最小值</strong> 等于 <code>minK</code> 。</li>
<li>数组中的 <strong>最大值</strong> 等于 <code>maxK</code> 。</li>
</ul>
<p>返回定界子数组的数目。</p>
<p>子数组是数组中的一个连续部分。</p>
</blockquote>
<p>参考了 <a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/solution/jian-ji-xie-fa-pythonjavacgo-by-endlessc-gag2/">这位大佬的解法</a>，我认为这个解法是最完美的了，这里就对该思路进行一个解释。</p>
<p>他的思路基于以下性质：</p>
<ol type="1">
<li>既然是求连续的子数组的个数，不妨对任意 <code>i</code>，考虑其作为数组右端点时能够产生的最大子数组个数；</li>
<li>如果数组某一区间及其右端点固定，则包含该区间的连续子数组个数为该区间左端点左侧的元素个数 + 1；</li>
<li>为了考虑到所有可能的情况，左端点必须尽可能靠近右端点；</li>
<li>区间内所有值必须在 <code>[minK, maxK]</code> 范围内。</li>
</ol>
<p>在 3 和 4 的约束下，左端点的坐标即 minK 和 maxK 上一次出现的坐标中的最小值。</p>
<p>再来看 2，区间不可能无限向左扩展，应该在遇到第一个不满足 <code>[minK, maxK]</code> 范围内的值时停下。</p>
<p>如果用 <code>minIndex, maxIndex, errIndex</code> 分别代表 minK、maxK 和 <strong>范围外的值</strong> 上一次出现的坐标。如果 errIndex 出现在左端点的右侧，则该区间无效，不进行考虑；反之，以 <code>i</code> 为右端点的子数组个数为 <span class="math display">\[
\min(minIndex, maxIndex) - errIndex
\]</span></p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubarrays</span><span class="params">(nums []<span class="type">int</span>, minK <span class="type">int</span>, maxK <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    minIndex, maxIndex, errIndex := <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>	       <span class="comment">// -1 代表未出现</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == minK &#123;</span><br><span class="line">            minIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num == maxK &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num &gt; maxK || num &lt; minK &#123;</span><br><span class="line">            errIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">        leftIndex := min(minIndex, maxIndex)</span><br><span class="line">        <span class="keyword">if</span> leftIndex &gt; errIndex &#123;</span><br><span class="line">            res += leftIndex - errIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear-Algebra(2)</title>
    <url>/math/linear-algebra(2)/</url>
    <content><![CDATA[<p>书接上回。</p>
<span id="more"></span>
<h4 id="如何求解无解方程组">如何求解无解方程组？</h4>
<p>在这个问题之前，我先做点铺垫。</p>
<h5 id="正交向量">正交向量</h5>
<p>若两向量 <span class="math inline">\(\vec{a}, \vec{b}\)</span> 正交，则必然有 <span class="math inline">\(\vec{a}^T\vec{b} = \vec{b}^T\vec{a} = 0\)</span></p>
<h5 id="正交子空间">正交子空间</h5>
<p>若子空间 <span class="math inline">\(S\)</span> 与子空间 <span class="math inline">\(T\)</span> 正交，则 <span class="math inline">\(S\)</span> 中任意向量与 <span class="math inline">\(T\)</span> 中任意向量正交。</p>
<p>不难发现，<span class="math inline">\(R(A)\)</span> 与 <span class="math inline">\(N(A)\)</span> 是正交的，而这两个空间恰好都是 <span class="math inline">\(R^n\)</span> 的子空间，更巧的是，<strong>其维数之和为</strong> <span class="math inline">\(n\)</span>。</p>
<p>我们称这两个子空间为 <span class="math inline">\(R^n\)</span> 的<strong>正交补</strong>——它们将 <span class="math inline">\(R^n\)</span> 划分为了<strong>两个正交的子空间</strong>。</p>
<p>同样的，<span class="math inline">\(C(A)\)</span> 与 <span class="math inline">\(L(A)\)</span> 也互为正交补。</p>
<blockquote>
<p>两个互为正交补的子空间的维数之和，不能超过原空间的维数。</p>
</blockquote>
<h5 id="投影问题">投影问题</h5>
<p>这一问题的几何解释为：如何在向量 <span class="math inline">\(\vec{a}\)</span> 的方向上寻找与向量 <span class="math inline">\(\vec{b}\)</span> 距离最近的一点。假设这一点对应的向量为 <span class="math inline">\(\vec{p}\)</span>，则 <span class="math inline">\(\vec{e}=\vec{b}-\vec{p}\)</span> 就是这一近似的误差。如图所示：</p>
<figure>
<img src="image-20220929215857174.png" alt="image-20220929215857174" /><figcaption aria-hidden="true">image-20220929215857174</figcaption>
</figure>
<p>若令 <span class="math inline">\(\vec{p} = \hat{x}\vec{a}\)</span>，因 <span class="math inline">\(\vec{e}\)</span> 与 <span class="math inline">\(\vec{a}\)</span> 正交，则有 <span class="math inline">\(\vec{a}^T(\vec{b}-\hat{x}\vec{a}) = 0\)</span>，解得 <span class="math display">\[
\hat{x} = \frac{\vec{a}^T\vec{b}}{\vec{a}^T\vec{a}}
\\[2ex]
\vec{p} = \vec{a}\frac{\vec{a}^T\vec{b}}{\vec{a}^T\vec{a}}
\]</span> 相当于把 <span class="math inline">\(\vec{b}\)</span> 以某种操作投影到了 <span class="math inline">\(\vec{p}\)</span> 上。若用<strong>投影矩阵</strong> <span class="math inline">\(P\)</span> 来描述这一操作，则有 <span class="math inline">\(\vec{p} = P\vec{b}\)</span>，得 <span class="math display">\[
P = \frac{\vec{a}\vec{a}^T}{\vec{a}^T\vec{a}}
\]</span> 这是一个<strong>对称矩阵</strong>（<span class="math inline">\(P^T=P\)</span>），而且是<strong>幂等矩阵</strong>（<span class="math inline">\(P^2 = P\)</span>）</p>
<h5 id="如果考虑该问题在高维空间的版本">如果考虑该问题在高维空间的版本</h5>
<p>有一个向量空间 <span class="math inline">\(V\)</span> 与一个不在该空间上的向量 <span class="math inline">\(\vec{b}\)</span>，如果把 <span class="math inline">\(V\)</span> 视为某一矩阵的列空间，且该空间的基为 <span class="math inline">\(\vec{a_1}, \vec{a_2},\dots, \vec{a_n}\)</span>，则该矩阵可以用 <span class="math inline">\(A = \begin{bmatrix}\vec{a_1} &amp; \vec{a_2} &amp; \cdots &amp; \vec{a_n} \end{bmatrix}\)</span> 来描述。</p>
<p>令 <span class="math inline">\(\vec{p}\)</span> 为 <span class="math inline">\(\vec{b}\)</span> 在该向量空间上的投影，则 <span class="math inline">\(\vec{p}\)</span> 可以用 <span class="math inline">\(\vec{p} = x_1\vec{a_1} + x_2\vec{a_2} + \dots + x_n\vec{a_n} = A\vec{\hat{x}}\)</span> 来表示。</p>
<p>显然误差 <span class="math inline">\(\vec{e}\)</span> 与整个向量空间正交，则有 <span class="math inline">\(\vec{a_1}^T\vec{e} = 0, \vec{a_2}^T\vec{e} = 0, \dots, \vec{a_n}^T\vec{e} = 0\)</span></p>
<p>上式可以写为 <span class="math inline">\(A^T\vec{e} = 0\)</span></p>
<p>从而得到 <span class="math display">\[
A^T(\vec{b} - A\vec{\hat{x}}) = 0 \quad \Rarr \quad \vec{\hat{x}} = (A^TA)^{-1}A^T\vec{b}
\]</span> 那么得到一个<strong>非常优美的结论</strong>： <span class="math display">\[
\vec{p} = A(A^TA)^{-1}A^T\vec{b}
\\[2ex]
P = A(A^TA)^{-1}A^T
\]</span> 这里的 <span class="math inline">\(P\)</span> 同样满足对称性和幂等性。</p>
<p>这里 <span class="math inline">\(\vec{p} \in C(A)\)</span>，同时惊喜的发现 <span class="math inline">\(\vec{e}\in L(A)\)</span>，说明 <span class="math inline">\(\vec{b} = \vec{p} + \vec{e}\)</span> 由两部分组成，一部分（<span class="math inline">\(\vec{p}\)</span>）投影到了 <span class="math inline">\(C(A)\)</span> 上，另一部分（<span class="math inline">\(\vec{e}\)</span>）投影到了 <span class="math inline">\(L(A)\)</span> 上。对于 <span class="math inline">\(\vec{e}\)</span>，我们发现可以通过 <span class="math inline">\(\vec{e} = \vec{b} - \vec{p} = \vec{b} - P\vec{b} = (I-P)\vec{b}\)</span> 表示，所以 <span class="math inline">\(I-P\)</span> 也是个投影矩阵，也具有和 <span class="math inline">\(P\)</span> 同样的性质。</p>
<p>当 <span class="math inline">\(A\)</span> 的列向量线性无关时，说明 <span class="math inline">\(C(A)\)</span> 就是 <span class="math inline">\(R^n\)</span>，此时任意 <span class="math inline">\(\vec{b}\in R^n\)</span> 都必然在 <span class="math inline">\(C(A)\)</span> 中，投影矩阵就是 <span class="math inline">\(I\)</span>。</p>
<p>对于 <span class="math inline">\(A^TA\)</span> 而言，其零空间与 <span class="math inline">\(A\)</span> 是一致的</p>
<ol type="1">
<li>对于 <span class="math inline">\(A^TA\vec{x}=\vec{0}\)</span>，必然满足 <span class="math inline">\(\vec{x}^TA^TA\vec{x} = (A\vec{x})^T A\vec{x} = \vec{0}\)</span>，从而 <span class="math inline">\(A\vec{x}\)</span> 与自身正交，那么 <span class="math inline">\(A\vec{x} = \vec{0}\)</span>。</li>
<li>对于 <span class="math inline">\(A\vec{x}=\vec{0}\)</span>，必然满足 <span class="math inline">\(A^TA\vec{x}=\vec{0}\)</span></li>
</ol>
<p>因此当 <span class="math inline">\(A\)</span> 的列向量线性无关时，<span class="math inline">\(A\vec{x}=\vec{0}\)</span> 只有零解，<span class="math inline">\(A^TA\vec{x}=\vec{0}\)</span> 也只有零解。且 <span class="math inline">\(A^TA\)</span> 为方阵，行列满秩，必然可逆。</p>
<h5 id="回到最开始的问题如何求解无解方程组">回到最开始的问题：如何求解无解方程组？</h5>
<p>这个问题看似很离谱，实则我们可以用一个最优解 <span class="math inline">\(\vec{\hat{x}}\)</span> 去近似。对于方程 <span class="math inline">\(A\vec{x} = \vec{b}\)</span>，如果其无解，说明 <span class="math inline">\(\vec{b}\)</span> 不在 <span class="math inline">\(A\)</span> 的列空间中。我们可以将 <span class="math inline">\(\vec{b}\)</span> 投影到 <span class="math inline">\(C(A)\)</span>，将问题转换为求解方程 <span class="math inline">\(A\vec{\hat{x}} = \vec{p}\)</span>，这个解就是我们想求的近似最优解。</p>
<p>根据上面描述的，我们能够很轻易地得到该解，即 <span class="math display">\[
\vec{\hat{x}} = (A^TA)^{-1}A^T\vec{b}
\]</span></p>
<h5 id="最小二乘法">最小二乘法</h5>
<p>应用投影矩阵求方程组最优解的方法，最常用于“最小二乘法”拟合曲线，如图：</p>
<figure>
<img src="image-20220929223041893.png" alt="image-20220929223041893" /><figcaption aria-hidden="true">image-20220929223041893</figcaption>
</figure>
<p>已知数据点，求一直线方程，使该直线尽可能经过所有点——所有点到该直线的距离尽可能小。</p>
<p>有一个思路是：这些数据点大概率不会共线，也就是说，将这些数据点代入直线方程利用待定系数法求其参数时，组成的线性方程组大多数情况下是无解的，此时就要用到上面的“求无解方程组最优解”的思路。</p>
<p>还有一个思路是，我们希望误差 <span class="math inline">\(\vec{e}\)</span> 尽可能小，也就是 <span class="math inline">\(||\vec{e}||^2=||A\vec{\hat{x}}-\vec{b}||^2\)</span> 尽可能小。这一等式可以写成一个 <span class="math inline">\(n\)</span> 元的方程，对该方程的所有变量求偏导并令偏导数为 0，则可以得到上面那个思路一样的结果。</p>
<h5 id="再回到正交向量">再回到正交向量</h5>
<p>现在说正交向量的升级版——<strong>标准正交向量</strong>，即满足以下条件的一组向量： <span class="math display">\[
\vec{q}_i^T\vec{q}_j = \begin{cases}1 \quad i = j\\[2ex] 0 \quad i \neq j\end{cases}
\]</span></p>
<h5 id="正交矩阵">正交矩阵</h5>
若令 $Q =
<span class="math display">\[\begin{bmatrix}\vec{q}_1 &amp; \vec{q}_2 &amp; \cdots &amp; \vec{q}_n \end{bmatrix}\]</span>
<p>$，易得 <span class="math display">\[
Q^TQ = I
\]</span> 此矩阵 <span class="math inline">\(Q\)</span> 称为<strong>正交矩阵</strong>，且显然有 <span class="math inline">\(Q^T=Q^{-1}\)</span>。</p>
<p>对于正交矩阵来说，在其列空间内关于投影问题的<strong>投影矩阵</strong>也可以<strong>简化为</strong> <span class="math inline">\(P=Q(Q^TQ)^{-1}Q^T = QQ^T\)</span>。若 <span class="math inline">\(Q\)</span> 为方阵，还可以进一步得到 <span class="math inline">\(P=I\)</span>，因为此时其列空间已经张成 <span class="math inline">\(R^n\)</span>，投影操作不会对向量有任何改变。</p>
<p>对应的 <span class="math inline">\(\vec{p} = P\vec{b} = QQ^T\vec{b} = Q\vec{\hat{x}}\)</span></p>
<h5 id="施密特正交化">施密特正交化</h5>
<p>对于一组线性无关的向量 <span class="math inline">\(\vec{a}_1, \vec{a}_2,\dots,\vec{a}_n\)</span>，若其能够张成空间 <span class="math inline">\(V\)</span>，我们希望能找到该空间的<strong>正交矩阵</strong>表示——即找到一组<strong>标准正交向量</strong> <span class="math inline">\(\vec{e}_1, \vec{e}_2, \dots, \vec{e}_n\)</span>，其恰好能张成同样的空间，也就是找到该空间的一组<strong>标准正交基</strong>。</p>
<blockquote>
<p>对一个向量的<strong>标准化</strong>过程就是令其除以其模长。</p>
</blockquote>
<p>我们不妨逐一分析：</p>
<ol type="1">
<li><p>第一个向量不作变动，即 <span class="math inline">\(\displaystyle \vec{e}_1 = \frac{\vec{a}_1}{||\vec{a}_1||}\)</span></p></li>
<li><p>对于之后的所有向量 <span class="math inline">\(\vec{a}_i\)</span>，由于我们已经求得一组标准正交向量 <span class="math inline">\(\vec{e}_1, \dots, \vec{e}_{i-1}\)</span>，设求其施密特正交化后的向量为 <span class="math inline">\(\vec{e}_i\)</span>，易得 <span class="math inline">\(\vec{e}_i\)</span> 垂直于 <span class="math inline">\(\vec{e}_1, \dots, \vec{e}_{i-1}\)</span>，从而有<span class="math inline">\(\vec{e}_i\)</span> 垂直于 <span class="math inline">\(\vec{e}_1, \dots, \vec{e}_{i-1}\)</span> 张成的向量空间。此时可以把问题转换为<strong>投影问题</strong>，只不过我们这里需要求投影问题中的<strong>误差</strong>，也就是原向量 <span class="math inline">\(\vec{a}_i\)</span> 减去它在投影到所有基 <span class="math inline">\(\vec{e}_k\)</span> 上的分量 <span class="math inline">\(\vec{p}_k\)</span>： <span class="math display">\[
 \vec{e}_i = \vec{a}_i - \sum\limits_{k=1}^{i-1}\vec{p}_k
 \\[2ex]
 \vec{p}_k = \frac{\vec{e}_k^T\vec{a}_i}{\vec{e}_k^T\vec{e}_k}\vec{e}_k
 \]</span></p></li>
<li><p>最后还需要对 <span class="math inline">\(\vec{e}_i\)</span> 进行标准化。</p></li>
</ol>
<h5 id="qr分解">QR分解</h5>
我们把得到的标准正交基写成矩阵的形式 <span class="math inline">\(Q = \begin{bmatrix}\vec{e}_1 &amp; \vec{e}_2 &amp; \cdots &amp; \vec{e}_n \end{bmatrix}\)</span>，若令 $A =
<span class="math display">\[\begin{bmatrix}\vec{a}_1 &amp; \vec{a}_2 &amp; \cdots &amp; \vec{a}_n \end{bmatrix}\]</span>
<p>$，则 <span class="math inline">\(C(Q)\)</span> 与 <span class="math inline">\(C(A)\)</span> 是同一个向量空间。</p>
由于 <span class="math inline">\(Q\)</span> 的列向量是 <span class="math inline">\(C(Q)\)</span> 空间中的标准正交基，则 <span class="math inline">\(A\)</span> 的列向量必能由 <span class="math inline">\(Q\)</span> 的列向量线性表示。前文提到，列变换相当于右乘一个置换矩阵，所以我们可以得到如下等式： $$ A = QR 
<span class="math display">\[\begin{bmatrix}
\vec{a}_1 &amp; \vec{a}_2 &amp; \cdots &amp; \vec{a}_n
\end{bmatrix}\]</span>
=
<span class="math display">\[\begin{bmatrix}
\vec{e}_1 &amp; \vec{e}_2 &amp; \cdots &amp; \vec{e}_n
\end{bmatrix}\]</span>
<span class="math display">\[\begin{bmatrix}
\vec{a}_1^T\vec{e}_1 &amp; \vec{a}_2^T\vec{e}_1 &amp; \cdots &amp; \vec{a}_n^T\vec{e}_1
\\
\vec{a}_1^T\vec{e}_2 &amp; \vec{a}_2^T\vec{e}_2 &amp; \cdots &amp; \vec{a}_n^T\vec{e}_2
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
\vec{a}_1^T\vec{e}_n &amp; \vec{a}_2^T\vec{e}_n &amp; \cdots &amp; \vec{a}_n^T\vec{e}_n
\end{bmatrix}\]</span>
<p>$$ 其中矩阵 <span class="math inline">\(R\)</span> 为列变换的置换矩阵。</p>
<p>根据我们求正交基的步骤，每一个 <span class="math inline">\(\vec{e}_i\)</span> 都正交于 <span class="math inline">\(\vec{a}_j\ (j &lt; i)\)</span>，因为 <span class="math inline">\(\vec{a}_j\)</span> 属于 <span class="math inline">\(\vec{e}_1, \vec{e}_2,\dots,\vec{e}_{i-1}\)</span> 张成的向量空间，而 <span class="math inline">\(\vec{e}_i\)</span> 与该向量空间正交。从而当 <span class="math inline">\(j &lt; i\)</span> 时，有 <span class="math inline">\(\vec{a}_j^T\vec{e}_i = 0\)</span>，得到 <span class="math inline">\(R\)</span> 为上三角矩阵。</p>
<p>更清楚的表示为： <span class="math display">\[
R =
\begin{bmatrix}
\vec{a}_1^T\vec{e}_1 &amp; \vec{a}_2^T\vec{e}_1 &amp; \cdots &amp; \vec{a}_{n-1}^T\vec{e}_1 &amp; \vec{a}_n^T\vec{e}_1
\\
0 &amp; \vec{a}_2^T\vec{e}_2 &amp; \cdots &amp; \vec{a}_{n-1}^T\vec{e}_2 &amp; \vec{a}_n^T\vec{e}_2
\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots
\\
0 &amp; 0 &amp; \cdots &amp;  \vec{a}_{n-1}^T\vec{e}_{n-1} &amp; \vec{a}_n^T\vec{e}_{n-1}
\\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; \vec{a}_n^T\vec{e}_n
\end{bmatrix}
\]</span></p>
<h4 id="进入第二部分行列式">进入第二部分：行列式</h4>
<p>跟国内教材上来就给学生塞一堆行列式的定义与性质让你记忆和做题不一样，GS 在讲完矩阵后，把<strong>“行列式作为属于矩阵的一个特性，包含大量矩阵的信息”</strong>教授给大家，并从<strong>三个基本性质</strong>开始。</p>
<blockquote>
<p>行列式记为 <span class="math inline">\(det(A) = |A|\)</span>。矩阵必须为方阵。</p>
</blockquote>
<h5 id="行列式性质">行列式性质</h5>
<ol type="1">
<li><p><span class="math inline">\(det(I) = 1\)</span></p></li>
<li><p>交换任意两行后，<span class="math inline">\(det(A)\)</span> 取相反数。</p></li>
<li><ul>
<li>数乘： <span class="math display">\[
  \begin{vmatrix}
  ta &amp; tb
  \\
  c &amp; d
  \end{vmatrix}
  =
  t
  \begin{vmatrix}
  a &amp; b
  \\
  c &amp; d
  \end{vmatrix}
  \]</span></li>
<li>相加： <span class="math display">\[
  \begin{vmatrix}
  a+a&#39; &amp; b+b&#39;
  \\
  c &amp; d
  \end{vmatrix}
  =
  \begin{vmatrix}
  a &amp; b
  \\
  c &amp; d
  \end{vmatrix}
  +
  \begin{vmatrix}
  a&#39; &amp; b&#39;
  \\
  c &amp; d
  \end{vmatrix}
  \]</span></li>
</ul></li>
</ol>
<p>更多的性质可以从以上基本性质中推导出：</p>
<ol start="4" type="1">
<li><p>任意两行相等，行列式为 0。</p></li>
<li><p>任意一行加上/减去另一行的 <span class="math inline">\(k\)</span> 倍，行列式值不变。</p></li>
<li><p>若某一行为 0，则行列式为 0。</p></li>
<li><p>上三角/下三角行列式的值等于其主对角线所有元素的乘积。</p>
<blockquote>
<p><span class="math display">\[
\begin{vmatrix}
a &amp; b
\\
c &amp; d
\end{vmatrix}
= ad - bc
\]</span></p>
</blockquote></li>
<li><p>若 <span class="math inline">\(det(A) = 0\)</span>，则 <span class="math inline">\(A\)</span> 奇异/不可逆；反之非奇异/可逆。</p></li>
<li><p><span class="math inline">\(det(AB) = det(A)det(B)\)</span> <span class="math inline">\(det(A^{-1}) = 1/det(A)\)</span> <span class="math inline">\(det(kA) = k^ndet(A)\)</span></p></li>
<li><p><span class="math inline">\(det(A^T) = det(A)\)</span></p></li>
</ol>
<h5 id="代数余子式">代数余子式</h5>
<p>讲完性质，就来讲怎么对高阶方阵的行列式求值了。</p>
<p><span class="math inline">\(n\)</span> 阶行列式中，任意位置 <span class="math inline">\(a_{ij}\)</span> 对应的<strong>代数余子式</strong> <span class="math inline">\(C_{ij}\)</span> 等于将第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列从行列式中移除后，剩下部分构成的 <span class="math inline">\(n-1\)</span> 阶行列式<strong>的值</strong>，且其正负性由 <span class="math inline">\((-1)^{i+j}\)</span> 表示。</p>
<p>行列式的值，等于任意一行中所有元素与其代数余子式乘积再求和，即<strong>代数余子式展开</strong>： <span class="math display">\[
det(A) = a_{i1}C_{i1} + a_{i2}C_{i2} + \dots + a_{in}C_{in} \quad (1 \leq i \leq n)
\]</span> 对列也有类似的展开方法。</p>
<blockquote>
<p>一般来说很少用这方法，以<strong>消元法化为上三角行列式</strong>为主。</p>
</blockquote>
<h5 id="逆矩阵公式">逆矩阵公式</h5>
<p>已知二阶矩阵 <span class="math inline">\(A = \begin{bmatrix}a &amp; b \\ c &amp; d\end{bmatrix}\)</span> 的行列式公式，则其逆矩阵为 <span class="math inline">\(\displaystyle A^{-1} = \frac{1}{ad-bc} \begin{bmatrix}d &amp; -b \\ -c &amp; a\end{bmatrix}\)</span></p>
<p>事实上，<strong>任意矩阵的逆</strong>都可以写为这样一个形式： <span class="math display">\[
A^{-1} = \frac{1}{det(A)}C^T
\\[2ex]
C = \begin{bmatrix}
C_{11} &amp; C_{12} &amp; \cdots &amp; C_{1n}
\\
C_{21} &amp; C_{22} &amp; \cdots &amp; C_{2n}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
C_{n1} &amp; C_{n2} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
\]</span> 其中 <span class="math inline">\(C_{ij}\)</span> 为 <span class="math inline">\(A\)</span> 中元素 <span class="math inline">\(a_{ij}\)</span> 的<strong>代数余子式</strong>。代数余子式矩阵 <span class="math inline">\(C\)</span> 的转置 <span class="math inline">\(C^T\)</span> 也称为 <span class="math inline">\(A\)</span> 的<strong>伴随矩阵</strong>。</p>
对上式进行左乘 <span class="math inline">\(A\)</span>，则有 $$ AC^T = 
<span class="math display">\[\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}
\\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}\]</span>
<span class="math display">\[\begin{bmatrix}
C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}
\\
C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}
\end{bmatrix}\]</span>
<p>$$ 主对角线元素很好判断，就是行列式的<strong>代数余子式展开</strong>；对于其它元素，以 <span class="math inline">\(\sum\limits_{i=1}^na_{2i}C_{1i}\)</span> 为例，它可以视为 <span class="math inline">\(A\)</span> 的第一行元素全由第二行替换后的新矩阵 <span class="math inline">\(A&#39;\)</span> 按第一行代数余子式展开，根据<strong>性质 4</strong>，我们得到 <span class="math inline">\(det(A&#39;)=0\)</span>，即最终结果仅有主对角线元素全为 1，其它都是 0——单位矩阵 <span class="math inline">\(I\)</span>，恰好是 <span class="math inline">\(AA^{-1}\)</span>，故该等式是正确的。</p>
<h5 id="克拉默法则">克拉默法则</h5>
<p>对于可逆矩阵 <span class="math inline">\(A\)</span>，方程 <span class="math inline">\(A\vec{x} = \vec{b}\)</span> 必有形如下式的解：<span class="math inline">\(\vec{x} = A^{-1}\vec{b}\)</span></p>
<p>代入上面得到的逆矩阵公式，有 <span class="math display">\[
\begin{bmatrix}
x_1
\\
x_2
\\
\vdots
\\
x_n
\end{bmatrix}
= \vec{x} = \frac{1}{det(A)}C^T\vec{b} = \frac{1}{det(A)}
\begin{bmatrix}
C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}
\\
C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
\begin{bmatrix}
b_1
\\
b_2
\\
\vdots
\\
b_n
\end{bmatrix}
\]</span> 根据之前得到的结论，<span class="math inline">\(\sum\limits_{i=1}^nb_kC_{ik}\)</span> 可以视为将 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(k\)</span> 列用 <span class="math inline">\(\vec{b}\)</span> 替换后得到的新矩阵 <span class="math inline">\(B_k\)</span> 的行列式值，从而得到 <span class="math display">\[
x_k = \frac{det(B_k)}{det(A)}
\]</span> 评价为：<strong>没消元法好用，但确实也是一个可行的方法</strong>。</p>
<h5 id="几何度量">几何度量</h5>
<p>二阶行列式 <span class="math inline">\(|det(A)|\)</span> 等于 <span class="math inline">\(A\)</span> 行（列）向量构成的平行四边形的面积。</p>
<p>三阶行列式 <span class="math inline">\(|det(A)|\)</span> 等于 <span class="math inline">\(A\)</span> 行（列）向量构成的平行六面体的体积。</p>
<h4 id="进入下一个议题特征向量与特征值">进入下一个议题：特征向量与特征值</h4>
<p>将矩阵 <span class="math inline">\(A\)</span> 与向量 <span class="math inline">\(\vec{x}\)</span> 相乘当做是对向量的一种操作或者函数，输入 <span class="math inline">\(\vec{x}\)</span> 而输出 <span class="math inline">\(A\vec{x}\)</span> 。<strong>特征向量</strong>即在特定的向量 <span class="math inline">\(\vec{x}\)</span> 方向上输出的 <span class="math inline">\(A \vec{x}\)</span> 平行于 <span class="math inline">\(\vec{x}\)</span> ，即为： <span class="math display">\[
A\vec{x} = \lambda\vec{x}
\]</span> 其中 <span class="math inline">\(\vec{x}\)</span> 为 <span class="math inline">\(A\)</span> 的<strong>特征向量</strong>，<span class="math inline">\(\lambda\)</span> 为 <span class="math inline">\(A\)</span> 的<strong>特征值</strong>。</p>
<h5 id="如何求解特征值与特征向量">如何求解特征值与特征向量？</h5>
<p>直接上结论：<strong>求解特征值等价于求解方程</strong> <span class="math inline">\(det(A-\lambda I) = 0\)</span></p>
<p>并且有：</p>
<ol type="1">
<li><p>矩阵的<strong>迹</strong>（对角线所有元素之和）等于<strong>特征值之和</strong>。</p></li>
<li><p>对称矩阵的特征向量<strong>正交</strong>。</p>
<blockquote>
<p>设 <span class="math inline">\(\vec{x}_1, \vec{x}_2\)</span> 分别是 <span class="math inline">\(A\)</span> 对应特征值 <span class="math inline">\(\lambda_1, \lambda_2\)</span> 的特征向量，有 <span class="math display">\[
\begin{align}
A\vec{x}_1 &amp;= \lambda_1\vec{x}_1
\\[2ex]
\vec{x}_2^TA\vec{x}_1 &amp;= \lambda_1\vec{x}_2^T\vec{x}_1
\\[2ex]
(A^T\vec{x}_2)^T\vec{x}_1 &amp;= \lambda_2\vec{x}_2^T\vec{x}_1
\\[2ex]
(\lambda_1 - \lambda_2)\vec{x}_2^T\vec{x}_1 &amp;= 0
\end{align}
\]</span></p>
<p>由于 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>，所以 <span class="math inline">\(\vec{x}_2^T\vec{x}_1 = 0\)</span>，故其正交。</p>
</blockquote></li>
</ol>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>MIT18.06</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition313</title>
    <url>/LeetCode/weekCompetition313/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-313/">第 313 场周赛</a>复盘。</p>
<p><strong>排名</strong> 106 / 5445</p>
<span id="more"></span>
<h4 id="公因子的数目">1. <a href="https://leetcode.cn/problems/number-of-common-factors/">公因子的数目</a></h4>
<blockquote>
<p>给你两个正整数 a 和 b ，返回 a 和 b 的 <strong>公</strong> 因子的数目。</p>
<p>如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 <strong>公因子</strong> 。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>从 1 到 gcd(a, b) 遍历即可。</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;	<span class="comment">// assert a &lt; b</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> b % a == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b % a, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commonFactors</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= gcd(a, b); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span> &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="沙漏的最大总和">2. <a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/">沙漏的最大总和</a></h4>
<blockquote>
<p>给你一个大小为 <strong>m x n</strong> 的整数矩阵 <code>grid</code> 。</p>
<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>
<p><img src="image-20221017190111674.png" alt="image-20221017190111674" style="zoom:50%;" /></p>
<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>
<p><strong>注意</strong>：沙漏无法旋转且必须整个包含在矩阵中。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>由于沙漏占据了 3×3 的矩阵空间，最不用思考的做法就是遍历沙漏的左上角即可。</p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSum</span><span class="params">(g [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(g)<span class="number">-3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= <span class="built_in">len</span>(g[i])<span class="number">-3</span>; j++ &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            sum += g[i][j] + g[i][j+<span class="number">1</span>] + g[i][j+<span class="number">2</span>] + g[i+<span class="number">1</span>][j+<span class="number">1</span>] + g[i+<span class="number">2</span>][j] + g[i+<span class="number">2</span>][j+<span class="number">1</span>] + g[i+<span class="number">2</span>][j+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> sum &gt; res &#123;</span><br><span class="line">                res = sum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小-xor">3. <a href="https://leetcode.cn/problems/minimize-xor/">最小 XOR</a></h4>
<blockquote>
<p>给你两个正整数 num1 和 num2 ，找出满足下述条件的整数 x ：</p>
<ul>
<li>x 的置位数和 num2 相同，且</li>
<li>x XOR num1 的值 <strong>最小</strong></li>
</ul>
<p>注意 XOR 是按位异或运算。</p>
<p>返回整数 x 。题目保证，对于生成的测试用例， x 是 <strong>唯一确定</strong> 的。</p>
<p>整数的 <strong>置位数</strong> 是其二进制表示中 1 的数目。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>若要使两个数按位异或所得结果最小，它们二进制中 1 的位置应尽可能一致，所以找题目中的 <span class="math inline">\(x\)</span> 实际上就是<strong>安排其二进制中 ‘1’ 的位置</strong>。令 <span class="math inline">\(k(num1)\)</span> 表示 <span class="math inline">\(num1\)</span> 的置位数。则对于给定的 <span class="math inline">\(num1\)</span> 与 <span class="math inline">\(k(x) = k(num2)\)</span> ，只有以下三种情况：</p>
<ol type="1">
<li><p><span class="math inline">\(k(num1) = k(num2)\)</span>：则 <span class="math inline">\(x=num1\)</span> 时 <span class="math inline">\(x\ XOR\ num1\)</span> 最小</p></li>
<li><p><span class="math inline">\(k(num1) &lt; k(num2)\)</span>：<span class="math inline">\(k(num1)\)</span> 个 ‘1’ 与 <span class="math inline">\(num1\)</span> 中的 ‘1’ 相互抵消后，还剩下 <span class="math inline">\(k(num2) - k(num1)\)</span> 个 ‘1’ 未安排位置，这部分应尽量“靠左”，并且不与 <span class="math inline">\(num1\)</span> 中 ‘1’ 的位置冲突。</p>
<p>例如，当 <span class="math inline">\(num1=10, k(num2)=3\)</span> 时，<span class="math inline">\(num1=(1010)_2\)</span>。首先能够得到 <span class="math inline">\(x=(1\_1\_)_2\)</span>，最后一个 ‘1’ 的位置显然易见，应该放在最右边，故得到 <span class="math inline">\(x = (1011)_2\)</span></p></li>
<li><p><span class="math inline">\(k(num1) &gt; k(num2)\)</span>：<span class="math inline">\(x\)</span> 的值即保留 <span class="math inline">\(num1\)</span> 右侧 <span class="math inline">\(k(num2)\)</span> 个 ‘1’ 的结果。</p></li>
</ol>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">k</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res += num &amp; <span class="number">1</span></span><br><span class="line">        num &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimizeXor</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt1, cnt2, x := k(num1), k(num2), num1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cnt1 &gt; cnt2 &#123;</span><br><span class="line">        p := <span class="number">1</span></span><br><span class="line">        cnt1 -= cnt2    <span class="comment">// x 为 num1 去掉低 cnt1-cnt2 位 1</span></span><br><span class="line">        <span class="keyword">for</span> cnt1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &amp; p &gt; <span class="number">0</span> &#123;</span><br><span class="line">                x -= p</span><br><span class="line">                cnt1--</span><br><span class="line">            &#125;</span><br><span class="line">            p &lt;&lt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> cnt1 &lt; cnt2 &#123;</span><br><span class="line">        p := <span class="number">1</span></span><br><span class="line">        cnt2 -= cnt1	<span class="comment">// x 为 num1 再加上 cnt2-cnt1 位 1</span></span><br><span class="line">        <span class="keyword">for</span> cnt2 &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &amp; p == <span class="number">0</span> &#123;</span><br><span class="line">                x += p</span><br><span class="line">                cnt2--</span><br><span class="line">            &#125;</span><br><span class="line">            p &lt;&lt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对字母串可执行的最大删除数">4. <a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/">对字母串可执行的最大删除数</a></h4>
<blockquote>
<p>给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以：</p>
<ul>
<li>删除 <strong>整个字符串</strong> s ，或者</li>
<li>对于满足 1 &lt;= i &lt;= s.length / 2 的任意 i ，如果 s 中的 <strong>前</strong> i 个字母和接下来的 i 个字母 <strong>相等</strong> ，删除 <strong>前</strong> i 个字母。</li>
</ul>
<p>例如，如果 s = "ababc" ，那么在一步操作中，你可以删除 s 的前两个字母得到 "abc" ，因为 s 的前两个字母和接下来的两个字母都等于 "ab" 。</p>
<p>返回删除 s 所需的最大操作数。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>考虑操作 2，删除前 i 个字母后还剩下长为 len(s)-i 的新字符串，我们要接着对新字符串执行同样的删除操作。这就是一个递归步骤，并且我们的递归是二叉树状的——每个 i 都需要考虑删 or 不删。</p>
<p>那么很容易想到用动态规划。定义 <code>dp[i]</code> 为删除 <code>s[i-1:]</code> 所需最大操作数，那么对于任意 <code>1 ≤ i &lt; j ≤ len(s)-1</code>，如果 <code>s[i:j] == s[j:2*j-i]</code>，则 <code>dp[i] = max(dp[i], dp[j] + 1)</code></p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)  <span class="comment">// dp[i]: s[i:] 所需最大删除数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">        l := n-i</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt;= i+l/<span class="number">2</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> temp[i:j] == temp[j:<span class="number">2</span>*j-i] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span> &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition312</title>
    <url>/LeetCode/weekCompetition312/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-312/">第 312 场周赛</a>复盘。</p>
<p><strong>排名</strong> 1273 / 6638</p>
<span id="more"></span>
<h4 id="按身高排序">1. <a href="https://leetcode.cn/problems/sort-the-people/">按身高排序</a></h4>
<blockquote>
<p>给你一个字符串数组 <code>names</code> ，和一个由 <strong>互不相同</strong> 的正整数组成的数组 <code>heights</code> 。两个数组的长度均为 n 。</p>
<p>对于每个下标 i，<code>names[i]</code> 和 <code>heights[i]</code> 表示第 i 个人的名字和身高。</p>
<p>请按身高 <strong>降序</strong> 顺序返回对应的名字数组 <code>names</code> 。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>由于人名可能有重复，故不能建 map，而是将 name 与其对应的 height 作为一个整体，然后排序。</p>
<h5 id="code">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">sortPeople</span><span class="params">(vector&lt;string&gt;&amp; names, vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; names.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            temp.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(names[i], heights[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : temp) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it.first);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="按位与最大的最长子数组">2. <a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/">按位与最大的最长子数组</a></h4>
<blockquote>
<p>给你一个长度为 n 的整数数组 <code>nums</code> 。</p>
<p>考虑 <code>nums</code> 中进行 <strong>按位与</strong>运算得到的值 <strong>最大</strong> 的 <strong>非空</strong> 子数组。</p>
<ul>
<li>换句话说，令 k 是 <code>nums</code> <strong>任意</strong> 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。</li>
</ul>
<p>返回满足要求的 <strong>最长</strong> 子数组的长度。</p>
<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>
<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>首先有一个性质：<code>a AND b ≤ min(a, b)</code>，那么 AND 运算能够得到的最大值必然是整个数组的最大值。从而问题转换为，找到一个最长的连续子数组，其中所有元素都是 <code>nums[]</code> 中的最大值。</p>
<h5 id="code-1">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxm = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxm) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, j - i);</span><br><span class="line">                i = j<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到所有好下标">3. <a href="https://leetcode.cn/problems/find-all-good-indices/">找到所有好下标</a></h4>
<blockquote>
<p>给你一个大小为 n 下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 k 。</p>
<p>对于 <code>k &lt;= i &lt; n - k</code> 之间的一个下标 i ，如果它满足以下条件，我们就称它为一个 <strong>好</strong> 下标：</p>
<ul>
<li>下标 i <strong>之前</strong> 的 k 个元素是 <strong>非递增的</strong> 。</li>
<li>下标 i <strong>之后</strong> 的 k 个元素是 <strong>非递减的</strong> 。</li>
</ul>
<p>按 <strong>升序</strong> 返回所有好下标。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>定义 <code>assend[]</code> 与 <code>dessend[]</code>：如果一个数比它前面那个数大，则 <code>assend[i] = 1</code>；如果一个数比它后面那个数小，则 <code>dessend[i] = 1</code></p>
<p>问题就变为：找到一个下标，它前面 k-1 个下标的 assend 值均为 0，后面 k-1 个下标的 dessend 值也均为 0</p>
<p>用滑动窗口来维护前后 k-1 个下标的 assend/dessend 值中 1 的个数，每个迭代的过程只需判断个数是否均为 0 即可。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goodIndices</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n - k &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assend := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dessend := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            assend[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assend[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n<span class="number">-1</span> &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            dessend[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dessend[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left1, right1, left2, right2 := <span class="number">1</span>, k<span class="number">-1</span>, k+<span class="number">1</span>, <span class="number">2</span>*k<span class="number">-1</span></span><br><span class="line">    cnt1, cnt2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := left1; i &lt;= right1; i++ &#123;</span><br><span class="line">        cnt1 += assend[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := left2; i &lt;= right2; i++ &#123;</span><br><span class="line">        cnt2 += dessend[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, k)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := k+<span class="number">1</span>; i &lt; n-k; i++ &#123;</span><br><span class="line">        right1++</span><br><span class="line">        cnt1 = cnt1 + assend[right1] - assend[left1]</span><br><span class="line">        left1++</span><br><span class="line">        </span><br><span class="line">        right2++</span><br><span class="line">        cnt2 = cnt2 + dessend[right2] - dessend[left2]</span><br><span class="line">        left2++</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="好路径的数目">4. <a href="https://leetcode.cn/problems/number-of-good-paths/">好路径的数目</a></h4>
<blockquote>
<p>给你一棵 n 个节点的树（连通无向无环的图），节点编号从 0 到 n - 1 且恰好有 n - 1 条边。</p>
<p>给你一个长度为 n 下标从 <strong>0</strong> 开始的整数数组 <code>vals</code> ，分别表示每个节点的值。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 ai 和 bi 之间有一条 <strong>无向</strong> 边。</p>
<p>一条 <strong>好路径</strong> 需要满足以下条件：</p>
<ul>
<li>开始节点和结束节点的值 <strong>相同</strong> 。</li>
<li>开始节点和结束节点中间的所有节点值都 <strong>小于等于</strong> 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。</li>
</ul>
<p>请你返回不同好路径的数目。</p>
<p>注意，一条路径和它反向的路径算作 同一 路径。比方说， <code>0 -&gt; 1</code> 与 <code>1 -&gt; 0</code> 视为同一条路径。单个节点也视为一条合法路径。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>参考了 <a href="https://leetcode.cn/problems/number-of-good-paths/solution/bing-cha-ji-by-endlesscheng-tbz8/">这位大佬的解法</a>。</p>
<p>朴素的考虑是，找到连通分量中所有的最大值节点，若有 <span class="math inline">\(x\)</span> 个，则共可以生成 <span class="math inline">\(\displaystyle C(x, 2) = \frac{x(x-1)}{2}\)</span> 条好路径；之后，将这些节点删除，对剩下的所有连通分量应用上述步骤。但这种方法实现起来较为复杂。</p>
<p>不妨逆向思维，从小到大走，同时将删除操作改为合并操作。于是可以考虑用<strong>并查集</strong>来完成这一操作。</p>
<p>刚开始所有节点都是 standalone 的，我们遍历 <code>edges[]</code> 时，不断合并节点，并让较大元素作为较小元素的<strong>代表元</strong>，一旦在合并过程中发现有两个节点的代表元相等（也就意味着这两个代表元满足<strong>好路径</strong>的要求），如果用 <code>size[]</code> 表示当前节点作为代表元时，所在并查集中最大值的数量，则可以用乘法解得合并后的连通分量里的好路径数量。</p>
<p>由于我们按照节点值升序访问节点，故每次只需和比自己小的邻居合并，则可以保证对于节点 <span class="math inline">\(v\)</span> 的任意邻居，其所在并查集的最大值不会超过 <span class="math inline">\(vals[v]\)</span>，好路径的数量也就不会遗漏。合并后 <span class="math inline">\(v\)</span> 即为代表元。</p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findfather</span><span class="params">(father []<span class="type">int</span>, x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, temp := x, x</span><br><span class="line">    <span class="keyword">for</span> father[x] != x &#123;</span><br><span class="line">        x = father[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> a != x &#123;</span><br><span class="line">        a = father[a]</span><br><span class="line">        father[temp] = x</span><br><span class="line">        temp = a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfGoodPaths</span><span class="params">(vals []<span class="type">int</span>, edges [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(vals)</span><br><span class="line">    res := n  <span class="comment">// 所有单节点好路径数量</span></span><br><span class="line">    father := <span class="built_in">make</span>([]<span class="type">int</span>, n)  <span class="comment">// 代表元</span></span><br><span class="line">    size := <span class="built_in">make</span>([]<span class="type">int</span>, n)    <span class="comment">// 当前节点为代表元时, 所在并查集中最大值的数量</span></span><br><span class="line">    ids := <span class="built_in">make</span>([]<span class="type">int</span>, n)     <span class="comment">// 序号, 根据 vals[id] 来排序</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="type">int</span>, n) <span class="comment">// 图</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> father &#123;</span><br><span class="line">        father[i] = i</span><br><span class="line">        size[i] = <span class="number">1</span></span><br><span class="line">        ids[i] = i</span><br><span class="line">        graph[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, edge := <span class="keyword">range</span> edges &#123;</span><br><span class="line">        x, y := edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">        graph[x] = <span class="built_in">append</span>(graph[x], y)</span><br><span class="line">        graph[y] = <span class="built_in">append</span>(graph[y], x)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(ids, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vals[ids[i]] &lt; vals[ids[j]]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">        fx := findfather(father, id)</span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[id] &#123;</span><br><span class="line">            fy := findfather(father, neighbor)</span><br><span class="line">            <span class="keyword">if</span> fx == fy || vals[fy] &gt; vals[id] &#123; <span class="comment">// fx == fy 则无需合并, 只考虑比自己小的邻居</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> vals[fx] == vals[fy] &#123;</span><br><span class="line">                res += size[fx] * size[fy]</span><br><span class="line">                size[fx] += size[fy]</span><br><span class="line">            &#125;</span><br><span class="line">            father[fy] = fx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
</search>
