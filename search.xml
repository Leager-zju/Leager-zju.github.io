<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CMU15445 Project#0 C++ Primer</title>
    <url>/lab/15445project0/</url>
    <content><![CDATA[<p>本项目与课程教学内容无关，仅作 C++ 水平检验用，但我在 code 过程中发现还是涉及到部分比较重要的知识点，故作记录。</p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2022/project0/">&gt;&gt;&gt; LAB 主页传送门 &lt;&lt;&lt;</a></p>
<span id="more"></span>
<p>此项目要求我们实现一个基于并发 Trie 的 k/v 存储，支持 Insert, Remove, GetValue 三种操作。</p>
<blockquote>
<p>有关 Trie 这种数据结构可以参考<a href="https://en.wikipedia.org/wiki/Trie">维基百科</a>。</p>
</blockquote>
<p>为了简化，这里假设 Key 都是非空的可变长度字符串，即 <code>std::string</code>。Value 存储在该键最后一个字符所处的节点（<strong>Terminal Node</strong>）中。例如，考虑将 kv 对 <code>("ab", 1)</code> 和 <code>("ac", "val")</code> 插入到 Trie 中，将如下所示。</p>
<img src="graph.png" style="zoom: 80%;">
<h2 id="Task-1-templated-trie">Task #1 - templated trie</h2>
<h3 id="TrieNode">TrieNode</h3>
<blockquote>
<p>该类定义了 Trie 中的单个节点。<code>TrieNode</code> 保存单个字符，<code>is_end_</code> 标志表示它是否为 Terminal Node。可以根据字符通过 <code>map&lt;char, unique_ptr&lt;TrieNode&gt;&gt; children</code> 访问子节点。</p>
</blockquote>
<p>其它成员函数实现都很简单，这里需要关注类的移动构造函数 <code>TrieNode(TrieNode&amp;&amp; )</code> 和插入子节点函数 <code>InsertChildNode(char , std::unique_ptr&lt;TrieNode&gt; )</code>。这里涉及到智能指针和左值右值，以及移动语义。</p>
<blockquote>
<p>这里<strong>智能指针</strong>只涉及 <strong>unique_ptr</strong>，我的理解是将裸指针封装成类以保证析构释放资源，同时独占该指针的使用权，既能防止其它指针指向该地址导致错误释放，也能在不生成副本的情况下访问数据。</p>
<p>具体可参考<a href="https://xhy3054.github.io/cpp-unique-ptr/">这篇文章</a>。</p>
</blockquote>
<blockquote>
<p><strong>左值</strong>简单来说是指有名的、可通过地址访问的变量，一般在等号左侧；相反，<strong>右值</strong>就是字面量，一般在等号右侧。<strong>左值引用</strong>只能绑定到左值，<strong>右值引用</strong>只能绑定到右值。然而，<strong>右值引用</strong>既可以是左值（函数形参）也可以是右值（函数返回值）。</p>
<p>具体可参考<a href="https://zhuanlan.zhihu.com/p/335994370">这篇文章</a>。</p>
</blockquote>
<blockquote>
<p>与深拷贝不同，<strong>移动语义</strong>直接移动数据的所有权。与 <strong>unique_ptr</strong> 结合就变成了转移指针的所有权。</p>
<p>具体可参考<a href="https://www.cnblogs.com/zhangyi1357/p/16018810.html">这篇文章</a>。</p>
</blockquote>
<p>再来看这两个函数。移动构造函数需要接管所有数据，基本类型变量直接赋值即可，对 <strong>unique_ptr</strong> 而言需使用 <code>std::move()</code> 转移所有权。如果参数声明为 <code>const Type&amp;</code> 则无法使用移动语义。</p>
<h3 id="TrieNodeWithValue">TrieNodeWithValue</h3>
<blockquote>
<p>继承自 <code>TrieNode</code>，并代表一个可以保存任意类型值的 Terminal Node，它的 <code>is_end_</code> 总为 true。</p>
</blockquote>
<p>该类会在 Insert 一个 Key 的最后一个字符时从 TrieNode 变化而来，由于 TrieNode 没有无参构造函数，所以在 TrieNodeWithValue 构造函数中需显式声明父类构造。</p>
<p>这里构造函数参数中的 <code>TrieNode &amp;&amp;trieNode</code> 虽然是右值引用，但是左值，故利用它执行父类构造时需使用 <code>std::move()</code> 将左值强转为右值。</p>
<h3 id="Trie">Trie</h3>
<blockquote>
<p>根节点是所有键的起始节点，它本身不存储任何字符。</p>
</blockquote>
<h4 id="插入">插入</h4>
<p>如果待插入的 key 已存在，即 key 的所有字符都在 Trie 中存在且最后一个字符所处节点为 Terminal Node，则插入失败。</p>
<p>反之，对于不存在的字符，调用 <code>TrieNode.InsertChildNode()</code> 方法。当遍历至最后一个字符时，需将该节点转为 <code>TrieNodeWithValue</code>，我的方法是维护父节点指针 <code>prev</code>，届时对 <code>prev</code> 中的 <code>children</code> 变量作修改即可。在 C++ 多态特性下，基类指针也可以指向子类。</p>
<h4 id="删除">删除</h4>
<p>删除需要递归式地去判断是否删除子节点，于是开个新函数 <code>RecursivelyRemove</code>。需要注意的是，即便成功删除了该键，也不一定需要将对应的节点删除，故需要用一个变量来通知父节点是否需要将自身移除。而对于该键的 non-Terminal Node，需要判断自身是不是其它键的 Terminal Node，不能随意删除。</p>
<blockquote>
<p>考虑对于两个 Trie 中的键 “Hi” 和 “High”，按不同顺序删除。</p>
</blockquote>
<h4 id="取值">取值</h4>
<p>和插入一样，但若下个节点不存在，或最后一个字符不是 Terminal Node，或最后一个是 Terminal Node 但存的值类型不一致，则取值失败。在使用 <code>dynamic_cast</code> 的时候我选择转为指针类型，是因为方便判断是否转成功。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>CMU15445 Project#1 Buffer Pool</title>
    <url>/lab/15445project1/</url>
    <content><![CDATA[<p>从这个 lab 起，就正式开始构建本课程 bustub DBMS 数据库系统了。</p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2022/project1/">&gt;&gt;&gt; LAB 主页传送门 &lt;&lt;&lt;</a></p>
<span id="more"></span>
<p>本项目要求我们实现存储管理器的 <strong>Buffer Pool</strong> 部分，即完善对物理页面进行调度的过程。Buffer Pool Manager 对上层公开一系列页面相关的 API，如获取页（FetchPage）、结束访问页（UnpinPage）等。上层根据 <code>page_id</code> 通过调用这些 API 从内存中获取相应数据。本项目的整体框架如下：</p>
<img src="image-20221217221523177.png" alt="image-20221217221523177" style="zoom:60%;">
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>pages</strong>：每个数组元素（即Page 对象）存放数据。模拟了实际内存对存储空间进行分页。</p>
</li>
<li class="lvl-2">
<p><strong>page_table</strong>：存放 <code>page_id</code> 到 <code>frame_id</code> 的映射。在本项目中，页表的设计基于<strong>可扩展哈希表</strong>。</p>
</li>
<li class="lvl-2">
<p><strong>lru_k_replacer</strong>：不存储数据。仅当内存发生页面置换时，其根据 LRU-K 算法提供最先被换出的帧号。</p>
</li>
</ul>
<p>基于上述讨论，可以开始进行 lab tasks 的构思了。</p>
<h2 id="Task-1-Extendable-Hash-Table">Task #1 - Extendable Hash Table</h2>
<p>具体概念请参考<a href="https://zhuanlan.zhihu.com/p/537292608">可扩展哈希实现</a>。</p>
<p>由于今年不需要实现删除元素后哈希表的收缩，所以这里的关键部分就是桶满了之后的 Split 操作。若 <code>Indexof(Key) = index</code> 的键值对插入前对应桶满了：</p>
<ol>
<li class="lvl-3">
<p>增加对应桶 $bucket_i$ 的 $local_depth$；</p>
</li>
<li class="lvl-3">
<p>如果此时 $local_depth$ 超过了 $global_ depth$，则对目录进行扩展；</p>
</li>
<li class="lvl-3">
<p>对所有指向桶 $bucket_i$ 的索引，作一次数据的再分配；</p>
<blockquote>
<p>若 $bucket_i$ 原先的 $local_ depth$ 为 $l$，则指向该桶的所有索引的低 $l$ 位都是一致的。当桶进行分裂时，第 $l+1$ 位出现了差异，则令与 <code>index</code> 的二进制表示中低 $l$ 位相同，第 $l+1$ 不同的索引指向新的桶 $new_bucket_i$。取出 $bucket_i$ 中所有键值对，对其重新插入。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>重复插入 Key 的操作直至不再分裂。</p>
</li>
</ol>
<h2 id="Task-2-LRU-K-Replacement-Policy">Task #2 - LRU-K Replacement Policy</h2>
<p>在 LRU 策略中，每次页面置换都会选择最近最不常访问的帧号。其原理是符合直觉的。但是，考虑这种情况，存在某一热点页面，之后 buffer pool 发生了偶然性的大量冷页面的读取，根据 LRU 策略，热页面会被换出。</p>
<p>但我们并不希望其被换出，因为这些冷页面可能在很长一段时间内仅仅只有此次访问。LRU 策略的缺点就在于，其不能跟踪某一页面是否为热点页面，我们希望读取的代价最小，也就是热点页面在大多数情况下都不会被置换出。</p>
<p>于是诞生了 LRU-K 策略。在本 lab 中，该策略是在原来的 LRU 基础上，新增维护了某一帧最近 K 次的访问记录，当需要置换页面时，replacer 会选出 $k-distance$ 最大的那一帧。如果有多个 $k-distance = inf$ 的帧，则换出最早被访问的那一个。</p>
<blockquote>
<p>$k-distance$：与倒数第 $k$ 次访问的时间差。若访问次数不足 $k$ 次，则认为该值为 $inf$。</p>
</blockquote>
<p>在 LRU-K 策略下，上述热点页的问题就能得到解决，即便发生了多个偶然性的冷页面访问，置换也仅仅发生在固定一帧，其余热点页面则会受到保护。</p>
<p>以上是对本 Task 核心部分的讨论，接下来是一些细节。</p>
<h3 id="成员函数">成员函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>Evict(frame_id_t *frame_id)</code>：根据已有访问记录，挑选合适的 frame_id 进行置换，同时这里有个坑点，即选出一个 frame_id_t 后需清空其访问记录；</p>
</li>
<li class="lvl-2">
<p><code>RecordAccess(frame_id_t frame_id)</code>：追加一条关于 frame_id 的访问记录；</p>
</li>
<li class="lvl-2">
<p><code>SetEvictable(frame_id_t frame_id, bool set_evictable)</code>：设置 frame_id 的可置换性，即能否在 Evict 操作中参与 $k-d$ 的比较；</p>
</li>
<li class="lvl-2">
<p><code>Remove(frame_id_t frame_id)</code>：移除 frame_id 在 replacer 中的所有信息；</p>
</li>
</ul>
<p>为了支持并发，需在上述所有函数中上锁。</p>
<h3 id="成员变量设计">成员变量设计</h3>
<p>基于提供的成员函数，作出如下成员变量设计。</p>
<h4 id="访问记录表">访问记录表</h4>
<p>在 bustub 框架下，帧号永远从 0 开始，于是访问记录表可以不采用 <code>unordered_map&lt;frame_id_t, AccessRecord&gt;</code>，而是 <code>std::vector&lt;AccessRecord&gt;</code>。每个 <code>AccessRecord</code> 记录最近 K 次访问的时间戳。</p>
<p>在本 Task 中，我采用了 <code>std::list&lt;timestamp&gt;</code> 实现 <code>AccessRecord</code>。对于访问记录而言，只需维护 K 条记录，在追加记录时，若记录数已达 K 次，则移除最早的那次。显然，访问记录需要频繁的插入删除，以及末尾（倒数第 K 次记录）的访问，而 list 底层为一个双向链表，支持 $O(1)$ 的增删查。</p>
<h4 id="置换队列与队列位置信息">置换队列与队列位置信息</h4>
<p>每次置换时，可以选择遍历一遍访问记录表，再取合适的帧进行置换，但这样每次置换的时间开销为 $O(n)$。不难想到可以定义一个"<strong>置换队列</strong>"，按照 $k-dis$ 大小进行排序，使得队首恒为下一次进行置换的帧号，用空间换时间，将置换开销提升至 $O(1)$。</p>
<p>在本 Task 中，我依然采用了 <code>std::list&lt;frame_id_t&gt;</code> 来实现 replace_queue。在 replace_queue 中，只需访问队首元素，且需要频繁的插入删除——<code>SetEvictable(true)</code> 将本来 unevictable 的帧设为 evictable，需要将 frame_id 插入置换队列中合适的位置；<code>SetEvictable(false)</code> 将本来 evictable 的帧设为 unevictable，需要将 frame_id 从置换队列中移除。</p>
<p>这就导致插入/删除位置并不一定在首尾，查找插入/删除位置时需要进行 $O(n)$ 遍历，为了减少这一开销，可以维护所有帧号在置换队列中的<strong>位置</strong>（迭代器），从而将开销降至 $O(1)$。</p>
<p>有了这一信息，就无需单独维护某个 frame_id 是否 evictable 了——若 frame_id 对应的迭代器为 <code>replace_queue.end()</code>，则认为其 unevictable，反之同理。</p>
<p>另外，若对一个 evictable 的帧进行 <code>RecordAccess</code>，则其访问记录会被修改，需改变其在 replace_queue 中的位置。</p>
<h2 id="Task-3-Buffer-Pool-Manager-Instance">Task #3 - Buffer Pool Manager Instance</h2>
<p>到这里，就需要我们整合前两个 Task 的内容，对内存中的页面进行管理了。</p>
<p>根据 lab guide 所述，<code>BufferPoolManagerInstance</code> 负责从 <code>DiskManager</code> 中获取页面并将它们存储在内存中，当它被明确指示这样做或者当它需要驱逐一个页面为新页面腾出空间时，它也可以将脏页写出到磁盘。系统中的所有内存页面都由 <code>Page</code> 对象表示。<code>BufferPoolManagerInstance</code> 不需要理解这些页面的内容。但作为系统开发人员，重要的是要了解 <code>Page</code> 对象只是缓冲池中内存的容器，因此并不特定于唯一页面。也就是说，每个 <code>Page</code> 对象都包含一个内存块，<code>DiskManager</code> 将使用这块内存存放从磁盘读取的物理页的内容的副本。</p>
<h3 id="Page-类">Page 类</h3>
<p>Page 类维护以下元信息：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>data_[]</code>：实际的数据信息，下面三个并非真实页面所拥有的变量；</p>
</li>
<li class="lvl-2">
<p><code>page_id_</code>：用于唯一标识当前 Page；</p>
</li>
<li class="lvl-2">
<p><code>pin_count_</code>：表明当前访问该 Page 的线程数；</p>
</li>
<li class="lvl-2">
<p><code>is_dirty_</code>：若数据被线程修改且未写回磁盘，则为 true。进行页面置换时，若被换出的页面的 is_dirty_ = true，则需写回磁盘；</p>
</li>
</ul>
<h3 id="成员变量">成员变量</h3>
<p>BPM 的成员变量无需额外设计，故研究一下其提供的变量。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>std::atomic&lt;page_id_t&gt; next_page_id_</code>：新建 Page 对象时赋予的 page_id，每次新建均自增；</p>
</li>
<li class="lvl-2">
<p><code>Page *pages_</code>：Page 对象数组，即帧，根据 frame_id 作为下标进行访问，相当于一个容器，只是存放实际存储中的一个副本；</p>
</li>
<li class="lvl-2">
<p><code>ExtendibleHashTable&lt;page_id_t, frame_id_t&gt; *page_table_</code>：哈希表，存放 page_id 到 frame_id 的映射，每次对 pages 数组进行修改时，都要对该变量进行操作；</p>
</li>
<li class="lvl-2">
<p><code>std::list&lt;frame_id_t&gt; free_list_</code>：跟踪未存放任何 Page 对象的帧，当从磁盘中取出页面时优先使用 free_list 中的帧；</p>
</li>
</ul>
<h3 id="成员函数-2">成员函数</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NewPgImp(page_id_t *page_id)</code>：新建一个 Page，并将其插入到帧中，插入时优先使用 free_list 中的帧，其次再考虑利用 replacer 挑选一帧进行页面置换，置换时若页面为脏，则需写回磁盘。之后，除了修改 Page 对象的元信息，还需修改哈希表，构建新的映射；</p>
</li>
<li class="lvl-2">
<p><code>FetchPgImp(page_id_t page_id)</code>：表明某一线程需要访问 Page。如果 BPM 中已经有该 Page，则直接访问；反之，从磁盘中读取 Page，执行和 NewPgImp 一样的插入 Page 操作。这里访问 Page 实际上也是访问帧，Page 层面的就是修改 <code>pin_count_</code> 变量，而对于帧层面的，除了要调用 <code>RecordAccess()</code> 函数追加访问记录，还要将该帧设为 unevictable；</p>
</li>
<li class="lvl-2">
<p><code>UnpinPgImp(page_id_t page_id, bool is_dirty)</code>：表明某一线程终止了对该 Page 的访问。若该 Page 并不在 BPM 中，直接返回。减少 <code>pin_count_</code> 后，若其降至 0，则表明无任何线程正在访问，可以参与到页面替换的评比之中，需将对应帧设置为 evictable；</p>
<blockquote>
<p>这里有一个<strong>坑点</strong>在于，仅当 <code>is_dirty = true</code> 时才修改 BPM 中对应 Page 对象的 <code>is_dirty_</code> 变量，这是因为其为 <code>true</code> 时必定代表对该 Page 进行了修改，而为 <code>false</code> 仅仅表明这一线程只读不写，不代表其它线程没有对其进行操作，故不能不加判断直接修改。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><code>FlushPgImp(page_id_t page_id)</code>：无条件将对应 Page 的内容写回磁盘；</p>
</li>
<li class="lvl-2">
<p><code>FlushAllPgsImp()</code>：对所有 Page 执行一次 <code>FlushPgImp</code> 操作；</p>
</li>
<li class="lvl-2">
<p><code>DeletePgImp(page_id_t page_id)</code>：删除 page_id 对应的 Page 的所有信息。如果该 Page 不在帧中，则直接返回，否则，判断对应 Page 对象是否仍有线程在访问，若有，则直接返回，反之需修改所有与该 Page 对象及所在帧相关的信息，无需考虑磁盘中的情况，<code>next_page_id_</code> 也不会随之变化；</p>
<blockquote>
<p>就是在这里调用 replacer 的 <code>Remove()</code> 函数了。</p>
</blockquote>
</li>
</ul>
<h2 id="总结">总结</h2>
<p>总体实现并不难，跟着注释以及 lab guide 一步步来即可。</p>
<p>善用框架提供的 <code>BUSTUB_ASSERT</code> 进行防御性编程，以便 DEBUG 时针对性地检测异常。</p>
<p>并发所采用的 <code>std::scope_lock</code> 实际上采用了 <a href="https://zhuanlan.zhihu.com/p/34660259">RAII</a> 的思想，简单来说就是利用类析构函数的特性来保证退出函数时必定能够释放锁，而无需手动释放，效果相当于 Go 里面的 <code>lock, defer unlock</code>。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>CMU15445 Project#2 B+ Tree</title>
    <url>/lab/15445project2/</url>
    <content><![CDATA[<p>接下来开始存储与索引部分的实现。手撕 B+ 树！</p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2022/project2/">&gt;&gt;&gt; LAB 主页传送门 &lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="Task-1-B-Tree-Pages">Task #1 - B+Tree Pages</h2>
<p>首先，在本 lab 中，B+ 树的所有节点都以 <code>BPlusTreePage</code> 即页的形式存在，其包含若干元数据。其中，根据所处位置不同，B+ 树的节点又分为内部节点(<strong>Internal node</strong>)与叶节点(<strong>Leaf node</strong>)。B+ 树的特点就是 internal node 仅用于索引，leaf node 存放真实数据，故这两者的键值对类型略有不同：</p>
<ol>
<li class="lvl-3">
<p>前者（<code>BPlusTreeInternalPage</code>）的 Value 为 child node 的索引；</p>
</li>
<li class="lvl-3">
<p>后者（<code>BPlusTreeLeafPage</code>）的 Value 为元组 RID。</p>
</li>
</ol>
<p>这便是第一个 Task 的主要任务——完善这三个数据结构。</p>
<h3 id="BPlusTreePage">BPlusTreePage</h3>
<p>基类，包含一些公共变量。</p>
<h4 id="成员变量">成员变量</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>page_type_</code>：指明该节点为内部节点还是叶节点，无需强转后判断；</p>
</li>
<li class="lvl-2">
<p><code>lsn_</code>：事务序列号，lab 4 中用到；</p>
</li>
<li class="lvl-2">
<p><code>size_</code>：当前存放的键值对数量；</p>
</li>
<li class="lvl-2">
<p><code>max_size_</code>：当前节点能容纳的最大键值对数量；</p>
</li>
<li class="lvl-2">
<p><code>parent_page_id_</code>：父节点 page_id，用于查找父节点；</p>
</li>
<li class="lvl-2">
<p><code>page_id_</code>：自身所处 Page 对象的 page_id；</p>
</li>
</ul>
<p>这些变量，或者说信息，都是 internal page 和 leaf page 共有的，这总共 <strong>24B</strong> 的不包含键值对的信息被称为 <strong>HEADER</strong>。</p>
<p>其相关的成员函数实现起来也比较简单，不再赘述。</p>
<p>btw，尽管名字里都带个 “Page”，但 lab1 和 lab2 的 “Page” 其实是不同的，<code>BPlusTreePage</code> 实际上对应了 BPM 里面 Page 对象的 <code>data_</code> 部分，因此在访问节点时，首先通过 BPM.FetchPage 方法获取 Page 对象，再将其 <code>data_</code> 部分 <code>reinterpret_cast</code> 为 <code>BPlusTreePage</code>，最后根据对应的 <code>page_type_</code> 强转为 Internal/Leaf page。具体数据排布如下图所示：</p>
<img src="image-20230111164135789.png" alt="image-20230111164135789" style="zoom:60%;">
<p>HEADER 内的 <code>page_id</code> 实际上和外层 Page 对象的 <code>page_id</code> 是相等的。</p>
<h3 id="BPlusInternalPage">BPlusInternalPage</h3>
<p>内部节点，不存放数据，仅用于索引，且 m 个 Key 对应 m+1 个 Child。基于 lab1 BPM 的实现，所有的 node 都可以通过 page_id 来进行获取，故这里的索引实际上就是 child node 对应的 page_id。</p>
<p>关于其成员函数的实现，除了原本给的，我还添加了以下函数：</p>
<ol>
<li class="lvl-3">
<p><code>Insert(const KeyType &amp;key, const ValueType &amp;value, int index)</code>：在 index 处插入 kv 对，后面所有 kv 对后移一位；</p>
</li>
<li class="lvl-3">
<p><code>Remove(int index)</code>：移除 index 处的 kv 对，后面所有元素前移一位；</p>
</li>
</ol>
<p>这在后续 BPlusTree 的 Insert/Remove 的实现中比较重要。当然，<code>BPlusLeafPage</code> 类中也包含以上两个方法。</p>
<h3 id="BPlusLeafPage">BPlusLeafPage</h3>
<p>叶节点，存放实际数据，且 m 个 Key 对应 m 个 Value。</p>
<p>根据 B+ 树的性质，所有叶节点同时以链表形式排布，从而支持 range-search。故 leaf page 的 HEADER 还要加上 4B 的 next_page_id，以索引到下一个叶节点。如果是最右边那个叶节点，则该变量为 <code>INVALID_PAGE_ID</code>。</p>
<h2 id="Task-2-B-Tree-Data-Structure">Task #2 - B+Tree Data Structure</h2>
<p>本 Task 是本 lab 的核心部分，也是最难的部分，相比于 Task1 仅仅是实现各节点的数据结构，Task2 就要开始真正手撕 B+ 树了。</p>
<h3 id="GetValue-Key">GetValue(Key)</h3>
<p>查操作较为简单，只需根据 Key 从根节点开始不断往下走即可，重点在于找 child，而不涉及多余的操作。根据 B+ 树的特性，对于 $Page_id_i$ 对应节点为根的子树中，所有 key $K$ 均满足 $Key_i \leq K &lt; Key_{i+1}$，且作索引的内部节点的第一个 Key 不参与比较。故查找子节点 page_id 所在索引的函数可以实现为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">GetChildPageIndex</span><span class="token punctuation">(</span>InternalPage <span class="token operator">*</span>internal_node<span class="token punctuation">,</span> <span class="token keyword">const</span> KeyType <span class="token operator">&amp;</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> child_index<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>child_index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> child_index <span class="token operator">&lt;</span> internal_node<span class="token operator">-&gt;</span><span class="token function">GetSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> child_index<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">comparator_</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> internal_node<span class="token operator">-&gt;</span><span class="token function">KeyAt</span><span class="token punctuation">(</span>child_index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> child_index<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Insert-Key-Value">Insert(Key, Value)</h3>
<p>B+ 树的插入规则如下：</p>
<ol>
<li class="lvl-3">
<p>若整棵树为空，则新建 root node 并作为 leaf node，进行插入；</p>
</li>
<li class="lvl-3">
<p>反之，根据 key 找到相应的叶节点 <strong>src</strong>，直接插入，注意叶节点的所有 kv 对均按照 key 递增排序；</p>
</li>
<li class="lvl-3">
<p>若插入后 src 满足 split 条件，进行 <strong>node split</strong>：</p>
<ol>
<li class="lvl-7">新建一个节点 <strong>sibling</strong>；
<blockquote>
<p>这里注意，新建 <code>BPlusTreePage</code> 对象后必须调用其 <code>Init()</code> 函数来初始化其元数据。</p>
</blockquote>
</li>
<li class="lvl-7">将 src 中的后一半 kv 对迁移到 sibling 中，若 src 为叶节点，则还需要修改 src 和 sibling 的 next page id；</li>
<li class="lvl-7">若 src 同时也是 root node，则创建一个新的根节点 new root node，插入一个新条目；</li>
<li class="lvl-7">反之，在其 parent 中插入一个新条目；</li>
</ol>
</li>
<li class="lvl-3">
<p>若 parent 因 child split 行为而导致其满足 split 条件，则继续进行 node split，直至不再满足 split 条件；</p>
</li>
</ol>
<blockquote>
<p>split 条件：</p>
<ol>
<li class="lvl-3">对于 leaf node，在插入后 size = max_size；</li>
<li class="lvl-3">对于 internal node，在插入后 size &gt; max_size；</li>
</ol>
</blockquote>
<p>实际上 Insert 是一个递归行为，每选择一个 child，就是对一棵新的 B+ 树进行 Insert 操作，故在我的实现中，定义了一个名为 <code>bool RecursivelyInsert(Key, Value, Root)</code> 的函数，其返回值表示的含义为：若为 <code>true</code>，则说明 child 满足 split 条件，由 parent 来执行 child node split，最后告知 parent 的 “grandparent” 其是否满足 split 条件；反之，此节点不进行任何操作，直接返回 <code>false</code>。</p>
<p>在 <code>Insert()</code> 中调用 <code>RecursivelyInsert()</code> 实际上是对 root 进行递归插入，所以如果返回值为 true，需要进行 root 的 split，相比其它节点而言多了一个新建 new root node 的操作。</p>
<blockquote>
<p>有个需要注意的点是，这里的 B+ 树仅支持 <strong>unique key</strong>，对相同 key 的重复插入会被认为是插入失败。</p>
</blockquote>
<p>基于上述讨论，总体过程大概如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">Insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> KeyType <span class="token operator">&amp;</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> ValueType <span class="token operator">&amp;</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 新建 root node 后直接插入</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">bool</span> need_split <span class="token operator">=</span> <span class="token function">RecursivelyInsert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> root_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>need_split<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 新建 new root node 和 sibling node</span>
    <span class="token comment">// 2. 若为叶节点，需修改 next_page_id</span>
    <span class="token comment">// 3. 移动一半 kv 对</span>
    <span class="token comment">// 4. 插入新条目</span>
    <span class="token comment">// 5. 修改 root_page_id_</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> success<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">bool</span> <span class="token function">RecursivelyInsert</span><span class="token punctuation">(</span><span class="token keyword">const</span> KeyType <span class="token operator">&amp;</span>key<span class="token punctuation">,</span> <span class="token keyword">const</span> ValueType <span class="token operator">&amp;</span>value<span class="token punctuation">,</span> BPlusTreePage <span class="token operator">*</span>cur_node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cur_node<span class="token operator">-&gt;</span><span class="token function">IsLeafPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 直接插入 leaf node</span>
    <span class="token keyword">return</span> leaf_node<span class="token operator">-&gt;</span><span class="token function">GetSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;=</span> leaf_node<span class="token operator">-&gt;</span><span class="token function">GetMaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">bool</span> res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token keyword">bool</span> need_split <span class="token operator">=</span> <span class="token function">RecursivelyInsert</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> child_node<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>need_split<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 1. 新建 sibling node</span>
    <span class="token comment">// 2. 若为叶节点，需修改 next_page_id</span>
    <span class="token comment">// 3. 移动一半 kv 对</span>
    <span class="token comment">// 4. 插入新条目</span>
    res <span class="token operator">=</span> cur_node<span class="token operator">-&gt;</span><span class="token function">GetSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> cur_node<span class="token operator">-&gt;</span><span class="token function">GetMaxSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Remove-Key">Remove(Key)</h3>
<p>删除规则和插入大体类似：</p>
<ol>
<li class="lvl-3">
<p>根据 key 找到相应的叶节点 <strong>src</strong>；</p>
</li>
<li class="lvl-3">
<p>若删除后 src 满足 merge 条件，则进行 <strong>node merge</strong>：</p>
<ol>
<li class="lvl-7">先看看自己的左右兄弟中任何一个是否能借一个 kv 对，条件是其借出后不会使得自身满足 merge 条件；</li>
<li class="lvl-7">若能借到，则修改 parent 相应条目；</li>
<li class="lvl-7">反之，挑选一个 sibling，将它俩合并，规则为，右侧的 node 将其所有 kv 对迁移到左侧的 node 中，并删除 parent 中相应条目；</li>
</ol>
</li>
<li class="lvl-3">
<p>若父节点因 child merge 行为而导致其满足 merge 条件，则继续进行 node merge，直至不再满足 merge 条件；</p>
</li>
</ol>
<blockquote>
<p>merge 条件：</p>
<ol>
<li class="lvl-3">对于 root node
<ol>
<li class="lvl-7">若为 leaf node，删除后 size = 0；</li>
<li class="lvl-7">若为 internal node，删除后 size = 1；</li>
</ol>
</li>
<li class="lvl-3">对于非 root node
<ol>
<li class="lvl-7">若为 leaf node，删除后 size &lt; min_size；</li>
<li class="lvl-7">若为 internal node，删除后 size &lt;= min_size；</li>
</ol>
</li>
</ol>
<blockquote>
<p>min_size = max_size / 2</p>
</blockquote>
</blockquote>
<p>它同样是个递归行为，我也定义了一个 <code>RecursivelyRemove()</code> 函数，流程和 insert 大体一致，不同之处在于 sibling 的挑选，需要考虑当前 child 是否为 parent 最左侧/最右侧的 child。</p>
<h2 id="Task-3-Index-Iterator">Task #3 - Index Iterator</h2>
<p>这一 Task 相对而言简单许多，首先需要我们完善 <code>IndexIterator</code> 类，实现其四个运算符（<code>*</code>, <code>++</code>, <code>==</code>, <code>!=</code>）以及一个 <code>IsEnd()</code> 函数，还需要我们完善 <code>BPlusTreePage</code> 类中的 <code>Begin()</code> 与 <code>End()</code> 函数，其分别返回一个 <code>IndexIterator</code>。总体而言还是不难的。</p>
<h3 id="IndexIterator">IndexIterator</h3>
<p>由于 <code>IndexIterator</code> 是遍历 leaf node 的迭代器，故需要记录当前 kv 对的一些信息，如所在的 leaf page 以及当前 kv 对所在下标，即：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">BPlusTreeLeafPage<span class="token operator">&lt;</span>KeyType<span class="token punctuation">,</span> ValueType<span class="token punctuation">,</span> KeyComparator<span class="token operator">&gt;</span> <span class="token operator">*</span>cur_page_<span class="token punctuation">;</span>
<span class="token keyword">int</span> cur_index_<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p><code>IsEnd()</code> 只需判断当前 Page 指针是否为 <code>nullptr</code> 即可。</p>
<p><code>==</code> 运算符不仅需要判断两个迭代器所处的 Page 的 page_id 及 index 是否相等，还需要在最开始加上 IsEnd() 的判断。</p>
<h3 id="Begin-End">Begin / End</h3>
<p><code>Begin</code> 有两个重载函数，一个是无参 <code>Begin()</code>，只要找到 B+ 树中最左边那个叶节点即可。</p>
<p>另一个是 <code>Begin(Key)</code>，返回的 <code>IndexIterator</code> 需满足对应的 key $K &lt;= Key$，这与之前实现的 <code>GetValue</code> 有异曲同工之妙。</p>
<h2 id="Task-4-Concurrent-Index">Task #4 - Concurrent Index</h2>
<p>这一 Task 要求我们在原先的基础上，令 B+ 树支持并发操作，这里需要用到的一个思路就是 <strong>Lock Crabbing</strong>。</p>
<p>如果要实现不冲突的并发操作，最朴素的想法是从 root 开始，一直到 leaf 这条路径上的所有 node 依次上锁，完成递归操作后依次解锁，直至所有锁都释放。</p>
<p>但这样就将并发变成了纯粹的 Serialized Operation，还不如直接对整个 B+ 树上一把大锁。实际上有些 node 可能并不需要这把锁，也就是说事务的这次 Insert/Remove 操作并不会对该 node 造成任何影响，完全可以直接解锁，让其它事务尽快获得该 node 上的锁，从而提高吞吐率。而对于 GetValue 操作，目的是读取 leaf node 上的数据，internal node 在索引完后就失去了其作用，因此也可以直接解锁。</p>
<p>那么问题来了，如何判断当前 node 需不需要提早解锁呢？在 B+ 树中，如果一个 node 无论是否 Insert/Remove 某一 kv 对都不满足 split/merge 条件，那么其 parent 也不会因为本次操作而改变自身所存放的 kv 对数量，我们就认为这样一个 node 是 <strong>Safe</strong> 的。如果在 Insert/Remove 操作中，某一 node 所引导的 child node 是 safe 的，那么无论什么情况，本次操作都不会对该 node 及其所有祖先产生影响，可以直接解除从 root 到该 node 的所有锁。</p>
<p>于是之前的 Insert/Remove 操作流程就变成了：</p>
<ol>
<li class="lvl-3">
<p>找到 child node；</p>
</li>
<li class="lvl-3">
<p>判断是否 safe，若是，则解锁，反之，等待操作结束后马上要退出递归了再解锁；</p>
</li>
<li class="lvl-3">
<p>对 child node 进行递归操作；</p>
</li>
<li class="lvl-3">
<p>操作结束后，根据是否提前解锁来判断此时是否需要解锁；</p>
</li>
<li class="lvl-3">
<p>返回至上层；</p>
</li>
</ol>
<blockquote>
<p>不能直接通过判断 child node 是否 safe 来判断有无提早解锁，因为 child node 可能在操作的过程中 size 发生了改变。实际上，Insert/Remove 函数的参数中有一个名为 <code>Transaction</code> 的变量，其内部有一个双端队列(<strong>std::deque</strong>)用来维护持有锁的情况，从队首到队尾依次为 root 到 leaf 这条路径上的所有 <code>BPlusTreePage</code>，提前解锁相当于 <code>pop_front()</code>。而当操作结束后，若当前锁队列非空，说明未提前解锁，故需要解锁，相当于 <code>pop_back()</code>。</p>
<p>这样加就能够保证递归返回时，所有子孙后代都已经解锁，若当前锁队列非空，说明当前 node 一直到 leaf 这条路径上都没发生过提前解锁事件，队列末端必定为当前 node。</p>
</blockquote>
<p>我这里是上了一把大锁，防止 root node 出现改变的情况，在锁队列中表现为一个空指针，即如果待解锁页面为 <code>nullptr</code>，则说明需要把大锁给解锁了。</p>
<p>当然也可以改为持续获取 root node，直至其为真正的 root node（事务首次访问到 root 时尝试上锁，然后等待至持有时 root 可能已经发生变化，即当前 node 已不为 root，需要重复之前的操作），但经过分析，这和上一把大锁没有区别：</p>
<ol>
<li class="lvl-3">
<p>若 root 不会发生变化，说明到 leaf 的这条路径上必然有一个 node 是 safe 的，会直接将大锁解除；</p>
</li>
<li class="lvl-3">
<p>反之，大锁会在 root page id 完成更新后解除，若采用法 2，解锁时机并没有发生变化，下一个事务依然会在同一时刻获取到最新 root node 的锁；</p>
</li>
</ol>
<h2 id="总结">总结</h2>
<p>课程组很贴心地为我们提供了 <strong>b_plus_tree_printer</strong> 这样的工具，生成 <code>.dot</code> 文件后可以直接复制到<a href="http://dreampuf.github.io/GraphvizOnline/">这个网站</a>上进行图像生成。当然，也可以<a href="https://15445.courses.cs.cmu.edu/fall2022/bpt-printer/">直接在浏览器上运行命令行</a>。将 B+ 树可视化，更方便我们 debug。</p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">这个网站</a>也为我们提供了 B+ 树各个操作的可视化过程，适合入门学习。</p>
<p>本 lab 的实现难度还是挺大的，debug 过程非常吃力，尤其是 GradeScope 不提供测试代码，打印 LOG 还有概率发生 error，跟 6.824 直接公开测试用例的做法比起来还是对小白恶意更大一些，不过手撕完 B+ 树的那种神清气爽还是前所未有的。</p>
<p>当然，还是要善用 BUSTUB_ASSERT 进行防御性编程。</p>
<h2 id="题外话：为什么用-B-Tree-而不是-B-Tree">题外话：为什么用 B+ Tree 而不是 B Tree</h2>
<p>主要有三点原因：</p>
<ol>
<li class="lvl-3">
<p>B+ 树的 internal 节点仅存放索引，因此数据量相同的情况下，同样的磁盘块大小，相比内部节点既存索引又存记录的 B 树，B+ 树的 internal 节点可以存放更多的索引，因此 B+ 树可以比 B 树更<strong>矮胖</strong>，查询叶节点的磁盘 I/O 次数会更少。</p>
</li>
<li class="lvl-3">
<p>B+ 树插入、删除的效率更高，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；</p>
</li>
<li class="lvl-3">
<p>B+ 树的所有叶子节点之间用链表连接了起来，有利于范围查询，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，效率不如 B+ 树；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.824 Lab1 MapReduce</title>
    <url>/lab/6-824lab1/</url>
    <content><![CDATA[<p>本实验要求我们构建一个分布式的 MapReduce 系统，并实现 paper 中提到的文章字数统计算法。</p>
<span id="more"></span>
<h2 id="参考资料">参考资料</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>描述该系统模型的<a href="https://pdos.csail.mit.edu/6.824/papers/mapreduce.pdf">论文</a>；</p>
</li>
<li class="lvl-2">
<p>我的<a href="../mapreduce">另一篇文章</a>是对该论文的解读；</p>
</li>
</ul>
<h2 id="实现">实现</h2>
<p>由于 paper 中已经给了算法流程图，只需要严格遵循该图即可。</p>
<h3 id="Coordinator">Coordinator</h3>
<blockquote>
<p>其实就是 paper 中的 Master</p>
</blockquote>
<p>因为不涉及 MapReduce 具体操作，总体而言比较简单。</p>
<h4 id="结构体">结构体</h4>
<p>Coordinator 负责任务调度以及维护任务状态，正如 paper 中提到的那样。同时，为了记录一个 Worker 是否超时未回应，需维护每个任务开始的时间戳。</p>
<p>于是结构体可以如下定义：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> TaskState <span class="token builtin">int</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
    IDLE TaskState <span class="token operator">=</span> <span class="token boolean">iota</span>
    IN_PROGRESS
    COMPLETED
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Coordinator <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    files <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span>

    MapTask      <span class="token punctuation">[</span><span class="token punctuation">]</span>TaskState
    ReduceTask      <span class="token punctuation">[</span><span class="token punctuation">]</span>TaskState

    MapStartTimeStamp    <span class="token punctuation">[</span><span class="token punctuation">]</span>time<span class="token punctuation">.</span>Time
    ReduceStartTimeStamp <span class="token punctuation">[</span><span class="token punctuation">]</span>time<span class="token punctuation">.</span>Time

    M     <span class="token builtin">int</span> <span class="token comment">// total map tasks</span>
    R     <span class="token builtin">int</span> <span class="token comment">// total reduce tasks</span>
    Mcnt  <span class="token builtin">int</span> <span class="token comment">// completed map tasks</span>
    Rcnt  <span class="token builtin">int</span> <span class="token comment">// completed reduce tasks</span>

    State TaskType <span class="token comment">// current Execution State</span>
    lock  sync<span class="token punctuation">.</span>RWMutex
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="任务调度">任务调度</h4>
<p>根据规则 <strong>“reduces can’t start until the last map has finished”</strong>，任务调度应当基于当前 MapReduce 执行阶段，即在所有 map 任务被标记为 <code>completed</code> 后才能进行 reduce 任务的调度，否则 reduce Worker 将未能读取部分数据。</p>
<p>各个阶段中任务调度的思想都是一样的，收到一个 Arrange RPC 时，Coordinator 找出一个 <code>idle</code> 或 <code>timeout</code> 的任务并分配；如果没有这样的任务，则需通知 Worker 等待。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Coordinator<span class="token punctuation">)</span> <span class="token function">Arrange</span><span class="token punctuation">(</span>message <span class="token operator">*</span>Args<span class="token punctuation">,</span> reply <span class="token operator">*</span>Reply<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> m<span class="token punctuation">.</span>Rcnt <span class="token operator">==</span> m<span class="token punctuation">.</span>R <span class="token punctuation">{</span> <span class="token comment">// all tasks completed</span>
        reply<span class="token punctuation">.</span>Over <span class="token operator">=</span> <span class="token boolean">true</span>
        <span class="token keyword">return</span> <span class="token boolean">nil</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> m<span class="token punctuation">.</span>State <span class="token operator">==</span> MAP <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">.</span>M<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
            <span class="token comment">// the task_i is as-yet-unstarted or time-out</span>
            <span class="token keyword">if</span> m<span class="token punctuation">.</span>MapTask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> IDLE <span class="token operator">||</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span>MapTask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> IN_PROGRESS <span class="token operator">&amp;&amp;</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>MapStartTimeStamp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                reply<span class="token punctuation">.</span>Task <span class="token operator">=</span> MAP
                reply<span class="token punctuation">.</span>Wait <span class="token operator">=</span> <span class="token boolean">false</span>
                reply<span class="token punctuation">.</span>Filename <span class="token operator">=</span> m<span class="token punctuation">.</span>files<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
                reply<span class="token punctuation">.</span>R <span class="token operator">=</span> m<span class="token punctuation">.</span>R
                reply<span class="token punctuation">.</span>MapTaskNumber <span class="token operator">=</span> i
                reply<span class="token punctuation">.</span>TimeStamp <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

                m<span class="token punctuation">.</span>MapStartTimeStamp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> reply<span class="token punctuation">.</span>TimeStamp
                m<span class="token punctuation">.</span>MapTask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> IN_PROGRESS
                <span class="token keyword">return</span> <span class="token boolean">nil</span>
            <span class="token punctuation">}</span>
       <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> m<span class="token punctuation">.</span>State <span class="token operator">==</span> REDUCE <span class="token punctuation">{</span>
        <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">.</span>R<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
            <span class="token comment">// the task_i is as-yet-unstarted or time-out</span>
            <span class="token keyword">if</span> m<span class="token punctuation">.</span>ReduceTask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> IDLE <span class="token operator">||</span> <span class="token punctuation">(</span>m<span class="token punctuation">.</span>ReduceTask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> IN_PROGRESS <span class="token operator">&amp;&amp;</span> time<span class="token punctuation">.</span><span class="token function">Since</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>ReduceStartTimeStamp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span><span class="token operator">*</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                reply<span class="token punctuation">.</span>Task <span class="token operator">=</span> REDUCE
                reply<span class="token punctuation">.</span>M <span class="token operator">=</span> m<span class="token punctuation">.</span>M
                reply<span class="token punctuation">.</span>ReduceTaskNumber <span class="token operator">=</span> i
                reply<span class="token punctuation">.</span>TimeStamp <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                m<span class="token punctuation">.</span>ReduceStartTimeStamp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> reply<span class="token punctuation">.</span>TimeStamp
                m<span class="token punctuation">.</span>ReduceTask<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> IN_PROGRESS
                m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token keyword">return</span> <span class="token boolean">nil</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// no more as-yet-unstarted tasks</span>
    reply<span class="token punctuation">.</span>Wait <span class="token operator">=</span> <span class="token boolean">true</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="完成通知">完成通知</h4>
<p>同样的，需要忽略那些过期回复。考虑这种场景，Coordinator 发给 WorkerA 的任务超时未完成，然后将该任务调度给 WorkerB，但从 WorkerA 的视角来看，它已经完成了该任务，并发送了完成通知，只不过该通知因为网络拥塞或其他原因过了很久才被 Coordinator 收到，Coordinator 如何判断这个通知是不是当前正在执行该任务的 Worker 发送的呢？一个思路是可以维护每个任务当前被哪个 Worker 执行，在这种情况下，任务的当前执行者为 B，那么收到 A 的通知后理所当然会将其忽略。</p>
<p>但还不足够，设想一下，如果 B 也因为同样原因超时，任务再一次调度给了 A 呢？虽然任务当前执行者为 A，但 A 并未完成，Coordinator 收到的是非常古老的那条消息，此时将任务设为 <code>completed</code>，显然会出现问题——A 并没有完成任务，尽管它"完成"过一次。</p>
<p>考虑到 Coordinator 结构体里维护了每个任务的开始时间戳，不妨令任务调度与完成通知中都捎带本次任务的 StartTime，这样就可以进行检查，如果一致则正确接收；反之视为过期消息。这样做减少了额外信息维护，也提高了安全性。</p>
<blockquote>
<p>这其实就相当于分配了一个递增的<strong>版本号</strong>了。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// an RPC handler to tell the Coordinator that the worker finishes the task</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>Coordinator<span class="token punctuation">)</span> <span class="token function">Finished</span><span class="token punctuation">(</span>message <span class="token operator">*</span>Args<span class="token punctuation">,</span> reply <span class="token operator">*</span>Reply<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
    m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">defer</span> m<span class="token punctuation">.</span>lock<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">if</span> message<span class="token punctuation">.</span>Finished <span class="token operator">==</span> MAP <span class="token punctuation">{</span>
        <span class="token keyword">if</span> m<span class="token punctuation">.</span>MapStartTimeStamp<span class="token punctuation">[</span>message<span class="token punctuation">.</span>MapTaskNumber<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>TimeStamp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            reply<span class="token punctuation">.</span>Wait <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token keyword">return</span> <span class="token boolean">nil</span>
        <span class="token punctuation">}</span>
        m<span class="token punctuation">.</span>MapTask<span class="token punctuation">[</span>message<span class="token punctuation">.</span>MapTaskNumber<span class="token punctuation">]</span> <span class="token operator">=</span> COMPLETED
        m<span class="token punctuation">.</span>Mcnt<span class="token operator">++</span>
        <span class="token keyword">if</span> m<span class="token punctuation">.</span>Mcnt <span class="token operator">==</span> m<span class="token punctuation">.</span>M <span class="token punctuation">{</span>
            m<span class="token punctuation">.</span>State <span class="token operator">=</span> REDUCE
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> m<span class="token punctuation">.</span>ReduceStartTimeStamp<span class="token punctuation">[</span>message<span class="token punctuation">.</span>ReduceTaskNumber<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span>TimeStamp<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>
            reply<span class="token punctuation">.</span>Wait <span class="token operator">=</span> <span class="token boolean">true</span>
            <span class="token keyword">return</span> <span class="token boolean">nil</span>
        <span class="token punctuation">}</span>
        m<span class="token punctuation">.</span>ReduceTask<span class="token punctuation">[</span>message<span class="token punctuation">.</span>ReduceTaskNumber<span class="token punctuation">]</span> <span class="token operator">=</span> COMPLETED
        m<span class="token punctuation">.</span>Rcnt<span class="token operator">++</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Worker">Worker</h3>
<p>Worker 就涉及具体的 MapReduce 操作了，好在课程给的代码提供了 <code>map/reduce</code> 函数，我们只需要关注对输入输出的处理即可。在本系统中，任务的调度采用 Worker pull 而非 Coordinator push 的策略。Worker 需不断请求任务，然后根据回复内容执行对应的操作：</p>
<ol>
<li class="lvl-3">
<p>如果所有任务已结束，reply 告知 Over，关闭线程；</p>
</li>
<li class="lvl-3">
<p>如果没有任务能分配，则调用 <code>time.Sleep()</code> 等待一段时间；</p>
</li>
<li class="lvl-3">
<p>如果收到一个 map 任务，此时 reply 会捎带所要操作的文件名，然后对文件进行 map 操作（这里需要去 mrsequential.go 里参考一下代码）。由于它这里需要考虑线程崩溃，先把结果写到临时文件，全部写完后（说明没有发生 crash）再输出到 <code>/mr-tmp</code> 中，那么 mrsequential.go 里的代码就不能完全照搬了。</p>
<p>我的做法是，开一个长度为 nReduce，类型为 []KeyValue 的切片 <code>temp</code>，其中 <code>temp[i]</code> 存放输出到 <code>mr-X-i</code> 中的所有 kv 对，先把所有 kv 对按照 key 的hash 值写到对应的 <code>temp[hash(key) % nReduce]</code> 里，再逐个写到临时文件中。</p>
<blockquote>
<p>示例提供的 json.Encoder() 在第二次及以后打开的时候不会在末尾添加，而是直接覆盖。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>reduce 任务大体类似，就是读取 <code>mr-X-Y</code> 文件。因为 Y 是固定的，所以 reply 要捎带 nMap。也是要对 mrsequential.go 里的代码进行一些修改。</p>
<blockquote>
<p>这里遇到一个坑点，和 paper 中所描述的产生了冲突。就是输出文件如果存在就不进行 <code>os.Rename()</code>，否则在 crash test 中会出现 <code>mr-X-?</code> 都有内容而 <code>mr-out-?</code> 没有内容的情况。合理猜测是读取 mr-X-Y 的时候出了点什么问题。</p>
</blockquote>
</li>
</ol>
<h4 id="执行">执行</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">Worker</span><span class="token punctuation">(</span>mapf <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">,</span>
            reducef <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token comment">// One way to get started is to modify mr/worker.go's Worker()</span>
    <span class="token comment">// to send an RPC to the coordinator asking for a task.</span>
    <span class="token keyword">for</span> <span class="token punctuation">{</span>
        reply <span class="token operator">:=</span> <span class="token function">AskForTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> reply<span class="token punctuation">.</span>Over <span class="token punctuation">{</span>
            <span class="token keyword">return</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">if</span> reply<span class="token punctuation">.</span>Wait <span class="token punctuation">{</span>
            time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>WorkerWaitTime<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> reply<span class="token punctuation">.</span>Task <span class="token operator">==</span> MAP <span class="token punctuation">{</span>
            <span class="token comment">// map phase</span>
            mapTaskNumber <span class="token operator">:=</span> reply<span class="token punctuation">.</span>MapTaskNumber

            <span class="token comment">// read file</span>
            file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>reply<span class="token punctuation">.</span>Filename<span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"cannot open %v"</span><span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Filename<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            content<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadAll</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span>
            <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                log<span class="token punctuation">.</span><span class="token function">Fatalf</span><span class="token punctuation">(</span><span class="token string">"cannot read %v"</span><span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Filename<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            kvs <span class="token operator">:=</span> <span class="token function">mapf</span><span class="token punctuation">(</span>reply<span class="token punctuation">.</span>Filename<span class="token punctuation">,</span> <span class="token function">string</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">)</span>

            <span class="token comment">// write kv into file buckets</span>
            <span class="token comment">// key -&gt; filename: "ihash(key)"</span>
            temp <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>R<span class="token punctuation">)</span>
            <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> temp <span class="token punctuation">{</span>
                temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> kv <span class="token operator">:=</span> <span class="token keyword">range</span> kvs <span class="token punctuation">{</span>
                hash <span class="token operator">:=</span> <span class="token function">ihash</span><span class="token punctuation">(</span>kv<span class="token punctuation">.</span>Key<span class="token punctuation">)</span> <span class="token operator">%</span> reply<span class="token punctuation">.</span>R
                temp<span class="token punctuation">[</span>hash<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>temp<span class="token punctuation">[</span>hash<span class="token punctuation">]</span><span class="token punctuation">,</span> kv<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>

            <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
                ofile<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">TempFile</span><span class="token punctuation">(</span><span class="token string">"./mr/mapfile"</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>
                enc <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewEncoder</span><span class="token punctuation">(</span>ofile<span class="token punctuation">)</span>
                <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> kv <span class="token operator">:=</span> <span class="token keyword">range</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">{</span>
                    enc<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kv<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>

                old_path <span class="token operator">:=</span> ofile<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                new_path <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"../main/mr-tmp/mr-%d-%d"</span><span class="token punctuation">,</span> mapTaskNumber<span class="token punctuation">,</span> i<span class="token punctuation">)</span>

                os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>old_path<span class="token punctuation">,</span> new_path<span class="token punctuation">)</span>
                ofile<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>

            <span class="token comment">// tell the master that the map job is done</span>
            <span class="token function">CallFinish</span><span class="token punctuation">(</span>MAP<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>TimeStamp<span class="token punctuation">,</span> mapTaskNumber<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
            <span class="token comment">// reduce phase</span>
            reduceTaskNumber <span class="token operator">:=</span> reply<span class="token punctuation">.</span>ReduceTaskNumber

            <span class="token comment">// read file</span>
            ofile<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">TempFile</span><span class="token punctuation">(</span><span class="token string">"./mr/reducefile"</span><span class="token punctuation">,</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> reduceTaskNumber<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token keyword">var</span> kva <span class="token punctuation">[</span><span class="token punctuation">]</span>KeyValue
            <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> reply<span class="token punctuation">.</span>M<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
                iFilename <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"../main/mr-tmp/mr-%d-%d"</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> reduceTaskNumber<span class="token punctuation">)</span>
                iFile<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>iFilename<span class="token punctuation">)</span>
                <span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                    dec <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">NewDecoder</span><span class="token punctuation">(</span>iFile<span class="token punctuation">)</span>
                    <span class="token keyword">for</span> <span class="token punctuation">{</span>
                        <span class="token keyword">var</span> kv KeyValue
                        <span class="token keyword">if</span> err <span class="token operator">:=</span> dec<span class="token punctuation">.</span><span class="token function">Decode</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>kv<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                            <span class="token keyword">break</span>
                        <span class="token punctuation">}</span>
                        kva <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>kva<span class="token punctuation">,</span> kv<span class="token punctuation">)</span>
                    <span class="token punctuation">}</span>
                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
                    log<span class="token punctuation">.</span><span class="token function">Fatal</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            sort<span class="token punctuation">.</span><span class="token function">Sort</span><span class="token punctuation">(</span><span class="token function">ByKey</span><span class="token punctuation">(</span>kva<span class="token punctuation">)</span><span class="token punctuation">)</span>
            i <span class="token operator">:=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> i <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>kva<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                j <span class="token operator">:=</span> i <span class="token operator">+</span> <span class="token number">1</span>
                <span class="token keyword">for</span> j <span class="token operator">&lt;</span> <span class="token function">len</span><span class="token punctuation">(</span>kva<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> kva<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token operator">==</span> kva<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key <span class="token punctuation">{</span>
                    j<span class="token operator">++</span>
                <span class="token punctuation">}</span>
                values <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
                <span class="token keyword">for</span> k <span class="token operator">:=</span> i<span class="token punctuation">;</span> k <span class="token operator">&lt;</span> j<span class="token punctuation">;</span> k<span class="token operator">++</span> <span class="token punctuation">{</span>
                    values <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>values<span class="token punctuation">,</span> kva<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>Value<span class="token punctuation">)</span>
                <span class="token punctuation">}</span>
                output <span class="token operator">:=</span> <span class="token function">reducef</span><span class="token punctuation">(</span>kva<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> values<span class="token punctuation">)</span>

                <span class="token comment">// this is the correct format for each line of Reduce output.</span>
                fmt<span class="token punctuation">.</span><span class="token function">Fprintf</span><span class="token punctuation">(</span>ofile<span class="token punctuation">,</span> <span class="token string">"%v %v\n"</span><span class="token punctuation">,</span> kva<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>Key<span class="token punctuation">,</span> output<span class="token punctuation">)</span>

                i <span class="token operator">=</span> j
            <span class="token punctuation">}</span>

            old_path <span class="token operator">:=</span> ofile<span class="token punctuation">.</span><span class="token function">Name</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            new_path <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"../main/mr-tmp/mr-out-%d"</span><span class="token punctuation">,</span> reduceTaskNumber<span class="token punctuation">)</span>

            <span class="token comment">// no reduce task finished yet before</span>
            <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>new_path<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
                os<span class="token punctuation">.</span><span class="token function">Rename</span><span class="token punctuation">(</span>old_path<span class="token punctuation">,</span> new_path<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            ofile<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

            <span class="token comment">// tell the master that the reduce job is done</span>
            <span class="token function">CallFinish</span><span class="token punctuation">(</span>REDUCE<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>TimeStamp<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> reduceTaskNumber<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="RPC">RPC</h3>
<p>综上所述，RPC 的结构体定义就呼之欲出了。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> Args <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Finished TaskType

  TimeStamp time<span class="token punctuation">.</span>Time

  MapTaskNumber    <span class="token builtin">int</span>
  ReduceTaskNumber <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Reply <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Task TaskType
  Wait <span class="token builtin">bool</span> <span class="token comment">// true for wait</span>
  Over <span class="token builtin">bool</span> <span class="token comment">// true for done</span>

  Filename <span class="token builtin">string</span>
  M        <span class="token builtin">int</span>
  R        <span class="token builtin">int</span>

  MapTaskNumber    <span class="token builtin">int</span>
  ReduceTaskNumber <span class="token builtin">int</span>

  TimeStamp time<span class="token punctuation">.</span>Time
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>CMU15445 Project#3 Query Execution</title>
    <url>/lab/15445project3/</url>
    <content><![CDATA[<p>到目前为止，咱们已经完成了存储与索引部分的功能实现，接下来就进入执行层面的内容了。</p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2022/project3/">&gt;&gt;&gt; LAB 主页传送门 &lt;&lt;&lt;</a></p>
<span id="more"></span>
<p>在 Bustub 框架下，执行层面采用<a href="https://zhuanlan.zhihu.com/p/219516250">火山模型</a>，又称 Iterator 模型。该计算模型将关系代数中每一种操作抽象为一个 Operator，将整个 SQL 构建成一个 Operator 树，从根节点到叶子结点自上而下地递归调用 <code>Next()</code> 函数，结果就如同流水线一般自底向上返回，并被处理。</p>
<p>这里的结果均用表中的行，或称元组(<strong>Tuple</strong>)，表示。</p>
<blockquote>
<p>Tuple 实际上是虚拟表的一行或一行中某几个连续的单元格按照规定模式组成的集合。</p>
</blockquote>
<p>换句话说，上层节点的 <code>Next()</code> 会调用下层节点的 <code>Next()</code> 函数取得一个 Tuple，将其处理后返回给更上层节点。</p>
<blockquote>
<p>跟另一种方式（节点一次处理完所有数据后一并返回给上层）相比，增加了吞吐率，但缺点在于增加了函数递归调用的开销。</p>
</blockquote>
<p>该 Task 在 code 层面难度并不大，甚至不如 lab1，真正的难度在于熟悉整个框架下数据的排布以及不同数据结构的含义。</p>
<p>课程组已经为我们提供了一部分 Operator 的实现，就先从 Projection 算子开始熟悉一下整个执行层所涉及到的内容。</p>
<h2 id="Sample-ProjectionExcecutor">Sample - ProjectionExcecutor</h2>
<p>Projection 算子的构造函数如下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">ProjectionExecutor</span><span class="token double-colon punctuation">::</span><span class="token function">ProjectionExecutor</span><span class="token punctuation">(</span>ExecutorContext <span class="token operator">*</span>exec_ctx<span class="token punctuation">,</span> <span class="token keyword">const</span> ProjectionPlanNode <span class="token operator">*</span>plan<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span>AbstractExecutor<span class="token operator">&gt;</span> <span class="token operator">&amp;&amp;</span>child_executor<span class="token punctuation">)</span><span class="token operator">:</span>
  <span class="token function">AbstractExecutor</span><span class="token punctuation">(</span>exec_ctx<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">plan_</span><span class="token punctuation">(</span>plan<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">child_executor_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>child_executor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="ExecutorContext">ExecutorContext</h3>
<p>这是每个算子在构造时都会获得的一个参数，即执行上下文，其包含当前 SQL 语句处理时相应的信息，包含：<code>Transaction</code>，<code>BufferPoolManager</code>，<code>TransactionManager</code>，<code>LockManager</code> 以及 <code>Catalog</code>。</p>
<blockquote>
<p>这里最关键的就是 <code>Catalog</code>，下面单独讲。</p>
</blockquote>
<h3 id="Catalog">Catalog</h3>
<p>它维护当前数据库的目录信息，包括所有表信息(<strong>TableInfo</strong>)以及索引信息(<strong>IndexInfo</strong>)。Bustub 框架下，所有 Table/Index 都有一个唯一标识符 <code>table_oid</code> / <code>index_oid</code>，以及唯一的表名 <code>table_name</code> / 索引名 <code>index_name</code>，在 <code>Catalog</code> 中，可以通过这些标识符通过自带的 <code>GetTable()</code> / <code>GetIndex()</code> 函数来检索到信息。</p>
<h4 id="TableInfo">TableInfo</h4>
<p>特定 Table 的所有信息，包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>schema_</code>：表的输出模式，指明 Table 每一列的类型、列名；</p>
</li>
<li class="lvl-2">
<p><code>name_</code>：表名；</p>
</li>
<li class="lvl-2">
<p><code>table_</code>：指向 TableHeap，其实就是表在磁盘上的所有物理页面组成的双向链表；</p>
</li>
<li class="lvl-2">
<p><code>oid</code>：表标识符；</p>
</li>
</ul>
<h4 id="IndexInfo">IndexInfo</h4>
<p>某一 Table 上特定 Index 的所有信息，包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>key_schema_</code>：指明在哪些列（Key）上建立的 Index；</p>
</li>
<li class="lvl-2">
<p><code>name_</code>：索引名；</p>
</li>
<li class="lvl-2">
<p><code>index_</code>：指向对应索引的数据结构，这里是之前就实现过的 B+ 树；</p>
</li>
<li class="lvl-2">
<p><code>index_oid_</code>：索引标识符；</p>
</li>
<li class="lvl-2">
<p><code>table_name_</code>：索引所在表名；</p>
</li>
</ul>
<h3 id="PlanNode">PlanNode</h3>
<p>当用户输入一句 SQL 查询时，SQL 层会先解析该语句，先生成一棵 AST 抽象语法树，接下来 Plan 层将该 AST 经过 Optimization 层优化后生成一棵 PlanNodeTree，指明该 SQL 语句应该以怎样的顺序从 Table 中获取数据.</p>
<p>下图就是语句 <code>(SELECT * FROM table_1, table_2 WHERE colA = colB) GROUP BY colA; </code> 对应的 PNT：</p>
<img src="image-20230112151707548.png" alt="image-20230112151707548" style="zoom:67%;">
<blockquote>
<p>在火山模型下，执行顺序为顺序扫描-&gt;嵌套循环连接-&gt;聚合</p>
</blockquote>
<p>PNT 上的所有 node 在执行层就对应了不同的 Operator，Operator 接收 Plan 作为参数，就知道自己的工作具体细节是什么。一个 Plan 根据类型不同，可能包含（但不限于）以下信息：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>output_schema_</code>：输出模式，规定了传递给上层算子的 Tuple 格式；</p>
</li>
<li class="lvl-2">
<p><code>children_</code>：子节点；</p>
</li>
<li class="lvl-2">
<p><code>expressions_</code>：用于筛选，像上面的 <code>ColA = ColB</code> 就是一个 Expression。其自身带有一个 <code>Evaluate()</code> 函数，接受一个 Tuple，并判断其是否满足条件。在 Join 操作中，其也有一个 <code>EvaluateJoin</code> 函数，适用于<code>xx join xx on (Expression)</code> 型的查询；</p>
</li>
</ul>
<h3 id="Projection-执行过程">Projection 执行过程</h3>
<p>Projection 操作实际上是语句 <code>SELECT col_name FROM table_name</code> 的具象化，在 PNT 中其接收 <code>SELECT</code> 部分对应算子返回表的所有 Tuple，然后选取 col_name 对应的列，构造新的 Tuple 进行返回。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">ProjectionExecutor</span><span class="token double-colon punctuation">::</span><span class="token function">Next</span><span class="token punctuation">(</span>Tuple <span class="token operator">*</span>tuple<span class="token punctuation">,</span> RID <span class="token operator">*</span>rid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Tuple child_tuple<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token comment">// 从下层算子中获取一条 Tuple</span>
  <span class="token keyword">const</span> <span class="token keyword">auto</span> status <span class="token operator">=</span> child_executor_<span class="token operator">-&gt;</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_tuple<span class="token punctuation">,</span> rid<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>	<span class="token comment">// 无法继续输出 Tuple，返回 false 告知上层终止调用</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// Tuple 本质上是由 Value 数组构成，故需要从 child_tuple 中选取对应 Value 再进行构造</span>
  std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Value<span class="token operator">&gt;</span> values<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  values<span class="token punctuation">.</span><span class="token function">reserve</span><span class="token punctuation">(</span><span class="token function">GetOutputSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetColumnCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>expr <span class="token operator">:</span> plan_<span class="token operator">-&gt;</span><span class="token function">GetExpressions</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    values<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>expr<span class="token operator">-&gt;</span><span class="token function">Evaluate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>child_tuple<span class="token punctuation">,</span> child_executor_<span class="token operator">-&gt;</span><span class="token function">GetOutputSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token operator">*</span>tuple <span class="token operator">=</span> Tuple<span class="token punctuation">{</span>values<span class="token punctuation">,</span> <span class="token operator">&amp;</span><span class="token function">GetOutputSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task-1-Access-Method-Executors">Task #1 - Access Method Executors</h2>
<p>诸如上述 Projection 算子，只是对真实表中的 Tuple 副本进行一系列操作，并不涉及磁盘中的 TableHeap。本 Task 需要我们与 TableHeap 打交道，实现 SeqScan，Insert，Delete 这三个算子。</p>
<h3 id="SeqScan">SeqScan</h3>
<p>对应 <code>SELECT * FROM table_name</code> 语句，需要获取 TableHeap 并从中读取所有 Tuple。</p>
<p>ExecutorContext 所有算子都是一样的，先来看看 Plan 为我们提供的额外信息：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>table_oid_</code>：当需要对 Table 进行读写操作时提供，为 Operator 指明需要操作的 Table，从而通过 Catalog 索引到具体的物理页面；</p>
</li>
<li class="lvl-2">
<p><code>table_name_</code>：同上；</p>
</li>
<li class="lvl-2">
<p><code>filter_predicate_</code>：这是一个 Expression，如果在上述语句中加入 <code>WHERE ...</code>，则该值即为对应的运算表达式，用于利用 <code>Evaluate()</code> 过滤 Tuple；</p>
</li>
</ul>
<p>既然有了 table id，那 TableHeap 就能获取了，通过 Guide 可知，我们需要通过一个叫 <code>TableIterator</code> 的对象来迭代表中 Tuple，并且适当地利用 <code>filter_predicate_</code> 进行过滤，规则为：</p>
<ol>
<li class="lvl-3">
<p>若其为 <code>nullptr</code>，则不作过滤，直接返回 Tuple；</p>
</li>
<li class="lvl-3">
<p>反之，利用 <code>Evaluate()</code> 判断返回值。若为 <code>true</code>，则返回 Tuple，反之，跳过当前 Tuple，迭代器继续向前，重复之前的步骤；</p>
<blockquote>
<p>该函数返回值为 <code>Value</code> 类型（底层包括数据类型与值），在过滤条件的判断中，认为其返回 Value 具体类型为 <code>bool</code>，故可以通过 <code>GetAs&lt;bool&gt;()</code> 来获取具体值；</p>
</blockquote>
</li>
</ol>
<h3 id="Insert-Delete">Insert/Delete</h3>
<p>下层算子返回需要 Insert/Delete 的 Tuple。</p>
<p>这里分别需要调用 TableHeap 中的 <code>InsertTuple()</code> 和 <code>MarkDelete()</code> 来进行实际的插入和删除。同时，所操作的 Table 可能建有索引，需要对所有建立好的 Index 调用 <code>InsertEntry()</code> 和 <code>DeleteEntry()</code> 操作。</p>
<p>除了对表的操作，Task 还要求我们输出一共操作了多少条 Tuple。很容易想到在算子里定义一个计数器 <code>cnt_</code>，初始化为 0，之后每操作一次便自增一次，直至下层没有 Tuple 输出后再将 <code>cnt_</code> 包装为 <code>Value(INTEGER, cnt_)</code>，最后构造为 Tuple 进行返回。</p>
<p>但有个测试点显示：如果没有任何操作，需返回 0。也就是说，对于下层不再返回元组的情况，不能简单返回 <code>false</code>，这样会导致 0 的情况不会输出——只有调用结果为 <code>true</code> 才会采用该 Tuple。</p>
<p>考虑到这两个算子实际上是在单次 <code>Next()</code> 调用中就将所有操作完成，后续的调用直接返回 <code>false</code>，也就是说上层最多调用 Insert/Delete 算子的 <code>Next()</code> 两次。那么事情就好办了，我的做法是参考了 TEST-AND-SET 思想：定义了一个 <code>still_need_read</code> 变量，初始化为 <code>true</code>，然后</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> res <span class="token operator">=</span> still_need_read_<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>still_need_read_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  still_need_read_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> res<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从而保证首次调用无论是否有操作都必然返回 <code>true</code>。</p>
<h3 id="IndexScan">IndexScan</h3>
<p>这个算子需要利用我们在 lab2 中实现的 B+ 树迭代器进行 Tuple 的获取。之前提到所有 leaf node 存的 kv 对中的 Value 都是 <code>RID</code>，故对于在某一列上作的索引，所有 Tuple 在该列上的值作为了 B+ 树的 Key，且根据索引的特性可知，这些值互不相同。</p>
<p>根据 Guide，我们可以通过以下语句来将 Index 对象变为 B+ 树</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">tree_ <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>BPlusTreeIndexForOneIntegerColumn <span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>index_info_<span class="token operator">-&gt;</span>index_<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个对象里面有一个函数为 <code>GetBeginIterator()</code>，用以初始化我们的 Iterator。接下来就是不断获取 rid，然后根据 rid 获取 Table 中对应的 Tuple。</p>
<h2 id="Task-2-Aggregation-Join-Executors">Task #2 - Aggregation &amp; Join Executors</h2>
<h3 id="Aggregation">Aggregation</h3>
<p>跟其余算子的流水线式运作不同，Aggregation 操作可以说是"Pipeline breaker"——对于一些诸如 <code>max()</code>，<code>sum()</code> 等的聚合函数，它们只能通过扫描全表来进行输出，而不能每取一个 Tuple 就能作出正确的判断。故这里我们的策略转变为：不断获取下层 Tuple，然后完善一个名为 <code>SimpleAggregationHashTable</code> 的对象，直至下层不再返回，此时利用构建好的聚合表，获取我们想要的聚合结果，根据输出模式构造 Tuple 并返回。</p>
<blockquote>
<p>相当于是最开始提到的方法 2 了。</p>
</blockquote>
<p>Plan 中为我们提供了如下新变量：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>group_bys_</code>：依次对应 SQL 语句中 <code>GROUP BY (Expression)</code> 中的表达式；</p>
</li>
<li class="lvl-2">
<p><code>aggregates_</code>：依次对应 SQL 语句中的待执行聚合函数的列表达式；</p>
</li>
<li class="lvl-2">
<p><code>agg_types_</code>：依次对应所有聚合类型；</p>
</li>
</ul>
<p>同时在 Plan 头文件中还为我们提供了 <code>AggregateKey</code> / <code>AggregateValue</code> 的类定义。前者就是 <code>group_bys_</code>，后者则是 <code>aggregates_</code>。当然，课程组已经为我们提供了根据 Tuple 构造这两个数据类型的函数，直接调用即可。</p>
<p><code>SimpleAggregationHashTable</code> 是课程组专门为本算子提供的一个数据结构，可以视为一张常驻内存的哈希表，其底层采用 <code>std::unordered_map</code> 实现。整张表的数据排布如下图所示：</p>
<blockquote>
<p>以语句 <code>SELECT MAX(colB), COUNT(colC) FROM table1 GROUP BY colA;</code> 为例。</p>
</blockquote>
<img src="image-20230112224841085.png" alt="image-20230112224841085" style="zoom:67%;">
<p>该数据结构的其余 api 都有现成的，同时还有一个 <code>SimpleAggregationHashTable::Iterator</code> 用来遍历表，我们要做的仅仅是完善 <code>CombineAggregateValues()</code> 函数。</p>
<p>该函数会在聚合表的另一个函数 <code>InsertCombine()</code> 中被调用，简单来说就是根据输入的 <code>AggregateValue</code> 去更新聚合表中具体的聚合函数值。生成这些聚合函数值所使用的聚合函数与 <code>agg_types_</code> 一一对应，所以遍历时需要</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint32_t</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> agg_types_<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span><span class="token punctuation">(</span>agg_types_<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 根据不同聚合类型采用不同方式更新聚合函数值</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>聚合类型有以下五种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>CountStarAggregate</strong>：对应 <code>Count(*)</code>。更新时直接加一。注意 Value 对象有自带的各种运算方法（<code>Add</code>，<code>Min</code>，<code>Max</code>），且参数也为 Value 类型，直接调用即可，注意需接受返回值，并不是真正修改了原值；</p>
<blockquote>
<p>整数"1"可以通过 <code>ValueFactory::GetIntegerValue(1)</code> 来转为 Value 类型。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>CountAggregate</strong>：对应 <code>Count(col_name)</code>。仅当输入项对应的列非空时才加一。Guide Hint 中有提到：</p>
<p><font color="grey"><strong>Hint:</strong> When performing aggregation on an empty table, <code>CountStarAggregate</code> should return zero and all other aggregate types should return <code>integer_null</code>. This is why <code>GenerateInitialAggregateValue</code> initializes most aggregate values as NULL.</font></p>
<p>仔细观察 <code>GenerateInitialAggregateValue</code> 函数，会发现除了 CountStarAggregate 类型，其余所有聚合函数值都被初始化为了 NULL，而在 Value 类型中，其并非为 0。这就需要在更新聚合函数值时增加函数值当前是否为 NULL 的判断，下同；</p>
</li>
<li class="lvl-2">
<p><strong>SumAggregate</strong>：对应 <code>sum(col_name)</code>。也是要判断输入项是否非空，并且函数值是否为 NULL；</p>
</li>
<li class="lvl-2">
<p><strong>MinAggregate</strong>：对应 <code>min(col_name)</code>。同上；</p>
</li>
<li class="lvl-2">
<p><strong>MaxAggregate</strong>：对应 <code>max(col_name)</code>。同上；</p>
</li>
</ul>
<p>这里有个易错点需要注意，SQL 语句中是否有 <code>GROUP BY</code> 关键字需分情况讨论：</p>
<ol>
<li class="lvl-3">
<p>无。此时我们的输出 Tuple 只需包含 <code>aggregates_</code> 所对应的列即可，并且如果表为空，需生成一个完全初始化的 Tuple，这里需跟 Insert/Delete 一样采用 TEST-AND-SET 的手段；</p>
</li>
<li class="lvl-3">
<p>有。此时我们的输出 Tuple 不仅要包含 <code>aggregates_</code> 列，还需要在前面加上 <code>group_bys_</code> 列，这里就不需要考虑表是否为空的情况了，直接构造输出 Tuple，并在迭代器到达表 End 时返回 <code>false</code> 即可；</p>
</li>
</ol>
<h3 id="NestedLoopJoin">NestedLoopJoin</h3>
<p>嵌套循环连接的朴素思路很简单，对于外表每一个 Tuple，遍历内表中所有 Tuple，进行连接条件判断（即 <code>Expression.EvaluateJoin</code>），若满足条件则构造输出元组。但在火山模型下，每次调用只输出一个 Tuple，这就意味着我们需要保留一些信息，防止下次调用时 Tuple 顺序错乱。</p>
<p>在 <code>Init()</code> 中就把所有输出 Tuple 构造好放到数组里，然后定义一个迭代器逐个输出是可以的，但这样就与火山模型的初衷背道而驰了。想要既能以正确顺序输出 Tuple，又满足流水线模式，就需要在算子内部存储外表 Tuple，并且在合适的时机对外表调用 <code>Next()</code>。</p>
<p>此外，在本 lab 中，NLJ 算子仅支持内连接和左外连接，这两种连接方式有所不同：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>内连接时，如果外表 Tuple 找不到任何内表满足条件的 Tuple，则直接跳过该 Tuple；</p>
</li>
<li class="lvl-2">
<p>左外连接时，如果外表 Tuple 找不到任何内表满足条件的 Tuple，则输出 <code>&lt;outer_tuple, NULL&gt;</code> 形式的 Tuple；</p>
</li>
</ul>
<p>故需要一个变量 <code>join_empty</code> 来记录当前外表 Tuple 是否找到了相应内表 Tuple。</p>
<p>代码框架大概长这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>outer_executor_<span class="token operator">-&gt;</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    next_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    join_empty_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span>inner_executor_<span class="token operator">-&gt;</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>plan_<span class="token operator">-&gt;</span><span class="token function">Predicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">EvaluateJoin</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token generic-function"><span class="token function">GetAs</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      join_empty_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
      <span class="token comment">// 构造 Tuple</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  next_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>			  <span class="token comment">// 内表已经无法继续输出 Tuple，更新 next_</span>
  inner_executor<span class="token punctuation">.</span><span class="token function">Init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 需定期初始化内表</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>plan_<span class="token operator">-&gt;</span><span class="token function">GetJoinType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> JoinType<span class="token double-colon punctuation">::</span>LEFT <span class="token operator">&amp;&amp;</span> join_empty_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 构造空值 Tuple</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// INNER JOIN &amp;&amp; JOIN EMPTY，需要外表继续 Next()，故外层用 while(true)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="NestedIndexJoin">NestedIndexJoin</h3>
<p>和 NLJ 思路大体一致，不同之处在于，内表相关的列已经建好了 Index，对于外表中的每一行 Tuple，我们需要利用外表对应的列通过 <code>key_predicate</code> 构建 probe key，从 Index 中获取相应内表的 RID，从而进一步去物理页面中获取 Tuple。</p>
<p><code>key_predicate</code> 是一个 Expression 变量，利用 <code>Evaluate()</code> 找到传入 Tuple 中建立了索引的列上的 Value，然后再根据 <code>key_schema</code> 模式来构造元组。probe key 的构建大概长这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">probe_value <span class="token operator">=</span> plan_<span class="token operator">-&gt;</span><span class="token function">KeyPredicate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">Evaluate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>outer_tuple_<span class="token punctuation">,</span> outer_schema_<span class="token punctuation">)</span><span class="token punctuation">;</span>
probe_key <span class="token operator">=</span> <span class="token function">Tuple</span><span class="token punctuation">(</span><span class="token punctuation">{</span>probe_value<span class="token punctuation">}</span><span class="token punctuation">,</span> index_info_<span class="token operator">-&gt;</span>index_<span class="token operator">-&gt;</span><span class="token function">GetKeySchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其余关于何时调用外表 <code>Next()</code> 以及连接类型的讨论同 NLJ。</p>
<h2 id="Task-3-Sort-Limit-Executors-and-Top-N-Optimization">Task #3 - Sort + Limit Executors and Top-N Optimization</h2>
<h3 id="Sort">Sort</h3>
<p>用于 <code>ORDER BY</code> 关键字，同时还规定了排序类型：<code>ASC</code> / <code>DeSC</code>。若没有明确表示，则默认为 <code>ASC</code>。</p>
<p>Sort 也是个 Pipeline Breaker，因为其需要等到获取完所有 Tuple 再返回结果。于是乎，需要在算子中定义一个 Tuple 数组，在 <code>Init()</code> 阶段构建好以后，用一个迭代器逐个输出即可。</p>
<p>构建的过程也很简单，不断调用下层算子获取 Tuple 后加入数组，然后调用 <code>std::sort()</code> 并自定义排序方法。对于每个 <code>ORDER BY</code> 对应的列，若相等则比较下一列，否则按照排序类型直接返回 true or false。由于不会出现完全相同的两行，故自定义排序方法必定能在 <code>for</code> 循环中退出。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 自定义排序方法</span>
<span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">const</span> Tuple <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> Tuple <span class="token operator">&amp;</span>b<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">bool</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> res <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>orderby <span class="token operator">:</span> plan_<span class="token operator">-&gt;</span><span class="token function">GetOrderBy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      AbstractExpression <span class="token operator">*</span>expr <span class="token operator">=</span> orderby<span class="token punctuation">.</span>second<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// expr-&gt;Evaluate 返回的是 Tuple 在对应列下的 Value，利用 Value.Comparexxx 方法进行比较</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>相等<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">continue</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>DESC<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res <span class="token operator">=</span> a 的 Value <span class="token operator">&gt;</span> b 的 Value
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        res <span class="token operator">=</span> a 的 Value <span class="token operator">&lt;</span> b 的 Value
      <span class="token punctuation">}</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Limit">Limit</h3>
<p>这个就更简单了，略。</p>
<h3 id="Top-N-Optimization-Rule">Top-N Optimization Rule</h3>
<p>默认情况下，<code>ORDER BY col_name LIMIT n</code> 会先经过 Sort 算子，再经过 Limit 算子，如果 n &lt;&lt; Tuple 数量，则有相当一部分 Tuple 并没有参与到最终的输出，这显然是低效的，因为我们只需要 n 个结果。</p>
<p>Top-N 将以上两个算子融合到一起，它动态维护当前所需的最多 n 条 Tuple，排序方式同 Sort 中讨论的那样。</p>
<blockquote>
<p>尽管这也需要下层算子返回所有 Tuple，但优势在于时空的开销——它本质上采用了类似于<strong>优先队列</strong>的方式，若 Tuple 数量为 N，则原先的 Sort+Limit 的方式需要 $N\log(N)$ 的时间开销，$N$ 的空间开销，而 Top-N 时空开销分别只需要 $N\log(n)$ 与 $n$。</p>
</blockquote>
<p>与此同时，我们还要实现 Optimizer 中的 <code>sort_limit_as_topn</code> 优化策略，观察其它策略我们发现，都有这样一段代码:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>AbstractPlanNodeRef<span class="token operator">&gt;</span> children<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">auto</span> <span class="token operator">&amp;</span>child <span class="token operator">:</span> plan<span class="token operator">-&gt;</span><span class="token function">GetChildren</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  children<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token function">OptimizeSortLimitAsTopN</span><span class="token punctuation">(</span>child<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">auto</span> optimized_plan <span class="token operator">=</span> plan<span class="token operator">-&gt;</span><span class="token function">CloneWithChildren</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>易得 Bustub 的 Optimizer 采用后序遍历的方法，先优化下层算子，再逐个向上。</p>
<p>需要注意的是 Top-N 优化有严格要求，必须是上层 Limit 下层 Sort 这样的形式才能进行优化。其余部分并不难。</p>
<h2 id="Leaderboard-Task-Optional">Leaderboard Task (Optional)</h2>
<h3 id="Query-1-Where’s-the-Index">Query 1: Where’s the Index?</h3>
<p>Guide 叽里呱啦讲了一堆，实际上就是让我们实现 Hash Join。思路很简单，构建一个哈希表，内外表在 Hash 函数下映射到同一个 HashKey 的进行 Join 即可。</p>
<p>这里哈希表的数据结构设计其实可以完全照搬 Aggregation 里的那个哈希表。</p>
<p>由于有左连接的设定，我选择用内表 Tuple 在 <code>Init()</code> 阶段构建哈希表，然后再用外表 Tuple 构建 HashJoinKey，到哈希表中进行查找。注意这里 HashJoinValue 应当为一个 Tuple 数组，毕竟内表的多个 Tuple 的 Hash 值可能会是相等的。</p>
<p>此外，为了按序输出以及流水线运作，还需要在 HashJoinValue 中额外定义一个 <code>index_</code> 变量，表明当前 <code>Next()</code> 进行到哪一步了，这次应该挑选数组中哪一个 Tuple。在 <code>index_</code> 到达数组末尾后，外表才调用 <code>Next()</code>，并且 <code>index_</code> 需要初始化为 0——防止后续外表 Tuple 继续 Hash 到这个 HashJoinKey 上。</p>
<p>关于左连接的特殊情况讨论同上。</p>
<h3 id="Query-2-Too-Many-Joins">Query 2: Too Many Joins!</h3>
<h3 id="Query-3-The-Mad-Data-Scientist">Query 3: The Mad Data Scientist</h3>
<p>这两个时间原因没做，之后再更新。</p>
<h2 id="总结">总结</h2>
<p>火山模型的执行过程还是挺有意思的，整体实现起来也不难，更令人感到友好的是 Bustub 直接提供了所有 test sample，可以直接在本地运行并 debug，不需要到 GradeScope 上等了。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>CMU15445 Project#4 Concurrency Control</title>
    <url>/lab/15445project4/</url>
    <content><![CDATA[<p>接下来，需要完善对事务并发的支持。</p>
<p><a href="https://15445.courses.cs.cmu.edu/fall2022/project4/">&gt;&gt;&gt; LAB 主页传送门 &lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="Task-1-Lock-Manager">Task #1 - Lock Manager</h2>
<p>LM 负责以五种不同的模式保持 Table 和 Tuple 两个粒度的锁：<code>IntensionShared(IS)</code>，<code>Shared(S)</code>，<code>IntensionExclusive(IX)</code>，<code>Exclusive(X)</code>，<code>SharedIntensionExclusive(SIX)</code>。LM 将处理来自事务的锁请求，向事务授予锁，并根据事务的隔离级别检查锁是否被适当释放。</p>
<p>先来看看各个类的数据定义。</p>
<h3 id="LockRequest">LockRequest</h3>
<p>锁请求，包含请求事务的标识符 <code>txn_id</code>，待上锁 Table 标识符 <code>oid</code>，待上锁表行标识符 <code>rid</code>，本次请求的上锁类型 <code>lock_mode</code>，以及指明该请求是否授予的变量 <code>granted</code>。</p>
<h3 id="LockRequestQueue">LockRequestQueue</h3>
<p>将实际队列 <code>std::list&lt;std::shared_ptr&lt;LockRequest&gt;&gt;</code> 进行封装，额外添加了一把锁 <code>latch</code> 以及条件变量 <code>cv</code>，以便锁释放后通知其余等待中的锁。此外还有一个 <code>upgrading</code> 用来标识当前锁请求队列是否有锁正在进行升级。</p>
<h3 id="LockManager">LockManager</h3>
<p>首先是定义了锁类型 <code>LockMode</code>，就是上面提到的 5 种。除此之外，还有以下变量：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>table_lock_map_</code>：每个 Table 都对应了一个锁请求队列，通过 table oid 获取；</p>
</li>
<li class="lvl-2">
<p><code>row_lock_map_</code>：每一 Row 同样也有一个锁请求队列，通过 rid 获取；</p>
</li>
<li class="lvl-2">
<p><code>waits_for_</code>：邻接表，表示某一事务正在等待的所有事务的集合，Task2 中会用到；</p>
</li>
</ul>
<p>还有以上每个变量对应的锁。</p>
<h3 id="LockTable-LockRow">LockTable() / LockRow()</h3>
<p>⚠<font color="red"><em><strong>在实现上锁过程之前，务必反复阅读并理解头文件中的 Lock Note。</strong></em></font></p>
<p>表锁和行锁的上锁过程基本类似，行锁在上锁前多了一个所在表是否正确上锁的判断，其余一致。这里就先讲<strong>表锁</strong>的上锁流程。</p>
<p>首先，判断以下三个变量是否兼容：</p>
<ol>
<li class="lvl-3">
<p><code>txn.TransactionState</code></p>
<blockquote>
<p>GROWING, SHRINKING, ABORTED, COMMITTED</p>
</blockquote>
</li>
<li class="lvl-3">
<p><code>txn.IsolationLevel</code></p>
<blockquote>
<p>Bustub 只规定了 3 个隔离级别：</p>
<ul class="lvl-3">
<li class="lvl-2"><code>READ_UNCOMMITTED</code>：该隔离级别下，不加 S 锁。会出现<strong>脏读</strong>问题，即会读到其它事务修改但未提交的数据；</li>
<li class="lvl-2"><code>READ_COMMITTED</code>：该隔离级别下，读操作会加 S 锁，但单次读结束会直接释放 S 锁，并且即便在 SHRINKING 阶段也可以再次加 S 锁。解决脏读，但会出现<strong>不可重复读</strong>问题，即由于中途释放了锁，同一事务的两次读中间可能会出现其它事务的写操作，从而前后读到不同的数据；</li>
<li class="lvl-2"><code>REPEATED_READ</code>：该隔离级别下，所有操作均遵循 2PL，支持所有上锁，但等到事务 ABORTED/COMMITTED 后才释放所有锁，解决不可重复读，但会出现<strong>幻读</strong>问题，例如第一个事务对一个表中的数据进行了修改，且涉及到表中的全部数据行，同时，第二个事务向该表中插入一行新数据，那么，第一个事务的用户之后就会发现表中还存在没有修改的数据行，仿佛出现幻觉。</li>
</ul>
</blockquote>
</li>
<li class="lvl-3">
<p><code>lock_mode</code></p>
</li>
</ol>
<p>具体规则如下：</p>
<ol>
<li class="lvl-3">
<p>如果 State 为 <code>ABORTED</code> / <code>COMMITTED</code>，则直接返回；</p>
</li>
<li class="lvl-3">
<p>如果 State 为 <code>GROWING</code>，IL 为 <code>READ_COMMITTED</code> 的事务不能上 S/IS/SIX 锁，否则抛出异常，其余上锁行为通过；</p>
</li>
<li class="lvl-3">
<p>如果 State 为 <code>SHRINKING</code>，只有 <code>READ_UNCOMMITTED</code> 能在此阶段上 S/IS/SIX 锁，其余所有上锁行为均抛出异常；</p>
</li>
</ol>
<p>接下来，尝试获取锁请求队列，并在获取到后立刻释放 <code>lock_map</code> 锁，紧接着尝试获取 <code>lock_request_queue</code> 的锁。</p>
<p>接着，遍历队列，检查同一事务是否已经上过锁，若有，则认为这是一次<strong>锁升级尝试</strong>：如果已经有其它事务正在进行锁升级，则抛出异常，否则，如果升级未遵循如下规则，也要抛出异常。</p>
<blockquote>
<p>IS -&gt; [S, X, IX, SIX]</p>
<p>S -&gt; [X, SIX]</p>
<p>IX -&gt; [X, SIX]</p>
<p>SIX -&gt; [X]</p>
</blockquote>
<p>检查通过后，需要将原来的锁取出队列，并修改事务维护的相应锁集合，再将新的锁请求插到等待区的最前面。Lock Note 中提到，锁升级是优先级最高的请求，故将其插到所有 <code>granted = false</code> 的请求中的第一个位置，以便前面不兼容的锁释放后，其能够最先被授予。</p>
<blockquote>
<p>原来的锁如果存在请求队列中，则必然已经授予，如若不然，事务不会退出，只会一直等待锁请求授予。</p>
</blockquote>
<p>当然，如果本次上锁并非锁升级，则将请求插到队列的末尾。</p>
<p>插入请求后，就进入停等状态。这里就要用到 <code>lock_request_queue</code> 中的条件变量了，通过调用 <code>cv_.wait</code> 使得当前线程挂起，直到被唤醒，具体用法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>lock_request_queue<span class="token operator">-&gt;</span>latch_<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">// 必须为 unique_lock</span>
<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>不满足授予条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lock_request_queue<span class="token operator">-&gt;</span>cv_<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>每次被唤醒，都会先检查授予条件是否满足，如果满足则直接退出循环，不再 <code>wait</code>。这里的授予条件是指，排在前面的所有锁（无论是否授予）的类型与其均兼容。只要有一个不兼容的锁，那就不满足条件。为了简化判断代码，我定义了一个锁兼容矩阵，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED_INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED_INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED_INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_SHARED<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
compatibility_matrix_<span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>INTENTION_EXCLUSIVE<span class="token punctuation">]</span><span class="token punctuation">[</span>LockMode<span class="token double-colon punctuation">::</span>SHARED_INTENTION_EXCLUSIVE<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>由于 <code>wait</code> 操作实际上是释放锁+挂起两个步骤，所以不用担心请求队列的 latch 出现死锁情况。而唤醒实际上也是执行一次获取锁的操作。</p>
</blockquote>
<p>最后就是授予锁了，将对应锁请求的 <code>granted</code> 改为 <code>true</code>，并修改事务维护的相应锁集合。如果这是一次锁升级请求，则说明升级完成，还需要修改请求队列的 <code>upgrading</code> 变量。</p>
<h3 id="UnlockTable-UnlockRow">UnlockTable() / UnlockRow()</h3>
<p>⚠<font color="red"><em><strong>在实现解锁过程之前，务必反复阅读并理解头文件中的 Unlock Note。</strong></em></font></p>
<p>解锁过程相比上锁过程简单许多，表锁和行锁的解锁流程也几乎一样，只是表锁在解锁时需要判断表中是否还有未解锁的行锁，其余一致。这里就先讲<strong>表锁</strong>的解锁流程。</p>
<p>首先判断锁是否存在，如果不存在，则抛出异常。</p>
<p>判断表中是否还有未解锁的行锁，如果有，则抛出异常。</p>
<p>接下来就是获取锁请求队列，根据 <code>txn_id</code> 找到事务对应的那个锁请求，从队列中移除，修改事务维护的相应锁集合，然后利用 <code>cv_.notify_all()</code> 通知所有挂起的线程。由于同一个事务在同一个表/行上最多仅能上一把锁，所以不会出现两个相同 <code>txn_id</code> 的请求。</p>
<h2 id="Task-2-Deadlock-Detection">Task #2 - Deadlock Detection</h2>
<p>死锁检测需要我们构建一个事务等待图，然后利用 DFS 算法检测环是否存在环，每次检测需打破所有环，并且 Aborted 环上 <code>txn_id</code> 最大的事务。</p>
<p>由于要求我们每次需从 <code>txn_id</code> 最小的事务开始执行 DFS，并且在挑选邻居的时候也要按照 <code>txn_id</code> 递增的顺序，所以进行 <code>wait_for</code> 等待图构建的时候，每次添加边都需要找到合适的位置进行插入。</p>
<p>另外，lab 要求我们在每次检测开始时进行图构建，检测完后再把图销毁，于是 <code>RunCycleDetection()</code> 函数就变成了</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">LockManager</span><span class="token double-colon punctuation">::</span><span class="token function">RunCycleDetection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>enable_cycle_detection_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>cycle_detection_interval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">{</span>
      waits_for_latch_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">MakeGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// cycle detection</span>
      <span class="token function">DestoryGraph</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      waits_for_latch_<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>本 Task 的核心也显而易见，就是环检测算法了。</p>
<p>这里易错点比较多，首先是 Guide 中 <code>txn_id</code> 前面的形容词 youngest 和 lowest 就傻傻分不清，实际上 youngest 指的就是 <code>txn_id</code> 大，因为 <code>txn_manager</code> 中是按照事务 id 递增来生成事务的，所以 <code>txn_id</code> 越大必然就越"年轻"嘛~</p>
<p>第二，图上不一定只有一个连通分量，这是要小心的。</p>
<p>第三，图上也不一定只有一个环，而我们需要打破所有环，所以这里要用一个 <code>while</code> 循环。</p>
<p>其余的环路径的维护，点访问的去重，需要自己慢慢琢磨。</p>
<p>在选出 youngest transaction 之后，要将其 Abort，并且以 LockManager 的名义通知所有锁等待队列。本来应该只通知该事务相关的队列即可，但我图省事，就直接全部通知一遍。事务在收到通知后，首先检查自身 State，如果变成了 <code>ABORTED</code>，则把队列中自己的锁请求给移除，并且再一次通知队列中的其它事务。</p>
<blockquote>
<p>这是因为排在后面的事务在被唤醒时可能先一步获取锁，检查前面所有锁兼容性失败后继续 wait，但实际上只要被 Aborted 的那个事务移除锁请求，后面事务就能获取锁了。</p>
</blockquote>
<h2 id="Task-3-Concurrent-Query-Execution">Task #3 - Concurrent Query Execution</h2>
<p>在 lab3 中实现的 3 个与真实物理页面打交道的算子 SeqScan，Insert，Delete 中加上锁。并且根据上述讨论提到的不同隔离级别的不同表现进行额外的判断，难度不大，略。</p>
<h2 id="总结">总结</h2>
<p>本 lab 最大的收获就是理解了隔离级别以及锁类型之间的关系，以及死锁检测是如何进行的。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.824 Lab2 RAFT</title>
    <url>/lab/6-824lab2/</url>
    <content><![CDATA[<p>本实验要求我们实现 Raft 算法，包括其领导人选举、日志复制、快照等关键要素。</p>
<span id="more"></span>
<h2 id="参考资料">参考资料</h2>
<ul class="lvl-0">
<li class="lvl-2">
<p>有一个<a href="http://thesecretlivesofdata.com/raft/#home">非常通俗易懂的Raft 可视化网站</a>；</p>
</li>
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">描述 Raft 算法的论文</a>；</p>
</li>
<li class="lvl-2">
<p>我的<a href="../raft">另一篇文章</a>是对该论文的解读；</p>
</li>
<li class="lvl-2">
<p>当然，这门课的 TA 编写的 <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">RAFT GUIDE</a> 也不容忽视。</p>
</li>
</ul>
<h2 id="PART-A-Raft-Leader-Election">PART A-Raft Leader Election</h2>
<p>PartA 主要负责 Raft 节点超时选举的流程。我把这一过程描述为以下步骤：</p>
<ol>
<li class="lvl-3">
<p>节点最开始的身份统一初始化为 Follower。每个节点自身包含一个定时器，逐 tick 增长，在 timeout 时间间隔内满足以下条件：</p>
</li>
</ol>
<ul class="lvl-0">
<li class="lvl-4">
<p>未投票给其它节点；</p>
</li>
<li class="lvl-4">
<p>未收到当前 Leader 的 any RPC；</p>
</li>
<li class="lvl-4">
<p>未发起选举；</p>
<p>则从 Follower 变为 Candidate，增加 <code>CurrentTerm</code>，并请求其它各个节点（下称 <strong>Peers</strong>）给自己投票；</p>
</li>
</ul>
<ol start="2">
<li class="lvl-3">
<p>Peers 收到 <code>requestVoteRPC</code> 后，对该 RPC 进行处理，并按照一定规则判断是否能够同意其成为 Leader；</p>
</li>
<li class="lvl-3">
<p>如果 Candidate 收到了超过半数的赞成票（自己也算一票），则成为当前 Term 的 Leader；</p>
</li>
</ol>
<p>至此，一个完整的选举过程就结束了。另外，节点成为 Leader 后，需要定期向其它 Peers 发送 <code>AppendEntriesRPC</code> 以稳固地位，也就是所谓的 <strong>HeartBeat</strong>。</p>
<blockquote>
<p>这一部分并不难，只需修改 <code>Raft.go</code> 即可，而解决它的关键在于 paper 中的 <strong>Figure2</strong>，为我们提供了非常有用的结构体定义以及规则。</p>
</blockquote>
<h3 id="结构体定义">结构体定义</h3>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>Raft.go</span></div><code class="language-go"><span class="token comment">// 每个日志条目存相应的索引、term 以及操作</span>
<span class="token keyword">type</span> LogEntry <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Index   <span class="token builtin">int</span>
  Term  <span class="token builtin">int</span>
  Command <span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 这里的 RaftState 与 persister 里的不一样</span>
<span class="token keyword">type</span> RaftState <span class="token builtin">string</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
  Follower  RaftState <span class="token operator">=</span> <span class="token string">"Follower"</span>
  Candidate RaftState <span class="token operator">=</span> <span class="token string">"Candidate"</span>
  Leader  RaftState <span class="token operator">=</span> <span class="token string">"Leader"</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Raft <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  mu    sync<span class="token punctuation">.</span>RWMutex
  peers   <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd
  persister <span class="token operator">*</span>Persister
  me    <span class="token builtin">int</span>
  dead    <span class="token builtin">int32</span>

  CurrentTerm <span class="token builtin">int</span>
  VoteFor   <span class="token builtin">int</span>
  Entry     <span class="token punctuation">[</span><span class="token punctuation">]</span>LogEntry
  raftState   RaftState

  commitIndex <span class="token builtin">int</span>
  lastApplied <span class="token builtin">int</span>
  nextIndex   <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
  matchIndex  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>

  applyChannel <span class="token keyword">chan</span> ApplyMsg
  applyCond  <span class="token operator">*</span>sync<span class="token punctuation">.</span>Cond

  electionTimer  <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer
  heartbeatTimer <span class="token operator">*</span>time<span class="token punctuation">.</span>Timer
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特别需要关注的是这里的 <code>nextIndex[]</code> 和 <code>matchIndex[]</code> 两个字段。这两者仅在当前节点为 Leader 时需要被 focus on。它俩并不是简单的 <code>next = match+1</code> 的关系，之所以分出两个字段，是因为它们分别代表不同意思。</p>
<p><code>nextIndex[i]</code> 指的是下一次同步日志时需要从哪一条<strong>开始</strong>发送给节点 i。同步日志并不一定是在每个 Heartbeat 时刻进行，当某个 Peer 因为日志冲突而拒绝了某次日志复制时，我们需要立即修改 <code>nextIndex[]</code> 以重新进行日志复制。</p>
<blockquote>
<p>当 Heartbeat1 时刻发给某 Peer 的同步日志请求被拒绝后，可能需要多次修改 <code>nextIndex[]</code> 重发。由于所有日志复制都是基于 <code>nextIndex[]</code>，所以即使到 Heartbeat2 时刻 Peer 仍未完成同步，此时发出的 Append Entries 也是正确的。只不过现在 Leader 要同时发出多个 Append Entries：Heartbeat1 未成功的和 Heartbeat2 新开始的。</p>
</blockquote>
<p><code>matchIndex[i]</code> 指的是<strong>作为 Leader 已知</strong>的节点 i 持有的最新日志号。每当一个 Peer 成功进行了日志复制时，都需要更新该字段。</p>
<blockquote>
<p>知道这一信息有什么用呢？在 6.824 的设计下，一个分布式节点收到一条来自客户端的请求时，都会将该请求打包成<strong>日志</strong>格式通过 Raft 层同步给其他节点，一旦某一条日志被过半节点持有，该日志就会被视为 <strong>Committed</strong>。Leader 需要不断更新这一信息并告知其它节点哪些日志已经 commit 了（这一信息一般捎带在 Heartbeat 里），那么对于 Committed 的日志，分布式节点就会认为其<strong>可靠</strong>，并提取日志中的请求并应用到存储中了，我们把这操作称为 <strong>Apply</strong>。</p>
</blockquote>
<p>并且，并不一定总是有 <code>next = match+1</code>，因为每个节点都会在刚上任时将 <code>matchIndex[]</code> 初始化为全 0，而 <code>nextIndex[]</code> 初始化为其当前持有最后一条日志的 lastLogIndex+1。</p>
<blockquote>
<p>当然，一旦 Follower 成功同步，它对应的两个字段会被更新为满足 <code>next = match+1 = lastLogIndex+1</code>。</p>
</blockquote>
<h3 id="Timer">Timer</h3>
<p>根据算法要求，需要<strong>选举定时器</strong>和<strong>心跳定时器</strong>各一个。如果当前为 Leader，则只处理心跳定时器的消息；反之，则只处理选举定时器的消息。当然，处理完了还得进行重置。</p>
<blockquote>
<p>尽管 6.824 提了一嘴不要用 go time 库里的 timer，但感觉应该是怕学生不会用用错。</p>
<p>由于 lab 要求 1s 内最多发十次心跳，所以 HeartBeatTimeOut 设置为 100ms。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">ResetTimer</span><span class="token punctuation">(</span>isleader <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> isleader <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span>heartbeatTimer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span><span class="token function">HeartBeatTimeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span>electionTimer<span class="token punctuation">.</span><span class="token function">Reset</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span><span class="token function">ElectionTimeOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">Ticker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">select</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token operator">&lt;-</span>rf<span class="token punctuation">.</span>electionTimer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
      <span class="token comment">// 选举投票超时，发起选举</span>
      <span class="token keyword">case</span> <span class="token operator">&lt;-</span>rf<span class="token punctuation">.</span>heartbeatTimer<span class="token punctuation">.</span>C<span class="token punctuation">:</span>
      <span class="token comment">// 心跳超时，发送心跳</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Candidate-发送投票请求">Candidate 发送投票请求</h3>
<p>理想情况下，Leader 发一次 voteRequest，Peer 收到后发送回复并被 Leader 接收，在一个 RTT 就能解决问题。但由于网络的不稳定性，可能存在丢包，Leader
发出去的不一定被 Peer 收到，Peer 的回复也不一定被 Leader 确认。那么此时就需要 Leader 不断发送 RPC 直至收到回复，保证选举严格正常进行。</p>
<p>那么在这种策略下，就不得不谈谈如何处理过期的消息。这里的过期有两层含义：</p>
<ol>
<li class="lvl-3">
<p>同一 Term 中已经发过一遍；</p>
</li>
<li class="lvl-3">
<p>上一 Term 甚至更早的；</p>
</li>
</ol>
<p>对于 Peer 而言，所有来自同一个 Candidate 的同一 Term 的投票请求，如果一开始就拒绝，那么将一直保持拒绝，如果 Term 过期就更不用说了；如果对于第一条同意，那么 Peer 会修改自己的 <code>voteFor</code>，下次遇到同一人发来的请求时，如果 Term 也对的上，那就直接同意。</p>
<p>对于 Candidate 而言，每次收到 reply 时，需要保证自身处于<strong>和发送请求时刻一样</strong>的状态下才能接收，即检查</p>
<ol>
<li class="lvl-3">
<p>当前状态是否为 Candidate；</p>
</li>
<li class="lvl-3">
<p>reply 的 Term 是否与节点当前 Term 一致；</p>
</li>
</ol>
<p>一旦有一个条件不满足，就认为该 reply 已过时并丢弃。对应现实情况为：若 Candidate 成功当选（破坏条件 1）或收到了一个更新 Term 节点的回复而更新自己的状态（破坏条件 1, 2），说明这次选举已经可以结束了，再进行下去没有意义了，后续收到所有的该次选举产生的 reply 都作废。</p>
<blockquote>
<p>这里不需要处理迟到的重复 grant，因为 gRPC 框架下，一旦调用失败，就可以认为该 reply 永远不会到自己这里。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">StartElection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  voteCnt <span class="token operator">:=</span> <span class="token number">1</span>  <span class="token comment">// 赞成票数</span>
  args <span class="token operator">:=</span> rf<span class="token punctuation">.</span><span class="token function">GetRequestVoteArg</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> rf<span class="token punctuation">.</span>peers <span class="token punctuation">{</span>
    <span class="token keyword">if</span> i <span class="token operator">!=</span> rf<span class="token punctuation">.</span>me <span class="token punctuation">{</span>
      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>peer <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">{</span>
          <span class="token comment">// for 循环保证选举正常运行，即选举请求正常送达。相应的，接收侧也应当处理重复的相同 RPC。</span>
          <span class="token comment">// 如果发送成功，则判断当前状态与发送时是否一致，即既没有切换身份也没有改变 Term</span>
          <span class="token comment">// 如果一致，首先检查 peer 的 Term 是否比自己高，高了就要自动切换成 Follower</span>
          <span class="token comment">// 然后检查 peer 是否同意给票</span>
          <span class="token comment">//    同意：增加同意计数器，并且当该计数器过半时，当选 Leader；</span>
          <span class="token comment">//    反对：增加反对计数器，并且当该计数器过半时，退为 Follower 等待下次选举或有人当选 Leader；</span>
          <span class="token comment">// 只要成功收到回复，就应停止发送，退出。</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="对投票请求进行回复">对投票请求进行回复</h3>
<p>关键在于<strong>拒绝</strong>请求的条件判断。以下情况需要拒绝投票请求的：</p>
<ol>
<li class="lvl-3">
<p>收到 Term 比自己低的 RPC，一律认为该 RPC 已过期；</p>
</li>
<li class="lvl-3">
<p>当前 Term 内已给其他节点投过票；</p>
</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">RequestVote</span><span class="token punctuation">(</span>args <span class="token operator">*</span>RequestVoteArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>RequestVoteReply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 先检查是否拒绝</span>

  <span class="token comment">// 如果不拒绝，那就同意请求，修改一系列变量，并重置选举定时器</span>
  <span class="token comment">// 如果当前 Term 较低，需要更新并转为 Follower</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="成为-Leader">成为 Leader</h3>
<p>当选后需<strong>立即</strong>广播一次 <strong>HeartBeat</strong>，以巩固地位。这是为了避免其他节点触发选举超时而进行新的一轮选举。<strong>而事实上我们并不需要这一次多余的选举</strong>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">StartHeartbeat</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> peer <span class="token operator">:=</span> <span class="token keyword">range</span> rf<span class="token punctuation">.</span>peers <span class="token punctuation">{</span>
    <span class="token keyword">if</span> peer <span class="token operator">!=</span> rf<span class="token punctuation">.</span>me <span class="token punctuation">{</span>
      <span class="token keyword">go</span> rf<span class="token punctuation">.</span><span class="token function">SendHeartBeat</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>2A 中，<code>SendHeartBeat()</code>不需要发送多余的信息，只要告诉其它节点"我"的当前 Term 即可。其它节点收到 RPC 后，根据收到的 Term 进行相应操作。</p>
</blockquote>
<h2 id="PART-B-Log-Replication">PART B-Log Replication</h2>
<p>这一 part 要求我们实现日志复制，选举约束与快速恢复。</p>
<h3 id="日志复制">日志复制</h3>
<h4 id="发送侧-Leader">发送侧(Leader)</h4>
<p>上层通过调用 Start() 函数向 Leader 发送一个 command，我们需要将这一 command 打包成日志，并同步给 Followers。按照实验要求，我们需要立刻返回这一 command 在日志中的索引与相应 term，同时如果上层调用的节点不是 Leader ，则直接 <code>false</code>。</p>
<p>Leader 定期发送 Heartbeat，如果满足 <code>nextIndex[i] &lt;= lastLogIndex</code>，说明有新的日志需要同步，且要求：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>If last log index ≥ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex。</p>
</li>
</ul>
<p>另外，paper 中还提到了：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm: set commitIndex = N (§5.3, §5.4).</p>
</li>
</ul>
<p>这条规则就是让我们更新 commitIndex 用的。当过半节点都告知 Leader 其持有某一条日志时，可以认为该日志及其之前的所有日志都得到 commit，然后就可以告知 Applier 将所有 committed 但未 apply 的日志应用到上层。</p>
<p><strong>注意</strong>，根据 Figure8，我们不能直接提交之前 Term 的日志，而是只能在 commit 当前 Term 的日志后，间接 commit 之前 Term 的日志。这是因为 Raft 的日志在 commit之前是可以回滚的，具体操作就是直接将其用更高 Term 的日志覆盖。</p>
<p>Leader 必须确保某一条日志不会被回滚才能 commit 它。当前 Term 的日志一旦被多数 Peer 持有，肯定不会回滚，因为选举流程可以保证这一点。</p>
<p>而之前 Term 的日志，即使已经被多数 Peer 持有，也有可能被回滚，因为没有别的机制来保证不会回滚。所以，不能直接 commit。</p>
<blockquote>
<p>为了尽快提交有效日志，Raft 令每个 Leader 在当选时立刻给自己塞一条 nop 日志（不包含任何命令的日志），一旦该日志复制到了多数 Peers，那么之前的日志就能很快被 commit。但遗憾的是，6.824 好像并不支持这一做法，如果用了就过不了测试。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">FindN</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// locked</span>
  matchIndexSet <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> peer <span class="token operator">:=</span> <span class="token keyword">range</span> rf<span class="token punctuation">.</span>peers <span class="token punctuation">{</span>
    <span class="token keyword">if</span> peer <span class="token operator">!=</span> rf<span class="token punctuation">.</span>me <span class="token punctuation">{</span>
      matchindex<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> rf<span class="token punctuation">.</span><span class="token function">GetMatchNextIndex</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span>
      matchIndexSet <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>matchIndexSet<span class="token punctuation">,</span> matchindex<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  sort<span class="token punctuation">.</span><span class="token function">Ints</span><span class="token punctuation">(</span>matchIndexSet<span class="token punctuation">)</span>
  N <span class="token operator">:=</span> matchIndexSet<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>peers<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">]</span>

  <span class="token comment">// 根据 Figure8，我们只能考虑当前 Term 的日志。</span>
  <span class="token comment">// 一旦当前 Term 的某条日志被 commit，那么之前的所有日志都会被 commit，然后逐渐 apply</span>
  <span class="token keyword">if</span> N <span class="token operator">&gt;</span> rf<span class="token punctuation">.</span>commitIndex <span class="token operator">&amp;&amp;</span> rf<span class="token punctuation">.</span>Entry<span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">.</span>Term <span class="token operator">==</span> rf<span class="token punctuation">.</span>CurrentTerm <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span><span class="token function">UpdateCommitAndApply</span><span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token comment">// 更新 commitindex 并唤醒 Applier</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">Applier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>rf<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> <span class="token operator">!</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>lastApplied <span class="token operator">&lt;</span> rf<span class="token punctuation">.</span>commitIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      rf<span class="token punctuation">.</span>applyCond<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// 将当前 commitIndex 拷贝到新变量中，</span>
    <span class="token comment">// 并将待 apply 的日志拷贝到 EntriesCopy 中，然后交给 Applier 去操作。</span>
    <span class="token comment">// 这样，尽管将待 apply 的日志传达给上层时未持有锁，也能按序 apply，</span>
    <span class="token comment">// 同时避免了 RAFT GUIDE 最后提到的死锁问题：</span>
    <span class="token comment">//  上层收到新消息后，会检查是否超过容量。若是，会选择进行快照。快照的过程中需要对 Raft 层上锁，那么此时如果持有锁必然造成死锁。</span>
    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> Entry <span class="token operator">:=</span> <span class="token keyword">range</span> EntriesCopy <span class="token punctuation">{</span>
      rf<span class="token punctuation">.</span>applyChannel <span class="token operator">&lt;-</span> ApplyMsg<span class="token punctuation">{</span>
        CommandValid<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
        Command<span class="token punctuation">:</span>    Entry<span class="token punctuation">.</span>Command<span class="token punctuation">,</span>
        CommandTerm<span class="token punctuation">:</span>  Entry<span class="token punctuation">.</span>Term<span class="token punctuation">,</span>
        CommandIndex<span class="token punctuation">:</span> Entry<span class="token punctuation">.</span>Index<span class="token punctuation">,</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    rf<span class="token punctuation">.</span>lastApplied <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>lastApplied<span class="token punctuation">,</span> CommitIndex<span class="token punctuation">)</span>
    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里需要注意的是：每次更新 Applied 不能用 goroutine，因为 goroutine 的执行顺序是不可预知的，否则会报 “out of order xxx” 的错，也就是未按序 apply。</p>
<h4 id="接收侧-Follower">接收侧(Follower)</h4>
<p>对于收到的 AppendEntries RPC，paper 中给出以下规则：</p>
<ol>
<li class="lvl-3">
<p>Reply false if term &lt; currentTerm (§5.1)</p>
</li>
<li class="lvl-3">
<p>Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</p>
</li>
<li class="lvl-3">
<p>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it (§5.3)</p>
</li>
<li class="lvl-3">
<p>Append any new entries not already in the log</p>
</li>
<li class="lvl-3">
<p>If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</p>
</li>
</ol>
<p>逐个 adapt 到代码里即可。这里同样要在更新 <code>commitIndex</code> 后通知 Applier 传达给上层。</p>
<h3 id="选举约束">选举约束</h3>
<p>这其实很好理解，Follwer 只 Grant 最后一个日志比它更 up-to-date 的 <code>VoteRequest</code>，也就是说要满足以下两点：</p>
<ol>
<li class="lvl-3">
<p>Candidate.LastLogTerm &gt; Follwer.LastLogTerm</p>
</li>
<li class="lvl-3">
<p>if Candidate.LastLogTerm == Follwer.LastLogTerm, Candidate.len(Entry) &gt; Follwer.len(Entry)</p>
</li>
</ol>
<p>如果不满足，说明这个 Candidate 可能因为网络分区等原因未能将最新命令同步，直接拒绝。在选举中额外加一次判断即可。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// 自己有的 LogEntry 条目更 up-to-date</span>
<span class="token keyword">if</span> args<span class="token punctuation">.</span>LastLogTerm <span class="token operator">&lt;</span> LastLogTerm <span class="token operator">||</span> <span class="token punctuation">(</span>args<span class="token punctuation">.</span>LastLogTerm <span class="token operator">==</span> LastLogTerm <span class="token operator">&amp;&amp;</span> args<span class="token punctuation">.</span>LastLogIndex <span class="token operator">&lt;</span> LastLogIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  reply<span class="token punctuation">.</span>Term<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Grant<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> rf<span class="token punctuation">.</span>CurrentTerm<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> ErrLogNotMatch
  <span class="token keyword">return</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="快速恢复">快速恢复</h3>
<p>Guide 上面讲的还挺清楚的，<code>conflictIndex</code> 是 Follwer <strong>发生冲突的那条日志</strong>的 Index，<code>conflictTerm</code> 就是那条日志的 Term。</p>
<h4 id="接受侧-Follower">接受侧(Follower)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>If a follower does not have prevLogIndex in its log, it should return with <strong>conflictIndex = len(log)</strong> and <strong>conflictTerm = None</strong>.</p>
</li>
<li class="lvl-2">
<p>If a follower does have prevLogIndex in its log, but the term does not match, it should return <strong>conflictTerm = log[prevLogIndex].Term</strong>, and then search its log for <strong>the first index whose entry has term equal to conflictTerm</strong>.</p>
</li>
</ul>
<h4 id="发送侧-Leader-2">发送侧(Leader)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>Upon receiving a conflict response, the Leader should first search its log for conflictTerm. If it finds an entry in its log with that term, it should <strong>set nextIndex to be the one beyond the index of the last entry in that term in its log</strong>.</p>
</li>
<li class="lvl-2">
<p>If it does not find an entry with that term, it should <strong>set nextIndex = conflictIndex</strong>.</p>
</li>
</ul>
<p>这样做有助于快速修改 next[]，而不用每次都只是减一。这里我用了 binary search 来找对应的 index。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">FindNextIndex</span><span class="token punctuation">(</span>ConflictIndex<span class="token punctuation">,</span> ConflictTerm <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>next <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> ConflictTerm <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> rf<span class="token punctuation">.</span>Entry<span class="token punctuation">[</span>ConflictIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>Term <span class="token operator">==</span> ConflictTerm <span class="token punctuation">{</span>
    next <span class="token operator">=</span> ConflictIndex
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  left<span class="token punctuation">,</span> right <span class="token operator">:=</span> BaseIndex<span class="token punctuation">,</span> rf<span class="token punctuation">.</span>Entry<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>rf<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>Index
  <span class="token keyword">for</span> left <span class="token operator">&lt;</span> right<span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">{</span>
    mid <span class="token operator">:=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span>
    <span class="token keyword">if</span> rf<span class="token punctuation">.</span>Entry<span class="token punctuation">[</span>mid<span class="token operator">-</span>BaseIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>Term <span class="token operator">&lt;=</span> ConflictTerm <span class="token punctuation">{</span>
      left <span class="token operator">=</span> mid
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      right <span class="token operator">=</span> mid <span class="token operator">-</span> <span class="token number">1</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> rf<span class="token punctuation">.</span>Entry<span class="token punctuation">[</span>right<span class="token operator">-</span>BaseIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>Term <span class="token operator">==</span> ConflictTerm <span class="token punctuation">{</span>
    next <span class="token operator">=</span> right <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> rf<span class="token punctuation">.</span>Entry<span class="token punctuation">[</span>left<span class="token operator">-</span>BaseIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>Term <span class="token operator">==</span> ConflictTerm <span class="token punctuation">{</span>
    next <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token number">1</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    next <span class="token operator">=</span> ConflictIndex
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="其他">其他</h3>
<ol>
<li class="lvl-3">
<p>在初始化 Raft node 的时候我把一个 <code>{Index: 0, Term: 0}</code> 的日志放到最开始，这样就能让它每一个 Index 都能直接对应，而不需要考虑数组从 0 开始，PrevLogTerm 也就不需要考虑 PrevLogIndex 是否大于零了；</p>
</li>
<li class="lvl-3">
<p>AppendEntryRPC 无论成功和失败都返回 ConflictIndex 和 ConflictTerm，并且规定当 Append Entry 成功时，Reply 中的 ConflictIndex 是 Follwer 执行 Append 后的最后一个索引，从而正确更新到 <code>next[]</code> 和 <code>match[]</code>；</p>
</li>
</ol>
<h2 id="PART-C-Persistence">PART C-Persistence</h2>
<p>这块虽然标了 hard，但实际代码量可以忽略不计。总的来说要我们实现一致性，即能保证节点 crash 后能恢复到原来的状态。</p>
<p>Paper 中已经为我们标出了哪些变量（VoteFor、Term、Entry）是需要保持一致性的，所以 Persist() 和 ReadPersist() 没什么好聊的，直接 uncomment 掉，稍微改改就好了。</p>
<p>我们需要在这三个变量被修改的时候，及时调用 Persist() 函数以保存到 rf.Persist 里。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>VoteFor</strong>：这个变量只有在两种情况下会变：</p>
<ol>
<li class="lvl-5">收到投票申请，同意投票。这个直接在 RequestVote 里改就好了。</li>
<li class="lvl-5">任期改变，重置投票。收到任一 Term 大于 CurrentTerm 的 Message 都会导致任期改变，同时也会使节点"convert to Follwer（Rules For Servers）"。</li>
</ol>
</li>
<li class="lvl-2">
<p><strong>Term</strong>：同上。</p>
</li>
<li class="lvl-2">
<p><strong>Entry</strong>：直接在 AppendEntries() 里加。</p>
</li>
</ul>
<p>由于系统的高并发性与网络的不可靠性，我们还需要在合适的位置及时上锁，尽可能保证线性一致（善用 <code>rf.mu</code>）。</p>
<h2 id="PART-D-Log-Compaction">PART D-Log Compaction</h2>
<p>由于日志会无限增长，如果不采取某些措施，内存则会被大大浪费。我们使用<strong>快照</strong>来解决这一问题。6.824 中，上层每收到 Raft 层传来的需要 Apply 的日志，都会检查日志大小是否超限，一旦超限，就会<strong>主动</strong>将当前存储的状态打包成一份 SnapshotData，传给 Raft 层并调用 <code>Snapshot()</code>，告知其上层在哪一位置做了快照，之前得到 Apply 的日志都不需要保留了，需要进行日志截断。如下图所示：</p>
<img src="1.jpg" style="zoom:80%;">
<p>原理就如 Paper 中说的那样。在这一 part 中我们需要做这些事情：</p>
<ol>
<li class="lvl-3">
<p>改变 Entry 的索引方式；</p>
</li>
<li class="lvl-3">
<p>实现 <code>Snapshot()</code> 函数；</p>
</li>
<li class="lvl-3">
<p>实现 <code>InstallSnapshotRPC()</code> 以及相应的 args、reply 结构；</p>
</li>
<li class="lvl-3">
<p>实现 crash 后恢复所需的持久状态；</p>
</li>
</ol>
<h3 id="索引">索引</h3>
<p>因为节点的日志里存的 Index 不一定和数组下标一一对应了，前面我将每个 <code>rf.Entry[0]</code> 都采用 <code>{Index: 0, Term: 0}</code> 的哨兵来防止越界，在这里由于进行了日志压缩，哨兵可以改为 {Index: LastIncludedIndex, Term: LastIncludedTerm}，这样一来日志索引 index 到数组里的位置就变成了 <code>index - rf.Entry[0].Index</code></p>
<p>⚠ 每个涉及到<strong>索引</strong>的地方都要进行修改</p>
<h3 id="Snapshot-index-int-snapshot-byte">Snapshot(index int, snapshot []byte)</h3>
<p>这里的 index 其实就是 <code>LastIncludedIndex</code>，而 snapshot 其实就是上层告诉我们的<strong>当前存储的快照数据 SnapshotData</strong>，需要进行持久化。我们对 index 进行一个范围的判断，如果不越界，则进行日志的截断，并进行一个 <code>persist.SaveSnapshot()</code> 的操作。</p>
<blockquote>
<p><code>persist.go</code> 里没有单独保存 snapshot 的函数，需要自己添加一个。</p>
</blockquote>
<h3 id="InstallSnapShotRPC">InstallSnapShotRPC</h3>
<p>args 和 reply 要的变量都直接在 6.824 lab 网页的 hint 里和 paper 里找就行。唯一要解决的问题是，发送端要在什么时机发送这个 RPC？</p>
<p>最简单的做法是，如果某个 peer 因为断电等原因已经落后太多（Leader 要发给它的首条日志已经被压缩进了 snapshot 中），那么为了让它跟上脚步快速推进，就需要发送一个快照过去。这种情况其实就是 <code>nextIndex[peer] &lt;= rf.Entry[0].Index</code>。而这一条件的检查可以放在待发送 AppendEntry 的时刻，也就是每个心跳时刻先检查 <code>nextIndex[peer]</code>。如果满足发快照的条件，就发 InstallSnapShotRPC；反之发 AppendEntryRPC。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">SendHeartBeat</span><span class="token punctuation">(</span>peer <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> rf<span class="token punctuation">.</span>raftState <span class="token operator">!=</span> Leader <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token boolean">_</span><span class="token punctuation">,</span> nextindex <span class="token operator">:=</span> rf<span class="token punctuation">.</span><span class="token function">GetMatchNextIndex</span><span class="token punctuation">(</span>peer<span class="token punctuation">)</span>
  prevLogIndex <span class="token operator">:=</span> nextindex <span class="token operator">-</span> <span class="token number">1</span>
  BaseIndex <span class="token operator">:=</span> rf<span class="token punctuation">.</span><span class="token function">GetBaseLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Index

  <span class="token keyword">if</span> prevLogIndex <span class="token operator">&lt;</span> BaseIndex <span class="token punctuation">{</span>
    <span class="token comment">// 发送 InstallSnapshotRPC</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 发送 AppendEntryRPC</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>peer 如果收到了这一 RPC，先按照 paper 里说的检查一下，检查通过后无条件变成 Follower（认可发送方的 Leader 地位）并覆盖日志，更新 <code>lastapplied</code> 和 <code>commitindex</code>，然后将快照交给上层进行覆盖。Leader 得知 peer 成功应用快照后，修改其对应的 <code>nextIndex</code> 和 <code>matchIndex</code>。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>rf <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">InstallSnapshot</span><span class="token punctuation">(</span>args <span class="token operator">*</span>InstallSnapshotArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>InstallSnapshotReply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">defer</span> rf<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">defer</span> rf<span class="token punctuation">.</span><span class="token function">Persist</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> rf<span class="token punctuation">.</span>CurrentTerm <span class="token operator">&gt;</span> args<span class="token punctuation">.</span>Term <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>Term<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> rf<span class="token punctuation">.</span>CurrentTerm<span class="token punctuation">,</span> ErrOldTerm
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> args<span class="token punctuation">.</span>Term <span class="token operator">&gt;</span> rf<span class="token punctuation">.</span>CurrentTerm <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span>CurrentTerm<span class="token punctuation">,</span> rf<span class="token punctuation">.</span>VoteFor <span class="token operator">=</span> args<span class="token punctuation">.</span>Term<span class="token punctuation">,</span> null
  <span class="token punctuation">}</span>

  rf<span class="token punctuation">.</span><span class="token function">ChangeState</span><span class="token punctuation">(</span>Follower<span class="token punctuation">)</span>
  rf<span class="token punctuation">.</span><span class="token function">ResetTimer</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span>

  <span class="token keyword">if</span> args<span class="token punctuation">.</span>LastIncludedIndex <span class="token operator">&lt;=</span> rf<span class="token punctuation">.</span>commitIndex <span class="token punctuation">{</span>
    <span class="token comment">// 这种情况不用进行任何操作，这是因为上层会逐渐 Apply 到 commitIndex，并且发现日志超限后主动进行 Snapshot。</span>
    <span class="token comment">// 同时也防止过期的 RPC。</span>
    reply<span class="token punctuation">.</span>Term<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> rf<span class="token punctuation">.</span>CurrentTerm<span class="token punctuation">,</span> ErrOldSnapshot
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// If existing log entry has same index and term as snapshot’s</span>
  <span class="token comment">// last included entry, retain log entries following it and reply</span>

  <span class="token comment">// 1. 截断日志</span>
  <span class="token comment">// 2. 修改变量</span>
  <span class="token comment">// 3. 持久化</span>

  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    rf<span class="token punctuation">.</span>applyChannel <span class="token operator">&lt;-</span> ApplyMsg<span class="token punctuation">{</span>
      SnapshotValid<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      SnapshotIndex<span class="token punctuation">:</span> args<span class="token punctuation">.</span>LastIncludedIndex<span class="token punctuation">,</span>
      SnapshotTerm<span class="token punctuation">:</span>  args<span class="token punctuation">.</span>LastIncludedTerm<span class="token punctuation">,</span>
      Snapshot<span class="token punctuation">:</span>      args<span class="token punctuation">.</span>Data<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.824 Lab3 FTkvserver</title>
    <url>/lab/6-824lab3/</url>
    <content><![CDATA[<p>本实验要求在每一个 Raft 节点上实现一个 K/V 服务器(server)，向上接受客户端(client)的请求并返回请求结果，向下生成日志应用到 Raft 节点中。</p>
<p>整个模式大概长<a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf">这样</a>。</p>
<p>主要流程是这样的：</p>
<ol>
<li class="lvl-3">
<p>client 寻找对应 Raft 节点是 Leader 的 server，并发起一个请求(Put/Append/Get)；</p>
</li>
<li class="lvl-3">
<p>server 收到请求后，调用 Raft 的 <code>Start()</code> 函数生成新日志；</p>
</li>
<li class="lvl-3">
<p>Raft 层间互相进行日志复制之后，将 committed 日志传到到 applyChannel 里；</p>
</li>
<li class="lvl-3">
<p>server 从 applyChannel 中拿到日志，提取出命令后，正式将命令应用到存储中；</p>
</li>
</ol>
<span id="more"></span>
<h2 id="PART-A-Key-value-service-without-snapshots">PART A-Key/value service without snapshots</h2>
<h3 id="发送请求">发送请求</h3>
<p>由于 <code>Start()</code> 函数会立即返回 isleader 信息，所以如果一个 server 节点调用了 Start() 后发现不是 Leader，则返回一个 <strong>ErrWrongLeader</strong></p>
<p>当且仅当 client RPC 发送给正确的 Leader 后，才算成功；否则：</p>
<ol>
<li class="lvl-3">
<p>If the Clerk sends an RPC to the wrong kvserver, or if it cannot reach the kvserver, the Clerk should re-try by sending to a different kvserver.</p>
</li>
<li class="lvl-3">
<p>If the operation failed to commit (for example, if the Leader was replaced), the server reports an error, and the Clerk retries with a different server.</p>
</li>
</ol>
<h3 id="server-向下调用">server 向下调用</h3>
<p>首先是根据 <code>Start()</code> 返回的 isleader 来确定是否需要返回 ErrWrongLeader 错误。若成功，则等待流程 4。</p>
<p>注意到，在等待的过程中 server 是上了锁的，那必然被阻塞，此时就需要在 startKVserver 的时候额外开启一个叫 Applier() 的 goroutine 来进行 applyChannel 的读取。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>KVServer<span class="token punctuation">)</span> <span class="token function">Applier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    msg <span class="token operator">:=</span> <span class="token operator">&lt;-</span>kv<span class="token punctuation">.</span>applyCh
    <span class="token keyword">if</span> msg<span class="token punctuation">.</span>CommandValid <span class="token punctuation">{</span>
        <span class="token comment">// 应用请求</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> msg<span class="token punctuation">.</span>SnapshotValid <span class="token punctuation">{</span>
        <span class="token comment">// 应用快照</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时遇到这样一个问题：存在一个网络分区 [1] | [2, 3, 4, 5]，Peer1 是分区前的 leader，分区后 1 仍然是 leader。分区 [2, 3, 4, 5] 由于选举导致它们的 Term 大于 Peer1 的 Term，假设该分区的 Leader 为 Peer2。现在有一个 clientA 一直给分区 [1] 发送请求，某一个请求 <code>{requestID: x，clientID: A}</code> 发给 Peer1 后，其调用 <code>Start()</code> 并返回日志所在索引 <code>Index=i</code> 后，网络恢复，Peer1 收到 Term 更高的 Peer2 的 AppendEntries 消息后将原先 <code>Index=i</code> 处的日志覆盖，更新 commitIndex 后告知上层进行 Apply。这就会导致同一 Index 处的命令出现二义性——client 发起了请求 A，但应用到存储却是另一请求 B。</p>
<p>解决方法为：在结构体 <code>Args</code> 中增加一个 channel，当 applier 处理完消息时通过该 channel 返回处理结果，同时判断 <code>msg.commandTerm</code> 和 <code>kv.rf.currentTerm</code> 是否匹配，如果不匹配，说明可能被其他日志覆盖，返回一个 ErrWrongLeader 让上层重发。</p>
<p>注意，只有 Leader 需要对请求做出答复。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token operator">&amp;&amp;</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetCurrentTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> msg<span class="token punctuation">.</span>CommandTerm <span class="token punctuation">{</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>reply_ <span class="token operator">*</span>Reply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ch <span class="token operator">&lt;-</span> reply_
  <span class="token punctuation">}</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="应用到状态机">应用到状态机</h3>
<p>Applier() 对 applyChannel 进行一个 for 的等待，收到消息后，根据收到消息的命令类型的不同，执行不同的应用操作。</p>
<blockquote>
<p>Put(key, value) replaces the value for a particular key in the database, Append(key, arg) appends arg to key’s value, and Get(key) fetches the current value for the key. A Get for a non-existent key should return an empty string. An Append to a non-existent key should act like Put.</p>
</blockquote>
<p>执行完后，返回消息到 <code>waitchannel[Index]</code>，唤醒 server。</p>
<h3 id="Other">Other</h3>
<ol>
<li class="lvl-3">
<p>刚开始想到和 Raft 里发送请求投票一样的手段，为每一个 server 开一个 goroutine 去发送 RPC，后来发现最后成功发送的只有一个，其它 goroutine 都是在占 cpu，遂放弃，直接用单个 for 循环。另外，有时候 Leader 会在相当一段时间内保持不变，我们可以 cache 上一次发送请求成功时的 serverId，认为这是 Leader，每次发请求时都可以利用这一信息，避免了不必要的 RPC，加快速度。当 RPC 失败，或发生了 ErrWrongLeader，只需要简单的令 Leader 切换到下一个即可（0-&gt;1-&gt;…-&gt;n-1-&gt;0-&gt;…）</p>
 <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>ck <span class="token operator">*</span>Clerk<span class="token punctuation">)</span> <span class="token function">SendRequest</span><span class="token punctuation">(</span>args <span class="token operator">*</span>Args<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">defer</span> ck<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  args<span class="token punctuation">.</span>RequestId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>ClerkId <span class="token operator">=</span> ck<span class="token punctuation">.</span>RequestId<span class="token punctuation">,</span> ck<span class="token punctuation">.</span>ClerkId
  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    reply <span class="token operator">:=</span> <span class="token operator">&amp;</span>Reply<span class="token punctuation">{</span><span class="token punctuation">}</span>
    ok <span class="token operator">:=</span> ck<span class="token punctuation">.</span>servers<span class="token punctuation">[</span>ck<span class="token punctuation">.</span>volatileLeader<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Call</span><span class="token punctuation">(</span><span class="token string">"KVServer.HandleRequest"</span><span class="token punctuation">,</span> args<span class="token punctuation">,</span> reply<span class="token punctuation">)</span>
    <span class="token keyword">if</span> ok <span class="token operator">&amp;&amp;</span> reply<span class="token punctuation">.</span>Err <span class="token operator">!=</span> ErrWrongLeader <span class="token punctuation">{</span>
        ck<span class="token punctuation">.</span>RequestId<span class="token operator">++</span>
        <span class="token keyword">return</span> reply<span class="token punctuation">.</span>Value
    <span class="token punctuation">}</span>
    ck<span class="token punctuation">.</span>volatileLeader <span class="token operator">=</span> <span class="token punctuation">(</span>ck<span class="token punctuation">.</span>volatileLeader <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token function">len</span><span class="token punctuation">(</span>ck<span class="token punctuation">.</span>servers<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>在分区测试中，有可能发生 Leader 超时未 apply 的情况（即一个 Leader 被分到了 minority 的网络区），此时需要在 server 等待环节加一个 &lt;-time.After() 的信号接受判断，若超时，则直接返回，并且认为超时也是一种"ErrWrongLeader"。</p>
</li>
<li class="lvl-3">
<p>lab3A 还要求我们不能执行同一个 client 的重复请求，那么需要在每个 server 上放一个 clientID 到其最近一次命令序号 requestID 的映射，如果 Worker 收到的这个命令序号已经被执行过了，那么就不再执行，直接返回 ErrDuplicated。Get 是否重复执行无所谓，因为它并不会对数据库产生实质性的影响，主要是防止多次 Put/Append 同一个值。</p>
</li>
</ol>
<p>总体代码量比 Raft 少太多，但因为论文中并没有给出很详细的指示，就走了很多弯路，以至于绝大多数时间都在 debug…</p>
<h2 id="PART-B-Key-value-service-with-snapshots">PART B-Key/value service with snapshots</h2>
<p>本实验要求在 3A 的基础上加上 snapshot 功能。</p>
<blockquote>
<p>虽然标的是hard，但代码量更少了</p>
</blockquote>
<p>server 不断检测 raftStateSize，如果过大，即当 persist.RaftStateSize() &gt;= kv.maxRaftState 时，将当前 db 状态保存下来，调用 Raft 层的 snapshot() 并将 db 状态传入。</p>
<p>要实现有两个函数：</p>
<ol>
<li class="lvl-3">
<p><code>MakeSnapshot()</code>: 当 raftStateSize 过大时保存存储状态；</p>
</li>
<li class="lvl-3">
<p><code>ApplySnapshot()</code>: raft 层将 snapshotValid 发到 applyCh，被 server 接收到后执行的操作；</p>
</li>
</ol>
<blockquote>
<p>persist 里的 raftstate 和 index 没有直接关系，所以不能用在 snapshot 里的 index 参数。</p>
</blockquote>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>MIT6.824 学习总结</title>
    <url>/lab/6-824-xue-xi-zong-jie/</url>
    <content><![CDATA[<p>磨蹭 3 个月，神课分布式系统 <a href="https://pdos.csail.mit.edu/6.824/">MIT 6.824</a> 终于完结了。学习这门课的起因是被同年 6 月份 pingCAP 训练营橄榄了，虽然同为 raft 算法，但工业级的实现显然要比教学级难更多。我对分布式的理解还是太浅，于是决心从基础打起，好好体会一下这门神课的洗礼。</p>
<span id="more"></span>
<h2 id="课程架构">课程架构</h2>
<p><a href="https://pdos.csail.mit.edu/6.824/">👉课程主页传送门👈</a></p>
<p>本课程设计了 4 个 lab。分别为</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-mr.html">MapReduce</a></p>
</li>
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-raft.html">Raft</a></p>
</li>
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-kvraft.html">Fault-tolerant Key/Value Service</a></p>
</li>
<li class="lvl-2">
<p><a href="https://pdos.csail.mit.edu/6.824/labs/lab-shard.html">Sharded Key/Value Service</a></p>
</li>
</ul>
<p>我的实现通过所有 test，将代码 push 在了我的 <a href="https://github.com/Leager-zju/MIT6.824">github 仓库</a>中，并写了说明文档：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="../6-824lab1">Lab1 doc</a></p>
</li>
<li class="lvl-2">
<p><a href="../6-824lab2">Lab2 doc</a></p>
</li>
<li class="lvl-2">
<p><a href="../6-824lab3">Lab3 doc</a></p>
</li>
<li class="lvl-2">
<p><a href="../6-824lab4">Lab4 doc</a></p>
</li>
</ul>
<h2 id="学习感悟">学习感悟</h2>
<p>每节课看一篇论文对我而言还是比较硬的，但确实能够从中学到许多知识，复制、容错、一致、性能优化……这些无一不是分布式领域中的人类思想的精华。在进一步经历了 4 个 lab 的虐待后，无论是对 go 还是对整个分布式系统的实现都有了更深的认识。这也难怪 MIT 的学生一直以来都是各大互联网企业争相抢夺的人才资源，能够把这门课完整的学下来已经能让一个人进步非常多了。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab0 Xv6 and Unix Utilities</title>
    <url>/lab/6-s081lab0/</url>
    <content><![CDATA[<p>热身运动，实现一些 shell 命令。</p>
<span id="more"></span>
<h2 id="Boot-xv6">Boot xv6</h2>
<p>首先去 <a href="https://pdos.csail.mit.edu/6.828/2021/tools.html">lab tool page</a> 把实验所需工具都给装上，然后查看一下各个工具的版本，检查是否安装成功。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ tool <span class="token parameter variable">--version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>获取代码，切换到实验对应分支，准备开撸。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> clone git://g.csail.mit.edu/xv6-labs-2021
$ <span class="token builtin class-name">cd</span> xv6-labs-2021
$ <span class="token function">git</span> checkout util<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>输入 <code>make qemu</code> 可以编译所有代码并模拟内核环境，输入 <code>ctrl+a x</code> 以退出环境。</p>
</blockquote>
<h2 id="Task1-sleep">Task1: sleep</h2>
<p>该任务要求实现 <code>sleep</code> 命令，模式为</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">sleep</span> 时间值<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这个任务就是帮助我们熟悉整个代码框架，以及一些头文件。</p>
<p>比如框架为我们提供了系统调用，位于头文件 <code>user/user.h</code> 中，以及 <code>kernel/types.h</code> 为我们提供了类型定义。这两个头文件在后面都是需要 include 的。</p>
<p>在 <code>user/</code> 文件夹下 <code>touch</code> 一个新文件，然后写入代码：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>user/sleep.c</span></div><code class="language-C">#include "kernel/types.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  if (argc &lt; 2) {
    fprintf(2, "Usage: sleep seconds...\n");
    exit(1);
  }

  int ticks = atoi(argv[1]);  // 自带的库函数，定义位于 user/ulib.c
  sleep(ticks);               // user.h 中的系统调用
  exit(0);                    // 每个进程都要调用 exit(0) 正常退出
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与此同时，还要修改 <code>Makefile</code> 里头 <code>UPROGS</code> 变量，在后面加上 <code>$U/_sleep\</code> 即可正确编译。编译后，我们可以进入 qemu 并调用 <code>sleep</code> 看看效果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> qemu
$ <span class="token function">sleep</span> <span class="token number">10</span>
<span class="token punctuation">(</span>nothing happens <span class="token keyword">for</span> a little <span class="token keyword">while</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>也可以用 lab 自带的 python 脚本 <code>grade-lab-util [test-name]</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./grade-lab-util <span class="token function">sleep</span>
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test sleep, no arguments <span class="token operator">==</span> sleep, no arguments: OK <span class="token punctuation">(</span><span class="token number">3</span>.6s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test sleep, returns <span class="token operator">==</span> sleep, returns: OK <span class="token punctuation">(</span><span class="token number">0</span>.6s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test sleep, makes syscall <span class="token operator">==</span> sleep, makes syscall: OK <span class="token punctuation">(</span><span class="token number">1</span>.0s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task2-pingpong">Task2: pingpong</h2>
<p>该任务要求我们利用 <code>pipe()</code> 和 <code>fork()</code> 两大系统调用进行父子进程间的同步：</p>
<ol>
<li class="lvl-3">
<p>父进程通过管道发送一个字节给子进程；</p>
</li>
<li class="lvl-3">
<p>子进程收到后，打印一条消息，然后将该字节返回给父进程，退出；</p>
</li>
<li class="lvl-3">
<p>父进程等待子进程运行完毕，再进行读取，这样做是防止读到自己已经写入的内容。收到后，打印一条消息，然后退出；</p>
</li>
</ol>
<p>首先是管道的创建。<code>int pipe(int *fd)</code> 会将 <code>fd[0]</code> 设置为读端，<code>fd[1]</code> 设置为写端，并返回调用是否成功（返回 <code>-1</code> 表示创建管道失败）</p>
<p>再是进程的创建。<code>int fork()</code> 会在当前进程 <code>parent</code> 的基础上创建一个新进程 <code>child</code>，<code>child</code> 相当于是 <code>parent</code> 的副本——拷贝了所有内容，唯一的区别在于这俩进程不共享地址空间，也就是说在 <code>child</code> 中修改全局变量并不会影响到 <code>parent</code> 里的全局变量，毕竟只是副本。对于父进程，<code>fork</code> 会返回子进程的 <code>pid</code>；而对于子进程则返回 <code>0</code>。</p>
<p>最后等待子进程运行完毕需要用到 <code>wait(int *)</code>，传入的是子进程 <code>pid</code> 的指针，如果传入 <code>0</code> 意为等待所有子进程结束。</p>
<p>有了这些预备知识，代码就很好编写了：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>user/pingpong.c</span></div><code class="language-C">#include "kernel/types.h"
#include "user/user.h"

#define ONEBYTE sizeof(char)

int
main(int argc, char *argv[])
{
  int fd[2]; // fd[0] 为读端, fd[1] 为写端
  if (pipe(fd) &lt; 0) {
    fprintf(2, "pingpong: pipe failed\n");
    exit(1);
  }

  // 1. The parent should send a byte to the child;
  // 2. the child should print "&lt;pid&gt;: received ping", where &lt;pid&gt; is its process ID,
  //    and write the byte on the pipe to the parent, and exit;
  // 3. the parent should read the byte from the child, print "&lt;pid&gt;: received pong", and exit.
  int pid = fork();
  if (pid &gt; 0) { // parent
    char *buf = (char*)malloc(ONEBYTE); // an one-byte memory
    if (write(fd[1], buf, ONEBYTE) != ONEBYTE) {
      fprintf(2, "pingpong: proc %d write failed\n", getpid());
      free(buf);
      exit(1);
    }

    wait(&amp;pid); // 如果不加这步，则下面的 read 可能会抢先拿出自己 write 的数据

    if (read(fd[0], buf, ONEBYTE) &lt; 0) {
      fprintf(2, "pingpong: proc %d read failed\n", getpid());
      free(buf);
      exit(1);
    }

    printf("%d: received pong\n", getpid());
    free(buf);  // malloc 后跟 free 防止内存泄漏
  } else if (pid == 0) { // child
    char* buf = (char*)malloc(ONEBYTE);
    if (read(fd[0], buf, ONEBYTE) &lt; 0) {
      fprintf(2, "pingpong: proc %d read failed\n", getpid());
      free(buf);
      exit(1);
    }

    printf("%d: received ping\n", getpid());

    if (write(fd[1], buf, ONEBYTE) != ONEBYTE) {
      fprintf(2, "pingpong: proc %d write failed\n", getpid());
      free(buf);
      exit(1);
    }
    free(buf);
  } else {
    fprintf(2, "pingpong: fork failed\n");
    exit(1);
  }

  exit(0);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改完 <code>Makefile</code> 后进行测试，结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./grade-lab-util pingpong
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test pingpong <span class="token operator">==</span> pingpong: OK <span class="token punctuation">(</span><span class="token number">1</span>.3s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task3-primes">Task3: primes</h2>
<p>该任务是上一个任务的 plus 版本，编写一个并发输出 2~35 之间所有素数的程序，算法思想见<a href="http://swtch.com/~rsc/thread/">这个网页</a>。</p>
<p>在这里，就是对于每一个进程 <code>p</code>，不断接收其父进程 <code>parent</code> 写入管道的数据。对于第一个收到的数据 <code>n</code>，直接打印，对于后续的数据 <code>data</code>，如果满足 <code>data % p != 0</code>，说明该数可能是个素数，通过管道交给子进程 <code>child</code>。</p>
<p>由于所有的管道都是单向的，即从 <code>parent</code> 流向 <code>child</code>，故每个进程需关闭左侧（与 <code>parent</code> 交互）管道的写端与右侧（与 <code>child</code> 交互）的读端，防止文件描述符不够用的情况。</p>
<p>注意到，由于范围内的最后一个素数是 31，所以收到并打印 31 以后就不用再进一步创建子进程，反之，打印完素数后进一步 <code>fork()</code>，这也指明了递归终止的条件（创建子进程相当于一个递归的过程）。同时，最左侧进程（也就是主进程）只能写不能读，那就干脆不让他打印了，只往管道写数据好了。</p>
<p>代码如下：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>user/primes.c</span></div><code class="language-C">#include "kernel/types.h"
#include "user/user.h"

void
createNewProc(int p, int *left)
{
  int right[2];
  if (pipe(right) &lt; 0) {
    fprintf(2, "primes: pipe failed\n");
    exit(1);
  }

  int pid = fork();
  if (pid &gt; 0) {
    close(right[0]);
    int n;
    while (read(left[0], &amp;n, sizeof(int)) == sizeof(int)) {
      if (n % p != 0) {
        if (write(right[1], &amp;n, sizeof(int)) != sizeof(int)) {
          fprintf(2, "primes: proc %d write failed\n", getpid());
          exit(1);
        }
      }
    }
    close(right[1]);
    wait((int*)0);
  } else if (pid == 0) {
    close(right[1]);

    int p;
    read(right[0], &amp;p, sizeof(int));
    printf("prime %d\n", p);

    if (p != 31) {
      createNewProc(p, right);
    }
  } else {
    fprintf(2, "primes: fork failed\n");
    exit(1);
  }
}

int
main(int argc, char *argv[])
{
  int fd[2];
  if (pipe(fd) &lt; 0) {
    fprintf(2, "primes: pipe failed\n");
    exit(1);
  }

  int pid = fork();
  if (pid &gt; 0) {
    close(fd[0]); // 关闭用不到的
    for (int i = 2; i &lt;= 35; i++) {
      if (write(fd[1], &amp;i, sizeof(int)) != sizeof(int)) {
        fprintf(2, "primes: proc %d write failed\n", getpid());
        exit(1);
      }
    }
    close(fd[1]); // 写完了就关掉，防止不够用
    wait((int*)0);
  } else if (pid == 0) {
    close(fd[1]); // 关闭用不到的
    int p;
    read(fd[0], &amp;p, sizeof(int));
    printf("prime %d\n", p);

    createNewProc(p, fd); // 第一个打印数据的进程，递归创建子进程进行打印数据
  } else {
    fprintf(2, "primes: fork failed\n");
    exit(1);
  }

  exit(0);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改完 <code>Makefile</code> 后进行测试，结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./grade-lab-util primes
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test primes <span class="token operator">==</span> primes: OK <span class="token punctuation">(</span><span class="token number">0</span>.7s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task4-find">Task4: find</h2>
<p>该任务要求我们实现一个简单版本的 <code>find</code> 命令。其模式为</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">find</span> 目录 文件名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>user/ls.c</code> 里有读取目录的样例实现。熟悉文件系统的应该知道，目录也是「文件」，也具有 <code>inode</code> 号和相应的磁盘空间，只不过其磁盘块上的内容是若干文件条目，在 lab 中用数据结构 <code>dirent</code> 表示，其内容为 <code>{inode, name}</code>，其中 <code>name</code> 既可以是文件名，也可以是目录名。</p>
<p>所以思路就清晰了：</p>
<ol>
<li class="lvl-3">
<p>对于每个当前目录 <code>dir</code>，遍历其 <code>dirent</code> 并利用 <code>stat()</code> 获取该条目对应的类型；</p>
</li>
<li class="lvl-3">
<p>如果是文件类型，则判断其 <code>name</code> 与待查找的文件名 <code>target</code> 是否一致，若一致则输出路径；</p>
</li>
<li class="lvl-3">
<p>如果是目录类型，递归查找，跳过当前目录 <code>.</code> 与父目录 <code>..</code>；</p>
</li>
</ol>
<p>代码如下：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>user/find.c</span></div><code class="language-C">#include "kernel/types.h"
#include "kernel/stat.h"
#include "user/user.h"
#include "kernel/fs.h"
#include "kernel/param.h"

#define BUFSIZE 512

void
searchFile(char *dir, char *file)
{
  int fd; // 指向目录 dir
  if ((fd = open(dir, 0)) &lt; 0){
    fprintf(STDERR, "find: cannot open %s\n", dir);
    exit(1);
  }

  if (strlen(dir) + 1 + DIRSIZ + 1 &gt; BUFSIZE){ // path + '/' + name + '\0'
    fprintf(STDERR, "find: path too long\n");
    exit(1);
  }

  // 构建路径名
  char buf[BUFSIZE], *p;
  strcpy(buf, dir);
  p = buf+strlen(buf);
  *p++ = '/'; // buf 当前为 "${dir}/"

  // 遍历目录下所有条目
  struct dirent de;
  struct stat st;
  while (read(fd, &amp;de, sizeof(de)) == sizeof(de)) { // 每次读一整个 dirent 大小
    if (de.inum == 0 || strcmp(de.name, ".") == 0 || strcmp(de.name, "..") == 0) { // 跳过无效项
      continue;
    }

    // 构建文件路径名
    memmove(p, de.name, DIRSIZ);
    p[DIRSIZ] = 0;
    if (stat(buf, &amp;st) &lt; 0) {
      fprintf(STDERR, "find: cannot stat %s\n", buf);
      continue;
    }

    switch (st.type) {
      case T_FILE: // 检查文件名是否一致
        if (strcmp(file, de.name) == 0) {
          printf("%s\n", buf);
        }
        break;
      case T_DIR: // 递归查找子目录
        searchFile(buf, file);
        break;
    }
  }
}

int
main(int argc, char *argv[])
{
  if (argc &lt;= 2) {
    fprintf(2, "Usage: find dir files...");
    exit(1);
  }

  for (int i = 2; i &lt; argc; i++) { // 支持同一目录下多文件查找
    searchFile(argv[1], argv[i]);
  }
  exit(0);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改完 <code>Makefile</code> 后进行测试，结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./grade-lab-util <span class="token function">find</span>
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test find, <span class="token keyword">in</span> current directory <span class="token operator">==</span> find, <span class="token keyword">in</span> current directory: OK <span class="token punctuation">(</span><span class="token number">0</span>.8s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test find, recursive <span class="token operator">==</span> find, recursive: OK <span class="token punctuation">(</span><span class="token number">1</span>.1s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task5-xargs">Task5: xargs</h2>
<p>最后一个任务是实现 <code>xargs</code> 命令。该命令一般配合管道使用，将前一个命令输出，作为后面命令的额外参数，比如</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> hello too <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token builtin class-name">echo</span> bye
bye hello too<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>就是将 <code>echo hello too</code> 的输出 <code>hello too</code> 作为 <code>echo bye</code> 的额外参数并附加到末尾，相当于执行了命令 <code>echo bye hello too</code>。这里我们只需实现 <code>-n 1</code> 的版本，即每 <code>1</code> 行输出作为一组额外参数。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">echo</span> <span class="token parameter variable">-e</span> <span class="token string">"1<span class="token entity" title="\n">\n</span>2"</span> <span class="token operator">|</span> <span class="token function">xargs</span> <span class="token parameter variable">-n</span> <span class="token number">1</span> <span class="token builtin class-name">echo</span> line
line <span class="token number">1</span>
line <span class="token number">2</span>
<span class="token comment">## 前面理论上输出为</span>
<span class="token comment">## 1</span>
<span class="token comment">## 2</span>
<span class="token comment">## 整行命令相当于依次执行了</span>
<span class="token comment">## echo line 1</span>
<span class="token comment">## echo line 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于 <code>xargs</code> 而言，必然前面是出现管道符 <code>|</code> 的，也就意味着有额外参数被写入到标准输出(fd=1)中，那就要从标准输入(fd=0)中读取了。思路很明确了：不断从标准输入中读字符直到 <code>'\n'</code>，意味着完整的参数已被读取，那就调用 <code>exec()</code> 执行命令。</p>
<p>注意到 <code>exec()</code> 会将当前进程替换为新进程，原来那个进程后面就不继续了，所以每次 <code>exec()</code> 都要由主进程 <code>fork()</code> 一个子进程去执行</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>user/xargs.c</span></div><code class="language-C">#include "kernel/types.h"
#include "kernel/param.h"
#include "user/user.h"

int
main(int argc, char *argv[])
{
  // eg: find . b | xargs grep hello
  char *cmd = argv[1];
  char *new_args[MAXARG];

  // 先把原本的参数加进去
  int k;
  for (k = 0; k &lt; argc-1; k++) {
    new_args[k] = argv[k+1];
  }

  char extra_arg[32];
  int p = 0;
  // 逐行读取，再把新参数 append 到 new_args 里去
  while (read(STDIN, extra_arg+p, 1) &gt; 0) {
    if (extra_arg[p] == '\n') {
      extra_arg[p] = '\0';

      // 遇到 '\n' 就意味着准备好 exec 了，立马 fork 一个子进程去做。
      // 记得用 wait 来进行同步
      int pid;
      pid = fork();
      if (pid &gt; 0) {
        wait(&amp;pid);
      } else if (pid == 0) {
        new_args[k] = extra_arg;
        exec(cmd, new_args);

        // 如果 exec 调用失败才会到这一行
        fprintf(2, "exec %s failed\n", cmd);
        exit(1);
      } else {
        fprintf(2, "xargs: fork failed\n");
        exit(1);
      }
      p = 0;
    } else {
      p++;
    }
  }
  exit(0);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改完 <code>Makefile</code> 后进行测试，结果如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ ./grade-lab-util <span class="token function">xargs</span>
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test <span class="token function">xargs</span> <span class="token operator">==</span> xargs: OK <span class="token punctuation">(</span><span class="token number">1</span>.9s<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p>新建一个 <code>time.txt</code> 文件，写上总共花了多少小时，然后 <code>git commit -am ""</code> 将所有修改提交到本地。</p>
</li>
<li class="lvl-3">
<p>去网页用邮箱注册，然后收到一封邮件，点击邮件链接会收到一个 key，妥善保管；</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>，输入刚才得到的那个 key，就成功提交了，并且显示当前的课程进度；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 系统调用流程</title>
    <url>/lab/6-s081systemcallprocess/</url>
    <content><![CDATA[<p>番外篇，探究通过 shell 运行命令时，系统调用到底是个什么流程。</p>
<span id="more"></span>
<h2 id="用户层是如何进行系统调用的">用户层是如何进行系统调用的</h2>
<p>以 <code>sleep.c</code> 为例，在 lab0 中我们知道要修改 Makefile 中的 <code>UPROGS</code> 变量，并且 <code>user/user.h</code> 中也为我们提供了 <code>sleep()</code> 的函数声明，但有一件事一直让我们感到疑惑，只不过 lab0 中并没有影响，那就是 <code>sleep()</code> 的定义在哪里？</p>
<p>事实上，<code>Makefile</code> 在构建时，会首先调用 <code>user/usys.pl</code> 脚本文件，其作用是生成一个汇编语言文件 <code>usys.S</code>，这个文件会被解释成 <code>usys.o</code>，最后再和其它 <code>*.o</code> 文件一起链接成内核文件。那么这个脚本具体做了什么事呢？根据阅读我们发现，该文件就是利用 <code>entry()</code> 将用户层的各个函数注册成汇编语言，比如 <code>entry("sleep")</code> 会被注册为：</p>
<pre class="line-numbers language-s" data-language="s"><div class="caption"><span>user/usys.S</span></div><code class="language-s">sleep:
  li a7, SYS_sleep
  ecall
  ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>user.h</code> 中的所有函数都在 <code>usys.pl</code> 中得到注册，所以它们的实现形式都是一样的。</p>
</blockquote>
<p>易得，<strong>调用用户层的 <code>sleep()</code> 时，会将 <code>SYS_sleep</code> 加载到寄存器 a7 中，然后调用 <code>ecall</code> 指令进入内核，最后通过 <code>ret</code> 返回用户态</strong>。</p>
<p>那么这里有个疑问：这个 <code>SYS_sleep</code> 是个什么东西？在 <code>kernel/syscall.c</code> 中有个叫 <code>syscalls[]</code> 的数组，这就是系统调用表，记载了系统调用号 <code>SYS_xxx</code> 到系统调用函数指针 <code>sys_xxx</code> 的映射，那么 <code>SYS_sleep</code> 对应的就是系统调用 <code>sys_sleep</code> 了。</p>
<blockquote>
<p>这些 <code>SYS_xxx</code> 的值都在 <code>kernel/syscall.h</code> 中定义。</p>
</blockquote>
<h2 id="ecall-与-uservec">ecall 与 uservec</h2>
<p><code>ecall</code> 实际上是一条 CPU 指令，它只做三件事情：</p>
<ol>
<li class="lvl-3">
<p>切换用户态到内核态；</p>
</li>
<li class="lvl-3">
<p>保存用户态程序计数器 PC 到寄存器 SEPC；</p>
</li>
<li class="lvl-3">
<p>将 PC 设置成寄存器 STVEC 的值，从而跳转到寄存器 STVEC 中指向的指令，也就是 <code>uservec</code>；</p>
</li>
</ol>
<p>那么 <code>uservec</code> 做了什么事呢？</p>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S">uservec:
    ## swap a0 and sscratch
    ## so that a0 is TRAPFRAME, and sscratch is user a0
    csrrw a0, sscratch, a0

    ## save the user registers in TRAPFRAME
    sd ra, 40(a0)
    ...
    sd t6, 280(a0)

    ## save the user a0 in p-&gt;trapframe-&gt;a0
    csrr t0, sscratch
    sd t0, 112(a0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最开始，地址 <code>TRAPFRAME</code> 的值记录在寄存器 SSCRATCH 中，而 trapframe 用于保存所有的 32 个用户寄存器值，而寄存器 a0 存放了<strong>第一个参数</strong>。<code>uservec</code> 首先交换这两个寄存器的值，这样 a0 就指向 trapframe 了，然后再将所有寄存器依次写入页中。当然，原本的 a0，也就是现在的 SSCRATCH，也需要被保存。</p>
<blockquote>
<p>之所以交换，是因为诸如 <code>sd ra 40(a0)</code> 这些指令的操作数必须位于用户寄存器，而原本的 32 个用户寄存器都被各自的数据占用，没法存 <code>TRAPFRAME</code>，于是就用 SSCRATCH，这个寄存器的作用就是「保存其他寄存器的值」。只要将 <code>TRAPFRAME</code> 存入其中，通过交换，就可以让 <code>TRAPFRAME</code> 放到用户寄存器了，从而能够根据 a0 访存，将用户寄存器保存到内存中。</p>
<p>当然，别忘了后面还要换回来。</p>
</blockquote>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S">## restore kernel stack pointer from p-&gt;trapframe-&gt;kernel_sp
ld sp, 8(a0)

## make tp hold the current hartid, from p-&gt;trapframe-&gt;kernel_hartid
ld tp, 32(a0)

## load the address of usertrap(), p-&gt;trapframe-&gt;kernel_trap
ld t0, 16(a0)

## restore kernel page table from p-&gt;trapframe-&gt;kernel_satp
ld t1, 0(a0)
csrw satp, t1

## clear page table cache(TLB)
sfence.vma zero, zero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一些内核数据保存在 trapframe 的前面几个变量中，这里将这些变量加载到寄存器中，方便使用。之后将 t1 与 SATP 交换，并清空页表缓存，我们就正式切换到了内核页表。又因为 trampoline 在用户态和内核态都处于同一个虚拟地址，并且映射到同一个物理地址，所以执行不会报错。</p>
<blockquote>
<p>原本 SATP 内的用户页表指针不用保存，因为它可以通过 <code>MAKE_SATP(p-&gt;pagetable)</code> 写回。</p>
<p>那么，叫 trampoline page 的原因就很好理解了——某种程度在它上面「弹跳」了一下，然后从用户空间走到了内核空间。</p>
</blockquote>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S">## a0 is no longer valid, since the kernel page
## table does not specially map p-&gt;tf.

## jump to usertrap(), which does not return
jr t0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后就是根据 t0 和内核页表，获取 <code>usertrap()</code> 函数物理地址，跳转过去并执行了。</p>
<h2 id="usertrap-做了什么">usertrap() 做了什么</h2>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">void
usertrap(void)
{
  if((r_sstatus() &amp; SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，检查 SSTATUS 的 SPP 位。该位指明了 CPU 之前的权限，如果为 0，则说明是从用户态来的，那检查通过。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">// send interrupts and exceptions to kerneltrap(),
// since we're now in the kernel.
w_stvec((uint64)kernelvec);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>w_stvec()</code> 将 <code>kernelvec</code> 写入 STVEC 中。由于已经处于内核态，如果在这里触发中断/异常就转到 <code>kernelvec</code> 去执行。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">struct proc *p = myproc();

// save user program counter.
p-&gt;trapframe-&gt;epc = r_sepc();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接着，它获取当前进程 p，并将 SEPC 的值保存在 p-&gt;trapframe 的 <code>epc</code> 字段中，这是为了防止切换进程时 SEPC 被覆写。</p>
<blockquote>
<p>当前进程的获取需要通过当前 CPU。事实上我们上面已经把 hartid 保存在 tp 中了，这里只需读取编号并从一个叫 <code>cpus</code> 的表中获取即可，每个 <code>struct cpu</code> 内都有一个指针来指向当前进程。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">if(r_scause() == 8){
  // system call

  if(p-&gt;killed)
    exit(-1);

  // sepc points to the ecall instruction,
  // but we want to return to the next instruction.
  p-&gt;trapframe-&gt;epc += 4;

  // an interrupt will change sstatus &amp;c registers,
  // so don't enable until done with those registers.
  intr_on();

  syscall();
} else if((which_dev = devintr()) != 0){
  // ok
} else {
  printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p-&gt;pid);
  printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
  p-&gt;killed = 1;
}

if(p-&gt;killed)
  exit(-1);

// give up the CPU if this is a timer interrupt.
if(which_dev == 2)
  yield();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>（快结束了！）它检查 SCAUSE 寄存器。在 RISC-V 中，一旦出现中断或异常，硬件就会自动设置该寄存器，如果是系统调用，那么会将其设置为 <code>8</code>。</p>
<ul class="lvl-0">
<li class="lvl-5">
<p>如果检查发现这是一个系统调用，就将 trapframe 中保存的用户 PC 增加一个指令字长，这是为了返回时可以直接从系统调用的下一条指令继续执行，然后通过 <code>intr_on()</code> 开中断，最后调用 <code>syscall()</code> 执行系统调用；</p>
</li>
<li class="lvl-5">
<p>如果是来自设备的中断，并且还是时钟中断，就让出 CPU；</p>
</li>
<li class="lvl-5">
<p>如果啥也不是，说明出现了某些错误，需要将该进程杀死；</p>
</li>
</ul>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">  usertrapret();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最后，调用 <code>usertrapret()</code> 返回用户态；我们需要关注的就是这个 <code>syscall()</code> 函数，它取出 trapframe 下 a7 的值……这个值好熟悉，原来就是之前我们放入的 <code>SYS_xxx</code>。读取这个值后，从系统调用表中找到相应的系统调用函数指针，通过读取 trapframe 中的寄存器获取参数，就可以做事情了。</p>
<h2 id="usertrapret-做了什么">usertrapret() 做了什么</h2>
<p><code>usertrapret()</code> 做了一些，为了返回用户态，软件层面要做的工作。嗯，其实就是恢复用户态数据到各个寄存器里。</p>
<p>先回想一下哪些数据因为执行 <code>usertrap()</code> 而被保存或覆写了……用户程序计数器 PC、32 个用户寄存器、SATP 寄存器、STVEC 寄存器、SSCRATCH 寄存器……嗯好像就这些，那接下来就需要将原来用户态的数据写回了。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">void
usertrapret(void)
{
  struct proc *p = myproc();

  // we're about to switch the destination of traps from
  // kerneltrap() to usertrap(), so turn off interrupts until
  // we're back in user space, where usertrap() is correct.
  intr_off();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>首先，关闭中断。这是因为接下来要重置 <code>STVEC</code>，而我们仍处于内核态，一旦发生中断/异常，可能会因为 <code>STVEC</code> 的重置而进入错误的处理程序。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">// send syscalls, interrupts, and exceptions to trampoline.S
w_stvec(TRAMPOLINE + (uservec - trampoline));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>接着，写回 STVEC。这是因为我们之前将其设为了 <code>kernelvec</code>，现在要返回用户态了，必须切回 <code>uservec</code>。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">// set up trapframe values that uservec will need when
// the process next re-enters the kernel.
p-&gt;trapframe-&gt;kernel_satp = r_satp();         // kernel page table
p-&gt;trapframe-&gt;kernel_sp = p-&gt;kstack + PGSIZE; // process's kernel stack
p-&gt;trapframe-&gt;kernel_trap = (uint64)usertrap;
p-&gt;trapframe-&gt;kernel_hartid = r_tp();         // hartid for cpuid()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与此同时，更新 trapframe 的前 5 个字段。其中 <code>kernel_satp</code> 与 <code>kernel_hartid</code> 分别从 <code>satp</code> 与 <code>tp</code> 中读取，而 <code>kernel_sp</code> 被设置为 <code>kstack + PGSIZE</code> 是因为栈大小为一个 <code>PGSIZE</code>，<code>kernel_trap</code> 则是直接被设置为 <code>usertrap</code> 的函数地址。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">// set up the registers that trampoline.S's sret will use
// to get to user space.

// set S Previous Privilege mode to User.
unsigned long x = r_sstatus();
x &amp;= ~SSTATUS_SPP; // clear SPP to 0 for user mode
x |= SSTATUS_SPIE; // enable interrupts in user mode
w_sstatus(x);

// set S Exception Program Counter to the saved user pc.
w_sepc(p-&gt;trapframe-&gt;epc);

// tell trampoline.S the user page table to switch to.
uint64 satp = MAKE_SATP(p-&gt;pagetable);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还需要设置一些 <code>userret</code> 会用到的寄存器，将 SSTATUS 寄存器的 SPP 位与 SPIE 位——因为要回去了，同时也以便下次能够顺利在用户层执行中断；将 trapframe 中的 <code>epc</code> 字段写回 SEPC，即恢复用户程序计数器；调用 <code>MAKE_SATP</code> 生成一个参数；</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">  // jump to trampoline.S at the top of memory, which
  // switches to the user page table, restores user registers,
  // and switches to user mode with sret.
  uint64 fn = TRAMPOLINE + (userret - trampoline);
  ((void (*)(uint64,uint64))fn)(TRAPFRAME, satp);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>该参数和 <code>TRAPFRAME</code> 一起传给 <code>userret</code> 并执行，相当于<strong>把 <code>TRAPFRAME</code> 写入了 a0，把新的 SATP 值写入了 a1</strong>；</p>
<blockquote>
<p><code>ret</code> 实际调用的也是 <code>kernel/trap.c</code> 中的 <code>usertrapret()</code> 函数，做一些用户空间的恢复工作。当然有些事情得硬件处理，即执行名为 <code>userret</code> 的汇编函数（位于 <code>trampoline.S</code>）。</p>
</blockquote>
<h2 id="探索-userret">探索 userret</h2>
<p><code>usertrapret()</code> 还有一些无法在软件层面做的事，这些工作统统由 <code>userret</code> 负责。</p>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S">.globl userret
userret:
        ## userret(TRAPFRAME, pagetable)
        ## switch from kernel to user.
        ## usertrapret() calls here.
        ## a0: TRAPFRAME, in user page table.
        ## a1: user page table, for satp.

        ## switch to the user page table.
        csrw satp, a1
        sfence.vma zero, zero<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一步是切换到用户页表。上面已经讲过，把参数传给 <code>userret</code> 时，新的 SATP 值在 a1 里，那就是要交换 a1 和 SATP。当然别忘了清楚页表缓存。</p>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S">## restore all but a0 from TRAPFRAME
ld ra, 40(a0)
...
ld t6, 280(a0)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来，复原所有 32 个用户寄存器。a0 已经在传参时被设为了 trapframe，所以直接用就行。</p>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S"> ## put the saved user a0 in sscratch, so we
 ## can swap it with our a0 (TRAPFRAME) in the last step.
 ld t0, 112(a0)
 csrw sscratch, t0

## restore user a0, and save TRAPFRAME in sscratch
 csrrw a0, sscratch, a0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而 SSCRATCH 在之前由于交换，放的<strong>值</strong>是 user a0，也就是系统调用传入的第一个实参（见 <a href="#ecall-%E4%B8%8E-uservec">uservec</a>），并且被保存到了 trapframe-&gt;a0 中。尽管 trapframe-&gt;a0 在系统调用过程中变成了<strong>系统调用函数返回值</strong>，但无论如何，现在需要进行逆操作了——先从 trapframe-&gt;a0 中将返回值 载入 SSCRATCH，再和实际寄存器 a0 进行交换。于是乎，现在寄存器 a0 和 SSCRATCH 成为了我们想要的模样，前者存返回值，后者存 <code>TRAPFRAME</code>。之后 <code>TRAPFRAME</code> 会一直保存在SSCRATCH中，直到用户程序执行了另一次 trap。</p>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>kernel/trampoline.S</span></div><code class="language-S">## return to user mode and user pc.
## usertrapret() set up sstatus and sepc.
sret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>最后，执行 <code>sret</code>，程序会切换回用户态，寄存器 SEPC 的数值会被拷贝到 PC，并且重新打开中断。因为同一进程的用户 PC 被记录到了 epc 中，直到 <code>usertrapret()</code> 才被写回 SEPC，所以不用担心被修改。</p>
<h2 id="最后总结">最后总结</h2>
<img src="1.webp">
<p>总结起来就是，对于任何一个用户层中允许调用的内核函数 <code>func()</code>，首先要在 <code>user/user.h</code> 中声明，还得在 <code>user/usys.pl</code> 中注册，在 <code>kernel/syscall.h</code> 定义新的系统调用号 <code>SYS_func</code>，以及在 <code>kernel/syscall.c</code> 的系统调用表中注册新的条目 <code>SYS_func =&gt; sys_func()</code>。当然不能忘了修改 <code>Makefile</code> 的 <code>UPROGS</code> 变量。</p>
<p>当调用 <code>func()</code> 时，会将 <code>SYS_func</code> 载入 a7，然后调用 <code>ecall</code> 指令，进入到 <code>usertrap()</code> 函数中执行 <code>syscall()</code>，取出 <code>a7</code> 的系统调用号，查表得到系统调用 <code>sys_func()</code> 并执行，将返回值存到 a0 寄存器中，最后调用 <code>sret</code> 指令返回。这就是完整流程。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.824 Lab4 Sharded Key/Value Service</title>
    <url>/lab/6-824lab4/</url>
    <content><![CDATA[<p>对于单个副本组而言，所有机器存储共享同一存储空间，机器数量的增加并不会扩大存储能力。而当 kv 对数量不断增长时，副本组的存储能力成为瓶颈。</p>
<p>参考 <a href="https://leager-zju.github.io/6-824/aurora/">Aurora</a> 的做法，不妨将数据划分为多个片段，每个副本组负责<strong>分片</strong>(Shard)的一个子集。组内机器使用 Raft 来复制分片。此外还有一个<strong>分片控制器</strong>(Shardctrler)，决定哪个副本组应该为每个分片服务，此信息称为<strong>配置</strong>(Config)。本实验就是实现这样一个 multi-raft 的 kv 存储系统。</p>
<span id="more"></span>
<p>lab4 和 lab3 非常像，主要流程是这样的：</p>
<ol>
<li class="lvl-3">
<p>client 通过 clerk 发送请求；</p>
</li>
<li class="lvl-3">
<p>clerk 根据 key 所在的分片，将请求转发给对应 group 的 Leader；</p>
</li>
<li class="lvl-3">
<p>Leader 通过 raft 层复制操作日志。</p>
</li>
</ol>
<h2 id="PART-A-The-Shard-controller">PART A-The Shard controller</h2>
<p>这一部分是比较简单的，去重检测、处理请求等方面几乎可以把 lab3 的代码搬过来。关键在于处理上层调用的 <code>Join</code>、<code>Leave</code>、<code>Move</code>、<code>Query</code> 这 4 个命令。由于 Shardctrler 管理一系列配置，故需要在结构体中额外设置一个 Config 切片。结构体如下：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ShardCtrler <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  mu    sync<span class="token punctuation">.</span>RWMutex
  me    <span class="token builtin">int</span>
  applyCh <span class="token keyword">chan</span> raft<span class="token punctuation">.</span>ApplyMsg
  rf    <span class="token operator">*</span>raft<span class="token punctuation">.</span>Raft

  lastRequestInfo <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token operator">*</span>RequestInfo <span class="token comment">// clerkID -&gt; requestID</span>
  configs <span class="token punctuation">[</span><span class="token punctuation">]</span>Config <span class="token comment">// indexed by config num</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="新建配置">新建配置</h3>
<p><code>Query</code> 相当于读命令，不会对 Config 有任何更改，是可以不经过去重的，直接根据规则返回相应 Config 即可。</p>
<p>其它 3 个需要经过去重表。其中 <code>Move</code> 较为简单，直接修改 Config 中 <code>Shards[]</code> 对应的值即可。对于 <code>Join</code> 和 <code>Leave</code>，在应用命令时需要创建一个新的 Config。</p>
<blockquote>
<p>在 Go 中，map 是引用类型，不能直接拷贝（浅拷贝），而是需要创建一个新的对象并单独复制键和值（深拷贝）。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>sc <span class="token operator">*</span>ShardCtrler<span class="token punctuation">)</span> <span class="token function">makeNewConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span>Config <span class="token punctuation">{</span>
  lastconfig <span class="token operator">:=</span> sc<span class="token punctuation">.</span>configs<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>configs<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
  newconfig <span class="token operator">:=</span> Config<span class="token punctuation">{</span>
    Num<span class="token punctuation">:</span>  lastconfig<span class="token punctuation">.</span>Num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>
    Shards<span class="token punctuation">:</span> lastconfig<span class="token punctuation">.</span>Shards<span class="token punctuation">,</span>
    Groups<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> gid<span class="token punctuation">,</span> members <span class="token operator">:=</span> <span class="token keyword">range</span> lastconfig<span class="token punctuation">.</span>Groups <span class="token punctuation">{</span>
    newconfig<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span> <span class="token operator">=</span> members
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token operator">&amp;</span>newconfig
<span class="token punctuation">}</span>


<span class="token keyword">func</span> <span class="token punctuation">(</span>sc <span class="token operator">*</span>ShardCtrler<span class="token punctuation">)</span> <span class="token function">ApplyCommand</span><span class="token punctuation">(</span>msg raft<span class="token punctuation">.</span>ApplyMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  args <span class="token operator">:=</span> msg<span class="token punctuation">.</span>Command<span class="token punctuation">.</span><span class="token punctuation">(</span>Args<span class="token punctuation">)</span>
  ch <span class="token operator">:=</span> args<span class="token punctuation">.</span>Ch
  reply <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Reply<span class="token punctuation">)</span>

  <span class="token keyword">if</span> args<span class="token punctuation">.</span>Op <span class="token operator">==</span> Query <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> OK
    <span class="token keyword">if</span> args<span class="token punctuation">.</span>Num <span class="token operator">==</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">||</span> args<span class="token punctuation">.</span>Num <span class="token operator">&gt;=</span> <span class="token function">len</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>configs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      reply<span class="token punctuation">.</span>Config <span class="token operator">=</span> sc<span class="token punctuation">.</span>configs<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>configs<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      reply<span class="token punctuation">.</span>Config <span class="token operator">=</span> sc<span class="token punctuation">.</span>configs<span class="token punctuation">[</span>args<span class="token punctuation">.</span>Num<span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> sc<span class="token punctuation">.</span><span class="token function">isDuplicated</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>RequestId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>ClerkId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> sc<span class="token punctuation">.</span>lastRequestInfo<span class="token punctuation">[</span>args<span class="token punctuation">.</span>ClerkId<span class="token punctuation">]</span><span class="token punctuation">.</span>Err
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    newconfig <span class="token operator">:=</span> sc<span class="token punctuation">.</span><span class="token function">makeNewConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">switch</span> args<span class="token punctuation">.</span>Op <span class="token punctuation">{</span>
      <span class="token keyword">case</span> Move<span class="token punctuation">:</span>
      newconfig<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>args<span class="token punctuation">.</span>Shard<span class="token punctuation">]</span> <span class="token operator">=</span> args<span class="token punctuation">.</span>GIDs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
      <span class="token keyword">case</span> Join<span class="token punctuation">:</span>
      <span class="token keyword">for</span> gid<span class="token punctuation">,</span> members <span class="token operator">:=</span> <span class="token keyword">range</span> args<span class="token punctuation">.</span>Servers <span class="token punctuation">{</span>
        newconfig<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span> <span class="token operator">=</span> members
      <span class="token punctuation">}</span>
      sc<span class="token punctuation">.</span><span class="token function">shuffleShard</span><span class="token punctuation">(</span>newconfig<span class="token punctuation">)</span>
      <span class="token keyword">case</span> Leave<span class="token punctuation">:</span>
      <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> gid <span class="token operator">:=</span> <span class="token keyword">range</span> args<span class="token punctuation">.</span>GIDs <span class="token punctuation">{</span>
        <span class="token function">delete</span><span class="token punctuation">(</span>newconfig<span class="token punctuation">.</span>Groups<span class="token punctuation">,</span> gid<span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
      sc<span class="token punctuation">.</span><span class="token function">shuffleShard</span><span class="token punctuation">(</span>newconfig<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    sc<span class="token punctuation">.</span>configs <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>sc<span class="token punctuation">.</span>configs<span class="token punctuation">,</span> <span class="token operator">*</span>newconfig<span class="token punctuation">)</span>
    sc<span class="token punctuation">.</span>lastRequestInfo<span class="token punctuation">[</span>args<span class="token punctuation">.</span>ClerkId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>RequestInfo<span class="token punctuation">{</span>
      RequestID<span class="token punctuation">:</span> args<span class="token punctuation">.</span>RequestId<span class="token punctuation">,</span>
      Err<span class="token punctuation">:</span>     reply<span class="token punctuation">.</span>Err<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> sc<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token operator">&amp;&amp;</span> sc<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetCurrentTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> msg<span class="token punctuation">.</span>CommandTerm <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>reply_ <span class="token operator">*</span>Reply<span class="token punctuation">)</span> <span class="token punctuation">{</span> ch <span class="token operator">&lt;-</span> reply_ <span class="token punctuation">}</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="分片再分配">分片再分配</h3>
<p>lab 要求<strong>新 Config 应尽可能将 Shard 均匀地分配到 groups 中，并应移动尽可能少的 Shard</strong>。这样做也是为了减少不必要的网络资源消耗，毕竟后续 Shard 的迁移是需要 RPC 的。</p>
<p>若分配前存在分片处于<strong>无主</strong>状态（即 Config.Shards[i] = 0），则优先<strong>将该分片分配给拥有最少分片的 group</strong>。反之，则<strong>每次选取拥有最多分片的 group 给拥有最少分片的 group 迁移 Shard，直至两者拥有数量不超过 1</strong>。</p>
<blockquote>
<p>在 Go 中，map 迭代顺序是<a href="https://blog.golang.org/maps#TOC_7.">不确定的</a>。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>sc <span class="token operator">*</span>ShardCtrler<span class="token punctuation">)</span> <span class="token function">shuffleShard</span><span class="token punctuation">(</span>config <span class="token operator">*</span>Config<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  N <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>config<span class="token punctuation">.</span>Groups<span class="token punctuation">)</span>
  <span class="token keyword">if</span> N <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>    <span class="token comment">// 所有 group 离开，将所有 Shard 设为无主</span>
    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> NShards<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>
      config<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  allocated <span class="token operator">:=</span> <span class="token number">0</span>
  NumofShards <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span>
  <span class="token keyword">for</span> gid <span class="token operator">:=</span> <span class="token keyword">range</span> config<span class="token punctuation">.</span>Groups <span class="token punctuation">{</span>
    NumofShards<span class="token punctuation">[</span>gid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> gid <span class="token operator">:=</span> <span class="token keyword">range</span> config<span class="token punctuation">.</span>Shards <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> config<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span>
      allocated<span class="token operator">++</span>
      NumofShards<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    WhoHasTheMostShards<span class="token punctuation">,</span> WhoHasTheLeastShards <span class="token operator">:=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span>
    MaxmShards<span class="token punctuation">,</span> MinmShards <span class="token operator">:=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> NShards<span class="token operator">+</span><span class="token number">1</span>

    <span class="token keyword">for</span> gid<span class="token punctuation">,</span> num <span class="token operator">:=</span> <span class="token keyword">range</span> NumofShards <span class="token punctuation">{</span>
      <span class="token keyword">if</span> num <span class="token operator">&gt;</span> MaxmShards <span class="token punctuation">{</span>
        MaxmShards <span class="token operator">=</span> num
        WhoHasTheMostShards <span class="token operator">=</span> gid
      <span class="token punctuation">}</span>
      <span class="token keyword">if</span> num <span class="token operator">&lt;</span> MinmShards <span class="token punctuation">{</span>
        MinmShards <span class="token operator">=</span> num
        WhoHasTheLeastShards <span class="token operator">=</span> gid
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> allocated <span class="token operator">==</span> NShards <span class="token operator">&amp;&amp;</span> MaxmShards <span class="token operator">&lt;</span> MinmShards<span class="token operator">+</span><span class="token number">2</span> <span class="token punctuation">{</span>  <span class="token comment">// allocated != NShards 说明存在无主分片，不能简单凭 MaxmShards &lt; MinmShards+2 退出循环</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">for</span> sid<span class="token punctuation">,</span> gid <span class="token operator">:=</span> <span class="token keyword">range</span> config<span class="token punctuation">.</span>Shards <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> config<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span> <span class="token comment">// gid 已离开，直接分给拥有分片最少的 group</span>
        config<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span> <span class="token operator">=</span> WhoHasTheLeastShards
        allocated<span class="token operator">++</span>
        NumofShards<span class="token punctuation">[</span>WhoHasTheLeastShards<span class="token punctuation">]</span><span class="token operator">++</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> gid <span class="token operator">==</span> WhoHasTheMostShards <span class="token operator">&amp;&amp;</span> allocated <span class="token operator">==</span> NShards <span class="token punctuation">{</span>
        config<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span> <span class="token operator">=</span> WhoHasTheLeastShards
        NumofShards<span class="token punctuation">[</span>WhoHasTheMostShards<span class="token punctuation">]</span><span class="token operator">--</span>
        NumofShards<span class="token punctuation">[</span>WhoHasTheLeastShards<span class="token punctuation">]</span><span class="token operator">++</span>
        <span class="token keyword">break</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="PART-B-Shared-Key-Value-Server">PART B-Shared Key/Value Server</h2>
<p>这一部分我认为是整个 6.824 lab 中最难的一个 Part。尽管 raft 算法也很难，但只要认真研读论文的图 2，依然能够写出 bugfree 的代码。这部分的难点在于，需要我们从头设计一个基于 Shard 的 KV 服务，而没有任何文献资料/Guide 来作指引，一旦没有灵感迸发，就会寸步难行。</p>
<h3 id="开始-4B-之前需要想明白的一些事">开始 4B 之前需要想明白的一些事</h3>
<p>磨蹭大半个月+仔细阅读实验要求后，我得出如下总结：</p>
<p>该部分与 lab3 的不同之处在于，group 会不断加入/离开系统，为了平衡负载，系统需要在 group 之间转移 Shard。同时，随着 groups 的变化，系统的 Config 也会不断发生变化，且需要告知所有 group。简而言之，该 lab 的难点并不在于对 client 操作的实现——它已经在 lab3 中做完了，直接照抄即可——而是：</p>
<ol>
<li class="lvl-3">
<p><strong>如何 ReConfig，Config 有更新后怎么做</strong>；</p>
</li>
<li class="lvl-3">
<p><strong>如何迁移 Shard，迁移后怎么做</strong>；</p>
</li>
</ol>
<p>能够想明白上面两个问题，4B 的所有难点都迎刃而解，包括两个 Challenge。</p>
<h3 id="Clerk">Clerk</h3>
<p>Clerk 的工作和 lab3 非常相似，样例代码的思路也很清楚——一旦收到 ErrWrongGroup 回复，则说明自己缓存的 Config 有误，需向 Shardctrler 请求最新的 Config。和 lab3 类似，Clerk 需要缓存每个 group 的 Leader。</p>
<p>这里有个很重要的一点：如果对某个 group 所有成员均发送失败，则认为该 group 全挂了，系统发生成员变动，此时 Clerk 缓存的 Config 一定已过时，再继续发下去极有可能死循环，需要尝试获取最新 Config。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>ck <span class="token operator">*</span>Clerk<span class="token punctuation">)</span> <span class="token function">SendRequest</span><span class="token punctuation">(</span>Command <span class="token operator">*</span>OperationCommand<span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>
  Command<span class="token punctuation">.</span>ClerkId<span class="token punctuation">,</span> Command<span class="token punctuation">.</span>RequestId <span class="token operator">=</span> ck<span class="token punctuation">.</span>ClerkId<span class="token punctuation">,</span> ck<span class="token punctuation">.</span>RequestId

  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    shard <span class="token operator">:=</span> <span class="token function">key2shard</span><span class="token punctuation">(</span>Command<span class="token punctuation">.</span>Key<span class="token punctuation">)</span>
    gid <span class="token operator">:=</span> ck<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>shard<span class="token punctuation">]</span>

    <span class="token keyword">if</span> servers<span class="token punctuation">,</span> ok <span class="token operator">:=</span> ck<span class="token punctuation">.</span>config<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token punctuation">;</span> ok <span class="token punctuation">{</span> <span class="token comment">// 若 gid 在当前 config 中</span>
      <span class="token keyword">if</span> <span class="token boolean">_</span><span class="token punctuation">,</span> ok <span class="token operator">:=</span> ck<span class="token punctuation">.</span>volatileLeader<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token operator">!</span>ok <span class="token punctuation">{</span>
         ck<span class="token punctuation">.</span>volatileLeader<span class="token punctuation">[</span>gid<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
      <span class="token punctuation">}</span>

      guard <span class="token operator">:=</span> ck<span class="token punctuation">.</span>volatileLeader<span class="token punctuation">[</span>gid<span class="token punctuation">]</span>
      leader <span class="token operator">:=</span> guard

      <span class="token keyword">for</span> <span class="token punctuation">{</span>
        <span class="token comment">// 寻找 Leader 发送请求</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">*</span> time<span class="token punctuation">.</span>Millisecond<span class="token punctuation">)</span>
    ck<span class="token punctuation">.</span>config <span class="token operator">=</span> ck<span class="token punctuation">.</span>sm<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Server">Server</h3>
<p>首先思考第一个问题，<strong>如何 ReConfig，Config 有更新后怎么做</strong>。这个问题还是比较容易的，只需要在启动 server 时异步开启一个 <strong>ConfigPuller</strong> 协程，定期向 Shardctrler 请求最新的 Config 即可。每个 server 还需维护一个 <code>CurrentConfig</code> 变量，一旦获得较新的 Config，就将其赋给 CurrentConfig。</p>
<blockquote>
<p>这个变量主要用于收到操作请求时判断是否返回 ErrWrongGroup，即如果 <code>CurrentConfig.Shards[key2shard(key)] != kv.gid</code>，说明本 group 不负责该分片，需报错。</p>
</blockquote>
<p>这里有一个问题，group 里的每个成员能够单独进行 Config 的拉取和更新吗？回答显然是<strong>不能</strong>的，这是对 raft 层的不尊重，单独进行 Config 拉取必然会造成不同步，则后续对不同 server 存储的读写也会产生管辖范围不一致的问题。所以这里需要进行是否为 Leader 的判断，如果 Leader 拿到了较新的Config，则向下层发一条更新记录，随着 raft 层的运作，这条记录最终会被所有 server 获得，传到上层进行 Apply 后更新 CurrentConfig。</p>
<p>随着 Config 的更新，Shard 的迁移问题也随之而来，这里我设计为新 owner 向旧 owner 发送 <strong>pull</strong> 请求（当然 push 也是可以的）：旧 owner 收到 pull RPC 后将属于该 Shard 的 kv 对打包进 reply 中发回给新 owner。</p>
<p>最开始我将节点的存储简单的设计为了单个 map，后来发现这样做不够优雅——所有数据都存到同一块区域，每次迁移 Shard 时需要对所有元素进行遍历，尽管对 Config/Shard 的操作只需要对服务器上一把大锁，但 $O(n)$ 的遍历无端增加了时间消耗，显然是现实不可用的。</p>
<p>在阅读了 Aurora 的论文后我有所启发：我们完全可以定义一个名为 <code>Shard</code> 的结构体，每个 <code>Shard</code> 拥有单独的 map 存储，这样一来进行分片迁移/垃圾回收时便能<strong>以 Shard 为粒度</strong>进行操作，而不需要遍历所有数据，还能对每个 <code>Shard</code> 进行一些额外的变量设置。</p>
<p>那么能不能在 Apply 更新 Config 日志后立马进行一次 pull Shard 呢？我最开始尝试通过条件变量来进行协程之间的通信，更新完 <code>CurrentConfig</code> 后通知另一个协程发送 pull Shard rpc。但考虑到一旦这个环节 group 挂了，server 重启后并不能够知道当前进行到哪一步，并且 Shard 在 pull 之前是不能提供服务的。所以这个方法立即被我弃用了。</p>
<p>不妨换个思路。任意时刻，server 可能会拥有以下几类 Shard：</p>
<ol>
<li class="lvl-3">
<p>继续持有的；</p>
</li>
<li class="lvl-3">
<p>不再持有，等待被其它 server pull 的；</p>
</li>
<li class="lvl-3">
<p>不再持有，但已经被其它 server pull 的；</p>
</li>
<li class="lvl-3">
<p>新持有，等待 server 从其他 group 那 pull 的；</p>
</li>
<li class="lvl-3">
<p>新持有，已经 pull 到了的；</p>
</li>
</ol>
<blockquote>
<p>如果考虑要做 Challenge1，又能够把 3 和 5 进一步细分为：</p>
<ol>
<li class="lvl-3">继续持有的；</li>
<li class="lvl-3">不再持有，等待被其它 server pull 的；</li>
<li class="lvl-3">不再持有，但</li>
<li class="lvl-5">被 pull，等待接受 GC 通知；</li>
<li class="lvl-5">被 pull，已进行 GC；</li>
<li class="lvl-3">新持有，等待 server 从其他 group 那 pull 的；</li>
<li class="lvl-3">新持有，且</li>
<li class="lvl-5">pull 到，需发送 GC 通知；</li>
<li class="lvl-5">pull 到，GC 发送完毕。</li>
</ol>
<p>之所以设计为<strong>新 owner pull 到 Shard 后向旧 owner 发送 GC 通知</strong>而不是<strong>旧 owner 在收到 pull Shard 并 reply OK 后自行 GC</strong>，还是因为如果 reply 发过去的途中新 owner 挂了，重启后因为没 pull 到还得重新发 pull Shard 请求，而此时旧 owner GC 完毕后存储清空了，就会产生错误——系统永久性地失去了该 Shard 对应的数据。</p>
<p>收到 GC 通知也意味着新 owner 收到了 reply 并完成了 Shard 的覆盖，可以进行数据回收而不用担心是否挂掉。当然，新 owner 收到 reply 也意味着旧 owner 完成了 GC，不用再发送 GC 通知了。</p>
</blockquote>
<p>那当然是选择完成 Challenge 啦！为了对这些不同种类的 Shard 进行区分，比较好的思路是在 Shard 结构体内设置一个 <strong>ShardStatus</strong> 变量，并且需要将其持久化。这样无论是否挂掉，group 都能在<strong>任意时刻</strong>根据 Shard 内部的 Status 变量进行相应的操作。并且除了 ConfigPuller 协程，我们还需要再启动两个 <code>ShardPuller</code> 和 <code>GarbageCollector</code> 协程，异步地进行<strong>遍历 Shard 并根据 ShardStatus 执行 RPC 等操作</strong>。和之前提到的一样，我们依然需要 Leader 来进行一系列交互行为，并利用 Raft 层进行日志同步，所有 server 收到下层传上来的 ApplyMsg 后执行最终的修改操作。</p>
<blockquote>
<p>其中 1, 3.b, 5.b 都意味着无需任何后续操作，统一设置为 Ready 状态</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> status <span class="token builtin">int</span>

<span class="token keyword">const</span> <span class="token punctuation">(</span>
  <span class="token comment">// everyone</span>
  Ready status <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// 一切就绪</span>
  <span class="token comment">// new owner</span>
  NeedPull       <span class="token comment">// 表明该分片等待从其他 group 处拉取</span>
  ReadyButNeedSendGC <span class="token comment">// 就绪，但需要通知其他 group 进行 GC</span>
  <span class="token comment">// old owner</span>
  Waiting <span class="token comment">// 表明该分片等待被其他 group 拉取 + 通知 GC</span>
<span class="token punctuation">)</span>

<span class="token keyword">type</span> Shard <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  KVs     <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
  ShardStatus status
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个 Shard 能不能正确处理 client 请求，一是看它是否被当前 server 持有，二是看该 Shard 状态是否为 Ready/ReadyButNeedSendGC，任一条件不满足，都返回 <code>ErrWrongGroup</code>。在 Apply 客户端操作时，需要将 lab3 的代码修改为：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">ApplyCommand</span><span class="token punctuation">(</span>msg raft<span class="token punctuation">.</span>ApplyMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// locked</span>
  command <span class="token operator">:=</span> msg<span class="token punctuation">.</span>Command<span class="token punctuation">.</span><span class="token punctuation">(</span>OperationCommand<span class="token punctuation">)</span>
  ch <span class="token operator">:=</span> command<span class="token punctuation">.</span>Ch
  reply <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>Reply<span class="token punctuation">)</span>

  shardId <span class="token operator">:=</span> <span class="token function">key2shard</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span>Key<span class="token punctuation">)</span>

  <span class="token keyword">if</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">ReadyForServer</span><span class="token punctuation">(</span>shardId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongGroup
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> command<span class="token punctuation">.</span>Op <span class="token operator">==</span> <span class="token string">"Get"</span> <span class="token punctuation">{</span>
    <span class="token comment">// Get</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">isDuplicated</span><span class="token punctuation">(</span>command<span class="token punctuation">.</span>RequestId<span class="token punctuation">,</span> command<span class="token punctuation">.</span>ClerkId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> kv<span class="token punctuation">.</span>lastRequestInfo<span class="token punctuation">[</span>command<span class="token punctuation">.</span>ClerkId<span class="token punctuation">]</span><span class="token punctuation">.</span>Err
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// Put or Append</span>
    kv<span class="token punctuation">.</span>lastRequestInfo<span class="token punctuation">[</span>command<span class="token punctuation">.</span>ClerkId<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">&amp;</span>RequestInfo<span class="token punctuation">{</span>
      RequestID<span class="token punctuation">:</span> command<span class="token punctuation">.</span>RequestId<span class="token punctuation">,</span>
      Err<span class="token punctuation">:</span>     reply<span class="token punctuation">.</span>Err<span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token operator">&amp;&amp;</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetCurrentTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> msg<span class="token punctuation">.</span>CommandTerm <span class="token punctuation">{</span>
    <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>reply_ <span class="token operator">*</span>Reply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      ch <span class="token operator">&lt;-</span> reply_
    <span class="token punctuation">}</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>考虑到 group 会挂掉这个情况，重启后找谁 pull Shard 也是个问题，故除了 CurrentConfig，server 内部还需设置一个 LastConfig 变量。在 lab3 的基础上，server 结构体应该修改为这样：</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> ShardKV <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  mu     sync<span class="token punctuation">.</span>RWMutex
  me     <span class="token builtin">int</span>
  mck    <span class="token operator">*</span>shardctrler<span class="token punctuation">.</span>Clerk
  rf     <span class="token operator">*</span>raft<span class="token punctuation">.</span>Raft
  applyCh  <span class="token keyword">chan</span> raft<span class="token punctuation">.</span>ApplyMsg
  make_end <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd
  gid    <span class="token builtin">int</span>
  ctrlers  <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd

  maxraftstate <span class="token builtin">int</span> <span class="token comment">// snapshot if log grows this big</span>
  lastapplied  <span class="token builtin">int</span>

  Shards      <span class="token punctuation">[</span>shardctrler<span class="token punctuation">.</span>NShards<span class="token punctuation">]</span>Shard
  lastRequestInfo <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token operator">*</span>RequestInfo

  lastConfig  shardctrler<span class="token punctuation">.</span>Config <span class="token comment">// (!new)</span>
  currentConfig shardctrler<span class="token punctuation">.</span>Config
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>🎉这样一来整体的工作流程就很明朗了：</p>
<ol>
<li class="lvl-3">
<p><code>ConfigPuller</code> 获得较新的 Config，通过 Raft 层进行 <code>UpdateConfig</code> 日志同步；</p>
</li>
<li class="lvl-3">
<p>Apply 到 <code>UpdateConfig</code> 日志后</p>
<ul class="lvl-2">
<li class="lvl-5">对于仍持有的 Shard，不作变动；</li>
<li class="lvl-5">对于不再持有的，设置状态为 <code>Waiting</code>；</li>
<li class="lvl-5">对于新持有的，设置状态为 <code>NeedPull</code>；</li>
</ul>
</li>
<li class="lvl-3">
<p><code>ShardPuller</code> 定期进行检测，一旦发现存在状态为 <code>NeedPull</code> 的 Shard，根据 LastConfig 找到旧 owner 并发送 pull Shard RPC；</p>
</li>
<li class="lvl-3">
<p>旧 owner 无条件将 Shard 写入 reply 并回复，不必考虑是否过期，因为不会改变其状态；</p>
</li>
<li class="lvl-3">
<p>新 owner 收到 reply 后，立即 <code>rf.Start()</code> 一条 <code>InsertShard</code> 日志，并在 Apply 后设置相应 Shard 的状态为 <code>ReadyButNeedSendGC</code>；</p>
</li>
<li class="lvl-3">
<p><code>GarbageCollector</code> 定期进行检测，一旦发现存在状态为 <code>ReadyButNeedSendGC</code> 的 Shard，根据 LastConfig 找到旧 owner 并发送 garbage collector RPC；</p>
</li>
<li class="lvl-3">
<p>旧 owner 收到 GC 通知，就可以认为上次的 PullReply 已经被新 owner 接收，立即 <code>rf.Start()</code> 一条 <code>GarbageCollect</code> 日志，Apply 后清理数据，并设置状态为 <code>Ready</code>；</p>
</li>
<li class="lvl-3">
<p>新 owner 收到 GC 的 reply 后，就可以认为 GC 通知已经发到旧 owner 手上，可以修改 ShardStatus 防止 GarbageCollector 进行重复 GC 通知，即 <code>rf.Start()</code> 一条 <code>GarbageCollect</code> 日志，Apply 后设置状态为 <code>Ready</code>。</p>
</li>
</ol>
<blockquote>
<p>7, 8 两步的不同之处在于，新旧 owner Apply GC 日志时，相应的 Shard 状态不同，前者为 <code>ReadyButNeedSendGC</code>，后者为 <code>Waiting</code>。根据状态不同执行不同操作即可，而不需要为新 owner 再新定义一个 <code>UpdateStatus</code> 这样的日志类别。</p>
</blockquote>
<p><strong>注意</strong>：ConfigPuller 不能无条件进行 Update Config，否则会破坏当前 Shard 的状态，甚至可能存在部分 Shard 仍未 pull 到就需要回复其它 group 的 pull 请求，结果是一部分任务永远无法正确完成，从而系统陷入无尽的错误。由于我们引入了 ShardStatus 这一概念，故令<strong>仅当所有 Shard 都变为 Ready 后才能更新 Config</strong>。这是一种更安全的行为。</p>
<p><strong>注意</strong>：可能某些 Shard 在迁移前仍然由旧 owner 向 client 提供服务，故存在这样一种情况：client 向 group1 发送 shard1 写请求后，group1 实际上执行了这一操作，但给 client 的 reply 丢包了，而其它 server 由于不是 Leader 无法应对请求，故认为 group1 全挂了，此时恰好发现 Config 存在更新，且新 Config 下 shard1 归属于 group2，client 转而向 group2 发送同一写请求。group2 向 group1 pull 了应用过请求的 Shard 后，收到 client 的同一请求，又执行了一遍。为了满足幂等性，pull Shard reply 里还应该包括旧 owner 的<strong>去重表</strong>来应对这一情况。新 owner 收到后会和自己的去重表进行比对，取同一 clerkId 下的最新 request。</p>
<p>另外，我也遇到了<a href="https://github.com/OneSizeFitsQuorum/MIT6.824-2021/blob/master/docs/lab4.md">谭佬遇到的同样问题</a>：</p>
<blockquote>
<p>最后，在 lab2 的文档中我就提到了 leader 上线后应该立刻 append 一条空日志，这样才可以保证 leader 的状态机最新，然而不幸的是，lab2 的测试在加了空日志后便 Fail 了，因此我便没有再关注。在实现 lab4 时，我最开始并没有关注这件事，最后成了一个大坑，导致我花费了一天的时间才找到问题。该 bug 一般跑 100 次测试能够复现一次，对外的表现是集群出现活锁，无法再服务请求直到超时，而且仅会在几个涉及到重启的测试中出现。经过一番探索，最终发现是在节点频繁的重启过后，出现了 lab2 中描述空日志必要性的例子。这导致某一 raft 组的状态机无法达到最新且不全是默认状态，这使得配置更新协程也无法提交新的配置日志，此时客户端碰巧没有向该 raft 组执行读写请求，因而该 raft 组始终没有当前 term 的日志，从而无法推进 commitIndex，因此整个集群便出现了活锁。该 bug 的解决方法很简单，就是让 raft 层的 leader 在 kv 层周期性的去检测下层是否包含当前 term 的日志，如果没有便 append 一条空日志，这样即可保证新选出的 leader 状态机能够迅速达到最新。其实我认为将空日志检测做到 KV 层并不够优雅，KV 层不需要去了解 raft 层有无空日志会怎么样，更优雅地方式应该是 raft 层的 leader 一上线就提交一个空日志。但总之目前在 6.824 的框架下，也只能在 KV 层做检测了。</p>
</blockquote>
<p>我参考了他的做法，加入了<strong>空日志检测机制</strong>。原文中有提到，不再赘述。</p>
<p>基于以上讨论，整体架构就能进行如下设计了。</p>
<h4 id="StartServer">StartServer</h4>
<p>注意 Shard.KVs 需要先 make() 对象。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">StartServer</span><span class="token punctuation">(</span>servers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd<span class="token punctuation">,</span> me <span class="token builtin">int</span><span class="token punctuation">,</span> persister <span class="token operator">*</span>raft<span class="token punctuation">.</span>Persister<span class="token punctuation">,</span> maxraftstate <span class="token builtin">int</span><span class="token punctuation">,</span> gid <span class="token builtin">int</span><span class="token punctuation">,</span> ctrlers <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd<span class="token punctuation">,</span> make_end <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span>labrpc<span class="token punctuation">.</span>ClientEnd<span class="token punctuation">)</span> <span class="token operator">*</span>ShardKV <span class="token punctuation">{</span>
  labgob<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>OperationCommand<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  labgob<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>ConfigCommand<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  labgob<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>ShardCommand<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
  labgob<span class="token punctuation">.</span><span class="token function">Register</span><span class="token punctuation">(</span>EmptyCommand<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

  kv <span class="token operator">:=</span> <span class="token operator">&amp;</span>ShardKV<span class="token punctuation">{</span>
    me<span class="token punctuation">:</span>        me<span class="token punctuation">,</span>
    mck<span class="token punctuation">:</span>       shardctrler<span class="token punctuation">.</span><span class="token function">MakeClerk</span><span class="token punctuation">(</span>ctrlers<span class="token punctuation">)</span><span class="token punctuation">,</span>
    make_end<span class="token punctuation">:</span>    make_end<span class="token punctuation">,</span>
    gid<span class="token punctuation">:</span>       gid<span class="token punctuation">,</span>
    ctrlers<span class="token punctuation">:</span>     ctrlers<span class="token punctuation">,</span>
    maxraftstate<span class="token punctuation">:</span>  maxraftstate<span class="token punctuation">,</span>
    lastapplied<span class="token punctuation">:</span>   <span class="token number">0</span><span class="token punctuation">,</span>
    lastRequestInfo<span class="token punctuation">:</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token operator">*</span>RequestInfo<span class="token punctuation">)</span><span class="token punctuation">,</span>
    lastConfig<span class="token punctuation">:</span>    shardctrler<span class="token punctuation">.</span>Config<span class="token punctuation">{</span>Num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    currentConfig<span class="token punctuation">:</span>   shardctrler<span class="token punctuation">.</span>Config<span class="token punctuation">{</span>Num<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  kv<span class="token punctuation">.</span>applyCh <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> raft<span class="token punctuation">.</span>ApplyMsg<span class="token punctuation">)</span>
  kv<span class="token punctuation">.</span>rf <span class="token operator">=</span> raft<span class="token punctuation">.</span><span class="token function">Make</span><span class="token punctuation">(</span>servers<span class="token punctuation">,</span> me<span class="token punctuation">,</span> persister<span class="token punctuation">,</span> kv<span class="token punctuation">.</span>applyCh<span class="token punctuation">)</span>

  <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> kv<span class="token punctuation">.</span>Shards <span class="token punctuation">{</span>
    kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>KVs <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  kv<span class="token punctuation">.</span><span class="token function">ApplySnapshot</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> persister<span class="token punctuation">.</span><span class="token function">ReadSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

  <span class="token keyword">go</span> kv<span class="token punctuation">.</span><span class="token function">Applier</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> kv<span class="token punctuation">.</span><span class="token function">ConfigPuller</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> kv<span class="token punctuation">.</span><span class="token function">ShardPuller</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> kv<span class="token punctuation">.</span><span class="token function">GarbageCollector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> kv<span class="token punctuation">.</span><span class="token function">EmptyEntryDetector</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">return</span> kv
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="MsgStruct">MsgStruct</h4>
<p>为不同操作命令定义了不同类型，这样就能通过 msg.Command.(type) 进行强转，并进一步根据 Command.Op 执行不同操作。rpc 的参数也统一采用 RPCArgs 的格式——pull Shard 请求和 GC 通知都需要 ShardId 与 ConfigNum。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">// cmd</span>
<span class="token keyword">type</span> OperationCommand <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Op    <span class="token builtin">string</span>
  Key     <span class="token builtin">string</span>
  Value   <span class="token builtin">string</span>
  ClerkId   <span class="token builtin">int64</span>
  RequestId <span class="token builtin">int</span>
  Ch    <span class="token keyword">chan</span> <span class="token operator">*</span>Reply
<span class="token punctuation">}</span>

<span class="token keyword">type</span> Reply <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Err   Err
  Value <span class="token builtin">string</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> ShardCommand <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Op        <span class="token builtin">string</span>
  Shard       <span class="token operator">*</span>Shard
  Sid       <span class="token builtin">int</span>
  ConfigNum     <span class="token builtin">int</span>
  LastRequestInfo <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span>RequestInfo
<span class="token punctuation">}</span>

<span class="token keyword">type</span> ConfigCommand <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  LastConfig shardctrler<span class="token punctuation">.</span>Config
  NewConfig  shardctrler<span class="token punctuation">.</span>Config
<span class="token punctuation">}</span>

<span class="token keyword">type</span> EmptyCommand <span class="token keyword">struct</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>

<span class="token comment">// RPC</span>
<span class="token keyword">type</span> RPCArgs <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Op    <span class="token builtin">string</span>
  ShardId   <span class="token builtin">int</span>
  ConfigNum <span class="token builtin">int</span>
<span class="token punctuation">}</span>

<span class="token keyword">type</span> RPCReply <span class="token keyword">struct</span> <span class="token punctuation">{</span>
  Err       Err
  Shard       Shard
  ConfigNum     <span class="token builtin">int</span>
  LastRequestInfo <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int64</span><span class="token punctuation">]</span>RequestInfo
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Applier">Applier</h4>
<p>和 lab3 大同小异，只是多加了一些 Command 类型的判断。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">Applier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// goroutine</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> msg <span class="token operator">:=</span> <span class="token keyword">range</span> kv<span class="token punctuation">.</span>applyCh <span class="token punctuation">{</span>
      <span class="token keyword">if</span> msg<span class="token punctuation">.</span>CommandValid <span class="token punctuation">{</span>
        kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> msg<span class="token punctuation">.</span>CommandIndex <span class="token operator">&gt;</span> kv<span class="token punctuation">.</span>lastapplied <span class="token punctuation">{</span>
          kv<span class="token punctuation">.</span>lastapplied <span class="token operator">=</span> msg<span class="token punctuation">.</span>CommandIndex
          <span class="token comment">// 基于 msg.Command.type 执行不同 Apply 操作</span>
          <span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">NeedSnapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            kv<span class="token punctuation">.</span><span class="token function">MakeSnapshot</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>CommandIndex<span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> msg<span class="token punctuation">.</span>SnapshotValid <span class="token punctuation">{</span>
        kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        kv<span class="token punctuation">.</span><span class="token function">ApplySnapshot</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>SnapshotIndex<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>SnapshotTerm<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>Snapshot<span class="token punctuation">)</span>
        kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="ConfigPuller">ConfigPuller</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">ApplyUpdateConfigCommand</span><span class="token punctuation">(</span>msg raft<span class="token punctuation">.</span>ApplyMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// locked</span>
  Command <span class="token operator">:=</span> msg<span class="token punctuation">.</span>Command<span class="token punctuation">.</span><span class="token punctuation">(</span>ConfigCommand<span class="token punctuation">)</span>
  lastconfig<span class="token punctuation">,</span> newconfig <span class="token operator">:=</span> Command<span class="token punctuation">.</span>LastConfig<span class="token punctuation">,</span> Command<span class="token punctuation">.</span>NewConfig
  <span class="token keyword">if</span> newconfig<span class="token punctuation">.</span>Num <span class="token operator">==</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num<span class="token operator">+</span><span class="token number">1</span> <span class="token punctuation">{</span> <span class="token comment">// 逐版本进行更新</span>
    kv<span class="token punctuation">.</span>lastConfig <span class="token operator">=</span> lastconfig
    kv<span class="token punctuation">.</span>currentConfig <span class="token operator">=</span> newconfig

    <span class="token keyword">if</span> newconfig<span class="token punctuation">.</span>Num <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">{</span>
      <span class="token comment">// config 发生变化：</span>
      <span class="token comment">// 1. 分配且仍持有的保持 Ready</span>
      <span class="token comment">// 2. 分配但未持有的变为 NeedPull，等到拉取 shard 完成后变为 Valid</span>
      <span class="token comment">// 3. 持有但未分配的变为 Waiting，等待其他组 pull 后被回收</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">ConfigPuller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// goroutine</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token punctuation">{</span>
      kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      CanPullConfig <span class="token operator">:=</span> <span class="token boolean">true</span>
      <span class="token comment">// 只要有一个 Shard 不是 Ready，就不能 Pull New Config</span>
      kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 及时放锁</span>

      <span class="token keyword">if</span> CanPullConfig <span class="token punctuation">{</span>
        newconfig <span class="token operator">:=</span> kv<span class="token punctuation">.</span><span class="token function">GetNewConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">if</span> newconfig<span class="token punctuation">.</span>Num <span class="token operator">&gt;</span> configNum <span class="token punctuation">{</span>
          <span class="token keyword">if</span> configNum <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> newconfig<span class="token punctuation">.</span>Num <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token punctuation">{</span> <span class="token comment">// 第一次加入集群，需初始化 lastconfig</span>
            lastConfig <span class="token operator">=</span> kv<span class="token punctuation">.</span>mck<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span>newconfig<span class="token punctuation">.</span>Num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
          kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>ConfigCommand<span class="token punctuation">{</span>
            LastConfig<span class="token punctuation">:</span> lastConfig<span class="token punctuation">,</span>
            NewConfig<span class="token punctuation">:</span>  newconfig<span class="token punctuation">,</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>NewConfigQueryTimeOut<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="ShardPuller-GarbageCollector">ShardPuller &amp; GarbageCollector</h4>
<p>两者其实非常相似。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">ApplyShardCommand</span><span class="token punctuation">(</span>msg raft<span class="token punctuation">.</span>ApplyMsg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Command <span class="token operator">:=</span> msg<span class="token punctuation">.</span>Command<span class="token punctuation">.</span><span class="token punctuation">(</span>ShardCommand<span class="token punctuation">)</span>
  <span class="token keyword">switch</span> Command<span class="token punctuation">.</span>Op <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">"InsertShard"</span><span class="token punctuation">:</span>
    kv<span class="token punctuation">.</span><span class="token function">InsertShard</span><span class="token punctuation">(</span>Command<span class="token punctuation">)</span>
  <span class="token keyword">case</span> <span class="token string">"GarbageCollect"</span><span class="token punctuation">:</span>
    kv<span class="token punctuation">.</span><span class="token function">GarbageCollect</span><span class="token punctuation">(</span>Command<span class="token punctuation">)</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span>
    <span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"Undefined Command!"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">InsertShard</span><span class="token punctuation">(</span>Command ShardCommand<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// locked</span>
  configNum<span class="token punctuation">,</span> newshard<span class="token punctuation">,</span> sid <span class="token operator">:=</span> Command<span class="token punctuation">.</span>ConfigNum<span class="token punctuation">,</span> Command<span class="token punctuation">.</span>Shard<span class="token punctuation">,</span> Command<span class="token punctuation">.</span>Sid
  <span class="token keyword">if</span> configNum <span class="token operator">==</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num <span class="token operator">&amp;&amp;</span> kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span><span class="token punctuation">.</span>ShardStatus <span class="token operator">==</span> NeedPull <span class="token punctuation">{</span> <span class="token comment">// 覆盖 Shard 前检查该命令是否过期</span>
    <span class="token comment">// 覆盖 kv 对与去重表，并修改 ShardStatus 为 ReadyButNeedSendGC</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">ShardPuller</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// goroutine</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token punctuation">{</span>
      kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      configNum <span class="token operator">:=</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num <span class="token comment">// 捎带当前 config.num，防止收到过期回复</span>
      <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
      <span class="token keyword">for</span> sid<span class="token punctuation">,</span> gid <span class="token operator">:=</span> <span class="token keyword">range</span> kv<span class="token punctuation">.</span>lastConfig<span class="token punctuation">.</span>Shards <span class="token punctuation">{</span>
        <span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">NeedPull</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
          <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>sid<span class="token punctuation">,</span> gid <span class="token builtin">int</span><span class="token punctuation">,</span> others <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// Send RPC and Pull Shard</span>
          <span class="token punctuation">}</span><span class="token punctuation">(</span>sid<span class="token punctuation">,</span> gid<span class="token punctuation">,</span> kv<span class="token punctuation">.</span>lastConfig<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>ShardPullerTimeOut<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">GarbageCollect</span><span class="token punctuation">(</span>Command ShardCommand<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// locked</span>
  configNum<span class="token punctuation">,</span> sid <span class="token operator">:=</span> Command<span class="token punctuation">.</span>ConfigNum<span class="token punctuation">,</span> Command<span class="token punctuation">.</span>Sid
  <span class="token keyword">if</span> configNum <span class="token operator">==</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num <span class="token punctuation">{</span>
    <span class="token keyword">if</span> kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span><span class="token punctuation">.</span>ShardStatus <span class="token operator">==</span> ReadyButNeedSendGC <span class="token punctuation">{</span>
      kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span><span class="token punctuation">.</span>ShardStatus <span class="token operator">=</span> Ready
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span><span class="token punctuation">.</span>ShardStatus <span class="token operator">==</span> Waiting <span class="token punctuation">{</span>
      kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span><span class="token punctuation">.</span>KVs <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span>
      kv<span class="token punctuation">.</span>Shards<span class="token punctuation">[</span>sid<span class="token punctuation">]</span><span class="token punctuation">.</span>ShardStatus <span class="token operator">=</span> Ready
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">GarbageCollector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// locked</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token punctuation">{</span>
      kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      configNum <span class="token operator">:=</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num <span class="token comment">// 捎带当前 config.num，防止收到过期回复</span>
      <span class="token keyword">var</span> wg sync<span class="token punctuation">.</span>WaitGroup
      <span class="token keyword">for</span> sid<span class="token punctuation">,</span> gid <span class="token operator">:=</span> <span class="token keyword">range</span> kv<span class="token punctuation">.</span>lastConfig<span class="token punctuation">.</span>Shards <span class="token punctuation">{</span>
        <span class="token keyword">if</span> kv<span class="token punctuation">.</span><span class="token function">ReadyButNeedSendGC</span><span class="token punctuation">(</span>sid<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 向前任持有者发送 GC 请求</span>
          wg<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
          <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span>sid<span class="token punctuation">,</span> gid <span class="token builtin">int</span><span class="token punctuation">,</span> others <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">defer</span> wg<span class="token punctuation">.</span><span class="token function">Done</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
            <span class="token comment">// Send RPC and make GC</span>
          <span class="token punctuation">}</span><span class="token punctuation">(</span>sid<span class="token punctuation">,</span> gid<span class="token punctuation">,</span> kv<span class="token punctuation">.</span>lastConfig<span class="token punctuation">.</span>Groups<span class="token punctuation">[</span>gid<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      wg<span class="token punctuation">.</span><span class="token function">Wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>GarbageCollectorTimeOut<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="EmptyEntryDetector">EmptyEntryDetector</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">ApplyEmptyCommand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// "EMPTY COMMAND"</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">EmptyEntryDetector</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span><span class="token function">killed</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> raft<span class="token punctuation">.</span>Leader <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token operator">!</span>kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">HasLogAtCurrentTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">Start</span><span class="token punctuation">(</span>EmptyCommand<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>EmptyEntryDetectorTimeOut<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="组间-RPC">组间 RPC</h4>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>kv <span class="token operator">*</span>ShardKV<span class="token punctuation">)</span> <span class="token function">HandleBetweenGroupRequest</span><span class="token punctuation">(</span>args <span class="token operator">*</span>RPCArgs<span class="token punctuation">,</span> reply <span class="token operator">*</span>RPCReply<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// RPC</span>
  <span class="token keyword">if</span> kv<span class="token punctuation">.</span>rf<span class="token punctuation">.</span><span class="token function">GetRaftState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> raft<span class="token punctuation">.</span>Leader <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> ErrWrongLeader
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">defer</span> kv<span class="token punctuation">.</span>mu<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  sid<span class="token punctuation">,</span> configNum <span class="token operator">:=</span> args<span class="token punctuation">.</span>ShardId<span class="token punctuation">,</span> args<span class="token punctuation">.</span>ConfigNum
  <span class="token keyword">if</span> configNum <span class="token operator">&gt;</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num <span class="token punctuation">{</span>
    reply<span class="token punctuation">.</span>ConfigNum<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> kv<span class="token punctuation">.</span>currentConfig<span class="token punctuation">.</span>Num<span class="token punctuation">,</span> ErrNotReady
    <span class="token keyword">return</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 允许接收过期 RPC，但 reply 会捎带 CurrentConfigNum，这样尽管收到过期 reply 也不会进行任何操作</span>
  <span class="token keyword">switch</span> args<span class="token punctuation">.</span>Op <span class="token punctuation">{</span>
  <span class="token keyword">case</span> <span class="token string">"PullShard"</span><span class="token punctuation">:</span>
    <span class="token comment">// 无条件回复</span>
  <span class="token keyword">case</span> <span class="token string">"GarbageCollect"</span><span class="token punctuation">:</span>
    <span class="token comment">// 无条件 Start 新命令，将状态判断留给 Apply 阶段</span>
  <span class="token punctuation">}</span>
  reply<span class="token punctuation">.</span>ConfigNum<span class="token punctuation">,</span> reply<span class="token punctuation">.</span>Err <span class="token operator">=</span> configNum<span class="token punctuation">,</span> OK
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="总结">总结</h2>
<p>这么设计有以下好处：</p>
<ol>
<li class="lvl-3">
<p>pull Shard 后能立即为 client 提供服务，而无需阻塞；</p>
</li>
<li class="lvl-3">
<p>不同 group 之间 Shard 状态互为同步关系，网络顺畅时系统才能够持续进行；</p>
</li>
<li class="lvl-3">
<p>不同 ShardId 的 Shard 互相独立，当两组互相迁移 Shard 时并不会造成死锁；</p>
</li>
<li class="lvl-3">
<p>group 能够 step-by-step 地更新 Config，所有任务都能稳定执行，而不会出现步子跨太大扯着蛋的情况；</p>
</li>
<li class="lvl-3">
<p>失去 Shard 所有权的 group 能够定期删除数据，而不会使存储无线增长；</p>
</li>
<li class="lvl-3">
<p>基于 ShardStatus 的任务执行减少了不必要的阻塞，使得整个系统设计更加优雅；</p>
</li>
</ol>
<p>总之系统的设计还是需要灵感与无数前人的经验总结，至少 Aurora 的论文给了我很大启迪。虽然因为磕盐原因 4B 磨蹭了很久，整个 lab 前前后后磨蹭了近 3 个月，但总归是 solo &amp;&amp; all passed 了，对 Distributed System 也有了更进一步的理解。完结撒花~</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab2 Page Tables</title>
    <url>/lab/6-s081lab2/</url>
    <content><![CDATA[<p>在本 lab 中，我们将进行页表机制的探索。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout pgtbl
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task1-Speed-up-system-calls">Task1: Speed up system calls</h2>
<p>该任务要求我们在进程虚拟地址空间中添加一个固定项：<code>USYSCALL</code>，该页的开头字段为当前进程 <code>pid</code>，这样一来 <code>getpid()</code> 就不用陷入内核，而是直接通过访问虚拟地址即可获取，从而加快速度。</p>
<p>用户层函数 <code>ugetpid()</code> 已经为我们实现好了，我们只需要关注内核中，更具体来讲，是新建进程时<strong>初始化虚拟地址空间</strong>动作中发生的事。</p>
<p>进程会在两个时候被创建，一个是 <code>userinit()</code>(<code>kernel/proc.c</code>)时，一个是调用 <code>fork()</code> 时。进程的创建会调用 <code>kernel/proc.c</code> 中的 <code>allocproc()</code>，然后通过 <code>proc_pagetable()</code> 来初始化页表。</p>
<p>我们要做的很简单。</p>
<p>第一步，在页表初始化时加入一个 <code>{USYSCALL =&gt; PHYPAGE}</code> 的 PTE。<code>USYSCALL</code> 在 <code>kernel/memlayout.h</code> 中定义（就是 <code>TRAPFRAME</code> 的前一页），而 <code>PHYPAGE</code> 则需要我们调用 <code>kalloc()</code>(<code>kernel/kalloc.c</code>) 进行空闲页分配。</p>
<p>第二步，也就是正确完成页表初始化后，将 <code>pid</code> 写入 <code>PHYPAGE</code>。</p>
<blockquote>
<p><code>#ifdef LAB_PGTBL</code> 是灰的不要紧，<code>make</code> 时会自动帮我们 define。</p>
</blockquote>
<p><code>PHYPAGE</code> 的分配操作只能在 <code>allocproc()</code> 中进行，因为一旦分配失败，我们需要释放当前进程。为了让同一 <code>PHYPAGE</code> 能被 <code>proc_pagetable()</code> 访问，我在 <code>struct proc</code> 中添加了 <code>usyscall</code> 字段（这些都是参考了 <code>trapframe</code> 的初始化流程）。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.c</span></div><code class="language-C">static struct proc*
allocproc(void)
{
  ...
found:
  ...
  // Allocate a trapframe page and a usyscall page.
  if((p-&gt;trapframe = (struct trapframe *)kalloc()) == 0 ||
     (p-&gt;usyscall = (struct usyscall *)kalloc()) == 0){
    ...
  }

  // An empty user page table.
  p-&gt;pagetable = proc_pagetable(p);
  if(p-&gt;pagetable == 0){
    ...
  }

  p-&gt;usyscall-&gt;pid = p-&gt;pid;
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>添加 PTE 的操作很简单，页表相关操作都在 <code>kernel/vm.c</code> 中，我们需要关注 <code>mempages()</code> 函数，该函数就是为指定页表添加 PTE。唯一需要关注的就是符号控制位，根据我们的需求，该页面为只读型，而且能被用户层函数访问，那么只赋予 <code>PTE_R|PTE_U</code> 即可。有效位会在 <code>mappages()</code> 内部添加，无需操心。</p>
<p>如果添加失败，需要把已经添加的表项清空，并且释放页表，参考上面的代码即可。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/vm.c</span></div><code class="language-C">pagetable_t
proc_pagetable(struct proc *p)
{
  ...
  // map the trapframe just below TRAPFRAME, for speeding up getpid()
  if (mappages(pagetable, USYSCALL, PGSIZE,
              (uint64)p-&gt;usyscall, PTE_R | PTE_U) &lt; 0) {
    uvmunmap(pagetable, TRAMPOLINE, 1, 0);
    uvmunmap(pagetable, TRAPFRAME, 1, 0);
    uvmfree(pagetable, 0);
    return 0;
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，不仅要考虑分配，还要考虑释放的操作。如果到这一步就急匆匆地 <code>make qemu; ./pgtbltest</code>，那你马上就会得到一个 <code>panic: freewalk leaf</code>。这是因为我们没有在清空页表时清空我们已分配的 <code>PHYPAGE</code>，而这一步在 <code>freeproc()</code> 函数中实现。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.c</span></div><code class="language-C">static void
freeproc(struct proc *p)
{
  if(p-&gt;trapframe)
    kfree((void*)p-&gt;trapframe);
  p-&gt;trapframe = 0;

  if (p-&gt;usyscall)              // (!new)
    kfree((void*)p-&gt;usyscall);  // (!new)
  p-&gt;usyscall = 0;              // (!new)

  if(p-&gt;pagetable)
    proc_freepagetable(p-&gt;pagetable, p-&gt;sz);
  p-&gt;pagetable = 0;
  p-&gt;sz = 0;
  p-&gt;pid = 0;
  p-&gt;parent = 0;
  p-&gt;name[0] = 0;
  p-&gt;chan = 0;
  p-&gt;killed = 0;
  p-&gt;xstate = 0;
  p-&gt;state = UNUSED;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然还要关注页表对应页的释放操作，<code>proc_freepagetable()</code>(<code>kernel/proc.c</code>) 的注释讲的很清楚：<strong>Free a process’s page table, and free the physical memory it refers to.</strong> 并且它也给了提示：要调用 <code>uvmunmap()</code>。所以新增一行即可，实际的释放操作会在 <code>uvmunmap()</code> 中完成：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.c</span></div><code class="language-C">void
proc_freepagetable(pagetable_t pagetable, uint64 sz)
{
  uvmunmap(pagetable, TRAMPOLINE, 1, 0);
  uvmunmap(pagetable, TRAPFRAME, 1, 0);
  uvmunmap(pagetable, USYSCALL, 1, 0); // (!new)
  uvmfree(pagetable, sz);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task2-Print-a-page-table">Task2: Print a page table</h2>
<p>现在我们需要按照给定格式，在 <code>kernel/exec.c:119</code> 插入 <code>if(p-&gt;pid==1) vmprint(p-&gt;pagetable)</code> 来输出初始进程的页表，以可视化并有助于 debug。</p>
<p>参考 <code>kernel/vm.c</code> 中的 <code>freewalk()</code>，我们主要关注的是它以怎样的方式遍历页目录结构——获取表项，得到物理地址，根据标志位判断这一物理地址是页表还是数据页，决定是否需要进一步深入。</p>
<blockquote>
<p>在 xv6 中，每个页表项的低位为标志位，如下图所示：</p>
<img src="1.png">
<p><code>kernel/riscv.h</code> 中已经为我们定义好了若干标志位，直接使用即可。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/vm.c</span></div><code class="language-C">void
freewalk(pagetable_t pagetable)
{
  ...
  for(int i = 0; i &lt; 512; i++){
    pte_t pte = pagetable[i];
    if((pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0){
      // this PTE points to a lower-level page table.
      uint64 child = PTE2PA(pte);
      freewalk((pagetable_t)child);
      ...
    }
    ...
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现，判断的条件就是 <code>(pte &amp; PTE_V) &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X) == 0</code>，<code>PTE_V</code> 位意味着该页表项中的物理地址是已分配的，<code>PTE_R|PTE_W|PTE_X</code> 意味着这一物理地址对应的是页表，而非数据项。</p>
<p>此外，我们还需要根据当前页表的 level 来打印，毕竟 level 越低，前面的 <code>..</code> 越多，所以还需要一个额外的 <code>vmprintwalk()</code> 函数。</p>
<p>那么先在 <code>kernel/def.h</code> 中添加函数签名，然后修改 <code>kernel/exec.c</code>，最后就是在 <code>kernel/vm.c</code> 下加入两个函数的代码了。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/vm.c</span></div><code class="language-C">void
vmprint(pagetable_t pagetable)
{
  printf("page table %p\n", pagetable); // 用 %p 来进行十六进制格式化
  vmprintwalk(pagetable, 2);
}

void
vmprintwalk(pagetable_t pagetable, int level)
{
  // there are 2^9 = 512 PTEs in a page table.
  for (int i = 0; i &lt; 512; i++) {
    pte_t pte = pagetable[i];
    if (pte &amp; PTE_V) {
      uint64 child = PTE2PA(pte);
      for (int i = 0; i &lt; 2-level; i++) {
        printf(".. ");
      }
      printf("..%d: pte %p pa %p\n", i, pte, child);
      if (level &amp;&amp; (pte &amp; (PTE_R|PTE_W|PTE_X)) == 0) {
        vmprintwalk((pagetable_t)child, level-1); // 这里需要用类型转换，否则编译报错
      }
    }
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task3-Detecting-which-pages-have-been-accessed">Task3: Detecting which pages have been accessed</h2>
<p>该任务要求我们利用跟踪哪些页被访问过，并且通过用户层函数 <code>pgaccess()</code> 来获取自从上一次调用以来被访问过的页。</p>
<p>既然如此，那每个页表项就需要一个「访问位」咯，根据上面那张图，我们可以在 <code>kernel/riscv.h</code> 中添加一行 <code>#define PTE_A (1L &lt;&lt; 6)</code>，方便进行位运算。</p>
<p>lab 已经贴心地为我们做好了所有准备工作，包括修改 <code>usys.pl</code>、注册系统调用等，所以我们只需要在 <code>kernel/sysproc.c</code> 中实现 <code>sys_pgaccess()</code> 函数即可。</p>
<p>查看 <code>user/user.h</code> 中 <code>pgaccess()</code> 的函数签名我们发现，我们需要接收三个参数，分别是一个虚拟地址 <code>vba</code>，一个整型 <code>npages</code>，和一个指针 <code>vp</code>，用 <code>argaddr()</code> 与 <code>argint()</code> 处理得到参数后，检查一下地址是否越界——<code>pgaccess</code> 的作用是追踪 <code>vba</code> 开始 <code>npages</code> 个页面的被访问情况，那么最大的地址一定不能超过 <code>MAXVA</code>，否则直接返回 <code>-1</code>。</p>
<p>然后根据得到的基地址，逐页查页表，检查指向数据页的那个页表项的 <code>PTE_A</code> 位，如果为 1，则将 <code>vp</code> 指针指向内存的第 <code>i</code> 个 bit 置 <code>1</code>。这就是一个简单的<strong>检查某页是否被访问过</strong>的流程。</p>
<blockquote>
<p>根据 <code>sys_sysinfo()</code> 的知识，这里必须用 <code>copyout()</code> 拷贝数据到 <code>vp</code> 指向的内存。</p>
</blockquote>
<p>那么如何根据页表找到最终的页表项呢？<code>kernel/vm.c</code> 中为我们提供了 <code>walk()</code> 的 API，它根据虚拟地址，返回指向数据页的那个页表项的指针。还有一个叫 <code>walkaddr()</code> 的，是直接返回物理页的起始地址，后面有用，这里暂时用不到。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysproc.c</span></div><code class="language-C">int
sys_pgaccess(void)
{
  uint64 vba; // virtual base address
  int npages;
  uint64 vp;
  if (argaddr(0, &amp;vba) &lt; 0 || argint(1, &amp;npages) &lt; 0 || argaddr(2, &amp;vp) &lt; 0) {
    return -1;
  }

  // 检查地址是否溢出虚拟内存空间
  vba = PGROUNDDOWN(vba);
  if (vba + npages*PGSIZE &gt; MAXVA) {
    return -1;
  }

  unsigned int abits = 0;
  struct proc* p = myproc();
  pagetable_t pagetable = p-&gt;pagetable;

  for (int i = 0; i &lt; npages; i++) {
    uint64 va = vba + i*PGSIZE;
    pte_t* pte = walk(pagetable, va, 0);  // 直接用会报 error: implicit declaration of function ‘walk’
                                          // 需要在 kernel/def.h 中添加声明
    if (*pte &amp; PTE_A) {
      abits |= 1 &lt;&lt; i;
      *pte &amp;= ~PTE_A;                     // 由于是上一次调用以来的访问情况，故每次调用都要解除访问
    }
  }

  copyout(pagetable, vp, (char*)&amp;abits, sizeof(abits));
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在还有一个问题，<code>PTE_A</code> 位是我们新增的，也就是说 lab 并没有实现在什么地方将其置 <code>1</code>，就需要我们找一个合适的位置去置位，不然 <code>*pte &amp; PTE_A</code> 将毫无意义。</p>
<p>前面提到的 <code>walkaddr()</code> 可以解决该问题。毕竟每次访问物理页的时候必然要经过这个调用，它返回的物理页起始地址，那肯定是要有人去访问的——就算没人访页，那也视为去访问了——所以，u know，在返回前置位即可。毕竟，这是访问物理页的唯一通道。</p>
<blockquote>
<p>如果加在 <code>walk()</code> 里，那么 <code>sys_pgaccess()</code> 检查的每一页，都会因为调用了 <code>walk()</code> 而置 <code>PTE_A=1</code>，这肯定是不行的。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/vm.c</span></div><code class="language-C">uint64
walkaddr(pagetable_t pagetable, uint64 va)
{
  pte_t *pte;
  uint64 pa;

  if(va &gt;= MAXVA)
    return 0;

  pte = walk(pagetable, va, 0);
  if(pte == 0)
    return 0;
  if((*pte &amp; PTE_V) == 0)
    return 0;
  if((*pte &amp; PTE_U) == 0)
    return 0;
  *pte |= PTE_A; // (!new)
  pa = PTE2PA(*pte);
  return pa;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test pgtbltest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">3</span>.4s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   pgtbltest: ugetpid <span class="token operator">==</span>
  pgtbltest: ugetpid: OK
<span class="token operator">==</span> Test   pgtbltest: pgaccess <span class="token operator">==</span>
  pgtbltest: pgaccess: OK
<span class="token operator">==</span> Test pte printout <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
pte printout: OK <span class="token punctuation">(</span><span class="token number">1</span>.0s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test answers-pgtbl.txt <span class="token operator">==</span> answers-pgtbl.txt: OK
<span class="token operator">==</span> Test usertests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">125</span>.0s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   usertests: all tests <span class="token operator">==</span>
  usertests: all tests: OK
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">46</span>/46<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab1 System Calls</title>
    <url>/lab/6-s081lab1/</url>
    <content><![CDATA[<p>本 lab 要求我们进行系统调用代码的编写。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout syscall
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>可以看到 <code>Makefile</code> 里内容都重置了，且测试脚本名也变成了 <code>grade-lab-syscall</code></p>
</blockquote>
<p>在做实验之前，可以先了解一下<a href="../6-s081systemcallprocess">整个系统调用流程</a>。</p>
<h2 id="Task1-System-call-tracing">Task1: System call tracing</h2>
<h3 id="实现系统调用">实现系统调用</h3>
<p>该任务要求我们实现 <code>trace</code> 命令，用于追踪特定命令的相应系统调用，并为其在 <code>kernel/</code> 文件夹下实现相应的系统调用。lab 已经为我们准备好了 <code>user/trace.c</code>。根据上面知识，我们修改完 <code>user/user.h</code>，<code>user/usys.pl</code>，<code>Makefile</code>，<code>kernel/syscall.h</code>，<code>kernel/syscall.c</code>，就可以正式编译了。</p>
<blockquote>
<p><code>user/user.h</code>: int trace(int);
<code>user/usys.pl</code>: entry(“trace”);
<code>Makefile</code>: $U/_trace<br>
<code>kernel/syscall.h</code>: #define SYS_trace 22
<code>kernel/syscall.c</code>: [SYS_trace] sys_trace</p>
</blockquote>
<p>但编译还不能通过，是因为我们还没有实现 <code>sys_trace()</code>。该函数在 <code>kernel/sys_proc.c</code> 中定义，作用就是令当前进程记住我们传入的参数 trace mask，这里需要在 <code>kernel/proc.h</code> 中为 <code>proc</code> 结构体新增一个变量 <code>int trae_mask</code>，然后在 <code>sys_trace()</code> 中利用 <code>argint()</code> 获取参数并赋值即可，函数如下：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysproc.c</span></div><code class="language-C">uint64
sys_trace(void)
{
  if (argint(0, &amp;myproc()-&gt;trace_mask) &lt; 0) {
    return -1;
  }
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>因为 exec 只会改变执行的代码段，进程还是同一个，<code>trace_mask</code> 变量并不会被修改，所以无需担心。</p>
</blockquote>
<p>为了令 <code>trace</code> 在 <code>fork</code> 场景下也支持追踪功能，需要在 <code>fork()</code> 系统调用中追加子进程拷贝父进程的 <code>trace_mask</code>，实现略。</p>
<h3 id="打印信息">打印信息</h3>
<p>现在我们已经让当前进程记住了 trace mask，接下来需要在执行命令时根据 mask 打印信息，格式为：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token operator">&lt;</span>pid<span class="token operator">&gt;</span>: syscall <span class="token operator">&lt;</span>syscall name<span class="token operator">&gt;</span> -<span class="token operator">&gt;</span> <span class="token operator">&lt;</span>return value<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>我们需要每遇到一个<strong>被跟踪的</strong>系统调用都打印一遍信息，这就要在 <code>kernel/syscall.c</code> 中的 <code>syscall()</code> 函数中实现了，判断条件就是 <code>(trace_mask &gt;&gt; num) &amp; 1</code> 非零.</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/syscall.c</span></div><code class="language-C">void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p-&gt;trapframe-&gt;a7;
  if(num &gt; 0 &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) {
    p-&gt;trapframe-&gt;a0 = syscalls[num](); // 系统调用返回值
    if ((p-&gt;trace_mask &gt;&gt; num) &amp; 1) {
      printf("%d: syscall %s -&gt; %d\n", p-&gt;pid, syscall_name[num], p-&gt;trapframe-&gt;a0);
    }
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task2-Sysinfo">Task2: Sysinfo</h2>
<p>该任务要求我们实现 <code>sysinfo(sysinfo*)</code> 函数，并为传入的结构体填充字段，分别为：</p>
<ol>
<li class="lvl-3">
<p><code>freemem</code>: 空闲内存字节数；</p>
</li>
<li class="lvl-3">
<p><code>nproc</code>: 当前进程数；</p>
</li>
</ol>
<p>由于这也是一个新建的系统调用函数，所以我们需要像上一个任务一样修改以下文件 <code>user/user.h</code>，<code>user/usys.pl</code>，<code>Makefile</code>，<code>kernel/syscall.h</code>，<code>kernel/syscall.c</code>，并且在 <code>kernel/sysproc.c</code> 中添加并实现 <code>sys_sysinfo()</code> 函数。</p>
<blockquote>
<p><code>user/user.h</code>: int sysinfo(struct sysinfo *);
<code>user/usys.pl</code>: entry(“sysinfo”);
<code>Makefile</code>: $U/_sysinfo<br>
<code>kernel/syscall.h</code>: #define SYS_sysinfo 23
<code>kernel/syscall.c</code>: [SYS_sysinfo] sys_sysinfo</p>
</blockquote>
<p>然而，lab 并没有为我们提供现成的「获取空闲字节数」与「获取当前进程数」的 API，需要我们自己实现。这两个 API 可以分别在 <code>kernel/kalloc.c</code> 与 <code>kernel/proc.c</code> 中实现（需要在 <code>kernel/defs.h</code> 中添加声明）。</p>
<h3 id="获取空闲内存字节数">获取空闲内存字节数</h3>
<p><code>kernel/kalloc.c</code> 中有一个名为 <code>kmem</code> 的数据结构，它维护了一个空闲链表。</p>
<p>事实上，所有内存中未分配的页面都有一个 header，大小为 64 位（一个指针那么大），指向（逻辑上的）下一个未分配的页面，这个指针在软件层面用数据结构 <code>struct run</code> 表示。一旦有一个空闲页面 <code>page</code> 被分配，那么（逻辑上的）上一个页面 <code>prev</code> 的 <code>run</code> 就会指向 <code>page</code> 的（逻辑上的）下一个空闲页面 <code>next</code>；而有个物理页被 free 了，就让它成为空闲链表的表头。</p>
<blockquote>
<p>这可以在 <code>kernel/kalloc.c</code> 中的 <code>kalloc()</code> 与 <code>kfree()</code> 中得知。</p>
</blockquote>
<p>那空闲内存的字节数就很好计算了，就是<strong>空闲页面数*页面大小</strong>嘛。写成代码就是</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/kalloc.c</span></div><code class="language-C">int
kfreemem(void)
{
  int npage = 0;
  acquire(&amp;kmem.lock);
  struct run *r = kmem.freelist;
  while (r) {
    r = r-&gt;next;
    npage++;
  }
  release(&amp;kmem.lock);
  return npage * PGSIZE;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="获取当前进程数">获取当前进程数</h3>
<p><code>kernel/proc.c</code> 中为我们定义了一个名为 <code>proc</code> 的进程表（对的，和结构体 <code>struct proc</code> 同名），我们只需要遍历该表，检查进程状态即可。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.c</span></div><code class="language-C">int
nproc(void)
{
  int cnt = 0;
  for (int i = 0; i &lt; NPROC; i++) {
    if (proc[i].state != UNUSED) {
      cnt++;
    }
  }
  return cnt;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="实现-sys-sysinfo">实现 sys_sysinfo()</h3>
<p>接下来就是实现系统函数了。由于我们在用户层调用 <code>sysinfo()</code> 时传入的是一个指针，所以在读取该参数时不能用 <code>argint()</code>，而是 <code>argaddr()</code>。</p>
<p>值得注意的是，读取到的参数是一个用户态的虚拟地址，如果我们创建一个 <code>struct sysinfo*</code> 变量用于接收指针，然后再赋值，像下面这样：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysproc.c</span></div><code class="language-C">uint64 va;
argaddr(0, &amp;va);
struct sysinfo* info = (struct sysinfo*)va;
info-&gt;freemem = kfreemem();
info-&gt;nproc = nproc();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那肯定是不行的。对于内核而言，如果直接访问地址，那访问的就是物理地址，可我们得到的却是一个用户态下的虚拟地址，这两者是完全不能等同的。要想访问到正确的物理地址，就需要通过页表进行地址转换。然而 lab 已经为我们提供了另一个实现方法，<code>kernel/vm.c</code> 中的 <code>copyout()</code> 函数，用于拷贝一段内存到虚拟地址。这正好是我们需要的，要用它，我们只需要在内核栈中新建一个 <code>struct sysinfo info</code> 变量，赋值后调用 <code>copyout()</code> 拷贝即可。完整的 <code>sys_sysinfo()</code> 如下：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysproc.c</span></div><code class="language-C">uint64
sys_sysinfo(void)
{
  uint64 va;
  if (argaddr(0, &amp;va) &lt; 0) {
    return -1;
  }

  // info is in kernel address space
  struct sysinfo info;
  info.freemem = kfreemem();
  info.nproc = nproc();

  // copy info to *va
  return copyout(myproc()-&gt;pagetable, va, (char*)&amp;info, sizeof(info));
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test trace <span class="token number">32</span> <span class="token function">grep</span> <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
trace <span class="token number">32</span> grep: OK <span class="token punctuation">(</span><span class="token number">2</span>.6s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test trace all <span class="token function">grep</span> <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
trace all grep: OK <span class="token punctuation">(</span><span class="token number">1</span>.0s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test trace nothing <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
trace nothing: OK <span class="token punctuation">(</span><span class="token number">0</span>.9s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test trace children <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
trace children: OK <span class="token punctuation">(</span><span class="token number">13</span>.6s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test sysinfotest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
sysinfotest: OK <span class="token punctuation">(</span><span class="token number">1</span>.7s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">35</span>/35<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab3 Traps</title>
    <url>/lab/6-s081lab3/</url>
    <content><![CDATA[<p>现在是，陷入内核时间。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout traps
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task1-RISC-V-assembly">Task1: RISC-V assembly</h2>
<p>第一个任务就是了解一下 RISC-V 汇编语言，直接跳过。</p>
<blockquote>
<p>反正 Hello World 就完事了(</p>
</blockquote>
<h2 id="Task2-Backtrace">Task2: Backtrace</h2>
<p>该任务要求我们实现 <code>backtrace()</code> 特性，打印函数调用层次，方便 debug。</p>
<p>课程笔记中已经为我们展示了栈中各个栈帧(Stack Frame)的排布情况，如下图所示。</p>
<img src="1.png">
<p>每当一个函数被调用，就会在栈中为其分配一个栈帧，先 push 函数返回地址，再 push 上一个栈帧的地址。如果用 <code>fp</code> 指向当前栈帧，则有 <code>return_addr = *(fp-8)</code>，以及 <code>prev_fp = *(fp-16)</code>。可以近似看成一个链表。那么如何判断一个栈帧是否位于调用层次结构的根呢？在 xv6 中，一个栈就是一个 PGSIZE 大小，由于栈从高往低增长，那么最开始那个栈帧必然大于该页的最大地址（事实上就是下一页的起始地址）。</p>
<p>有了这些知识，那么实现起来就很简单了，只需在一个有限循环里遍历栈帧即可。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/printf.c</span></div><code class="language-C">void
backtrace(void)
{
  printf("backtrace:\n");

  uint64 fp = r_fp();
  uint64 top = PGROUNDUP(fp);

  for (; fp &lt; top; fp = *(uint64*)(fp-16)) {
    uint64 ret = *(uint64*)(fp-8);    // get return addr
    printf("%p\n", ret);
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task3-Alarm">Task3: Alarm</h2>
<p>该任务要求我们实现定时器功能，即给定 interval 和一个 handler，每 interval 次时钟中断，调用一次 <code>handler()</code>。</p>
<p>lab 手册已经给我们提供了 <code>sigalarm()</code> 和 <code>sigreturn()</code> 函数签名，我们要做的就是实现对应的系统调用。注册过程略掉，我们先看看 <code>sys_sigalarm()</code> 要做什么。</p>
<h3 id="sys-sigalarm">sys_sigalarm</h3>
<p><code>sys_sigalarm()</code> 接收两个参数 interval 和 handler，并将其保存到当前进程，这样每次时钟中断时，我们检查距离上次调用 handler 的时间，如果到了 interval 个 ticks，就进行调用。</p>
<p>但不能直接进行 <code>p-&gt;handler()</code> 这样的指令，因为 handler 是个用户态函数指针，保存的是用户态的虚拟地址，而处理时钟中断时位于内核态。为了正确调用，我们可以令 <code>p-&gt;trapframe-&gt;epc = p-&gt;handler</code>，这样在 <code>usertrapret()</code> 时，该值会被写入 SEPC，那么我们返回用户态时就可以直接跳到这个指令。而由于 handler 内部调用了 <code>sigreturn()</code>，会返回时钟中断之前的代码位置 （记为 origin）。</p>
<p>总结一下就是，代码运行到 origin 时触发时钟中断，进入内核态处理，再进入用户态调用 handler，完了之后触发系统调用 <code>sigreturn()</code> 再一次进入内核态进行处理，最后回到 origin。</p>
<p>这就要求我们保存代码处于 origin 时的上下文，否则触发 <code>sigreturn()</code> 时当前进程的 trapframe 内容可能会被 handler 的数据占据，导致之前的数据丢失，再也回不去了。比较典型的就是 PC，还有 SP。</p>
<p>如果不知道哪些要保存，那就干脆点直接把整个 trapframe 进行一个拷贝，也就要在 <code>struct proc</code> 里新增一个 <code>trapframe_copy</code> 变量用于拷贝 origin 进入内核态时暂存的用户寄存器。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.h</span></div><code class="language-C">struct proc {
  ...

  // every timeout ticks, call handler
  int timeout;
  int tick;         // ticks since last call
  uint64 handler;
  uint8 in_handler; // 1 for is running handler, 0 for else
  struct trapframe trapframe_copy;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>test2 中要求我们在执行 handler 时忽视时钟中断，就还要一个 <code>in_handler</code> 变量用来指示当前是否正在调用 handler。</p>
<p>这样一来，<code>sys_sigalarm()</code> 函数就很好实现了——仅仅是保存一些变量而已。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysproc.c</span></div><code class="language-C">uint64
sys_sigalarm(void)
{
  int timeout;
  uint64 handler;

  if (argint(0, &amp;timeout) &lt; 0 || argaddr(1, &amp;handler) &lt; 0) {
    return -1;
  }

  struct proc* p = myproc();
  p-&gt;timeout = timeout;
  p-&gt;tick = 0;
  p-&gt;handler = handler;
  p-&gt;in_handler = 0;
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以及别忘了需要在 <code>allocproc()</code> 和 <code>freeproc()</code> 中进行一些修改。</p>
<h3 id="when-and-how-to-call-handler">when and how to call handler?</h3>
<p>上文说到，需要在每次时钟中断时检查 ticks。而时钟中断的处理位于 <code>kernel/trap.c</code> 的 <code>usertrap()</code> 函数中，即函数末尾的 <code>if (which_dev==2)</code> 分支。这个判断条件为真，意味着当前处理的是时钟中断。</p>
<p>那么如果 <code>p-&gt;timeout</code> 非零，意味着定时器有效（<code>p-&gt;handler</code> 为零不能作为是否有效的依据，因为传入的函数地址可能在虚拟空间的最开始，也就是地址为 <code>0x0</code>）。</p>
<p>如果当前未运行 handler，将 tick 增加，一旦达到阈值 timeout，就将 trapframe 进行拷贝，然后修改 trapframe 的 epc 字段，等待 <code>usertrapret()</code> 结束后跳转到 handler 并执行。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">void
usertrap(void)
{
  ...
  if(which_dev == 2) {
    if (p-&gt;timeout &amp;&amp; !p-&gt;in_handler) {
      p-&gt;tick++;
      if (p-&gt;tick &gt;= p-&gt;timeout) {
        p-&gt;tick = 0;
        p-&gt;in_handler = 1;
        memmove(&amp;p-&gt;trapframe_copy, p-&gt;trapframe, sizeof(struct trapframe));
        p-&gt;trapframe-&gt;epc = p-&gt;handler; // p-&gt;trapframe-&gt;epc should be set as the handler address
      }
    }
    yield();
  }

  usertrapret();
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="sys-sigreturn">sys_sigreturn</h3>
<p>定时器返回函数就更简单了。恢复原来的 trapframe 数据，这样对硬件而言，中间发生的事都无所谓，毕竟从 origin 触发时钟中断，到 sigreturn 返回，trapframe 都没有变，那也就能进行正确的恢复。</p>
<blockquote>
<p>由此可见 trapframe 在恢复用户态的重要性。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysproc.c</span></div><code class="language-C">uint64
sys_sigreturn(void)
{
  struct proc* p = myproc();
  p-&gt;tick = 0;
  p-&gt;in_handler = 0; // finish calling handler, set it as 0
  memmove(p-&gt;trapframe, &amp;p-&gt;trapframe_copy, sizeof(struct trapframe));
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test answers-traps.txt <span class="token operator">==</span> answers-traps.txt: OK
<span class="token operator">==</span> Test backtrace <span class="token builtin class-name">test</span> <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
backtrace test: OK <span class="token punctuation">(</span><span class="token number">3</span>.6s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test running alarmtest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">3</span>.9s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   alarmtest: test0 <span class="token operator">==</span>
  alarmtest: test0: OK
<span class="token operator">==</span> Test   alarmtest: test1 <span class="token operator">==</span>
  alarmtest: test1: OK
<span class="token operator">==</span> Test   alarmtest: test2 <span class="token operator">==</span>
  alarmtest: test2: OK
<span class="token operator">==</span> Test usertests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
usertests: OK <span class="token punctuation">(</span><span class="token number">123</span>.9s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">85</span>/85<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab5 Multithreading</title>
    <url>/lab/6-s081lab5/</url>
    <content><![CDATA[<p>现在进入操作系统的另一大特性：并发。</p>
<span id="more"></span>
<h2 id="线程切换-in-xv6">线程切换 in xv6</h2>
<p>在 xv6 中，每个进程都可以视为有一个主线程，逐行运行指令，享有所有寄存器的使用权。然而，时间片到期，也就是进程收到时钟中断后，会调用 <code>yield()</code> 函数<strong>自愿</strong>让出 CPU。</p>
<p>该函数会将当前进程运行状态设置为 <code>RUNNABLE</code>，也就是所谓的<strong>就绪态</strong>，然后调用 <code>sched()</code>。</p>
<p><code>sched()</code> 进行一些合理性检查后，会调用 <code>switch()</code> 进行上下文的切换：保存当前进程上下文到 <code>proc-&gt;context</code> 中，并将寄存器设置为 CPU 调度器线程的上下文（<code>struct context</code> 指明了保存的上下文都有哪些寄存器，基本都是 <strong>Callee Saved Register</strong>，这里主要关注 ra）。也就是说，调用 <code>swtch()</code> 后，本来 ra 应该为 <code>sched()</code> 中调用 <code>swtch()</code> 处的地址，但 <code>switch()</code> 的一通操作，ra 成为了调度器线程 <code>scheduler()</code> 函数的地址，那么 <code>swtch()</code> 最后的 ret 指令会进入到 <code>scheduler()</code> 开始执行。</p>
<p><code>scheduler()</code> 本质上是个 for 循环，遍历进程表找到下一个处于就绪态的进程 A，将 A 设置为 <code>RUNNING</code>，即<strong>运行态</strong>，然后调用 <code>swtch()</code> 保存当前寄存器到调度进程中，然后读 A 的上下文到寄存器中，这样就完成了切换的工作。</p>
<p>如果是首次调度 A，那么由于 A 的 <code>context.ra</code> 会被初始化为 <code>forkret()</code>，直接跳转过去；</p>
<p>反之，A 的 <code>context.ra</code> 因为上次时间片到期而被初始化为 <strong><code>sched()</code> 中调用 <code>swtch()</code> 处的地址</strong>，恢复上下文后相当于跟什么都没发生一样，继续执行，退出 <code>sched()</code>，退出 <code>yield()</code>，后面就是到 <code>usertrapret()</code> 返回用户态了。</p>
<p>所以，进程的切换相当于主线程的切换，而在硬件层面，就是几个寄存器的切换，同一个进程切换出去，会在同一位置切换回来继续执行，保证了并发的正确性。</p>
<blockquote>
<p>ret 指令会自动设置 PC，也就不用保存。</p>
</blockquote>
<p>而页表寄存器的切换与 TLB 的清除工作，是当进程切换后，必然会进入 <code>usertrapret()</code>（<code>forkret()</code> 最后也会进入），这里会进行内核态到用户态页表的切换，而用户态页表地址在 <code>struct proc</code> 中的 <code>pagetable</code> 里，调度到哪个进程自然就会将 SATP 设为对应进程的 <code>proc-&gt;pagetable</code>。</p>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout thread
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task1-Uthread-switching-between-threads">Task1: Uthread: switching between threads</h2>
<p>该任务就是实现线程间的切换，其实现完全可以参考进程切换，毕竟本质上也是主线程的切换。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>user/uthread.c</span></div><code class="language-C">...
// 定义上下文结构体，其实就是直接抄了 proc.h 里的。
struct context {
  uint64 ra;
  uint64 sp;

  // callee-saved
  uint64 s0;
  uint64 s1;
  uint64 s2;
  uint64 s3;
  uint64 s4;
  uint64 s5;
  uint64 s6;
  uint64 s7;
  uint64 s8;
  uint64 s9;
  uint64 s10;
  uint64 s11;
};

struct thread {
  char           stack[STACK_SIZE]; /* the thread's stack */
  int            state;             /* FREE, RUNNING, RUNNABLE */
  struct context ctx;               // (!new)
};
...
void
thread_schedule(void)
{
  struct thread *t, *next_thread;

  /* Find another runnable thread. */
  ...

  if (current_thread != next_thread) {         /* switch threads?  */
    next_thread-&gt;state = RUNNING;
    t = current_thread;
    current_thread = next_thread;
    thread_switch((uint64)&amp;t-&gt;ctx, (uint64)&amp;next_thread-&gt;ctx); // (!new)
  } else {
    next_thread = 0;
  }
}

void
thread_create(void (*func)())
{
  struct thread *t;

  for (t = all_thread; t &lt; all_thread + MAX_THREAD; t++) {
    if (t-&gt;state == FREE) break;
  }
  t-&gt;state = RUNNABLE;

  memset(&amp;t-&gt;ctx, 0, sizeof(struct context)); // (!new)
  t-&gt;ctx.ra = (uint64)func;                   // (!new)
  t-&gt;ctx.sp = (uint64)&amp;t-&gt;stack + STACK_SIZE; // (!new)
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-S" data-language="S"><div class="caption"><span>user/uthread_switch.S</span></div><code class="language-S">.globl thread_switch
thread_switch:
  sd ra, 0(a0)
  ...
  sd s11, 104(a0)

  ld ra, 0(a1)
  ...
  ld s11, 104(a1)

  ret    /* return to ra */<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基本都是参考已有的实现，但关键是弄明白具体发生了什么。</p>
<h2 id="Task2-Using-threads">Task2: Using threads</h2>
<p>该任务（和下一个任务）是熟悉 <code>pthread.h</code> 库并发编程，场景是对一个哈希表进行并发读写，由于是批量写完再读，所以不用给读操作加锁（读写交错的话就要加锁了）。</p>
<p>这里的哈希表采用最简单的拉链法处理冲突和直接哈希进行映射，一共有 <code>NBUCKETS</code> 个桶，每个桶用链表实现，用 <code>key % NBUCKETS</code> 进行映射，然后插到桶链表的末尾。</p>
<p>最开始我们可以为整个表设置一个大锁，一旦要进行写操作，就上锁，写完放锁。但这样效率很低，毕竟一共有互不干涉的 <code>NBUCKETS</code> 个桶，如果两个 key 分别映射到不同的桶，那就没有必要用大锁来互斥。于是可以考虑开一个锁数组，每个桶对应一个表，根据 key 的映射结果决定给哪个桶上锁放锁，这样效率会比之前快很多。</p>
<blockquote>
<p>大锁的设计粒度太粗，无法通过 <code>ph_fast</code> 测试，改为「一桶一锁」方能通过。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>notxv6/ph.c</span></div><code class="language-C">...
pthread_mutex_t locks[NBUCKET];
...
static
void put(int key, int value)
{
  int i = key % NBUCKET;
  pthread_mutex_lock(&amp;locks[i]);
  // insert
  pthread_mutex_unlock(&amp;locks[i]);
}

int
main(int argc, char *argv[])
{
  ...
  // before put
  for (int i = 0; i &lt; NBUCKET; i++) {
    pthread_mutex_init(&amp;locks[i], 0);
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task3-Barrier">Task3: Barrier</h2>
<p>这个任务就是用到条件变量相关的库函数了。场景是每个线程都有一个 for 循环，每次循环都要调用 <code>barrier()</code> 进行短暂阻塞，保证每个线程的循环轮次保持一致。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>notxv6/barrier.c</span></div><code class="language-C">static void *
thread(void *xa)
{
  ...
  for (i = 0; i &lt; 20000; i++) {
    int t = bstate.round;
    assert (i == t);
    barrier();
    usleep(random() % 100);
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有一个全局结构体 <code>struct barrier bstate</code>，里面设置了一些变量，比如 <code>bstate.nthread</code> 就是当前位于 barrier 的线程数，<code>bstate.round</code> 是当前 barrier 所处的轮次。全局静态变量 <code>nthread</code> 和 <code>round</code> 分别表示总线程数与……这个 <code>round</code> 变量需要我们自己品，暂且不表。</p>
<p>令第 i 次循环调用的阻塞为 barrier_i，不妨考虑 barrier_0。一开始所有线程都会进入 barrier_0，如果不是最后一个进入的，就阻塞，反之，唤醒其他线程。此外，还要有一个线程负责修改 <code>bstate.round</code>，那么由谁来修改呢？是最后一个进入的，还是最后一个离开的？</p>
<p>如果是最后一个出去的进行修改，那就会出问题。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>Wrong Case1</span></div><code class="language-C">static void
barrier()
{
  pthread_mutex_lock(&amp;bstate.barrier_mutex);
  bstate.nthread++;
  if (bstate.nthread &lt; nthread) { // 不是最后一个进来的
    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);
  } else { // 是最后一个进来的
    pthread_cond_broadcast(&amp;bstate.barrier_cond);
  }

  if (--bstate.nthread == 0) { // 是最后一个离开的
    bstate.round++;
  }
  pthread_mutex_unlock(&amp;bstate.barrier_mutex);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里，每个进程在进入后与离开前都会修改 <code>bstate.nthread</code>，如果由最后一个离开的修改 <code>bstate.round</code>，就会导致其他先离开的线程经历短暂的 <code>usleep()</code> 后，进入到下一个循环，此时 <code>bstate.round</code> 为 0，但 <code>i</code> 为 1，断言失败，程序报错。问题的本质在于，<code>bstate.round</code> 没有得到及时修改。那么是不是改完这个问题就没事了呢？当然不是。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>Wrong Case2</span></div><code class="language-C">static void
barrier()
{
  pthread_mutex_lock(&amp;bstate.barrier_mutex);
  bstate.nthread++;
  if (bstate.nthread &lt; nthread) { // 不是最后一个进来的
    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);
  } else { // 是最后一个进来的，也是第一个离开的，毕竟从进来到退出之间一直持有锁
    bstate.round++;
    pthread_cond_broadcast(&amp;bstate.barrier_cond);
  }
  pthread_mutex_unlock(&amp;bstate.barrier_mutex);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管上面的修改确实解决了断言的问题，但断言之后，线程会进入 barrier_1，获取锁，然后修改 <code>bstate.nthread</code>。然而，还有其他 <code>nthread-1</code> 个线程还逗留在 <code>barrier_0()</code> 中，甚至可能没有走到 <code>if (bstate.nthread-- == nthread)</code> 这一步。</p>
<p>第一个离开的线程会先将 barrier_0 的 <code>bstate.nthread</code> 减少，然后进入 barrier_1 将 <code>bstate.nthread</code> 增加——<code>bstate.nthread</code> 相当于没有变化，这就导致其他线程到了 <code>if (bstate.nthread-- == nthread)</code> 后，会误以为自己是第一个离开的，从而修改 <code>bstate.round</code>。这是个毁灭性的错误！</p>
<p>这个错误的根源在于，后面的 barrier 不应该在 <strong>有线程未退出前面的 barrier 的时候</strong> 对 <code>bstate.nthread</code> 进行修改。那么如何判断是否所有线程都退出前一个 barrier 了呢？全局变量 <code>round</code> 派上用场了。如果将这个变量解释为，<strong>最晚的线程所处的 barrier 轮次</strong>，那么只要有线程没有退出 barrier_{i-1}，<code>round</code> 就会停留在 <code>i-1</code>，直到所有线程都阻塞在 <code>barrier_i</code>（或退出 <code>barrier_{i-1}</code>），此时 <code>round</code> 才会被设置为 <code>i</code>。</p>
<p>所以，在修改 <code>bstate.nthread</code> 之前，所有线程都要阻塞，直到 <code>round</code> 被修改为与 <code>bstate.round</code> 一致，然后被修改 <code>round</code> 的那个线程唤醒。</p>
<blockquote>
<p>修改 <code>round</code> 的线程其实就是最后一个离开 <code>barrier_{i-1}</code> 的线程。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>notxv6/barrier.c</span></div><code class="language-C">static void
barrier()
{
  pthread_mutex_lock(&amp;bstate.barrier_mutex);

  while (round != bstate.round) { // 等待所有线程退出前一个 barrier
    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);
  }

  bstate.nthread++;
  if (bstate.nthread &lt; nthread) { // 等待所有线程进入当前 barrier
    pthread_cond_wait(&amp;bstate.barrier_cond, &amp;bstate.barrier_mutex);
  } else { // 最后一个进入的，负责修改 bstate.round，并唤醒其他线程
    bstate.round++;
    pthread_cond_broadcast(&amp;bstate.barrier_cond);
  }

  if (--bstate.nthread == 0) { // 最后一个离开的，负责修改 round，并唤醒下一个 barrier 等待的所有线程
    round = bstate.round;
    pthread_cond_broadcast(&amp;bstate.barrier_cond);
  }

  pthread_mutex_unlock(&amp;bstate.barrier_mutex);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test uthread <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
uthread: OK <span class="token punctuation">(</span><span class="token number">3</span>.1s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test answers-thread.txt <span class="token operator">==</span> answers-thread.txt: OK
<span class="token operator">==</span> Test ph_safe <span class="token operator">==</span> make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>:
ph_safe: OK <span class="token punctuation">(</span><span class="token number">14</span>.1s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test ph_fast <span class="token operator">==</span> make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>:
ph_fast: OK <span class="token punctuation">(</span><span class="token number">32</span>.3s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test barrier <span class="token operator">==</span> make<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>:
barrier: OK <span class="token punctuation">(</span><span class="token number">2</span>.7s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">60</span>/60<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab6 Networking</title>
    <url>/lab/6-s081lab6/</url>
    <content><![CDATA[<p>这里要我们在软件层面实现数据包的收发操作。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout net
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="模拟网络">模拟网络</h2>
<p>我们将使用名为 <strong>E1000</strong> 的网络设备来处理网络通信，实际上是 qemu 模拟了一个网卡和 PCI 总线，以及若干寄存器。不妨从 <code>connect()</code> 开始，逐步分析。</p>
<h3 id="从-connect-开始">从 connect 开始</h3>
<p><code>connect()</code> 实际上会触发系统调用 <code>sys_connect()</code>，它主要调用 <code>sockalloc()</code> 根据传入的参数（目的 ip 地址，源端口和目的端口）新建一个套接字，然后将其注册到一个 SOCK 类型的文件中，然后为该文件分配一个 fd 并返回。</p>
<p>通过对该 fd 进行读写，就是进行数据的收发操作。</p>
<h3 id="write-fd">write(fd)</h3>
<p>先看发数据。在用户态执行 <code>write(fd)</code> 会跳转到系统调用 <code>sys_write(fd)</code>，进一步执行 <code>filewrite(fd)</code>，发现传入的 fd 指向一个 SOCK 文件，下一步就会执行 <code>sockwrite()</code>。该函数就是将数据拷贝到 <code>struct mbuf</code> 类型的变量中，然后利用协议栈，不断封装 TCP/UDP 首部、IP 首部、以太网首部，最后得到一个完整的数据包，就可以发送了。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysnet.c</span></div><code class="language-C">int
sockwrite(struct sock *si, uint64 addr, int n)
{
  struct proc *pr = myproc();
  struct mbuf *m;

  m = mbufalloc(MBUF_DEFAULT_HEADROOM); // 分配一个 mbuf，并留出首部空间。
  if (!m)
    return -1;

  if (copyin(pr-&gt;pagetable, mbufput(m, n), addr, n) == -1) { // 载入数据
    mbuffree(m);
    return -1;
  }
  net_tx_udp(m, si-&gt;raddr, si-&gt;lport, si-&gt;rport);
  return n;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/net.c</span></div><code class="language-C">void
net_tx_udp(struct mbuf *m, uint32 dip,
           uint16 sport, uint16 dport)
{
  struct udp *udphdr;

  // put the UDP header...

  // now on to the IP layer
  net_tx_ip(m, IPPROTO_UDP, dip);
}

static void
net_tx_ip(struct mbuf *m, uint8 proto, uint32 dip)
{
  struct ip *iphdr;

  // push the IP header...

  // now on to the ethernet layer
  net_tx_eth(m, ETHTYPE_IP);
}

static void
net_tx_eth(struct mbuf *m, uint16 ethtype)
{
  struct eth *ethhdr;

  // push the ethernet header...

  if (e1000_transmit(m)) { // 发送，该函数需要我们实现
    mbuffree(m);
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="read-fd">read(fd)</h3>
<p>收数据的流程基本与上面类似。在用户态执行 <code>read(fd)</code> 会跳转到系统调用 <code>sys_read(fd)</code>，进一步执行 <code>fileread(fd)</code>，发现传入的 fd 指向一个 SOCK 文件，下一步就会执行 <code>sockread()</code>。到这里就开始不一样了。<code>sockread()</code> 如果发现接收队列 <code>mbufq</code> 为空，就 sleep 直到被唤醒。</p>
<p>而唤醒操作实际上由硬件决定。每当 E1000 收到一个数据包，就会触发一次中断 <code>e1000_intr()</code>，里面会调用 <code>e1000_recv()</code>。这是我们需要实现的，事实上，根据任务手册我们也能大概推断出，该函数需要调用若干次 <code>net_rx</code>，不断拆解头部最后得到数据，发给 <code>sockrecvudp()</code>，它会将数据（实际上是 <code>mbuf</code>）push 进接收队列，并唤醒沉睡中的 <code>sockread()</code>。醒了以后发现数据已经有了，那就美滋滋地读取，最后返回给用户态。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysnet.c</span></div><code class="language-C">int
sockread(struct sock *si, uint64 addr, int n)
{
  ...
  acquire(&amp;si-&gt;lock);
  while (mbufq_empty(&amp;si-&gt;rxq) &amp;&amp; !pr-&gt;killed) { // 等待 sockrecvudp 的唤醒
    sleep(&amp;si-&gt;rxq, &amp;si-&gt;lock);
  }
  ...
  m = mbufq_pophead(&amp;si-&gt;rxq); // 取出 socket 的接收队列队首数据
  ...
  if (copyout(pr-&gt;pagetable, addr, m-&gt;head, len) == -1) {
    mbuffree(m);
    return -1;
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/net.c</span></div><code class="language-C">// called by e1000_recv
void net_rx(struct mbuf *m)
{
  ...
  if (type == ETHTYPE_IP) // type 为以太网首部的类型字段
    net_rx_ip(m);
  else if (type == ETHTYPE_ARP)
    net_rx_arp(m);
  else
    mbuffree(m);
}

static void
net_rx_ip(struct mbuf *m)
{
  ...
  struct ip *iphdr;
  iphdr = mbufpullhdr(m, *iphdr);
  net_rx_udp(m, len, iphdr);
  ...
}

static void
net_rx_udp(struct mbuf *m, uint16 len, struct ip *iphdr)
{
  struct udp *udphdr;
  udphdr = mbufpullhdr(m, *udphdr);
  ...
  sockrecvudp(m, sip, dport, sport); // 分别从首部中提取出，并经过 ntohs 的大小端转换
  ...
}

static void
net_rx_arp(struct mbuf *m)
{
  ...
  net_tx_arp(ARP_OP_REPLY, smac, sip); // 这个要特别注意，收到一个 ARP 包后要马上发回去
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysnet.c</span></div><code class="language-C">void
sockrecvudp(struct mbuf *m, uint32 raddr, uint16 lport, uint16 rport)
{
  ...
found:
  ...
  mbufq_pushtail(&amp;si-&gt;rxq, m);  // 将数据插到 socket 的接收队列末尾
  wakeup(&amp;si-&gt;rxq);             // 并唤醒
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task1-E1000-Transmit">Task1: E1000 Transmit</h2>
<p>OK，接下来我们首先进行一个发送函数的实现。关于 <code>tx_ring[]</code>、<code>tx_mbufs[]</code> 以及其他寄存器就不提了，我们只要知道是一个环形结构即可，且 E1000_TDT 寄存器表明了我们应该从哪个索引进行写入。lab 手册的 hint 其实给的很详细了，这里只说一些我认为比较坑的点：</p>
<ol>
<li class="lvl-3">
<p><code>Otherwise, use mbuffree() to free the last mbuf that was transmitted from that descriptor (if there was one).</code> 这里需要遍历整个 mbuf 链表释放，防止内存泄漏；</p>
</li>
<li class="lvl-3">
<p><code>tx_desc</code> 的 <code>cmd</code> 字段设置的是比特位，因为以太网最大数据包大小为 1518，而 <code>mbuf</code> 的 buffer 大小为 2048，所以一个 <code>mbuf</code> 必定能容纳一个以太网包，需要为其置位 <code>E1000_TXD_CMD_EOP</code>，表示一个包结束了；</p>
</li>
<li class="lvl-3">
<p><code>tx_desc</code> 的 <code>cso</code>、<code>css</code>、<code>special</code> 字段都可以不用设置；</p>
</li>
<li class="lvl-3">
<p>别忘了用<strong>锁</strong>来对并发 transmit 进行互斥处理；</p>
</li>
</ol>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/e1000.c</span></div><code class="language-C">int
e1000_transmit(struct mbuf *m)
{
  acquire(&amp;e1000_lock);
  uint32 tail = regs[E1000_TDT];
  struct tx_desc* txd = &amp;tx_ring[tail];
  struct mbuf* last_mbuf = tx_mbufs[tail];

  if ((txd-&gt;status &amp; E1000_TXD_STAT_DD) == 0) {
    release(&amp;e1000_lock);
    return -1;
  }

  if (last_mbuf) {
    struct mbuf* t;
    while (last_mbuf) {
      t = last_mbuf-&gt;next;
      mbuffree(last_mbuf);
      last_mbuf = t;
    }
  }

  tx_mbufs[tail] = m;
  txd-&gt;addr = (uint64)(m-&gt;head);
  txd-&gt;length = (uint16)(m-&gt;len);
  txd-&gt;cmd = E1000_TXD_CMD_RS | E1000_TXD_CMD_EOP;
  txd-&gt;status = 0;  // not done
  regs[E1000_TDT] = (tail+1) % TX_RING_SIZE;

  release(&amp;e1000_lock);
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task2-E1000-Recv">Task2: E1000 Recv</h2>
<p>接收函数也是按照 hint 来即可。也说下坑点：</p>
<ol>
<li class="lvl-3">
<p>不用加锁！不用加锁！如果加了锁，调用 <code>net_rx</code> 发现是个 ARP 包会马上调用 <code>e1000_transmit()</code>，里面也有加锁，那就会导致连上两次锁又得不到释放，结果不言而喻；</p>
</li>
<li class="lvl-3">
<p>因为一开始会先令 E1000_RDT 增加，所以如果检查 E1000_RDT 发现对应 <code>rx_desc</code> 的 E1000_RXD_STAT_DD 位为 0，需要将 E1000_RDT 回退一格，这样下一次调用时就会跳到正确的位置；</p>
</li>
<li class="lvl-3">
<p>每次读取要把所有满足 E1000_RXD_STAT_DD=1 的读完，而不能一次调用只读一个 <code>mbuf</code>，所以需要一个大的循环；</p>
</li>
</ol>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/e1000.c</span></div><code class="language-C">static void
e1000_recv(void)
{
  uint32 tail;
  struct rx_desc* rxd;
  struct mbuf* m;

  for (;;) {
    regs[E1000_RDT] = (regs[E1000_RDT]+1) % RX_RING_SIZE;
    tail = regs[E1000_RDT];
    rxd = &amp;rx_ring[tail];
    m = rx_mbufs[tail];

    if ((rxd-&gt;status &amp; E1000_RXD_STAT_DD) == 0) {
      regs[E1000_RDT] = (regs[E1000_RDT]-1) % RX_RING_SIZE;
      break;
    }

    m-&gt;len = rxd-&gt;length;
    net_rx(m);

    if ((rx_mbufs[tail] = mbufalloc(0)) == 0)
      panic("e1000_recv");
    rxd-&gt;status = 0;
    rxd-&gt;addr = (uint64)rx_mbufs[tail]-&gt;head;
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test running nettests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">3</span>.1s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   nettest: <span class="token function">ping</span> <span class="token operator">==</span>
  nettest: ping: OK
<span class="token operator">==</span> Test   nettest: single process <span class="token operator">==</span>
  nettest: single process: OK
<span class="token operator">==</span> Test   nettest: multi-process <span class="token operator">==</span>
  nettest: multi-process: OK
<span class="token operator">==</span> Test   nettest: DNS <span class="token operator">==</span>
  nettest: DNS: OK
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">100</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab4 Copy-on-Write Fork for Xv6</title>
    <url>/lab/6-s081lab4/</url>
    <content><![CDATA[<p>课上谈了个 COW 优化策略，这里就要具体实现了。</p>
<span id="more"></span>
<h2 id="关于-COW-Copy-On-Write-写时拷贝">关于 COW(Copy-On-Write, 写时拷贝)</h2>
<h3 id="The-Problem">The Problem</h3>
<blockquote>
<p>The fork() system call in xv6 copies all of the parent process’s user-space memory into the child. If the parent is large, copying can take a long time. Worse, the work is often largely wasted; for example, a fork() followed by exec() in the child will cause the child to discard the copied memory, probably without ever using most of it. On the other hand, if both parent and child use a page, and one or both writes it, a copy is truly needed.</p>
</blockquote>
<p>在 xv6 中，系统调用 <code>fork()</code> 会将父进程页表中所有指向的数据页拷贝到子进程中。有些页不一定用到，用到也不一定写，那就先浅拷贝，等到要写的时候再深拷贝。</p>
<h3 id="The-Solution">The Solution</h3>
<blockquote>
<p>The goal of copy-on-write (COW) fork() is to defer allocating and copying physical memory pages for the child until the copies are actually needed, if ever.</p>
<p>COW fork() creates just a pagetable for the child, with PTEs for user memory pointing to the parent’s physical pages. COW fork() marks all the user PTEs in both parent and child as not writable. When either process tries to write one of these COW pages, the CPU will force a page fault. The kernel page-fault handler detects this case, allocates a page of physical memory for the faulting process, copies the original page into the new page, and modifies the relevant PTE in the faulting process to refer to the new page, this time with the PTE marked writeable. When the page fault handler returns, the user process will be able to write its copy of the page.</p>
<p>COW fork() makes freeing of the physical pages that implement user memory a little trickier. A given physical page may be referred to by multiple processes’ page tables, and should be freed only when the last reference disappears.</p>
</blockquote>
<p>具体要怎么做呢？在原来的版本，<code>fork()</code> 会调用 <code>uvmcopy()</code> 函数，对于父进程内的每一个虚拟地址 <code>va</code>，其对应一个页表项 <code>pte</code> 及其指向的数据页 <code>pa</code>，调用 <code>kalloc()</code> 在内存中分配一个新的数据页 <code>npa</code>，将 <code>pa</code> 的内容完整拷贝到 <code>npa</code> 中，最后将 <code>pte</code> 的 <code>flag</code> 和 <code>npa</code> 组合成一个新的 <code>npte</code>，插入子进程页表中 <code>va</code> 对应的位置。</p>
<p>引入 COW 优化后，就不需要在这里进行 <code>kalloc()</code> 了。我们可以直接拷贝页表项，毕竟虚拟地址和相应的物理地址都是一样的。但注意，要将 <code>PTE_W</code> 位清除，因为这里有多个进程同时指向同一片内存，如果都允许写的话可能会产生冲突，所以这里将写的权限取消，但保留读权限。此外，还要添加一个 <code>PTE_COW</code> 位，用于标识这一页是享受到 COW 优化了的。</p>
<p>那么一旦尝试对这个虚拟地址进行写入操作，通过查页表发现没有对应物理地址的写权限，就会产生异常，进入 <code>usertrap()</code>。在这个函数中，我们就要对这种特定异常进行处理。通过查看 RISC-V 文档可知，出现该异常时，<strong>SCAUSE 寄存器中的值为 15，同时 STVAL 中的值为引起异常的虚拟地址</strong>。一旦遇到该异常，说明我们尝试写入一个 <code>PTE_W=0</code> 的页，在 COW 策略下，我们就需要在这里进行拷贝了，那第一步就是判断该虚拟地址对应的物理页是否「有资格享用 COW」。方法很简单，只需要检查页表项的 <code>PTE_V</code>，<code>PTE_U</code> 和 <code>PTE_COW</code> 位是否均为 1 即可。</p>
<p>如果通过检查，那就分配新的数据页 <code>npa</code>，并将原来的页拷贝到新页中，还有别忘了更新页表项，令其指向新的页。哦哦哦，还得设置一下标志位，毕竟指向新页后整个优化策略就与它无关了，就需要去掉 <code>PTE_COW</code>，并且加上 <code>PTE_W</code>。</p>
<blockquote>
<p>如果这里分配页失败，那就杀掉进程，处理方式为 <code>p-&gt;killed = 1</code>。</p>
</blockquote>
<p>这是在用户态写入的情况。还有一种情况是在内核态向用户空间写入数据，那就是 <code>copyout()</code> 函数。同样的，如果遇到一个虚拟地址对应页表项的 <code>PTE_COW</code> 被置 1，说明这一页要在写入时进行拷贝，那流程跟上面基本是一样的，只不过遇到没有空闲内存而导致分配页失败后直接 <code>return -1</code> 即可。</p>
<p>到这里就够了吗？还不够。因为还有一个关键问题我们没有解决，那就是父子进程中的如果都使用 COW 分配新页并修改页表项后，原来的那个页面将没有任何页表项指向——内存泄漏产生了。本质原因在于现有的机制没法意识到一个页面什么时候该被释放，一个合理的措施是维护所有页面的「<strong>引用计数</strong>」，每当一个页面被一个页表项指向时，调用 <code>pin()</code> 将其计数值加一，同样的，每当一个页表项取消指向时，调用 <code>unpin()</code> 将其计数值减一，而减到 0 后就调用 <code>kfree</code> 进行释放。这样一来就解决了内存泄漏的问题。这样就需要把原本对 <code>kfree</code> 的调用统一替换为 <code>unpin()</code>。</p>
<blockquote>
<p>分配一个页面时，其引用计数自动设为 1。</p>
</blockquote>
<p>引用计数能做的事情很多，比如当某一进程写入 COW 页却发现这一页的引用计数只有 1 时，它会意识到这一页被自己<strong>独占</strong>，那就不需要进行新页的分配了，直接修改页表项的标志位即可。</p>
<p>lab 手册提示我们可以将引用计数实现为一个数组，定义在 <code>kernel/kalloc.c</code> 中。那么数组有多大呢？毕竟我们是通过页号进行索引的，那么数组大小就是可用页数，通过查看 <code>kernel/riscv.h</code> 我们发现了两个宏，<code>KERNBASE</code> 与 <code>PHYSTOP</code>，这两值之差便是整个可用内存空间大小，再除以 <code>PGSIZE</code> 那就是可用页数了。</p>
<p>数组大小确定了，那么索引方式也很快能想到，直接 <code>(pa - KERNBASE) &gt;&gt; 12</code> 即可。虽然前面可能有部分页会被浪费，但胜在简单可靠。</p>
<p>思路捋清了，那代码就很好写了。</p>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout cow
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task-Implement-copy-on-write">Task: Implement copy-on write</h2>
<h3 id="引用计数">引用计数</h3>
<p>首先实现引用计数。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/kalloc.c</span></div><code class="language-C">#define NPAGES (PHYSTOP-KERNBASE)/PGSIZE

static uint8 ref_count[NPAGES];

// arg start_pa must be PGROUNDed
uint64
page_idx(void* start_pa)
{
  uint64 idx = ((uint64)start_pa-KERNBASE) &gt;&gt; 12;
  if (idx &gt;= NPAGES) {
    return -1;
  }
  return idx;
}

// plus the reference count of page at pa
void
pin(void* pa)
{
  void* start_pa = (void*)PGROUNDDOWN((uint64)pa);
  uint64 idx = page_idx(start_pa);
  if (idx == -1) {
    panic("invalid page\n");
  }

  ref_count[idx]++;
}

// minus the reference count of page at pa
// if the count is 0 after unpin, free it
void
unpin(void* pa)
{
  void* start_pa = (void*)PGROUNDDOWN((uint64)pa);
  uint64 idx = page_idx(start_pa);
  if (idx == -1) {
    panic("invalid page\n");
  }

  if (--ref_count[idx] == 0) {
    kfree(start_pa);
  }
}

uint8
getcount(void* pa)
{
  void* start_pa = (void*)PGROUNDDOWN((uint64)pa);
  uint64 idx = page_idx(start_pa);
  if (idx == -1) {
    panic("invalid page\n");
  }
  return ref_count[idx];
}

int
pinned(void* pa)
{
  return getcount(pa) &gt; 0;
}

int
exown(void* pa)
{
  return getcount(pa) == 1;
}

void
kinit()
{
  initlock(&amp;kmem.lock, "kmem");
  memset(ref_count, 0, sizeof(ref_count));   // (!new)
  freerange(end, (void*)PHYSTOP);
}

// Allocate one 4096-byte page of physical memory.
// Returns a pointer that the kernel can use.
// Returns 0 if the memory cannot be allocated.
void *
kalloc(void)
{
  struct run *r;

  acquire(&amp;kmem.lock);
  r = kmem.freelist;
  if(r)
    kmem.freelist = r-&gt;next;
  release(&amp;kmem.lock);

  if(r){
    memset((char*)r, 5, PGSIZE);
    pin((void*)r);   // (!new)
  }
  return (void*)r;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了在其他文件中调用，部分函数需要在 <code>def.h</code> 中添加声明。</p>
<h3 id="uvmcopy">uvmcopy()</h3>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/vm.c</span></div><code class="language-C">int
uvmcopy(pagetable_t old, pagetable_t new, uint64 sz)
{
  pte_t *pte;
  uint64 pa, i;
  uint flags;

  for(i = 0; i &lt; sz; i += PGSIZE){
    if ((pte = walk(old, i, 0)) == 0)
      panic("uvmcopy: pte should exist");
    if ((*pte &amp; PTE_V) == 0)
      panic("uvmcopy: page not present");

    pa = PTE2PA(*pte);
    *pte &amp;= ~PTE_W;   // clear PTE_W
    *pte |= PTE_COW;  // add PTE_COW

    flags = PTE_FLAGS(*pte);
    if (mappages(new, i, PGSIZE, pa, flags) != 0) {
      uvmunmap(new, 0, i / PGSIZE, 0);
      return -1;
    }

    pin((void*)pa); // !!!很重要
  }
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="usertrap">usertrap()</h3>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">void
usertrap(void)
{
  ...
  if(r_scause() == 8){
    ...
  } else if (r_scause() == 15) {
    if(p-&gt;killed)
      exit(-1);

    uint64 start_va = PGROUNDDOWN(r_stval());
    if (start_va &gt;= MAXVA) // walk 前检查一下，避免 panic 导致测试卡住
      exit(-1);

    pte_t* pte = walk(p-&gt;pagetable, start_va, 0);
    if (pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0 || (*pte &amp; PTE_COW) == 0)
      panic("invalid pte");

    uint64 pa = PTE2PA(*pte);
    if (exown((void*)pa)) { // 如果独占，只需修改标志位，无需拷贝，省时省力
      *pte &amp;= ~PTE_COW;
      *pte |= PTE_W;
    } else {
      char* npa = (char*)kalloc();
      if(npa == 0){
        // 如果没有可用内存，杀掉进程
        acquire(&amp;p-&gt;lock);
        p-&gt;killed = 1;
        release(&amp;p-&gt;lock);
      } else {
        memmove(npa, (char*)pa, PGSIZE);

        *pte &amp;= ~PTE_COW;
        *pte |= PTE_W;
        *pte = PTE_FLAGS(*pte) | PA2PTE(npa);

        unpin((void*)pa);
      }
    }
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="copyout">copyout()</h3>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/vm.c</span></div><code class="language-C">int
copyout(pagetable_t pagetable, uint64 dstva, char *src, uint64 len)
{
  pte_t *pte;
  uint64 n, va0, pa0;
  while(len &gt; 0){
    va0 = PGROUNDDOWN(dstva);
    if (va0 &gt;= MAXVA) // walk 前检查一下，避免 panic 导致测试卡住
      return -1;

    pte = walk(pagetable, va0, 0);
    if (pte == 0 || (*pte &amp; PTE_V) == 0 || (*pte &amp; PTE_U) == 0)
      return -1;

    pa0 = PTE2PA(*pte);
    if (*pte &amp; PTE_COW) {
      if (exown((void*)pa0)) {
        *pte &amp;= ~PTE_COW;
        *pte |= PTE_W;
      } else {
        char* npa = (char*)kalloc();
        if(npa){
          memmove(npa, (char*)pa0, PGSIZE);

          *pte &amp;= ~PTE_COW;
          *pte |= PTE_W;
          *pte = PTE_FLAGS(*pte) | PA2PTE(npa);

          unpin((void*)pa0);
        }
        pa0 = (uint64)npa;  // 如果 npa 为 0，则最终会 return -1
                            // 反之，npa 成为新的 pa0，即 dst pa
      }
    }

    if(pa0 == 0)
      return -1;
    ...
  }
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test running cowtest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">6</span>.8s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   simple <span class="token operator">==</span>
  simple: OK
<span class="token operator">==</span> Test   three <span class="token operator">==</span>
  three: OK
<span class="token operator">==</span> Test   <span class="token function">file</span> <span class="token operator">==</span>
  file: OK
<span class="token operator">==</span> Test usertests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">116</span>.5s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   usertests: copyin <span class="token operator">==</span>
  usertests: copyin: OK
<span class="token operator">==</span> Test   usertests: copyout <span class="token operator">==</span>
  usertests: copyout: OK
<span class="token operator">==</span> Test   usertests: all tests <span class="token operator">==</span>
  usertests: all tests: OK
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">110</span>/110<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab7 Lock</title>
    <url>/lab/6-s081lab7/</url>
    <content><![CDATA[<p>这个 lab 就是对原先的并发控制进行优化。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout lock
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task1-Memory-allocator">Task1: Memory allocator</h2>
<p>原来的内存分配模块持有一把大锁，每当要分配内存时都会将大锁锁定，直至分配完成。这样对多核的机器并不是很友好，因为每个 CPU core 都需要在大锁上竞争，造成资源浪费。</p>
<p>一种优化策略是，将空闲的内存划分为 CPU core 数量的区域，每个 core 对应整个空闲链表的一部分，且各自维护相应的锁，不同 core 只需要在自己负责那部分即可。当然有的 core 上运行的进程可能需要多个页，一旦自己那部分空闲内存不够了，就需要从其他 core 的空闲内存中「窃取」一页出来。</p>
<blockquote>
<p>毕竟闲着也是闲着，不如最大化利用。</p>
</blockquote>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/kalloc.c</span></div><code class="language-C">...
// NCPU 个 freelist 与 lock
struct {
  struct spinlock lock;
  struct run *freelist;
} kmems[NCPU];
...
void
kinit()
{
  for (int i = 0; i &lt; NCPU; i++) {
    initlock(&amp;kmems[i].lock, "kmem"); // 初始化所有 kmem
  }
  ...
}

void
kfree(void *pa)
{
  // 将原本的 kmem 改为 kmems[cpu_id] 即可
}

void *
kalloc(void)
{
  ...
  // 从当前 core 开始遍历所有 core 负责的 kmem
  // 直到找到一个有空闲页的 kmem，直接拿来用
  // 最后 kfree 会将该页加到当前 core 的 kmem 里
  for (int i = 0; i &lt; NCPU; i++) {
    acquire(&amp;kmems[cpu_id].lock);
    r = kmems[cpu_id].freelist;
    if (r) {
      kmems[cpu_id].freelist = r-&gt;next;
    }
    release(&amp;kmems[cpu_id].lock);
    if (r) {
      break;
    }
    cpu_id = (cpu_id+1)%NCPU;
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task2-Buffer-cache">Task2: Buffer cache</h2>
<p>这个 task 也是对并发控制进行优化，只不过针对的是磁盘块在内存中的 cache。<code>kernel/bio.c</code> 里有相关实现，结构体 <code>bcache</code> 内部维护了一个双向链表，用于支持 LRU 策略。同样的，每次操作都要对大锁进行竞争。</p>
<p>由于每个 disk block 都有各自的块号 <code>blockno</code>，那么可以划分为不同的 “bucket”，根据 blockno 映射到不同的 bucket，每个 bucket 有一把锁，这样就减少了竞争。</p>
<p>同时，根据 <code>kernel/trap.c</code> 里的 <code>ticks</code> 变量，我们也可以为每个 block 增加一个 <code>timestamp</code> 字段，用于标识最后访问该块的时间戳，这样就不需要双向链表来做 LRU 了，每次 victim 的时候找到 <code>timestamp</code> 最小的 block 即可。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/buf.h</span></div><code class="language-C">// 移除了 prev 和 next 字段，新增 timestamp 字段
struct buf {
  int valid;   // has data been read from disk?
  int disk;    // does disk "own" buf?
  uint dev;
  uint blockno;
  struct sleeplock lock;
  uint refcnt;
  uint timestamp; // (!new)
  uchar data[BSIZE];
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/bio.c</span></div><code class="language-C">#define NBUCKETS 5

struct {
  struct spinlock lock;
  struct buf buf[NBUF]; // 这里相当于做了个 tricky，单纯增加 Cache 容量来降低 miss 概率
} bcache[NBUCKETS];

void
binit(void)
{
  struct buf *b;
  for (int i = 0; i &lt; NBUCKETS; i++) {
    initlock(&amp;bcache[i].lock, "bcache");
    for(b = bcache[i].buf; b &lt; bcache[i].buf+NBUF; b++){
      initsleeplock(&amp;b-&gt;lock, "buffer");
      b-&gt;timestamp = 0;
    }
  }
}

static struct buf*
bget(uint dev, uint blockno)
{
  struct buf *b;
  uint bucketno = blockno % NBUCKETS;
  uint earliest = __INT_MAX__;
  uint idx = -1;

  acquire(&amp;bcache[bucketno].lock);
  for(int i = 0; i &lt; NBUF; i++){
    b = &amp;bcache[bucketno].buf[i];
    if (b-&gt;dev == dev &amp;&amp; b-&gt;blockno == blockno) {
      // 意味着缓存命中
    }

    // 同时也进行 LRU 策略，如果 miss 就可以直接用，不用再次 for 遍历
    if (b-&gt;refcnt == 0 &amp;&amp; b-&gt;timestamp &lt; earliest) {
      earliest = b-&gt;timestamp;
      idx = i;
    }
  }

  if (idx != -1) { // 意味着有 block 被 victim，且就在 buf[idx] 处
    ...
  }

  panic("bget: no buffers");
}

void
brelse(struct buf *b)
{
  ...
  if (--b-&gt;refcnt == 0) {
    b-&gt;timestamp = 0; // 将其置 0，以便 victim
  }
}

void
bpin(struct buf *b) {
  // 根据 b-&gt;blockno 映射到 bucket
}

void
bunpin(struct buf *b) {
  // 根据 b-&gt;blockno 映射到 bucket
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test running kalloctest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">70</span>.1s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   kalloctest: test1 <span class="token operator">==</span>
  kalloctest: test1: OK
<span class="token operator">==</span> Test   kalloctest: test2 <span class="token operator">==</span>
  kalloctest: test2: OK
<span class="token operator">==</span> Test kalloctest: sbrkmuch <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
kalloctest: sbrkmuch: OK <span class="token punctuation">(</span><span class="token number">10</span>.5s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test running bcachetest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">8</span>.7s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   bcachetest: test0 <span class="token operator">==</span>
  bcachetest: test0: OK
<span class="token operator">==</span> Test   bcachetest: test1 <span class="token operator">==</span>
  bcachetest: test1: OK
<span class="token operator">==</span> Test usertests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
usertests: OK <span class="token punctuation">(</span><span class="token number">134</span>.2s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">70</span>/70<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab8 File System</title>
    <url>/lab/6-s081lab8/</url>
    <content><![CDATA[<p>现在开始进入文件系统的阶段。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout fs
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="Task1-Large-files">Task1: Large files</h2>
<p>该任务要求我们为 inode 实现<strong>二级间接索引</strong>。</p>
<p>原本的 inode 含有 11 个直接索引和 1 个一级间接索引，已知一个 disk block 大小为 <code>1024</code>，一个块地址大小为 4B，那一个 block 内部可以容纳 256 条地址，即当前文件系统仅支持最大 <code>(11+256)*BSIZE = 267KB</code> 大小的文件。</p>
<p>这里，我们需要将 1 个直接索引拿来升级为二级间接索引（指向一个包含 256 个一级间接索引的 block）。那么首先要修改 inode 结构体。xv6 中，除了表示磁盘上的 inode <code>struct dinode</code> 外，内存中还包含磁盘 inode 的拷贝 <code>struct inode</code>，这两者分别位于 <code>kernel/fs.h</code> 与 <code>kernel/file.h</code>。同时，还要修改一些宏字段如 <code>MAXFILE</code>，以适配我们「升级」后的文件系统。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/fs.h</span></div><code class="language-C">...
#define NDIRECT 11                                                      // (!new)
#define NINDIRECT (BSIZE / sizeof(uint))
#define NDOUBLYINDIRECT ((BSIZE / sizeof(uint))*(BSIZE / sizeof(uint))) // (!new)
#define MAXFILE (NDIRECT + NINDIRECT + NDOUBLYINDIRECT)                 // (!new)

// On-disk inode structure
struct dinode {
  ...
  uint addrs[NDIRECT+1+1];  // (!new)
};
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/file.h</span></div><code class="language-C">// in-memory copy of an inode
struct inode {
  ...
  uint addrs[NDIRECT+1+1];  // (!new)
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>修改完后，便可以通过 <code>make fs.img</code> 重构 qemu 的文件系统了。</p>
<p>现在，我们就能尝试创建更大的文件了。当然，最开始创建一个文件时，文件系统仅仅是为其分配了一个 inode，还没有分配任何 disk block，只有当对文件进行写入时，才根据写入文件的 offset 检查是否需要为其分配 block。我们查看写文件的 <code>sys_write()</code> 操作，会发现其调用了 <code>filewrite()</code>，然后进一步调用 <code>writei()</code>。<code>writei()</code> 里有个 for 循环，每次取文件中一个 block 的大小进行写入，那么第 i 次写入数据对应的文件偏移量为 <code>i * BSIZE</code>，相当于写入了 inode 对应的逻辑块号为 <code>i</code> 的 disk block。</p>
<p><code>bread()</code> 函数就是根据 block number 找到 block cache 中对应的 block 的，那么 block number 怎么求？我们发现 <code>bread()</code> 的第二个参数是根据函数 <code>bmap()</code> 得来的，而这个 <code>bmap()</code> 就是根据 <code>inode</code> 中的逻辑块号获取物理块号的。进去看了一眼发现，当前 <code>bmap()</code> 仅支持一级间接索引，所以我们要做的就是修改该函数，令其支持二级间接索引。</p>
<p><code>bmap()</code> 的基本思路很简单，首先查直接索引，然后查一级间接索引。如果某一逻辑块号没有对应的索引块，那就为其分配一个索引块。从这也能看出，索引块是按需分配的，即便支持了二级间接索引，也不会因此导致大量的磁盘块分配。</p>
<p>参考一级索引的查找方式，很容易能写出二级的：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/fs.c</span></div><code class="language-C">static uint
bmap(struct inode *ip, uint bn)
{
  uint addr, *a;
  struct buf *bp;

  if(bn &lt; NDIRECT){
    ...
  }
  bn -= NDIRECT;

  if(bn &lt; NINDIRECT){
    // Load indirect block, allocating if necessary.
    ...
  }
  bn -= NINDIRECT;

  // 在二级索引块中，包含了 256 个一级间接索引块号，相当于其 `addr[]` 中的每个下标都覆盖了 256 个物理块
  // 由于这里逻辑块号 bn 已经被映射到 0~256*256-1 的范围，所以
  // bn/NINDIRECT 为二级索引块的下标
  // bn%NINDIRECT 为二级索引块指向的一级索引块的下标
  if (bn &lt; NDOUBLYINDIRECT) {
    // Load doubly-indirect block, allocating if necessary.
    if((addr = ip-&gt;addrs[NDIRECT+1]) == 0)
      ip-&gt;addrs[NDIRECT+1] = addr = balloc(ip-&gt;dev);
    bp = bread(ip-&gt;dev, addr);
    a = (uint*)bp-&gt;data;

    if ((addr = a[bn/NINDIRECT]) == 0) {
      a[bn/NINDIRECT] = addr = balloc(ip-&gt;dev);
      log_write(bp);
    }
    brelse(bp); // 在指向新的 block 前，释放原来的，下同

    bp = bread(ip-&gt;dev, addr);
    a = (uint*)bp-&gt;data;
    bn %= NINDIRECT;

    if((addr = a[bn]) == 0){
      a[bn] = addr = balloc(ip-&gt;dev);
      log_write(bp);
    }
    brelse(bp);
    return addr;
  }
  panic("bmap: out of range");
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，有写操作，自然有相应的清空操作。什么时候要清空呢？我们这里写的都是位于内存的 block cache 中的数据，<code>struct inode</code> 也是位于内存的相对于磁盘的缓存。有 cache 那必然有 victim，当一个 cache-inode 要被 victim 时，会将其所有块的数据写入 disk，然后释放，从而实现内存复用。</p>
<p>inode 里有一个 <code>ref</code> 字段，表明该文件的引用计数。我们对 inode 的操作总是伴随着 <code>ilock()</code> 与 <code>iunlock()</code>，事实上还有一个函数叫 <code>iunlockput()</code>，它将 <code>iunlock()</code> 与 <code>iput()</code> 结合到一起。那么 <code>iput()</code> 是干嘛的？通过阅读函数原型，我们发现它就是将 <code>inode.ref--</code>，如果减到 0，并且 <code>inode.nlink</code> 也为 0，说明内存中不要这个文件了，磁盘里也不再需要该文件，此时就可以通过 <code>itruc()</code> 将 inode 所使用的所有块写入磁盘并释放。</p>
<p>同样的，我们现在支持了二级索引，那必然要对<strong>用到 inode 索引</strong>的所有函数进行修改。<code>itrunc()</code> 即是如此。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/fs.c</span></div><code class="language-C">void
itrunc(struct inode *ip)
{
  ...
  for(i = 0; i &lt; NDIRECT; i++){
    ...
  }

  if(ip-&gt;addrs[NDIRECT]){
    ...
  }

  if (ip-&gt;addrs[NDIRECT+1]) {
    bp = bread(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);
    a = (uint*)bp-&gt;data;
    for (i = 0; i &lt; NINDIRECT; i++) { // 释放二级索引下的所有一级索引
      if (a[i]) {
        struct buf *tmp = bread(ip-&gt;dev, a[i]);
        uint *tmp_addr = (uint*)tmp-&gt;data;
        for (j = 0; j &lt; NINDIRECT; j++) {
          if (tmp_addr[j]) {
            bfree(ip-&gt;dev, tmp_addr[j]);
          }
        }
        brelse(tmp);
        bfree(ip-&gt;dev, a[i]);
      }
    }
    brelse(bp);
    bfree(ip-&gt;dev, ip-&gt;addrs[NDIRECT+1]);
    ip-&gt;addrs[NDIRECT+1] = 0;
  }

  ip-&gt;size = 0;
  iupdate(ip);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Task2-Symbolic-links">Task2: Symbolic links</h2>
<p>该任务要求我们实现创建符号链接的系统调用，也就是创建一个 SYMLINK 类型的 inode，其指向的磁盘块数据内容为某个文件/目录的路径。这里我们不用实现指向目录的符号链接，只需要实现对文件的符号链接即可。</p>
<p>新增系统调用需要修改的文件就不说了。首先要新增两个宏，一个是用于 inode 类型的 <code>T_SYMLINK</code>，在 <code>kernel/stat.h</code> 中修改，另一个是用于 open 操作的选项 <code>O_NOFOLLOW</code>，在 <code>kernel/fcntl.h</code> 中修改，表明如果传入的路径解析出来是一个符号链接，且设置了该 option，就不用进一步打开链接对象，而是直接打开文件。否则，要逐渐深入，直到某路径对应的文件不是符号链接。</p>
<p>接下来，我们已经创建了系统调用 <code>sys_symlink()</code>，那么该函数要做什么呢？只需要新建一个 inode，然后调用 <code>writei()</code> 将目标文件路径写入即可。对就这么简单。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysfile.c</span></div><code class="language-C">// Create the path with content target in block data.
uint64
sys_symlink(void)
{
  char target[MAXPATH], path[MAXPATH];
  struct inode* ip;

  if (argstr(0, target, MAXPATH) &lt; 0 || argstr(1, path, MAXPATH) &lt; 0) {
    return -1;
  }

  begin_op();
  {
    if ((ip = create(path, T_FILE, 0, 0)) == 0) {
      end_op();
      return -1;
    }
    ip-&gt;type = T_SYMLINK;
    writei(ip, 0, (uint64)target, 0, MAXPATH);
    iunlockput(ip); // 调用
  }
  end_op();
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>还要改的是 <code>sys_open()</code> 函数，我们需要新增一条特性，以便打开 SYMLINK inode 时能打开其链接的目标文件。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysfile.c</span></div><code class="language-C">uint64
sys_open(void)
{
  ...
  if(ip-&gt;type == T_DEVICE){
    ...
  } else {
    if (ip-&gt;type == T_SYMLINK &amp;&amp; (omode &amp; O_NOFOLLOW) == 0) { // 意味着要 follow 下去
      char target[MAXPATH];
      uint threshold = 10; // 以防出现 b-&gt;a-&gt;b-&gt;... 的循环链接
      while (threshold) {
        if (readi(ip, 0, (uint64)target, 0, MAXPATH) != MAXPATH) { // 读取 inode 存储的 target 文件路径
          panic("link error");
        }
        iunlockput(ip); // ip 即将赋值为下一个 inode，记得释放

        if ((ip = namei(target)) == 0) { // 根据路径获取相应的 inode
          end_op();
          return -1;
        }

        ilock(ip);
        if (ip-&gt;type != T_SYMLINK) {
          break;
        }
        threshold--;
      }

      if (threshold &lt;= 0) { // 突破阈值，说明可能存在循环，直接报错
        iunlockput(ip);
        end_op();
        return -1;
      }
    }
    f-&gt;type = FD_INODE;
    f-&gt;off = 0;
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test running bigfile <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
running bigfile: OK <span class="token punctuation">(</span><span class="token number">106</span>.6s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test running symlinktest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">0</span>.8s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   symlinktest: symlinks <span class="token operator">==</span>
  symlinktest: symlinks: OK
<span class="token operator">==</span> Test   symlinktest: concurrent symlinks <span class="token operator">==</span>
  symlinktest: concurrent symlinks: OK
<span class="token operator">==</span> Test usertests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
usertests: OK <span class="token punctuation">(</span><span class="token number">197</span>.8s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">100</span>/100<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
<h2 id="附录：软链接与硬链接的区别">附录：软链接与硬链接的区别</h2>
<h3 id="unix-文件系统简述">unix 文件系统简述</h3>
<p>文件数据存放在若干磁盘块中，unix fs 用索引节点(inode)来定位文件所对应的磁盘块号。C 语言实现中，inode 是一个结构体，存放若干文件属性，例如 xv6 完整的 inode 结构体如下所示：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">// On-disk inode structure
struct dinode {
  short type;               // File type
  short major;              // Major device number (T_DEVICE only)
  short minor;              // Minor device number (T_DEVICE only)
  short nlink;              // Number of links to inode in file system
  uint size;                // Size of file (bytes)
  uint addrs[NDIRECT+1+1];  // Data block addresses
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于 unix fs 而言，根目录对应的 inode（unix 的<strong>万物皆文件</strong>理念）位置是全局可知的。一个目录文件对应的磁盘块数据中，有目录下所有子文件的 {文件名 =&gt; inode} 索引，根据此即可通过文件名到 inode cache 中拿到相应的数据。</p>
<blockquote>
<p>所以对于路径 “/foo/bar/hello.c” 上的文件而言，需要经过多次定位 inode 与读盘操作将 hello.c 的数据读入内存。</p>
</blockquote>
<h2 id="软链接">软链接</h2>
<blockquote>
<p>ln -s target symlink</p>
</blockquote>
<p>创建软链接相当于创建一个内容为<strong>目标文件路径</strong>的文件 <code>symlink</code>，为其分配一个全新的 inode 结构体与磁盘空间，通过 <code>symlink</code> 索引文件时只需获取盘块中的路径字符串，再对该路径进行递归访问。</p>
<p>删除 <code>target</code> 后不会影响 <code>symlink</code>，如果在原来的目录下继续新建一个名为 <code>target</code> 的<strong>新</strong>文件，访问 <code>symlink</code> 依然成功。继续强调一遍，软链接即<strong>文件路径</strong>，只不过存放在磁盘中，不需要我们手打。在 Linux 中，利用 PATH 创建用户自定义目录下的软链接十分好用，不必进行 cp/mv 等操作。同时，允许用户<strong>跨文件系统</strong>进行访问。根据「万物即文件」，软链接也可以对<strong>目录</strong>创建。</p>
<p>缺点是相比直接访问 <code>target</code> 多了一次（如果路径上的文件还是软链接类型文件则需要多次）读盘操作，同时存在一些创建文件的系统调用开销。</p>
<h2 id="硬链接">硬链接</h2>
<blockquote>
<p>ln target hardlink</p>
</blockquote>
<p>创建硬链接相当于在目录文件中写入一个与 <code>target</code> 相同 inode 号的字段，访问 <code>hardlink</code> 时会定位到 <code>target</code> 同一 inode，不会额外分配空间。</p>
<p>此时需要在 inode 中维护一个 <code>linkRef</code> 的字段，当多个文件 <code>f1</code>,<code>f2</code>,… 在同一 inode 上创建硬链接时，只要有至少一个文件 <code>fi</code> 存在（即 <code>linkRef&gt;0</code>），对应的 inode 就不会被释放；当且仅当链接到那个 inode 的所有文件被删除后（即 <code>linkRef=0</code>），才释放 inode 与磁盘。</p>
<p>根据上述特性，硬链接比较适合对于处于深层次目录下的 <code>target</code> 进行创建，这样可以省去很多目录的读盘开销。但与软链接不同，<code>hardlink</code> 与 <code>target</code> 只能在同一文件系统下，且不允许对目录创建硬链接。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>6.s081 Lab9 Mmap</title>
    <url>/lab/6-s081lab9/</url>
    <content><![CDATA[<p>最后一个，也是最有挑战性的一项 coding 任务，是所有前置 lab 的知识综合。</p>
<span id="more"></span>
<h2 id="Preparation">Preparation</h2>
<p>切换到对应分支</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">git</span> fetch
$ <span class="token function">git</span> checkout mmap
$ <span class="token function">make</span> clean<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>我们需要实现的 <code>mmap()</code> 与 <code>munmap()</code> 这两个是系统调用，那就要修改若干文件，这在之前的 lab 中已经操作过很多次了，跳过不聊。</p>
<h2 id="从-mmap-开始">从 mmap 开始</h2>
<blockquote>
<p>void* mmap(void* addr, size_t length, int prot, int flags, int fd, off_t offset);</p>
</blockquote>
<p>其作用是将某一文件 <code>fd</code> 从偏移量 <code>offset</code> 开始 <code>length</code> 个字节的长度映射到内存中。操作系统不仅要为其分配物理内存空间 <code>pa</code>，还需要在进程的虚拟地址空间为其分配一块虚拟内存 <code>va</code>，这样才能通过页表机制进行内存的访问。其中 <code>addr</code> 就是用户指定的虚拟地址。如果 <code>addr</code> 为 0，则由操作系统进行目标虚拟地址的挑选。</p>
<p><code>prot</code> 指定了映射内存区域 <code>pa</code> 的访问权限，<code>flags</code> 指定了映射内存是否应当在 unmap 时将所有修改写回文件。这两者对应的标志位都定义在 <code>kernel/fcntl.h</code> 中。</p>
<blockquote>
<p>本 lab 中，入参 <code>addr</code> 可以假设恒为 0。</p>
</blockquote>
<h3 id="如何映射？">如何映射？</h3>
<p><strong>假设</strong>，对于文件 <code>f</code>，我们选择从 <code>offset</code> 处开始 2 个 PGSIZE 大小的内容进行映射，操作系统会为我们分配 2 个 PGSIZE 大小的虚拟空间，起始地址为 <code>va</code>，长度 <code>length = 2*PGSIZE</code>，并记录下对应文件的偏移量 <code>offset</code>。操作系统还会在合适的时间分配内存，但要注意的是，虽然虚拟地址空间是连续的，但是分配的物理内存并不一定连续，这两页可能会分别映射到两个离散的地址 <code>pa1</code> 和 <code>pa2</code>。其中 <code>pa1</code> 中的内容为 <code>f</code> 中 <code>offset</code> 开始的一个 PGSIZE 的数据，而 <code>pa2</code> 中的内容为 <code>f</code> 中 <code>offset+PGSIZE</code> 开始的一个 PGSIZE 的数据。</p>
<table>
<thead>
<tr>
<th style="text-align:center">文件</th>
<th style="text-align:center">虚拟地址</th>
<th style="text-align:center">物理地址</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">offset</td>
<td style="text-align:center">va</td>
<td style="text-align:center">pa1</td>
</tr>
<tr>
<td style="text-align:center">offset+PGSIZE</td>
<td style="text-align:center">va+PGSIZE</td>
<td style="text-align:center">pa2</td>
</tr>
</tbody>
</table>
<h3 id="实现-VMA">实现 VMA</h3>
<p>根据手册，第一次调用 <code>mmap()</code> 时，我们不必为其分配物理内存，而是仅仅在虚拟空间划出一块区域并返回相应的 <code>va</code>，等到通过 <code>va</code> 访问内存时，发现页表中没有相应 pte，这个时候再去分配物理内存。</p>
<blockquote>
<p>这就是和 <strong>lab COW</strong> 一样利用了 page fault，防止映射大文件时一次 alloc 所有空间导致物理内存不够用的情况。</p>
</blockquote>
<p>那么第一步我们就要解决「在虚拟空间划出一块区域」这个问题了。然而，内核中并没有虚拟地址空间的分配器，但是对我们而言，虚拟地址之所以「虚拟」，是因为我们只需要记住一定的数据，最后 <code>usertrap()</code> 里根据这些数据，在页表中建立页表项并且映射到物理地址即可。所以，进程结构体中可以增加这样一个字段，用于分配并追踪某个虚拟地址的使用情况。</p>
<p>这个字段除了标明某一对映射的虚拟地址、长度，还要有偏移量以及标志位等信息，以及对应的文件信息，那么就有：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">struct vma {
  int valid;      // 该字段是否有效

  uint64 va;      // 虚拟起始地址
  uint64 length;  // 长度，可以不是 PGSIZE 的整数倍
  int prot;       // 权限标志位
  int flags;      // 脏数据处理标志位
  int fd;         // 文件描述符
  struct file* f; // 文件
  int offset;     // 相对于文件的偏移量
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>valid</code> 为 1，那么就表明从 <code>va</code> 开始 <code>length</code> 个 bytes 的这段虚拟空间已经被使用了，下次要分配时也应当避开这段空间。一个进程很可能调用多次 <code>mmap()</code> 进行多个文件的映射，那么就不能只存一条记录，而是实现为数组的形式。手册中提示我们 16 是个合适的大小。</p>
<p>现在还有一个问题，该怎样为 <code>va</code> 赋值？回想之前写 lab Page Table 的时候，我们实现了一个功能，是通过固定的虚拟地址加快 <code>getpid()</code>。当时分配的虚拟地址是位于虚拟空间最末端，TRAMPOLINE 和 TRAPFRAME 之前，这是因为虚拟空间非常大，完全可以把后面那点用不到的空间利用起来。</p>
<p>根据这一经验，我们完全可以在进程中建立一个字段 <code>max_VMA</code>，它会在新建进程时初始化为 <code>MAXVA-2*PGSIZE</code>，每次分配时往低地址增长：当调用 <code>mmap()</code> 时，<code>max_VMA</code> 会减去待映射的长度 <code>length</code>，然后找到一个 <code>valid=0</code> 的 vma，进行 <code>vma.va = max_VMA</code> 的赋值。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.h</span></div><code class="language-C">struct proc {
  ...
#define NVMA 16
  struct vma vma[NVMA]; // mmap record
  uint64 max_VMA;         // trampoline and trapframe
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>到此，虚拟内存的分配记录就完成了。</p>
<h3 id="sys-mmap">sys_mmap</h3>
<p>读取参数，找到可用 vma 并设置数据即可。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysfile.c</span></div><code class="language-C">uint64
sys_mmap(void)
{
  uint64 addr;
  int length;
  int prot;
  int flags;
  int fd;
  struct file *f;
  int offset;
  if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0 || argint(2, &amp;prot) &lt; 0 ||
      argint(3, &amp;flags) &lt; 0 || argfd(4, &amp;fd, &amp;f) &lt; 0 || argint(5, &amp;offset) &lt; 0) {
    return -1;
  }

  // 权限不匹配
  if (!f-&gt;readable &amp;&amp; (prot &amp; PROT_READ)) {
    return -1;
  }
  if (!f-&gt;writable &amp;&amp; (prot &amp; PROT_WRITE) &amp;&amp; (flags &amp; MAP_PRIVATE) == 0) { // 如果文件不可写，但是允许对 MAP_PRIVATE 模式映射的内存进行写操作，反之不行
    return -1;
  }

  uint64 va = -1;
  struct proc *p = myproc();
  struct vma *vma;
  for (int i = 0; i &lt; NVMA; i++) {
    if (!p-&gt;vma[i].valid) {
      vma = &amp;p-&gt;vma[i];
      break;
    }
  }

  vma-&gt;valid = 1;

  if (addr == 0) {
    p-&gt;max_VMA -= PGROUNDUP(length);
    vma-&gt;va = va = p-&gt;max_VMA;
  }
  // else { // 现有测试不会跳到这一个分支
  //   vma-&gt;va = va = addr;
  // }

  vma-&gt;length = length;
  vma-&gt;prot = prot;
  vma-&gt;flags = flags;
  vma-&gt;fd = fd;
  vma-&gt;f = filedup(f);  // 映射会增加文件引用计数
  vma-&gt;offset = offset;
  return va;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="page-fault">page fault</h3>
<p>当出现读/写的 page fault 时，就需要检查是否是在 mmap 内存上引起的。如果是，那就进行物理内存的分配，页表项的建立，以及文件数据的拷贝。注意需要逐页进行物理内存分配。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/trap.c</span></div><code class="language-C">void
usertrap(void)
{
  ...
  if (r_scause() == 13 || r_scause() == 15) {
    // page fault occured by reading or writing a mmap virtual address
    // that hasn't been allocated any physical page
    if(p-&gt;killed)
      exit(-1);

    uint64 va = PGROUNDDOWN(r_stval());
    if (va &gt;= MAXVA)
      exit(-1);

    // 找到相应的字段
    struct vma *vma = 0;
    for (int i = 0; i &lt; NVMA; i++) {
      if (p-&gt;vma[i].valid &amp;&amp; p-&gt;vma[i].va &lt;= va &amp;&amp; p-&gt;vma[i].va + PGROUNDUP(p-&gt;vma[i].length) &gt; va) {
        vma = &amp;p-&gt;vma[i];
        break;
      }
    }

    // 如果没有找到，说明出错的虚拟地址没有进行映射，直接退出
    if (!vma) {
      exit(-1);
    }

    // 完善页表项的标志位
    int flags = PTE_U;
    if (vma-&gt;prot &amp; PROT_READ) {
      flags |= PTE_R;
    }
    if (vma-&gt;prot &amp; PROT_WRITE) {
      flags |= PTE_W;
    }
    if (vma-&gt;prot &amp; PROT_EXEC) {
      flags |= PTE_X;
    }

    uint64 pa;
    uint64 following = vma-&gt;va - va + PGROUNDUP(vma-&gt;length);
    // 逐页进行映射+拷贝操作
    ilock(vma-&gt;f-&gt;ip);
    for (uint64 off = 0; off &lt; following; off += PGSIZE) {
      // 如果当前地址已有映射，跳过
      if ((pa = walkaddr(p-&gt;pagetable, va+off)) != 0) {
        continue;
      }
      // 无可用内存，报错
      if ((pa = (uint64)kalloc()) == 0) {
        panic("no free memory");
      }

      // 清空数据，并建立映射，再进行拷贝
      memset((void*)pa, 0, PGSIZE);
      if (mappages(p-&gt;pagetable, va+off, PGSIZE, pa, flags) != 0) {
        panic("cannot map");
      }
      if (readi(vma-&gt;f-&gt;ip, 0, pa, vma-&gt;offset+off, PGSIZE) == -1) {
        panic("read file failed");
      }
    }
    iunlock(vma-&gt;f-&gt;ip);
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="进行-munmap">进行 munmap</h2>
<blockquote>
<p>int munmap(void *addr, int length)</p>
</blockquote>
<p><code>munmap()</code> 是对指定地址 <code>addr</code> 上长度为 <code>length</code> 的地址解除映射，即释放对应内存，删除页表项，并且还要修改相应的 vma 字段。</p>
<p>比如对之前表格中进行 <code>munmap(va+PGSIZE, PGSIZE)</code>，就会导致文件映射长度减少，那么 <code>vma</code> 的 <code>length</code> 字段就需要改为 <code>PGSIZE</code>（原来是 2*PGSIZE）。</p>
<p>而如果进行 <code>munmap(va, PGSIZE)</code>，那么还会额外导致 <code>vma</code> 的 <code>va</code> 字段改为 <code>va+PGSIZE</code>，并且偏移量 <code>offset</code> 也会增加 <code>PGSIZE</code>。</p>
<p>当然，调用 <code>munmap(va, 2*PGSIZE)</code> 会使 <code>vma</code> 的 <code>length</code> 和 <code>offset</code> 直接归零，此时意味着该文件的映射区域被完全解除，应降低该文件的引用计数，并且重置相应 <code>vma</code> 的所有字段（即归零）。</p>
<blockquote>
<p>这很合理，毕竟解除了某一区域的映射，那么 vma 中文件的映射长度与偏移量肯定也会发生变化，不然就会出现不一致的问题。下次对已解除区域重新 <code>mmap()</code> 时，经查 vma 数组发现已经有映射了，这显然与现实矛盾。</p>
</blockquote>
<h3 id="sys-munmap">sys_munmap</h3>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/sysfile.c</span></div><code class="language-C">uint64
sys_munmap(void)
{
  uint64 addr;
  int length;

  if (argaddr(0, &amp;addr) &lt; 0 || argint(1, &amp;length) &lt; 0) {
    return -1;
  }

  struct proc *p = myproc();
  struct vma *vma = 0;
  for (int i = 0; i &lt; NVMA; i++) {
    if (p-&gt;vma[i].valid &amp;&amp; p-&gt;vma[i].va &lt;= addr &amp;&amp; p-&gt;vma[i].va + PGROUNDUP(p-&gt;vma[i].length) &gt; addr) {
      vma = &amp;p-&gt;vma[i];
      break;
    }
  }

  if (vma) {
    vmaunmap(p, vma, addr, length);
    return 0;
  }

  return -1;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>vmaunmap()</code> 就是做了所需要的全部工作——修改 page table、释放内存、修改 vma。</p>
<h3 id="还不够">还不够</h3>
<p>进程结束的时候，可能用户会忘记调用 <code>munmap()</code>，而进程只会释放 TRAMPOLINE 和 TRAPFRAME 以及低虚拟地址处的内存，对于文件映射内存区域，还需要我们额外加入代码进行处理。手册提示我们加在 <code>exit()</code> 函数里，我想是因为所有进程正常退出时都会调用该函数，并且我尝试在 <code>freeproc()</code> 中进行内存释放和数据写回，发现会在 <code>bcache</code> 上产生死锁的问题，但并未深究。</p>
<p>以及还要在 <code>allocproc()</code> 与 <code>freeproc()</code> 里增加对 <code>vma[]</code> 与 <code>max_VMA</code> 的初始化与重置。</p>
<p>哦对，调用 <code>fork()</code> 创建子进程时，只需要拷贝 <code>vma[]</code> 与 <code>max_VMA</code> 即可，而不需要拷贝物理内存，这也是利用了 page fault 的 lazy allocation 策略——用到再分配。</p>
<p>当然，还要增加 <code>vma[]</code> 中记录的文件的引用计数。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>kernel/proc.c</span></div><code class="language-C">static struct proc*
allocproc(void)
{
  ...
found:
  ...
  memset(&amp;p-&gt;vma, 0, sizeof(p-&gt;vma));
  p-&gt;max_VMA = PGROUNDUP(MAXVA) - PGSIZE*2;
  ...
}

static void
freeproc(struct proc *p)
{
  ...
  memset(&amp;p-&gt;vma, 0, sizeof(p-&gt;vma));
  p-&gt;max_VMA = 0;
}

void
exit(int status)
{
  ...
  for (int i = 0; i &lt; NVMA; i++) {
    struct vma* vma = &amp;p-&gt;vma[i];
    if (vma-&gt;valid) {
      vmaunmap(p, vma, vma-&gt;va, vma-&gt;length);
    }
  }
  p-&gt;max_VMA = 0;
  ...
}

int
fork(void)
{
  ...
  for (int i = 0; i &lt; NVMA; i++) {
    np-&gt;vma[i] = p-&gt;vma[i];
    if (np-&gt;vma[i].f) {
      np-&gt;vma[i].f-&gt;ref++;
    }
    np-&gt;max_VMA = p-&gt;max_VMA;
  }
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="测试结果">测试结果</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">make</span> grade
<span class="token punctuation">..</span>.
<span class="token operator">==</span> Test running mmaptest <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
<span class="token punctuation">(</span><span class="token number">3</span>.9s<span class="token punctuation">)</span>
<span class="token operator">==</span> Test   mmaptest: mmap f <span class="token operator">==</span>
  mmaptest: mmap f: OK
<span class="token operator">==</span> Test   mmaptest: mmap private <span class="token operator">==</span>
  mmaptest: mmap private: OK
<span class="token operator">==</span> Test   mmaptest: mmap read-only <span class="token operator">==</span>
  mmaptest: mmap read-only: OK
<span class="token operator">==</span> Test   mmaptest: mmap read/write <span class="token operator">==</span>
  mmaptest: mmap read/write: OK
<span class="token operator">==</span> Test   mmaptest: mmap dirty <span class="token operator">==</span>
  mmaptest: mmap dirty: OK
<span class="token operator">==</span> Test   mmaptest: not-mapped unmap <span class="token operator">==</span>
  mmaptest: not-mapped unmap: OK
<span class="token operator">==</span> Test   mmaptest: two files <span class="token operator">==</span>
  mmaptest: two files: OK
<span class="token operator">==</span> Test   mmaptest: fork_test <span class="token operator">==</span>
  mmaptest: fork_test: OK
<span class="token operator">==</span> Test usertests <span class="token operator">==</span>
$ <span class="token function">make</span> qemu-gdb
usertests: OK <span class="token punctuation">(</span><span class="token number">129</span>.9s<span class="token punctuation">)</span>
    <span class="token punctuation">(</span>Old xv6.out.usertests failure log removed<span class="token punctuation">)</span>
<span class="token operator">==</span> Test <span class="token function">time</span> <span class="token operator">==</span>
time: OK
Score: <span class="token number">140</span>/140<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="最后的工作">最后的工作</h2>
<ol>
<li class="lvl-3">
<p><code>git commit -am ""</code> 将所有修改提交到本地;</p>
</li>
<li class="lvl-3">
<p>执行 <code>make handin</code>。由于 lab0 保存了 APIKey，故直接成功提交；</p>
</li>
</ol>
<p>可选的挑战再说吧，没有什么想做的欲望。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 别名(Alias)</title>
    <url>/c/c-alias/</url>
    <content><![CDATA[<p>虽然使用 <code>auto</code> 可以大大简化代码，但对于一些使用 <code>dynamic_cast</code> 的结果不能用 <code>auto</code> 作为占位符。将冗长的变量类型简化仍然是很头疼的一个问题，幸好 C++11 提供了用关键字 <strong><code>using</code></strong> 给类型起<strong>别名</strong>的特性，既能有效简化代码，又不影响可读性。</p>
<span id="more"></span>
<h2 id="define-与-typedef">#define 与 typedef</h2>
<p>C 中就已经存在使用 <code>#define</code> / <code>typedef</code> 来给类型取别名的用法，但为什么还要多此一举用 <code>using</code>？它们的区别在哪？</p>
<p><code>#define</code> 是宏定义指令，其在预处理阶段直接将源码文本进行替换，不进行类型检查。</p>
<blockquote>
<p>也就是说，如果 <code>#define</code> 为一个不存在的类型取了别名，写代码的时候 IDE 并不会给你飘红线，但编译时就会报一堆错误。</p>
</blockquote>
<p>而对于 <code>typedef</code>，其在编译时期执行，故可以进行类型检查，但它不能直接进行模板替换，只能采用<strong>外面套一个结构体</strong>的方式。也就是说，如果定义了这样一个类模板：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果试图用 <code>typedef</code> 取<strong>模板别名</strong>，则必须用上面那种写法，下面那种写法会报错：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// OK</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">Alias</span> <span class="token punctuation">{</span>
  <span class="token keyword">typedef</span> A<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> a_t<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// ERROR</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">typedef</span> A<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> a_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样起别名的方式又增加了冗余的结构体名，降低了可读性与 code 效率。</p>
<p>不仅如此，<code>typedef</code> 在定义<strong>函数指针</strong>时也存在降低可读性的情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">void</span> <span class="token punctuation">(</span><span class="token operator">*</span>func<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// func 为函数指针 void(*)(int, int) 的别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>在网上找到很多说 <code>typedef</code> / <code>#define</code> 无法起模板别名的文章，但实际操作了一遍，发现或许是编译器更新了，一些以前认为无法实现的代码如今都能编译通过。所以还是绝知此事要躬行。</p>
</blockquote>
<h2 id="using">using</h2>
<p><code>using</code> 不仅可以用于导入命名空间或类成员，还可以用于起别名。事实上，<code>using</code> 能够实现的功能也已经完全将 <code>typedef</code> 能做的包含在内，完全可以舍弃功能单一并且代码反人类直觉的 <code>typedef</code>，改用可读性更高的 <code>using</code>。</p>
<blockquote>
<p>委员会既然推出了这一新特性，照着用就完事了~</p>
</blockquote>
<p>关于 <code>using</code> 的用法，简单来说就是这样的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> new_alias <span class="token operator">=</span> old_typename<span class="token punctuation">;</span>

<span class="token comment">// or</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">using</span> new_alias <span class="token operator">=</span> old_typename<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果需要使用 <code>using</code> 为函数指针取别名，则可以直接用类似赋值的方式，即</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> func <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>一目了然，符合直觉。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 类型推导(Auto &amp; Decltype)</title>
    <url>/c/c-autodecltype/</url>
    <content><![CDATA[<p>C++11引入了 <strong><code>auto</code></strong> 和 <strong><code>decltype</code></strong> 这两个关键字，从而可以在编译期就推导出变量或者表达式的类型，方便开发者编码也简化了代码。</p>
<span id="more"></span>
<h2 id="auto">auto</h2>
<p>关键字 <code>auto</code> 的作用便是自动推导变量/函数(C<ins>14起)/模板(C</ins>20起)的类型，例如这样推导是可以的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> foobar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>           <span class="token comment">// OK! 此时 auto 被编译器推导为 int</span>
<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">*</span>bar <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span> <span class="token comment">// OK! foo, bar 分别为 int 与 int*，此时 auto 被推导为 int（若将 * 删去则报错）</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>但不能这样推导：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> foobar<span class="token punctuation">;</span>               <span class="token comment">// ERROR! 必须初始化，否则编译器无法推导。毕竟 auto 只是一个占位符，不能真正代替数据类型进行声明</span>
<span class="token keyword">auto</span> foo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> bar <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>   <span class="token comment">// ERROR! foo, bar 分别为 int 和 double 类型，auto 会产生二义性，非良构</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h3 id="推导规则">推导规则</h3>
<p>除了上面讲的外，关于 <code>auto</code> 还有以下几条规则：</p>
<ol>
<li class="lvl-3">
<p>不允许在一个声明中混合 <code>auto</code> 的变量和函数，如 <code>auto f() -&gt; int, i = 0;</code> 是错误的；</p>
</li>
<li class="lvl-3">
<p>不允许用于<strong>函数形参</strong>的类型推导，如 <code>void func(auto i);</code> 是错误的；</p>
</li>
<li class="lvl-3">
<p>在有 <strong>cv 限定符</strong>的类型推导中，若不声明为引用，<code>auto</code> 会忽略等号右边的 cv 限定；反之则保留。例如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">auto</span> con_i <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">// con_i 为 const int, auto 推导为 int</span>

<span class="token comment">// no reference</span>
<span class="token punctuation">{</span>
  <span class="token keyword">auto</span> auto_i <span class="token operator">=</span> i<span class="token punctuation">;</span>             <span class="token comment">// auto_i 为 const int, auto 推导为 int</span>
  <span class="token keyword">auto</span> auto_con_i <span class="token operator">=</span> con_i<span class="token punctuation">;</span>     <span class="token comment">// auto_con_i 为 const int, auto 推导为 int</span>
<span class="token punctuation">}</span>

<span class="token comment">// reference</span>
<span class="token punctuation">{</span>
  <span class="token keyword">auto</span> <span class="token operator">&amp;</span>autoref_i <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token comment">// autoref_i 为 int&amp;, auto 推导为 int&amp;</span>
  <span class="token keyword">auto</span> <span class="token operator">&amp;</span>autoref_con_i <span class="token operator">=</span> con_i<span class="token punctuation">;</span> <span class="token comment">// autoref_con_i 为 const int&amp;, auto 推导为 const int&amp;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，cv 限定符指关键字 <code>const</code> 和 <code>volatile</code>。</p>
</li>
<li class="lvl-3">
<p>不允许用作类的<strong>非静态成员变量</strong>；</p>
</li>
<li class="lvl-3">
<p>不允许用于推导<strong>数组</strong>类型，如 <code>auto arr[3] = {1, 2, 3};</code> 是不允许的；</p>
</li>
<li class="lvl-3">
<p>不允许用作<strong>模板参数</strong>，如 <code>std::vector&lt;auto&gt; f{1, 2, 3}; </code> 是不允许的，编译器会报 <code>'auto' not allowed in template argument</code> 错误；</p>
</li>
</ol>
<h3 id="应用场景">应用场景</h3>
<p>将变量声明为迭代器类型是一件非常痛苦的事，尤其是 <code>std::unordered_map&lt;Typename1, Typename2&gt;::iterator it = map.begin();</code> 这样的语句，对本人这样的懒惰程序员而言简直是灾祸🤦‍♂️……</p>
<p>在有了 <code>auto</code> 后，就可以把上面的语句改写为 <code>auto it = map.begin()</code>，懒癌福音🥰</p>
<p>一般地，我个人认为，使用 <code>auto</code>的前提是不能影响代码可读性，对于一些不重要的中间变量，使用 <code>auto</code> 不会破坏可读性，还能大大提高 code 效率，但对于一些关键的变量，如函数返回值，或是利用到类多态特性的地方，则不建议用 <code>auto</code>。</p>
<h2 id="decltype">decltype</h2>
<p>尽管都是在编译器进行类型推导，但与 <code>auto</code> 不同，<code>decltype</code> 根据已声明的变量或表达式推导其类型，无需初始化，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span> bar<span class="token punctuation">;</span> <span class="token comment">// 由于 foo 为 int，则 decltype(foo) 被推导为 int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>上面的 <code>foo</code> 可以为任意有类型的表达式，但不能是 <code>void</code> 类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> p<span class="token punctuation">;</span>   <span class="token comment">// OK! p 为 void(void) 的函数类型，注意和函数指针类型 void(*p)(void) 不同</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> q<span class="token punctuation">;</span> <span class="token comment">// ERROR!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="推导规则-2">推导规则</h3>
<p>除了上面讲的外，关于 <code>decltype</code> 还有以下几条规则：</p>
<ol>
<li class="lvl-3">
<p>若推导对象为不被括号包裹的变量表达式或函数调用，则推导结果为该表达式声明时的类型或函数的返回值类型。例如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> <span class="token operator">&amp;</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">double</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> Foo <span class="token operator">*</span>foo<span class="token punctuation">;</span>

<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> di <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token comment">// 推导结果为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> dj <span class="token operator">=</span> j<span class="token punctuation">;</span>         <span class="token comment">// 推导结果为 const int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span> k<span class="token punctuation">;</span>            <span class="token comment">// 推导结果为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f<span class="token punctuation">;</span>         <span class="token comment">// 推导结果为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>foo<span class="token operator">-&gt;</span>bar<span class="token punctuation">)</span> foo_bar<span class="token punctuation">;</span> <span class="token comment">// 推导结果为 double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>不难发现，<code>decltype</code>会保留表达式的引用和 cv 限定符。</p>
</blockquote>
<p>反之，如果表达式类别为左值，则返回 <code>T&amp;</code>；如果为右值，则返回 <code>T</code>，其中 <code>T</code> 为表达式类型。例如将上面的代码改为下面这样：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> di <span class="token operator">=</span> i<span class="token punctuation">;</span>                    <span class="token comment">// 左值，推导结果为 int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> dj <span class="token operator">=</span> j<span class="token punctuation">;</span>                    <span class="token comment">// 左值。推导结果为 const int&amp;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>i<span class="token operator">+</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> k<span class="token punctuation">;</span>                       <span class="token comment">// 右值，推导结果为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> f<span class="token punctuation">;</span>                    <span class="token comment">// 右值，推导结果为 int</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token punctuation">(</span>foo<span class="token operator">-&gt;</span>bar<span class="token punctuation">)</span><span class="token punctuation">)</span> foo_bar <span class="token operator">=</span> foo<span class="token operator">-&gt;</span>bar<span class="token punctuation">;</span> <span class="token comment">// 左值，推导结果为 const double&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>若推导对象为函数名，则不允许出现有多个重载的函数，否则会产生二义性，例如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> f1<span class="token punctuation">;</span> <span class="token comment">// OK! func 仅有一个重载</span>

<span class="token keyword">double</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">double</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">decltype</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> f2<span class="token punctuation">;</span> <span class="token comment">// ERROR! func 有两个重载</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="应用场景-2">应用场景</h3>
<p>当类模板中需要根据传入的模板参数类中的成员变量来进一步确定类型的变量时，则用 <code>decltype</code> 是个很好的选择。常见于推导函数返回值类型的情况，例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token operator">?</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于 T 和 U 不确定，故返回值类型无法判断。一个好的想法是试图用 <code>decltype(t + u)</code> 来代替 “?” 的位置，但这样会因为 <code>t, u</code> 未定义而报错。但如果与<strong>尾随返回类型</strong>相配合，则完美解决该问题：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token function">func</span><span class="token punctuation">(</span>T t<span class="token punctuation">,</span> U u<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span>t <span class="token operator">+</span> u<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> t <span class="token operator">+</span> u<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>尾随返回类型</strong>也是 C++11 新特性之一，就是用在这种需要根据函数形参类型判断返回值类型的场景中。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 类型转换(Type&amp;Cast)</title>
    <url>/c/c-cast/</url>
    <content><![CDATA[<p>当表达式期望为 <code>T</code> 类型，而我们只能产生 <code>S</code> 类型的表达式时，就需要利用<strong>类型转换</strong>功能来满足需求。</p>
<span id="more"></span>
<p>传统的转换总结来说分为<strong>隐式</strong>与<strong>显式</strong>两种。</p>
<h2 id="隐式转换">隐式转换</h2>
<p>凡是在语境中使用了某种表达式类型 <code>T1</code>，但语境不接受该类型，而接受另一类型 <code>T2</code> 的时候，会进行<strong>隐式转换</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>隐式转换</span></div><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">long</span> <span class="token keyword">long</span> b <span class="token operator">=</span> a <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// int -&gt; long long</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment">// int -&gt; bool</span>
  <span class="token keyword">char</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>        <span class="token comment">// int -&gt; char</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> d <span class="token operator">=</span> a<span class="token punctuation">;</span>     <span class="token comment">// int -&gt; const int</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>事实上，C++ 的任何的<strong>隐式转换</strong>都是使用 <code>static_cast</code> 来实现，所以讲 <code>static_cast</code> 的时候已经提了一部分内容。</p>
<blockquote>
<p>这里有个比较有有意思的例子：<strong>生成了几个 string？</strong></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>string s <span class="token operator">=</span> <span class="token string">"hi"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>首先，<code>"hi"</code> 会被编译器认为是 <code>const char*</code> 型字面量。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p>在 C++11 之前，会首先调用 <code>std::string::string(const char *)</code> 的初始化构造函数，进行隐式转换生成一个临时变量，再调用拷贝构造函数生成 <code>s</code>；</p>
</li>
<li class="lvl-2">
<p>引入移动语义的 C++11 之后，依然会隐式转换生成临时变量，但此时由于该变量为右值，于是调用了移动构造函数将临时变量保有的资源 <code>"hi"</code> 移至 <code>s</code> 中；</p>
</li>
<li class="lvl-2">
<p>而到了 C++17，引入了一个叫<a href="https://zh.cppreference.com/w/cpp/language/copy_elision"><strong>复制消除</strong></a>的规则，要求在满足一定的条件下避免对象的复制，于是这里的临时变量不会生成，直接调用 <code>std::string::string(const char *)</code> 构造对象。这可比移动构造高效多了；</p>
</li>
</ul>
<p>综上所述，在不同编译器标准下，答案分别为 2 2 1。</p>
</blockquote>
<h2 id="显式转换">显式转换</h2>
<p>显式转换就是在表达式之前加上想要转换的目标类型。</p>
<h3 id="Cast-in-C">Cast in C</h3>
<p>C 中的类型转换语法非常简单粗暴，直接在表达式前加上 <code>(Target_Type)</code> 即可，如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>显式转换</span></div><code class="language-cpp"><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>pi<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> p<span class="token punctuation">;</span> <span class="token comment">// output: 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>但这种粗暴的强转会带来许多难以察觉的安全性问题。于是，C++ 提供了许多应用场景更广泛的转换算子，用于删除 C 语言转换中的一些多义性和危险继承。</p>
<h3 id="Cast-in-C-2">Cast in C++</h3>
<h4 id="static-cast">static_cast</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>new_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>该算子实现的效果与 C 中的强转差不多，但由于<strong>没有</strong>在运行时进行类型检查来确保安全性，故跟 <strong>Cast in C</strong> 一样存在隐患，用于<strong>非多态对象</strong>的转换。</p>
<blockquote>
<p>所谓<strong>多态对象</strong>，就是声明或继承了至少一个虚函数的<strong>类类型</strong>的对象。每个多态对象中，实现都会储存额外的信息，它被用于进行虚函数的调用，<strong>RTTI</strong> 功能特性也用它在运行时确定对象创建时所用的类型，而不管使用它的表达式是什么类型。</p>
<p>对于<strong>非多态对象</strong>，值的解释方式由使用对象的表达式所确定，这在编译期就已经决定了。</p>
</blockquote>
<p>通常用于数值类型的相互转换，比如浮点型到整型（如 <code>double</code> 到 <code>int</code>），整型到字符型（如 <code>int</code> -&gt; <code>char</code>）等。</p>
<blockquote>
<p>得到的 <code>char</code> 可能没有足够的位来保存整个 <code>int</code> 值，故需要程序员来验证转换的结果是否安全。</p>
</blockquote>
<p>但在类的层次结构之间进行转换时，比如将基类指针<strong>向下转换</strong>为派生类指针这一操作，由于派生类可能有自己新定义的字段或信息，故<strong>向下转换是不安全</strong>的。但<strong>向上转换一定是安全</strong>的，因为派生类一定包含基类的所有信息。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>static_cast</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Foo</span><span class="token punctuation">(</span>B<span class="token operator">*</span> pb<span class="token punctuation">,</span> D<span class="token operator">*</span> pd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  D<span class="token operator">*</span> pd1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>D<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// not safe! D::val 不在 B 中。</span>
                                <span class="token comment">// 如果此时 pb 指向一个非 D 类对象，则调用 pd1-&gt;val 出错。</span>
  B<span class="token operator">*</span> pb1 <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// safe! 基类指针一定能指向所有派生类</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="dynamic-cast">dynamic_cast</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>new_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 其中 new_type/expr 必须为指针或引用。若 new_type 为指针，则 expr 必须为指针；如为引用，则 expr 为左值</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>与 <code>static_cast</code> 相对，<code>dynamic_cast</code> 在运行时执行类型检查，故用于<strong>多态对象</strong>的<strong>向上</strong>转换，且更加安全。具体表现为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果转型成功，那么 <code>dynamic_cast</code> 就会正确返回转换后的值；</p>
</li>
<li class="lvl-2">
<p>如果转型失败且 <code>new_type</code> 是指针类型，那么它会返回 <code>nullptr</code>；</p>
</li>
<li class="lvl-2">
<p>如果转型失败且 <code>new_type</code> 是引用类型，那么它会抛出 <code>std::bad_cast</code> 异常。</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>dynamic_cast</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"A foo()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B foo()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B bar()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C foo()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"C bar()\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">Foo</span><span class="token punctuation">(</span>A<span class="token operator">&amp;</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span><span class="token punctuation">[</span>__maybe_unused__<span class="token punctuation">]</span><span class="token punctuation">]</span> C <span class="token operator">&amp;</span>c <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>C<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cast to C SUCCESS!\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>bad_cast<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cast to C ERROR!\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A<span class="token operator">*</span> pa1 <span class="token operator">=</span> <span class="token keyword">new</span> C<span class="token punctuation">;</span>
  A<span class="token operator">*</span> pa2 <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>

  pa1<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  B<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa1<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Try to cast A* pa1 to B* pb ...\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cast success\n"</span><span class="token punctuation">;</span>
    pb<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pb<span class="token operator">-&gt;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cast failed\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  C<span class="token operator">*</span> pc <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>C<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pa2<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Try to cast A* pa2 to C* pc ...\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>pc<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cast success\n"</span><span class="token punctuation">;</span>
    pc<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    pc<span class="token operator">-&gt;</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Cast failed\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  C c<span class="token punctuation">;</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>

  B b<span class="token punctuation">;</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// C foo()</span>

<span class="token comment">// Try to cast A* pa1 to B* pb ...</span>
<span class="token comment">// Cast success</span>
<span class="token comment">// C foo()</span>
<span class="token comment">// B bar()</span>

<span class="token comment">// Try to cast A* pa2 to C* pc ...</span>
<span class="token comment">// cast failed</span>

<span class="token comment">// Cast to C SUCCESS!</span>

<span class="token comment">// Cast to C ERROR!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整体类层次结构为 <code>A -&gt; B -&gt; C</code>。从上述结果中不难发现：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>A* pa1</code> 指向 <code>C</code> 类对象，调用虚函数 <code>foo()</code> 时实现了多态的效果；</p>
</li>
<li class="lvl-2">
<p><code>A* pa1</code> 指向 <code>C</code> 类对象，转换为 <code>B*</code> 指针时成功，因为 <code>C</code> 是 <code>B</code> 的派生类，拥有基类的所有信息；</p>
</li>
<li class="lvl-2">
<p><code>A* pa2</code> 指向 <code>B</code> 类对象，转换为 <code>C*</code> 指针时失败，并返回空指针；</p>
</li>
<li class="lvl-2">
<p><code>A&amp; a</code> 绑定到 <code>C</code> 类对象时，能够转换到 <code>C&amp;</code> 型；</p>
</li>
<li class="lvl-2">
<p><code>A&amp; a</code> 绑定到 <code>B</code> 类对象时，无法转换到 <code>C&amp;</code> 型，并抛出异常；</p>
</li>
</ul>
<p>总结出，<code>dynamic_cast&lt;new_type&gt;(expr)</code> 转换成功与否，关键看指针/引用 <code>expr</code> 指向/绑定的对象是否为 <code>new_type</code> 的相同类型或派生类，而不用关心指针/引用类型本身。</p>
<p>再来看另一种情况。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>复杂继承关系</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">D</span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">E</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">C</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">D</span></span> <span class="token punctuation">{</span> <span class="token keyword">virtual</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">/********
   A  
  / \
 B   C   D
 |___|___|
     |
     E
********/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们拥有一个 <code>D* pd = new E;</code> 的指针，希望将其转换为 <code>A*</code>，一种可行的思路是先转到 <code>E*</code> 再转到 <code>B*</code> 最后转到 <code>A*</code>，就像这样进行"crabbing"：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">E<span class="token operator">*</span> pe <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>E<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span>
B<span class="token operator">*</span> pb <span class="token operator">=</span> pe<span class="token punctuation">;</span>
A<span class="token operator">*</span> pa <span class="token operator">=</span> pb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>事实上，如果 <code>new_type</code> 与 <code>expr</code> 所指代的指针/引用类型处于同一层次（比如这里的 <code>D</code> 与 <code>B</code>），并且 <code>expr</code> 所指向/绑定的对象为它俩的共同派生类，则可以进行<strong>横向转换</strong>，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">B<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token generic-function"><span class="token function">dynamic_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>pd<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在一些更复杂的类层次结构中，<strong>横向转换</strong>可以极大地提高 coding 效率。</p>
<h4 id="reinterpret-cast">reinterpret_cast</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>new_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>reinterpret_cast</code> 通过对底层比特位重新解读来进行类型间的转换。当然，这也是不安全的，需要程序员手动检查。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>reinterpret_cast</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>a <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将 64 位指针类型的 &amp;a 重新解读为 64 位 unsigned long long 类型。</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 0000000169AFFD5C</span>
<span class="token comment">// 6068108636</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="const-cast">const_cast</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>new_type<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>expr<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>const_cast</code> 最大特点就在于它可以移除 <code>expr</code> 的 cv 限定，这是其余几个算子都做不到的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>const_cast</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> val_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> val <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">// val = i;                    // ERROR! A::foo() is const</span>
    <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>val <span class="token operator">=</span> i<span class="token punctuation">;</span> <span class="token comment">// A::foo() const 中，this 为 const A* 型，使用 const_cast 去限定后允许修改成员变量</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  A <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output: 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>const_cast</code> 使得到非 <code>const</code> / 非 <code>volatile</code> 类型的指针/引用能够实际指向/绑定到 <code>const</code> / <code>volatile</code> 对象。通过非 <code>const</code> 访问路径修改 <code>const</code> 对象和通过非 <code>volatile</code> 泛左值指代 <code>volatile</code> 对象是 UB。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">*</span> pa <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span><span class="token operator">&amp;</span> ra <span class="token operator">=</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" *pa = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pa <span class="token operator">&lt;&lt;</span> <span class="token string">" ra = "</span> <span class="token operator">&lt;&lt;</span> ra <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

  ra <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"a = "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" *pa = "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>pa <span class="token operator">&lt;&lt;</span> <span class="token string">" ra = "</span> <span class="token operator">&lt;&lt;</span> ra <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// a = 1 *pa = 2 ra = 2</span>
<span class="token comment">// a = 1 *pa = 3 ra = 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="用户定义转换">用户定义转换</h2>
<p>在现代 C++ 中，传统转换已然无法轻易满足日益增长的应用需求，需要用户自己制定转换规则，来提高代码效率。</p>
<p>但用户能修改的只有两种，初始化构造函数与用户定义转换函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>User Defined Cast</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 初始化构造函数</span>
  <span class="token comment">// 其他类型 -&gt; Foo</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call Foo(int)\n"</span> <span class="token punctuation">}</span>

  <span class="token comment">// 用户定义转换函数，不需要显式指定返回值</span>
  <span class="token comment">// Foo -&gt; 其他类型</span>
  <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>               <span class="token comment">// 可隐式自定义转换</span>
  <span class="token keyword">explicit</span> <span class="token keyword">operator</span> <span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 强制显式自定义转换</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo <span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>f <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call operator int()\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"call explicit operator int* ()\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// call Foo(int)</span>
<span class="token comment">// call operator int()</span>
<span class="token comment">// call explicit operator int* ()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>有了这一功能，我们就能轻易地使用 <code>operator bool()</code> 来将某些类对象直接嵌到条件判断表达式中——直接通过自定义规则隐式转换为可被接收的 <code>bool</code> 类型。</p>
<h2 id="运行时类型信息-RTTI">运行时类型信息(RTTI)</h2>
<h3 id="typeid-算子">typeid 算子</h3>
<blockquote>
<p>定义于头文件 <code>&lt;typeinfo&gt;</code></p>
</blockquote>
<p><code>typeid</code> 用于获取当前对象的类型信息，返回一个 <code>type_info</code> 类，可以通过调用 <code>type_info</code> 的 <code>name()</code> 方法来获取相应的字符串型名称。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>typeid</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">bool</span> b<span class="token punctuation">;</span>
  <span class="token keyword">char</span> c<span class="token punctuation">;</span>
  <span class="token keyword">int</span> i<span class="token punctuation">;</span>
  <span class="token keyword">double</span> d<span class="token punctuation">;</span>

  A<span class="token operator">*</span> foo <span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
  B bar<span class="token punctuation">;</span>

  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>foo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// b</span>
<span class="token comment">// c</span>
<span class="token comment">// i</span>
<span class="token comment">// d</span>
<span class="token comment">// P1A</span>
<span class="token comment">// 1A</span>
<span class="token comment">// 1B</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现，<code>typeid</code> 不仅支持内置类型，还允许获取用户自定义类型的信息。但上面只描述了静态类型的情况，在编译期就能确定类型，下面看看涉及多态的 RTTI 情况。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>RTTI</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>
  Derived d<span class="token punctuation">;</span>
  Base<span class="token operator">&amp;</span> rb <span class="token operator">=</span> d<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>pb<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>pb<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span>
            <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>rb<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// P4Base</span>
<span class="token comment">// 7Derive</span>
<span class="token comment">// 7Derive</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现无论是否为多态场景，指针的类型依然为其静态类型，但其解引用后的类型却存在差异，即虽然 <code>pb</code> 的类型为 <code>Base*</code>，但其指向的对象被识别为 <code>Derived</code> 类型，这与之前 <code>A* foo = new B</code> 的表现大相径庭。</p>
<p>这是因为这里的 <code>Base</code> 为多态对象，当应用于多态类型的表达式时，<code>typeid</code> 的求值会对表达式求值，并指代表示该表达式动态类型的对象，这涉及运行时开销（虚表查找）。这里如果表达式是通过对一个指针解引用所得，且该指针是空指针值，那么就会抛出 <code>std::bad_typeid</code> 异常。</p>
<p>而其他情况下 <code>typeid</code> 表达式都在编译时解决，不会对表达式求值。</p>
<p>了解了这一点，也就基本知道 <code>dynamic_cast</code> 的原理了——其实它就是利用 <strong>RTTI</strong> 去判断一个指针实际所指的对象类型，这依赖于虚函数表，故仅用于多态类型的转换，无法对非多态对象执行 <code>dynamic_cast</code>。</p>
<h3 id="type-info">type_info</h3>
<p>上面说到 <code>typeid</code> 会返回一个 <code>type_info</code> 类，实际上它保有一个类型的实现指定信息，包括类型的名称和比较二个类型相等的方法或相对顺序。定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">type_info</span> <span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">type_info</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">==</span><span class="token punctuation">(</span><span class="token keyword">const</span> type_info<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token operator">!=</span><span class="token punctuation">(</span><span class="token keyword">const</span> type_info<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span> <span class="token comment">// C++20 移除</span>

  <span class="token keyword">bool</span> <span class="token function">before</span><span class="token punctuation">(</span><span class="token keyword">const</span> type_info<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
  size_t <span class="token function">hash_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>

  <span class="token function">type_info</span><span class="token punctuation">(</span><span class="token keyword">const</span> type_info<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  type_info<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> type_info<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个类型的 <code>type_info</code> 是独一无二的，故禁止了拷贝。除了之前提过的 <code>name()</code> 方法，在这里我仅关注 <code>operator=</code> 算子，另外两个不作深究。而 <code>operator=</code> 主要是检查对象是否指代相同类型，这个会经常用到，通常用于比较两个带有虚函数的类的对象是否相等。</p>
<h3 id="RTTI-底层原理">RTTI 底层原理</h3>
<p>在一个多态对象的内存模型中，最开始就会放一个指向虚表的虚表指针 <code>vptr</code>，而在虚表的 <strong><code>-1</code></strong> 索引处保有一个 <code>type_info*</code> 条目，其指向的 <code>type_info</code> 保存着该多态对象的类型信息。<code>typeid</code> 会判断出表达式是否为一个多态对象，若是，则不断地深入内存，进行虚表指针 -&gt; 类型信息指针 -&gt; 类型信息层层递进，最后找到 <code>type_info</code> 并返回；而非多态对象则没有虚表这一概念，直接在编译期求得静态类型即可。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 并发支持(Concurrency)</title>
    <url>/c/c-concurrent/</url>
    <content><![CDATA[<p>C++11 新增了官方<strong>并发支持库</strong>，使得我们能够更好地在系统间移植程序，之前的 Boost 库等也就随之成为历史了。</p>
<span id="more"></span>
<h2 id="并发与并行">并发与并行</h2>
<p>多线程的世界中，常常会涉及这俩重要概念。</p>
<p>从定义的角度来说，在操作系统中，<strong>并发</strong>是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行；而<strong>并行</strong>指的是一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。 （抄自百科）</p>
<p>用自己的语言描述：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>只会先把饭吃完，再把菜吃完，这叫<strong>单线程</strong>行为；</p>
</li>
<li class="lvl-2">
<p>先扒拉几口饭，再夹点菜，再吃饭，以这一时间段为单位，两个行为看似一起进行，但任意时刻却又不同时发生，存在资源（嘴巴）的调度，这叫<strong>并发</strong>；</p>
</li>
<li class="lvl-2">
<p>嘴巴里既嚼饭又嚼菜的，即同时吃饭吃菜，有能力同时处理多件事，这叫<strong>并行</strong>；</p>
</li>
</ul>
<p>综上所述，<strong>并发</strong>与<strong>并行</strong>的最主要区别，就在于各个线程是否能够"同时"进行。</p>
<h2 id="并发支持库">并发支持库</h2>
<p>并发支持库与 boost 很像，主要包含以下 5 个头文件。</p>
<h3 id="thread">&lt; thread &gt;</h3>
<blockquote>
<p>此头文件中定义了 <code>std::thread</code> 以及访问当前执行线程的函数 <code>std::this_thread</code></p>
</blockquote>
<h4 id="std-thread">std::thread</h4>
<p>该类管理<strong>单个<a href="https://en.wikipedia.org/wiki/Thread_(computing)">执行线程</a></strong>，并对外提供 api。</p>
<p>首先讲下<strong>初始化方式</strong>。由于每个线程都是一个独立的执行单位，故不存在两个同样的执行线程，那么<strong>拷贝构造</strong>与<strong>拷贝赋值</strong>因此被<strong>弃置</strong>(<code>delete</code>)。除此之外，其初始化方式共有四种重载形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">重载形式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>thread() noexcept</code></td>
<td style="text-align:center"><strong>默认构造函数</strong>。构造<strong>不</strong>关联执行线程的新 thread 对象。</td>
</tr>
<tr>
<td style="text-align:center"><code>thread( thread&amp;&amp; other ) noexcept</code></td>
<td style="text-align:center"><strong>移动构造函数</strong>。将 <code>other</code> 所关联的执行线程的资源转移，此后 <code>other</code> <strong>不</strong>关联任何执行线程。</td>
</tr>
<tr>
<td style="text-align:center"><code>thread&amp; operator=( thread&amp;&amp; other ) noexcept</code></td>
<td style="text-align:center"><strong>移动赋值运算符</strong>。若当前对象此时拥有关联的运行中线程（即 <code>joinable() == true</code> ），则调用 <code>std::terminate()</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>template&lt; class Func, class... Args &gt; explicit thread( Func&amp;&amp; f, Args&amp;&amp;... args )</code></td>
<td style="text-align:center"><strong>初始化构造函数</strong>。thread 创建并关联一个新的执行线程，开始执行可调用对象 <code>f</code>，相应参数也一并给出。</td>
</tr>
</tbody>
</table>
<p>接下来是其<strong>成员函数</strong>：</p>
<ol>
<li class="lvl-3">
<p><code>get_id()</code>：任何关联执行线程的 thread 对象均有一个唯一标识线程的对象 <code>id</code>。若当前对象存在关联的执行线程，则返回其 <code>id</code>；反之，输出 “<strong>thread::id of a non-executing thread</strong>”；</p>
</li>
<li class="lvl-3">
<p><code>join()</code>：阻塞当前线程直至 thread 对象关联的线程运行完毕。当前线程的 <code>id</code> 不能与 thread 的 <code>id</code> 相同，否则出现死锁（自己等自己）。并且，thread 自身不进行同步。同时从多个线程在同一 thread 对象上调用 <code>join()</code> 构成数据竞争，导致 <strong>UB</strong>；</p>
</li>
<li class="lvl-3">
<p><code>joinable()</code>：判断当前 thread 是否可以 join，即是否关联<strong>活跃</strong>的执行线程。简单来说，就是<strong>是否正在执行</strong>。结束执行但未 join 的 thread 也视为 <strong>joinable</strong>。由默认构造函数生成的 thread 对象 <code>joinable() == false</code>；</p>
</li>
<li class="lvl-3">
<p><code>detach()</code>：从 thread 对象分离执行线程，允许其独立执行。线程结束后，才释放资源。分离后，thread 也就不再关联任何执行对象了，既无法 <code>get_id()</code>，也无法 <code>join()</code>；</p>
<blockquote>
<p>考虑这样一种情况：</p>
<p>若 thread 关联的线程执行周期比 thread 对象生命周期还长，则当 thread 周期结束后调用析构函数删除资源时，如果没有调用 <code>join()</code> 或 <code>detach()</code>，此时线程仍在运行，则会出大问题。</p>
<p>所以要么用 <code>join()</code> 来阻塞当前线程防止过早结束，要么用 <code>detach()</code> 进行线程与 thread 对象的分离。</p>
<p>当然，也可以进一步封装 thread，在析构函数中调用 <code>join()</code> / <code>detach()</code> 操作，就不会出现上述情况了。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><code>native_handler()</code>：返回实现线程句柄，实现实时调度。</p>
</li>
<li class="lvl-3">
<p><code>[static] hardware_concurrency()</code>：静态方法，返回实现支持的并发线程数。</p>
</li>
</ol>
<p>下面用具体代码进行演示。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>thread</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">" executing\n"</span><span class="token punctuation">;</span>
  this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  thread t1<span class="token punctuation">;</span>
  thread <span class="token function">t2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  thread <span class="token function">t3</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  thread <span class="token function">t4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  cout <span class="token operator">&lt;&lt;</span> boolalpha
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t1 id: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t2 id: "</span> <span class="token operator">&lt;&lt;</span> t2<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t2<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t3 id: "</span> <span class="token operator">&lt;&lt;</span> t3<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t3<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t4 id: "</span> <span class="token operator">&lt;&lt;</span> t4<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t4<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

  t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  t4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
 * output:
 * Thread 3 executing
 * Thread 2 executing
 * t1 id: thread::id of a non-executing thread, joinable: false
 * t2 id: 2, joinable: true
 * t3 id: thread::id of a non-executing thread, joinable: false
 * t4 id: 3, joinable: true
 */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-this-thread">std::this_thread</h4>
<p>这实际上是 <code>std</code> 下的一个命名空间，用来表示当前线程。</p>
<p>该命名空间下有以下常用成员函数：</p>
<ol>
<li class="lvl-3">
<p><code>get_id()</code>：获取当前线程 <code>id</code>；</p>
</li>
<li class="lvl-3">
<p><code>yield()</code>：让出 CPU 资源；</p>
</li>
<li class="lvl-3">
<p><code>sleep_for()</code>：当前线程主动睡眠指定时间后醒来。<strong>函数原型</strong>为</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Period</span> <span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> time<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p><code>sleep_until()</code>：当前线程主动睡眠，直至指定时刻。<strong>函数原型</strong>为</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Duration</span> <span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sleep_until</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> time<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="mutex">&lt; mutex &gt;</h3>
<blockquote>
<p>此头文件中定义了各种互斥锁如 <code>std::mutex</code>，<code>std::lock_guard</code>，<code>std::unique_lock</code> 等</p>
</blockquote>
<h4 id="std-mutex">std::mutex</h4>
<p>mutex，全称 <strong>mutual exclusion</strong>(互斥体)，用于保护共享数据的<strong>互斥</strong>访问，也就是常说的<strong>锁</strong>。mutex 相当于一种独占性的资源，仅有 <code>lock</code> / <code>try_lock</code>（获取该资源）与 <code>unlock</code>（释放该资源）两种操作，其余各种锁都是围绕 mutex 进行封装与变形，故这些锁的<strong>拷贝构造函数</strong>与<strong>拷贝赋值运算符</strong>被<strong>弃置</strong>。其<strong>主要特性</strong>如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>调用方</strong>线程从它成功调用 <code>lock</code> / <code>try_lock</code> 开始，到它调用 unlock 为止占有 mutex；</p>
</li>
<li class="lvl-2">
<p>任一其它线程占有 mutex 时，当前线程若试图通过 <code>lock</code> / <code>try_lock</code> 要求获得 mutex 的所有权，则阻塞，直至<strong>占有方</strong>通过 <code>unlock</code> 释放 mutex；</p>
</li>
<li class="lvl-2">
<p>调用方线程在 <code>lock</code> / <code>try_lock</code> 前必须不占有 mutex，否则为 <strong>UB</strong>；</p>
</li>
</ul>
<p>就<strong>初始化方式</strong>而言，直接通过<strong>默认构造函数</strong>进行创建互斥锁对象，创建后锁处于<strong>未锁定</strong>状态。</p>
<p>mutex 类是所有锁的基础，其<strong>成员函数</strong>只有三个，都是基于之前讨论的特性：</p>
<ol>
<li class="lvl-3">
<p><code>lock()</code>：尝试锁定 mutex；</p>
</li>
<li class="lvl-3">
<p><code>try_lock()</code>：尝试锁定 mutex，成功获得锁时返回 <code>true</code> ，否则返回 <code>false</code>；</p>
</li>
<li class="lvl-3">
<p><code>unlock()</code>：释放 mutex；</p>
</li>
</ol>
<h4 id="std-timed-mutex">std::timed_mutex</h4>
<p>在 mutex 基础上，timedMutex 添加了<strong>超时语义</strong>，相关成员函数为：</p>
<ol>
<li class="lvl-3">
<p><code>try_lock_for( time )</code>：尝试获取锁，若一段时间 time 后超时未获得锁则放弃；</p>
</li>
<li class="lvl-3">
<p><code>try_lock_until( time )</code>：尝试获取锁，若指定时刻 time 后超时未获得锁则放弃；</p>
</li>
</ol>
<p>以上两个函数都会在成功时返回 <code>true</code>，失败时返回 <code>false</code>。</p>
<h4 id="std-recursively-mutex">std::recursively_mutex</h4>
<p>以上两种锁都无法重复获取，即已占有 mutex 的线程继续 <code>lock</code> / <code>try_lock</code> 会发生 UB。在 mutex 基础上，recursivelyMutex 添加了<strong>递归语义</strong>，即允许线程多次上锁，并在释放相等次数的锁后结束（好比左右括号匹配）。其成员函数与 mutex 一致。</p>
<h4 id="std-recursively-timed-mutex">std::recursively_timed_mutex</h4>
<p><strong>省流</strong>：recursivelyMutex + timedMutex</p>
<h4 id="std-lock-std-try-lock">std::lock() &amp; std::try_lock()</h4>
<p>除了各个锁类以外，&lt;mutex&gt; 头文件下还定义了两个全局函数 <code>std::lock()</code> 与 <code>std::try_lock()</code>，提供了通用的<strong>一次性加多个锁</strong>的方法。<strong>函数原型</strong>如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Lockable1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lockable2</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LockableN <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span> Lockable1<span class="token operator">&amp;</span> lock1<span class="token punctuation">,</span> Lockable2<span class="token operator">&amp;</span> lock2<span class="token punctuation">,</span> LockableN<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lockn <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Lockable1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lockable2</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LockableN <span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">try_lock</span><span class="token punctuation">(</span> Lockable1<span class="token operator">&amp;</span> lock1<span class="token punctuation">,</span> Lockable2<span class="token operator">&amp;</span> lock2<span class="token punctuation">,</span> LockableN<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lockn <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::lock()</code> 为阻塞式加锁，<code>std::try_lock()</code> 为异步式加锁，它俩其实是去调用每种 lockable 对象，即 mutex 自身的方法，然后加锁，并且不会因为不同线程上锁顺序不同而死锁，这是因为一旦上锁失败，则不再推进，而对所有已上锁的 mutex 调用 <code>unlock()</code>，然后再次重复尝试，直至所有 mutex 都已上锁。</p>
<h4 id="std-lock-guard">std::lock_guard</h4>
<p>对于不加超时语义的 mutex 而言，需要程序员主动上锁解锁，但如果某线程在 unlock 之前就因为抛出异常而被迫终止，那么其持有的 mutex 就永远无法释放，所有等待该资源的线程也就陷入了无尽的阻塞中，这显然是不可用的。并且这样的手动释放要求我们在所有执行体的出口都要解锁，也增加了不必要的代码量。</p>
<p><code>lock_guard</code> 应用了 <a href="https://zhuanlan.zhihu.com/p/34660259">RAII 技术</a>，其将 mutex 进一步封装，并在构造/析构函数中进行资源的分配/释放，这样就不会出现上述问题——因为一旦线程退出，其所有资源都会被释放，那么必然会调用析构函数，进行解锁，防止线程由于编码失误导致一直持有锁。</p>
<blockquote>
<p>这样一来，就不能用同一个 mutex 对象来初始化两个不同的 lock_guard 对象了，否则会出现<strong>死锁</strong>，下面几个锁也是如此。</p>
</blockquote>
<p>其类定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Mutex</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">lock_guard</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> mutex_type <span class="token operator">=</span> Mutex<span class="token punctuation">;</span>

  <span class="token keyword">explicit</span> <span class="token function">lock_guard</span><span class="token punctuation">(</span>mutex_type<span class="token operator">&amp;</span> m<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token function">lock_guard</span><span class="token punctuation">(</span>mutex_type<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> adopt_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 线程拥有锁时调用此构造函数</span>

  <span class="token operator">~</span><span class="token function">lock_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> m_<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token function">lock_guard</span><span class="token punctuation">(</span><span class="token keyword">const</span> lock_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  lock_guard<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> lock_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  mutex_type<span class="token operator">&amp;</span>  m_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两种构造函数区别在于：第一种在构造时上锁；而第二种重载形式形参中的 <code>adopt_lock_t</code> 为空结构体类型，表示<strong>构造模式</strong>，即<strong>假设调用方线程已拥有 mutex 的所有权</strong>，以此种方式进行构造时不会上锁。<code>std</code> 命名空间下已为我们实现了名为 <code>adopt_lock</code> 的全局变量，故可以用以下方式进行初始化：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>mutex a<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>lock_guard <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 构造后 a 上锁</span>

a<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 这句没有就报错</span>
std<span class="token double-colon punctuation">::</span>lock_guard <span class="token function">c</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 告知 a 已上锁，此时用这种初始化方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面还会讲另外两种上锁模式，也是同理的。</p>
<h4 id="std-unique-lock">std::unique_lock</h4>
<p>顾名思义，unique_lock 是独占性的，故不存在两个 unique_lock 对应同一个 mutex 对象，故<strong>移动构造函数</strong>与<strong>移动赋值运算符</strong>得到了实现，方便转移资源。</p>
<p>类定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Mutex</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">unique_lock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> mutex_type <span class="token operator">=</span> Mutex<span class="token punctuation">;</span>

  <span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">explicit</span> <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    own_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 支持三种上锁模式</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> defer_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> try_to_lock_t<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>m_<span class="token operator">-&gt;</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> adopt_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 超时语义</span>
  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Duration</span><span class="token operator">&gt;</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> <span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>time<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>m_<span class="token operator">-&gt;</span><span class="token function">try_lock_until</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Period</span><span class="token operator">&gt;</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> <span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>time<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>m_<span class="token operator">-&gt;</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>own_<span class="token punctuation">)</span>
      <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拷贝被弃置</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_lock <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  unique_lock <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_lock <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

  <span class="token comment">// 移动被实现</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>unique_lock <span class="token operator">&amp;&amp;</span>u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>m_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>own_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    u<span class="token punctuation">.</span>m_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    u<span class="token punctuation">.</span>own_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  unique_lock <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>unique_lock <span class="token operator">&amp;&amp;</span>u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>own_<span class="token punctuation">)</span>
      <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unique_lock</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    u<span class="token punctuation">.</span>m_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    u<span class="token punctuation">.</span>own_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  mutex_type <span class="token operator">*</span>m_<span class="token punctuation">;</span>
  <span class="token keyword">bool</span> own_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>unique_lock 在 lock_guard 基础上添加了超时语义，并且支持另外两种<strong>上锁模式</strong>：</p>
<ol>
<li class="lvl-3">
<p><code>defer_lock_t</code>：不上锁；</p>
</li>
<li class="lvl-3">
<p><code>try_lock_t</code>：尝试上锁，而不阻塞；</p>
</li>
</ol>
<p>除此以外，<code>unique_lock</code> 还提供了 <code>lock()</code>，<code>unlock()</code>，<code>try_lock()</code>，<code>try_lock_for()</code>，<code>try_lock_until()</code> 这几个 api，并能通过调用 <code>release()</code> 解绑所拥有的锁对象。</p>
<p>为了支持上述功能，类中新添加了变量 <code>own_</code> 来判断当前是否持有锁，并且 mutex 对象改为了指针类型，以便判断当前是否存在绑定的 mutex。</p>
<blockquote>
<p>lock_gurad 相比于 unique_lock 更轻量，但因为 unique_lock 类可以手动解锁，所以<strong>条件变量</strong>都搭配 unique_lock 一起使用，因为条件变量在 wait 时需要有手动解锁的能力。</p>
</blockquote>
<h4 id="std-call-once">std::call_once()</h4>
<p>此函数保证某一函数在多线程环境中只调用一次，它需要配合 <code>std::once_flag</code> 使用。<strong>函数原型</strong>为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Callable</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">call_once</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>once_flag<span class="token operator">&amp;</span> flag<span class="token punctuation">,</span> Callable<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>若 <code>flag == true</code>，则直接返回；反之，利用 <code>std::forward</code> 调用 <code>f</code>，且仅当正常返回时将 <code>flag</code> 由 <code>false</code> 改为 <code>true</code>。具体代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

once_flag flag<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">call_once</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" call\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  thread threads<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output: 0 call</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="atomic">&lt; atomic &gt;</h3>
<blockquote>
<p>此头文件中定义了原子变量 <code>std::atomic&lt;T&gt;</code>，以及其各种特化 <code>std::atomic_int</code>，<code>std::atomic_bool</code> 等</p>
</blockquote>
<h4 id="std-atomic">std::atomic</h4>
<p>考虑这样一个情况：存在一整型变量 <code>x = 0</code>，现在有两个线程 A, B 分别对其执行加 1 与 减 1 的操作，这些操作可以归结为两步原子操作：</p>
<ol>
<li class="lvl-3">
<p>读取变量值；</p>
</li>
<li class="lvl-3">
<p>加/减该值，赋值给原变量；</p>
</li>
</ol>
<p>如果不加以限制，可能会出现 <strong>Write-After-Read</strong>, <strong>Write-After-Write</strong> 的情况，+则 x 最终的结果可能是 -1, 0, 1 这三种，这取决于线程每一步原子操作之间的执行顺序。</p>
<p>我们希望最终结果是<strong>确定性</strong>的，就需要严格控制线程同步，一个很好的考虑是使用前面提到的 mutex，代码可以写为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">lock_guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  x<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">lock_guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  x<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而如果使用<strong>原子变量</strong>，则代码可以简化为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// or std::atomic_int x(0)</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>事实上，原子变量能帮助我们自动控制线程之间的同步，保证加/减等操作的原子性——若一个线程写入原子对象，同时另一线程从它读取，则行为良好定义。</p>
<h3 id="condition-variable">&lt; condition_variable &gt;</h3>
<h4 id="std-condition-variable">std::condition_variable</h4>
<p><code>condition_variable</code> 是利用线程间共享的<strong>全局变量</strong>进行<strong>同步</strong>的一种机制，能用于阻塞一个或多个线程（或称使其等待(<strong>wait</strong>)），直至另一线程通知(<strong>notify</strong>)条件变量将等待的线程唤醒。相当于操作系统里的 <strong>P/V</strong> 操作。</p>
<blockquote>
<p>下面就用 P/V 代称 wait/notify。</p>
</blockquote>
<p>即使共享变量是原子的，也必须互斥地修改它，故尝试进行 P/V 的线程必须在持有锁时进行 P/V，这里的锁必须采用 <code>unique_lock</code>，因为需要 RAII 以及手动 lock/unlock。具体用法大致如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>

<span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*
   * predicate 为布尔类型表达式
   * 若 predicate == true，则 do something
   * 反之，进入休眠状态，直至被唤醒后检查到 predicate == true
   */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>predicate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 必须在持有锁的情况下调用 wait，会被其它线程通过 notify 唤醒</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// do something</span>

  cond<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与互斥方式相比，条件变量的 P 操作以<strong>非竞争方式</strong>争夺资源，会进入一个等待队列，这样一来 CPU 的时间片就得到了充分利用，而不是耗费在无意义的等待上锁上。</p>
<p>接下来谈谈其<strong>成员函数</strong>。</p>
<p>首先是 <strong>wait</strong> 系列：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 1. wait</span>
<span class="token comment">// 原子地进行 unlock ，阻塞当前线程，并将它添加到等待队列。唤醒后，进行 lock 且 wait 退出。</span>
<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于 while(!pred()) { wait(lock); }，这里 pred 是一个返回 bool 值的可调用对象</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Predicate</span> <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span> Predicate pred <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 2. wait_until</span>
<span class="token comment">// 等待至时刻 timeout_time 后若还未被唤醒，则强制唤醒</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span> <span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>cv_status <span class="token function">wait_until</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timeout_time <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于:</span>
<span class="token comment">// while (!pred()) {</span>
<span class="token comment">//   if (wait_until(lock, timeout_time) == std::cv_status::timeout) {</span>
<span class="token comment">//     return pred();</span>
<span class="token comment">//   }</span>
<span class="token comment">// }</span>
<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Pred</span> <span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">wait_until</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timeout_time<span class="token punctuation">,</span>
                 Pred pred <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 3. wait_for</span>
<span class="token comment">// 等待 rel_time 后若还未被唤醒，则强制唤醒</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>cv_status <span class="token function">wait_for</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rel_time<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等价于</span>
<span class="token comment">// return wait_until(lock,</span>
<span class="token comment">//                   std::chrono::steady_clock::now() + rel_time,</span>
<span class="token comment">//                   std::move(pred));</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Predicate</span> <span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">wait_for</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
               <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rel_time<span class="token punctuation">,</span>
               Predicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>其中 <code>cv_status</code> 是一个枚举型变量，描述定时等待是否因时限返回。其只包含两个枚举值：</p>
<ol>
<li class="lvl-3"><code>no_timeout</code>：表示条件变量因 <code>notify_all</code> 、 <code>notify_one</code> 或虚假地被唤醒；</li>
<li class="lvl-3"><code>timeout</code>：表示条件变量因时限耗尽被唤醒；</li>
</ol>
</blockquote>
<p>接下来是 <strong>notify</strong> 系列：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 唤醒等待队列中的某一线程，一般只有两个线程的时候才会用 notify_one，因为非此即彼。</span>
<span class="token keyword">void</span> <span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>

<span class="token comment">// 唤醒等待队列中的所有线程</span>
<span class="token keyword">void</span> <span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-condition-variable-any">std::condition_variable_any</h4>
<p>与 <code>condition_variable</code> 相比，<code>condition_variable_any</code> 是 <code>condition_variable</code> 的泛化，其支持任一 Lockable 的锁，不一定非要用 <code>unique_lock</code>。除此以外与 <code>condition_variable</code> 几乎完全一致，就不聊了。</p>
<h4 id="std-notify-all-at-thread-exit">std::notify_all_at_thread_exit()</h4>
<p>在此线程完全结束时调用 <code>notify_all()</code>。函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">notify_all_at_thread_exit</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">&amp;</span> cond<span class="token punctuation">,</span>
                                std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lk <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>需要注意的是，调用该函数之前，必须首先用与 cond 绑定的相同 mutex 来创建 unique_lock 对象，并且传参时需要用 <code>move()</code> 将先前获得的锁 <code>lk</code> 的所有权转移到内部存储。</p>
<h4 id="唤醒丢失">唤醒丢失</h4>
<p>上面讲条件变量用法时，我提到"<strong>尝试进行 P/V 的线程必须在持有锁时进行 P/V</strong>"，那么如果不上锁就 wait/notify 会怎样呢？不加锁便进行wait 操作的行为我们已经说过是 UB，而不加锁便进行 notify 的行为会导致<strong>唤醒丢失</strong>，且看：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case1 唤醒丢失</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread1 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread2 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们希望的是：thread1 首先上锁，然后 wait（此时会隐式地解锁），然后 thread2 上锁，修改 flag，唤醒 thread1，然后两个线程分别打印一条消息出来。</p>
<p>但线程是异步推进的，极有可能由于 thread2 未进行 <code>m</code> 的上锁操作，故其执行体不会被阻塞，从而出现 thread1 上锁，thread2 notify，thread1 再 wait 的执行顺序，显然会导致 thread1 无限阻塞。这便是<strong>不加锁导致唤醒丢失</strong>的经典案例。</p>
<p>为了解决这一问题，我们需要在 notify 前上锁，这样保证了在 thread1 的上锁与 wait 之间不会发生 notify 行为——thread2 会因竞争锁资源而被阻塞。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// OK</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread1 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread2 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这种情况中，我们只考虑了 notify 是否会发生在上锁与 wait 之间，但 notify 也有可能发生在上锁之前，这也可能导致唤醒丢失。考虑下面这种情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case2 唤醒丢失</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread1 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread2 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>thread2 先上锁然后 notify_all（此时会隐式地解锁），再是 thread1 上锁并进行 wait。由于没有其它线程执行唤醒的工作，thread1 将永远 wait 下去——thread2 的 notify 实际上丢失了！这便是<strong>不加条件导致唤醒丢失</strong>的经典案例。</p>
<p>为了解决这一问题，我们应当加上某些限制，使得 notify 确定性地位于 wait 之后。于是需要套上一层条件判断的语句（如 <code>while</code>），检测当前是否应当 wait，套上 <code>while</code> 后，即便 thread2 首先执行，但由于 thread2 中修改了 predicate，thread1 也就能够很快检测到，能够跳过 wait 阶段。当然也可以不用 <code>while</code>，而是写成下面这种样子，这两者是等价的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="虚假唤醒">虚假唤醒</h4>
<p>当上面的条件判断语句由 <code>while</code> 改为 <code>if</code> 时，便存在<strong>虚假唤醒</strong>的情况。</p>
<blockquote>
<p>当一个线程从等待一个已发出信号的条件变量中醒来，却发现它正在等待的条件不满足时，就会发生<strong>虚假唤醒</strong>。之所以称为虚假，是因为该线程似乎无缘无故地被唤醒了。但是虚假唤醒不会无缘无故地发生：它们通常会发生，因为在条件变量发出信号和等待线程最终运行之间，另一个线程运行并改变了条件。（抄自<a href="https://en.wikipedia.org/wiki/Spurious_wakeup">百科</a>）</p>
</blockquote>
<p>用一个例子来说明：在<strong>生产者消费者</strong>问题中，生产者每生产出一个产品，就通知所有消费者；当所有消费者被唤醒时，它们对产品的获取顺序为竞争关系，此时第一个赢得竞争的消费者取走了产品，而之后的消费者会发现并没有任何产品存在，又此时已经退出了 wait 阶段，也就继续推进下去直至消亡，最后就导致只有一个消费者进行了消费。比如下面这段代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case3 虚假唤醒</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 产品</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cnt<span class="token operator">++</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决办法就是<strong>将 wait 放到条件判断循环中</strong>，即类似于上一节中第二段代码。</p>
<h3 id="future">&lt; future &gt;</h3>
<h4 id="std-future">std::future</h4>
<p><code>std::future</code> 类型变量可以用于保存某个异步任务的结果（<strong>共享变量</strong>），并且内含一个状态(state)来表示该任务是否完成(ready)。因此可以把它当成一种简单的线程间同步的手段。通常由某个 “Provider” 创建，并在未来的某个线程中设置共享变量的值（future 因此得名），另外一个线程中与该共享变量相关联的 <code>std::future</code> 对象调用 <code>get()</code> 获取该值。</p>
<p>如果共享变量中 <code>state != ready</code>，则对 <code>std::future::get()</code> 的调用会阻塞，直到 Provider 设置了共享变量的值（然后 <code>state == ready</code>），这才返回异步任务的值或异常（如果发生了异常）。</p>
<h4 id="std-promise">std::promise</h4>
<p><code>std::promise&lt;T&gt;</code> 属于 Provider。它关联了一个 <code>std::future&lt;T&gt;</code> 对象，并可以通过 <code>get_future()</code> 返回该对象。同样的，它也可以通过 <code>set_value(T)</code> 进行共享变量的赋值，从而唤醒另一个调用了 <code>std::future::get()</code> 的线程（如果有）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">print_int</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> fut<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 1. 阻塞</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 3. 打印 value: 10.</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> prom<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> prom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>print_int<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  prom<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2. 线程 t 结束对 fut.get() 的阻塞</span>
  t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// value: 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std-packaged-task">std::packaged_task</h4>
<p><code>std::packaged_task&lt;T(Args...)&gt;</code> 也是 Provider。它除了关联一个 <code>std::future&lt;T&gt;</code> 对象，还包装了一个类型为 <code>T(Args...)</code> 的<strong>可调用对象</strong>。packaged_task 实现了 <code>operator()</code>（因而可以作为 <code>std::thread</code> 的初始化参数），调用一个 packaged_task 相当于调用内含的可调用对象，并将返回值或异常存在关联的 future 里。</p>
<p>当线程 a 用一个 <code>std::packaged_task</code> 初始化新线程 b 时，a 可以调用 <code>std::packaged_task::get_future()</code> 返回一个 future 对象，并调用 <code>get()</code> 阻塞直至 b 执行完返回。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> from<span class="token punctuation">;</span> i <span class="token operator">!=</span> to<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Finished!\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> from <span class="token operator">-</span> to<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// contruct a packaged_task</span>
  std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ret <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// get its future</span>

  std<span class="token double-colon punctuation">::</span>thread <span class="token function">th</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> value <span class="token operator">=</span> ret<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wait until count() is done</span>

  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The countdown lasted for "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds.\n"</span><span class="token punctuation">;</span>

  th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 10</span>
<span class="token comment">// 9</span>
<span class="token comment">// 8</span>
<span class="token comment">// 7</span>
<span class="token comment">// 6</span>
<span class="token comment">// 5</span>
<span class="token comment">// 4</span>
<span class="token comment">// 3</span>
<span class="token comment">// 2</span>
<span class="token comment">// 1</span>
<span class="token comment">// Finished!</span>
<span class="token comment">// The countdown lasted for 10 seconds.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="pthread-POSIX-thread">pthread(POSIX thread)</h2>
<p>pthread 是一个在类 UNIX 系统下广泛使用的并发包，Linux 系统下在 glibc 库里实现。</p>
<h3 id="pthread-mutex-t">pthread_mutex_t</h3>
<p>这是 pthread 中对于锁的数据结构定义，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">union</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">__pthread_mutex_s</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> __lock<span class="token punctuation">;</span>             <span class="token comment">// 锁状态。0: 未占用；1: 占用</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __count<span class="token punctuation">;</span>   <span class="token comment">// 为可重入锁所使用，表示持有锁的次数</span>
    <span class="token keyword">int</span> __owner<span class="token punctuation">;</span>            <span class="token comment">// 持有锁的 thread id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __nusers<span class="token punctuation">;</span>
    <span class="token comment">/* KIND must stay at this position in the structure to maintain binary compatibility. */</span>
    <span class="token keyword">int</span> __kind<span class="token punctuation">;</span>             <span class="token comment">// 锁类型。</span>
                            <span class="token comment">// PTHREAD_MUTEX_TIMED_NP:      普通锁(默认值)</span>
                            <span class="token comment">// PTHREAD_MUTEX_RECURSIVE_NP:  可重入锁</span>
                            <span class="token comment">// PTHREAD_MUTEX_ADAPTIVE_NP:   自适应锁</span>
                            <span class="token comment">// PTHREAD_MUTEX_ERRORCHECK_NP: 检错锁</span>
    <span class="token keyword">int</span> __spins<span class="token punctuation">;</span>            <span class="token comment">// 当前已自旋次数，用于计算自适应锁单次最大自旋次数</span>
    __pthread_list_t __list<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> __data<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> pthread_mutex_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="pthread-mutex-lock-mutex">pthread_mutex_lock(mutex)</h3>
<p>这是提供给用户的加锁函数，内部会判断锁的类型，并执行不同的上锁策略。</p>
<h4 id="普通锁">普通锁</h4>
<p>对于<strong>普通锁</strong>，直接进行加锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> PTHREAD_MUTEX_TIMED_NP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 普通锁 */</span>
  simple<span class="token operator">:</span>
    <span class="token function">LLL_MUTEX_LOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="可重入锁">可重入锁</h4>
<p>对于<strong>可重入锁</strong>，如果同一线程加锁，则直接增加计数器；否则，像普通锁一样加锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">PTHREAD_MUTEX_TYPE</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">==</span> PTHREAD_MUTEX_RECURSIVE_NP<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 可重入锁 */</span>
  pid_t id <span class="token operator">=</span> <span class="token function">THREAD_GETMEM</span> <span class="token punctuation">(</span>THREAD_SELF<span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">/* 意思是当前计数器达到了 unsigned int 的上界 */</span>
      <span class="token keyword">return</span> EAGAIN<span class="token punctuation">;</span>

    <span class="token operator">++</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>

  <span class="token function">LLL_MUTEX_LOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="自适应锁">自适应锁</h4>
<p>对于<strong>自适应锁</strong>，则是首先进行一定次数的「自旋」，如果达到次数上限后依然没有获得锁，则像普通锁一样加锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">PTHREAD_MUTEX_TYPE</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">==</span> PTHREAD_MUTEX_ADAPTIVE_NP<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 自适应锁 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> __is_smp<span class="token punctuation">)</span>
    <span class="token comment">/* 如果不是 SMP 系统，则跳过自旋，直接像普通锁一样加锁 */</span>
    <span class="token keyword">goto</span> simple<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LLL_MUTEX_TRYLOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> max_cnt <span class="token operator">=</span> <span class="token function">MIN</span> <span class="token punctuation">(</span>MAX_ADAPTIVE_COUNT<span class="token punctuation">,</span> mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__spins <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token operator">++</span> <span class="token operator">&gt;=</span> max_cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">LLL_MUTEX_LOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">atomic_spin_nop</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">LLL_MUTEX_TRYLOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 如果这次自旋次数少，说明竞争不激烈，之后可以减少最大自旋次数；反之需要更多次的竞争 */</span>
    mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__spins <span class="token operator">+=</span> <span class="token punctuation">(</span>cnt <span class="token operator">-</span> mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__spins<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="检错锁">检错锁</h4>
<p>对于<strong>检错锁</strong>，则首先检查是否为同一线程重复上锁，是一种简单的避免死锁的逻辑。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 检错锁 */</span>
  pid_t id <span class="token operator">=</span> <span class="token function">THREAD_GETMEM</span> <span class="token punctuation">(</span>THREAD_SELF<span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">PTHREAD_MUTEX_TYPE</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">==</span> PTHREAD_MUTEX_ERRORCHECK_NP<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> EDEADLK<span class="token punctuation">;</span>

  <span class="token keyword">goto</span> simple<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="LLL-MUTEX-LOCK-mutex">LLL_MUTEX_LOCK(mutex)</h3>
<p>这其实是一个宏，将其展开后我们可以得到 <code>__lll_lock(&amp;((mutex)-&gt;__data.__lock), PTHREAD_MUTEX_PSHARED (mutex))</code>。所以其实是走了 <code>__lll_lock()</code> 宏，第二个参数用于获取当前锁是否为共享锁（读锁）。</p>
<p>来看看上锁的策略吧！简单来说就是先尝试用 CAS 获取锁，如果获取失败（被占用）就执行 <code>__lll_lock_wait*()</code> 挂起等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__lll_lock</span><span class="token expression"><span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>                                      </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                                                               </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                                   </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span>__futex <span class="token operator">=</span> <span class="token punctuation">(</span>futex<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>__glibc_unlikely                                               </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token punctuation">(</span><span class="token function">atomic_compare_and_exchange_bool_acq</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        </span><span class="token punctuation">\</span>
       <span class="token expression"><span class="token punctuation">{</span>                                                                </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_constant_p</span> <span class="token punctuation">(</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token operator">==</span> LLL_PRIVATE<span class="token punctuation">)</span></span><span class="token punctuation">\</span>
           <span class="token expression"><span class="token function">__lll_lock_wait_private</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">)</span><span class="token punctuation">;</span>                           </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token keyword">else</span>                                                           </span><span class="token punctuation">\</span>
           <span class="token expression"><span class="token function">__lll_lock_wait</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          </span><span class="token punctuation">\</span>
       <span class="token expression"><span class="token punctuation">}</span>                                                                </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现这里有个 <code>futex</code>，对此，源码里面的注释是这样的：</p>
<p>「If FUTEX is 0 (not acquired), set to 1 (acquired with no waiters) and return.</p>
<p>Otherwise, ensure that it is &gt;1 (acquired, possibly with waiters) and then block until we acquire the lock, at which point FUTEX will still be &gt; 1.</p>
<p>The lock is always acquired on return.」</p>
<blockquote>
<p>这里是直接把 <code>pthread_mutex_t</code> 里的 <code>__lock</code> 拿来当 futex 使了。</p>
</blockquote>
<h4 id="lll-lock-wait">__lll_lock_wait()</h4>
<p><code>*futex</code> 为 2 表示 “acquired, possibly with waiters”，所以如果已经为 2 了，就直接等待；之后检查锁状态是否为 0，然后将其置 2，如果最开始状态非 0 则等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">__lll_lock_wait</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>futex<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>futex <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token function">lll_futex_wait</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Wait if *futex == 2. */</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">atomic_exchange_acq</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">lll_futex_wait</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Wait if *futex == 2. */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lll-futex-wait-lll-futex-timed-wait">lll_futex_wait()/lll_futex_timed_wait()</h4>
<p><code>lll_futex_wait</code> 这个宏走的是 <code>lll_futex_timed_wait()</code>。如果 lll_futex_wake 后 *futexp 值还是 val，则以 <strong>FUTEX_WAIT</strong> 执行系统调用 <code>futex()</code> 进行等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_futex_timed_wait</span><span class="token expression"><span class="token punctuation">(</span>futexp<span class="token punctuation">,</span> val<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>     </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">lll_futex_syscall</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> futexp<span class="token punctuation">,</span>                                 </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token function">__lll_private_flag</span> <span class="token punctuation">(</span>FUTEX_WAIT<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              </span><span class="token punctuation">\</span>
         <span class="token expression">val<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_futex_syscall</span><span class="token expression"><span class="token punctuation">(</span>nargs<span class="token punctuation">,</span> futexp<span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                       </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                                    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">INTERNAL_SYSCALL_DECL</span> <span class="token punctuation">(</span>__err<span class="token punctuation">)</span><span class="token punctuation">;</span>                                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">int</span> __ret <span class="token operator">=</span> <span class="token function">INTERNAL_SYSCALL</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> __err<span class="token punctuation">,</span> nargs<span class="token punctuation">,</span> futexp<span class="token punctuation">,</span> op<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
               <span class="token expression">__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">INTERNAL_SYSCALL_ERROR_P</span> <span class="token punctuation">(</span>__ret<span class="token punctuation">,</span> __err<span class="token punctuation">)</span><span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token operator">?</span> <span class="token operator">-</span><span class="token function">INTERNAL_SYSCALL_ERRNO</span> <span class="token punctuation">(</span>__ret<span class="token punctuation">,</span> __err<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="lll-unlock">lll_unlock()</h3>
<p>释放锁的核心函数。无条件将锁的状态置 0，如果旧状态值为 2，则还需要执行 <code>lll_futex_wake</code> 去唤醒等待的线程，此时第一个竞争成功的线程通过 <code>atomic_exchange_acq (futex, 2)</code> 将状态置 2 后成功获取到锁，如此往复。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__lll_unlock</span><span class="token expression"><span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>                   </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                                              </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                  </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span>__futex <span class="token operator">=</span> <span class="token punctuation">(</span>futex<span class="token punctuation">)</span><span class="token punctuation">;</span>                           </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">int</span> __oldval <span class="token operator">=</span> <span class="token function">atomic_exchange_rel</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>__oldval <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>
       <span class="token expression"><span class="token function">lll_futex_wake</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_unlock</span><span class="token expression"><span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">__lll_unlock</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>futex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lll-futex-wake">lll_futex_wake()</h4>
<p>以 <strong>FUTEX_WAKE</strong> 去执行系统调用 <code>futex()</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_futex_wake</span><span class="token expression"><span class="token punctuation">(</span>futexp<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                   </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">INTERNAL_SYSCALL_DECL</span> <span class="token punctuation">(</span>__err<span class="token punctuation">)</span><span class="token punctuation">;</span>                 </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">int</span> __ret<span class="token punctuation">;</span>                                </span><span class="token punctuation">\</span>
        <span class="token expression">__ret <span class="token operator">=</span> <span class="token function">INTERNAL_SYSCALL</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> __err<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>     </span><span class="token punctuation">\</span>
                       <span class="token expression"><span class="token punctuation">(</span>futexp<span class="token punctuation">)</span><span class="token punctuation">,</span> FUTEX_WAKE<span class="token punctuation">,</span> <span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression">__ret<span class="token punctuation">;</span>                                         </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="并发应用">并发应用</h2>
<h3 id="无锁队列-Lockless-Queue">无锁队列(Lockless Queue)</h3>
<p>可参考<a href="https://coolshell.cn/articles/8239.html">这篇文章</a>。</p>
<h3 id="线程池-Thread-Pool">线程池(Thread Pool)</h3>
<p>利用 <code>std::future</code> 和 <code>std::packaged_task</code>，我们可以实现一个支持异步返回结果的<strong>线程池</strong>。</p>
<p>和普通的仅支持<strong>执行但不返回结果</strong>的线程池相比，其核心在于一个 <code>ThreadPool::execute()</code> 执行函数。该函数为模板函数，允许传入一个可调用对象及其参数列表，内部通过 <code>std::packaged_task</code> 包装后交付给空闲线程执行，并将返回结果保存在其关联的 <code>std::future</code> 对象中。执行函数可以返回这个 future，并让用户通过 <code>std::future::get()</code> 等待执行结果。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>线程池</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token class-name">ThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">execute</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> callable<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">callable</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> returnType <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">callable</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">returnType</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>future result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  taskQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入就绪队列，唤醒线程取出任务并执行</span>

  <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ThreadPool<span class="token operator">&amp;</span> tp <span class="token operator">=</span> <span class="token class-name">ThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 单例模式</span>
  <span class="token keyword">int</span> res <span class="token operator">=</span> tp<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 常量(Const)</title>
    <url>/c/c-const/</url>
    <content><![CDATA[<p>const 与 volatile 一起并称 <strong>CV 限定符</strong>，用于指定被声明对象或被命名类型的常量性或易变性。</p>
<span id="more"></span>
<p>const 全称 <strong>constant</strong>，其指定一个约束，告知编译器该变量无法被修改。对于那些明确不发生改变的变量，应尽可能使用 <code>const</code>，以获得编译器的帮助。</p>
<h2 id="const-普通变量">const 普通变量</h2>
<p>声明时，<code>const</code> 与 <code>typename</code> 顺序可以互换，并且可以直接初始化常量，之后就不能对常量进行修改了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>         <span class="token comment">// OK!</span>
<span class="token keyword">int</span> <span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token comment">// OK!</span>

<span class="token keyword">int</span> c <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
a <span class="token operator">=</span> c<span class="token punctuation">;</span>               <span class="token comment">// ERROR! 无法对 const 进行修改</span>
c <span class="token operator">=</span> a<span class="token punctuation">;</span>               <span class="token comment">// OK!</span>

<span class="token keyword">int</span> <span class="token keyword">const</span> nums<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="const-指针">const 指针</h2>
<p>const 搭配指针使用时，也会出现不同的顺序：</p>
<ol>
<li class="lvl-3">
<p><strong>底层 const</strong>：<code>const</code> 位于 <code>*</code> 之<strong>前</strong>，是为<strong>常量指针</strong>，表明指针指向的变量为常量，无法通过指针修改指向的对象；</p>
</li>
<li class="lvl-3">
<p><strong>顶层 const</strong>：<code>const</code> 位于 <code>*</code> 之<strong>后</strong>，是为<strong>指针常量</strong>，表明指针为常量，无法修改指针变量本身；</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bar <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>             <span class="token comment">// ERROR! 常量只能被常量指针指向</span>
<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>       <span class="token comment">// OK!</span>

<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>       <span class="token comment">// OK! 常量指针</span>
<span class="token keyword">int</span> <span class="token keyword">const</span><span class="token operator">*</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>bar<span class="token punctuation">;</span>       <span class="token comment">// OK! 可以指向非常量，但无法通过 *b = ? 的方式修改变量 bar</span>
<span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>bar<span class="token punctuation">;</span>       <span class="token comment">// OK! 指针常量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">*</span> <span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span> <span class="token comment">// OK! 指向常量的常量指针</span>

<span class="token comment">// *a = 1, d = &amp;foo 这些操作都是编译报错的</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这段代码其实存在漏洞，即将 <code>foo</code> 的地址强转为 <code>int*</code> 类型并赋值给了 <code>int* q</code>。这是不安全的，因为 <code>p</code> 并不是常量指针，可以凭借 <code>p</code> 修改指向的变量，如果加上下面这段代码，则会发现一些奇妙的事：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>foo <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> foo <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output:</span>
<span class="token comment">// 0x78fe0c 1</span>
<span class="token comment">// 0x78fe0c 0 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现，<code>q</code> 与 <code>&amp;foo</code> 为同一个地址，但奇怪的是，<code>*q</code> 与 <code>foo</code> 值不同，并且 <code>foo</code> 竟然与 <code>*(&amp;foo)</code> 的值也产生了差异！</p>
<p>Actually，函数中定义的常量放在内存的<strong>栈</strong>区，而栈内存是可以通过指针修改的，不过即使修改了这块内存，在程序中仍然看起来没有修改常量，这是因为 C++ 编译器对 const 做了优化——当编译器遇到 <code>foo</code> 的定义时，会在内存的某个位置开辟一张表，然后将 key-value 对 <code>{foo, 0}</code> 写入该表，这就相当于将常量 0 绑定在符号 <code>foo</code> 上，之后每次取数据 <code>foo</code> 时，虽然运行时栈会为 <code>foo</code> 分配内存，但不是取栈中地址对应的值，而会去查这张表，然后用 value: 0 直接代替。</p>
<p>所以尽管指针 <code>p</code> 对地址上的值进行了修改，打印 <code>foo</code> 时我们得到的并不是真正的地址 <code>&amp;foo</code> 上的值。</p>
<p>但并不是所有的常量声明时都是如此，比如将上面的代码略作修改：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case 1</span>
<span class="token keyword">int</span> bar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> bar<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>foo <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> foo <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output:</span>
<span class="token comment">// 0x78fe0c 1</span>
<span class="token comment">// 0x78fe0c 1 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case 2</span>
<span class="token keyword">constexpr</span> <span class="token keyword">int</span> bar <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> bar<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>

<span class="token punctuation">(</span><span class="token operator">*</span>q<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>q <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token operator">&amp;</span>foo <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> foo <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output:</span>
<span class="token comment">// 0x78fe0c 1</span>
<span class="token comment">// 0x78fe0c 0 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现上面两个 case 唯一的区别在于变量 <code>bar</code> 是否为 <a href="../../c/c-else/#constexpr"><strong>constexpr</strong></a>，换句话说，就是用于初始化 <code>foo</code> 的变量值是否在编译时可知。如果只有到了运行时才能确定常量 <code>foo</code> 的值，那么编译器并不会写 key-value 进表，而是表现地像 C 语言一样，直接从栈上获取数据；反之，如果在编译时就能确定值（比如上面那个 <code>const int foo = 0;</code>），编译器就会跟我们上面讨论的一样运作。</p>
<blockquote>
<p>所以有些时候改用 <code>constexpr</code> 是更好的选择。</p>
</blockquote>
<p>而如果对<strong>全局变量</strong>进行 <code>const</code> 约束，此时变量分配在<strong>静态区</strong>，那么无论怎样都无法修改。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
  <span class="token punctuation">(</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">// ERROR!</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="const-引用">const 引用</h2>
<p>修饰引用时，<code>const</code> 只能位于 <code>&amp;</code> 左侧，毕竟引用变量本身一经初始化就无法更改，自带 const 语义。这种情况下，const + 引用均视为<strong>常量引用</strong>，即引用的变量为常量，无法修改。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> bar <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> a <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// OK!</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> b <span class="token operator">=</span> bar<span class="token punctuation">;</span> <span class="token comment">// OK!</span>
<span class="token keyword">int</span> <span class="token keyword">const</span><span class="token operator">&amp;</span> c <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// OK!</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> <span class="token keyword">const</span> d <span class="token operator">=</span> foo<span class="token punctuation">;</span> <span class="token comment">// ERROR!</span>

<span class="token comment">// a = 1 编译报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="const-函数">const 函数</h2>
<p>const 与函数搭配只有两种情况：</p>
<ol>
<li class="lvl-3">
<p><strong>修饰形参</strong>。此时函数体内无法修改 const 修饰的形参；</p>
</li>
<li class="lvl-3">
<p><strong>修饰函数返回值</strong>。</p>
</li>
</ol>
<h2 id="const-类成员变量">const 类成员变量</h2>
<p>类中定义常量主要有以下实现方式：</p>
<ol>
<li class="lvl-3">
<p><strong>枚举</strong>。此时枚举变量相当于静态变量，在编译时可知。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">enum</span> <span class="token class-name">test</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// static</span>
  <span class="token keyword">int</span> nums1<span class="token punctuation">[</span>test<span class="token double-colon punctuation">::</span>foo<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> nums2<span class="token punctuation">[</span>test<span class="token double-colon punctuation">::</span>bar<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> A<span class="token double-colon punctuation">::</span>test<span class="token double-colon punctuation">::</span>foo<span class="token punctuation">;</span> <span class="token comment">// output: 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p><strong>const 修饰</strong>。仅用 const 修饰的变量为非静态变量，只有在运行时才能确定值。仅能在构造函数的初始化列表进行初始化，或者直接就地初始化。此后无法再修改。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">const</span> <span class="token keyword">int</span> foo<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> bar<span class="token punctuation">[</span>foo<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment">// ERROR! invalid use of non-static A::foo</span>
  <span class="token comment">// A() { foo = 1; }    // ERROR!</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> foo<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// ERROR! foo is const</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<h2 id="const-类成员函数">const 类成员函数</h2>
<p>除了普通函数的用法外，类成员函数还可以在函数体前加上 <code>const</code> 修饰符，表明该成员函数不会修改任何非 <a href="../C-Mutable">mutable</a> 关键字修饰的成员变量。此时 this 隐式为 <code>const *</code>（更严谨地说应该为 <code>const *const</code>，因为 this 不可修改指向），表明在该函数体内，编译器将该对象视为 const 对象。对于 const 对象，只能调用 const 成员函数，因为非 const 函数无法保证不会修改成员变量。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> bar<span class="token punctuation">;</span>
    bar<span class="token operator">++</span><span class="token punctuation">;</span>               <span class="token comment">// ERROR!</span>
    Foo<span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>       <span class="token comment">// ERROR! this 为 const Foo*</span>
    <span class="token keyword">const</span> Foo<span class="token operator">*</span> q <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> bar<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此外，<code>const</code> 类成员函数亦可与不加 <code>const</code> 的同名成员函数产生不同重载版本。至于调用哪个重载版本，就看调用的对象是否为常量，如果是常量，则调用 const 版本，否则调用非 const 版本。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 两个重载版本</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"const\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"non-const\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo a<span class="token punctuation">;</span>
  <span class="token keyword">const</span> Foo b<span class="token punctuation">;</span>
  <span class="token keyword">const</span> Foo<span class="token operator">*</span> c <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  b<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  c<span class="token operator">-&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token comment">// non-const</span>
<span class="token comment">// const</span>
<span class="token comment">// const</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="与宏定义的区别">与宏定义的区别</h2>
<table>
<thead>
<tr>
<th style="text-align:center">宏定义 #define</th>
<th style="text-align:center">常量 const</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">宏定义，相当于字符替换</td>
<td style="text-align:center">常量声明</td>
</tr>
<tr>
<td style="text-align:center">预处理器处理</td>
<td style="text-align:center">编译器处理</td>
</tr>
<tr>
<td style="text-align:center">无类型安全检查</td>
<td style="text-align:center">有类型安全检查</td>
</tr>
<tr>
<td style="text-align:center">不分配内存</td>
<td style="text-align:center">要分配内存</td>
</tr>
<tr>
<td style="text-align:center">存储在代码段</td>
<td style="text-align:center">存储在数据段</td>
</tr>
<tr>
<td style="text-align:center">可通过 <code>#undef</code> 取消</td>
<td style="text-align:center">不可取消</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 委托与继承的构造函数(Delegating &amp; Inherited Constructors)</title>
    <url>/c/c-constructor/</url>
    <content><![CDATA[<p><strong>委托构造函数</strong>与<strong>继承构造函数</strong>并非独立的新构造函数，而是 C++11 新增的用于提高编码效率的特性。</p>
<span id="more"></span>
<h2 id="委托构造函数">委托构造函数</h2>
<p><strong>委托构造函数</strong>允许构造函数通过初始化列表调用同一个类的其他构造函数，相当于将自己的构造职责<strong>委托</strong>给了其它构造函数。目的是简化构造函数的书写，提高代码的可维护性，避免代码冗余膨胀。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 不使用委托，显得十分臃肿且冗余</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i <span class="token operator">=</span> i_<span class="token punctuation">;</span>
    j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">,</span> <span class="token keyword">int</span> j_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    i <span class="token operator">=</span> i_<span class="token punctuation">;</span>
    j <span class="token operator">=</span> j_<span class="token punctuation">;</span>
    <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span> i<span class="token punctuation">;</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 使用委托，精简干练</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">=</span> i_<span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>    <span class="token comment">// 委托构造函数</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">,</span> <span class="token keyword">int</span> j_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span> j <span class="token operator">=</span> j_<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 委托构造函数</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span> i<span class="token punctuation">;</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个委托构造函数也有一个成员初始化列表和一个函数体，成员初始化列表只能包含一个其它构造函数，且参数列表必须与已有的构造函数匹配。初始化列表里<strong>不能</strong>再包含其它成员变量的初始化，只能在函数体中对变量进行赋值。</p>
<h3 id="注意事项">注意事项</h3>
<p>委托构造不能形成循环，比如下面这种代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>i_<span class="token punctuation">,</span> <span class="token char">'c'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">,</span> <span class="token keyword">int</span> j_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span> j <span class="token operator">=</span> j_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span> i<span class="token punctuation">;</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>A(int i_)</code> 与 <code>A(int i_, char j_)</code> 反复调用对方形成循环，这样会导致编译错误。</p>
<h2 id="继承构造函数">继承构造函数</h2>
<p>子类为完成基类初始化，在 C++11 之前，需要须要在构造函数中<strong>显式</strong>声明，即在初始化列表调用基类的构造函数，从而完成构造函数的传递。如果基类拥有多个构造函数，那么子类也需要实现多个与基类构造函数对应的构造函数，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">=</span> i_<span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">,</span> <span class="token keyword">int</span> j_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span> j <span class="token operator">=</span> j_<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span> i<span class="token punctuation">;</span>
  <span class="token keyword">int</span> j<span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span>  <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> j <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">,</span> <span class="token keyword">int</span> j_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>i_<span class="token punctuation">,</span> j_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果仅仅是为了完成基类的初始化，那么这样的做法显得非常冗余，代码的书写开销高达 $O(n)$！</p>
<p>从 C++11 开始，我们可以直接使用 <code>using Base::Base</code> 的方式来将基类中的构造函数全继承到派生类中，而无需重复书写，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> i <span class="token operator">=</span> i_<span class="token punctuation">;</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">Base</span><span class="token punctuation">(</span><span class="token keyword">char</span> i_<span class="token punctuation">,</span> <span class="token keyword">int</span> j_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">Base</span><span class="token punctuation">(</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span> j <span class="token operator">=</span> j_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// private 部分略</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>Base<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>和上面那种写法是等价的，比如使用 <code>char</code> 变量去初始化 <code>Derived</code> 类变量时，会调用 <code>Base(char)</code> 去初始化基类，然后调用 <code>display()</code> 打印输出。更巧妙的是，这是<strong>隐式</strong>声明继承的，即假设一个继承来的构造函数不被相关的代码使用，编译器不会为之产生真正的函数代码，这样比显式书写各种构造函数更加节省代码量。</p>
<h3 id="注意事项-2">注意事项</h3>
<p><strong>继承构造函数</strong>的注意事项较多，一一说明。</p>
<ol>
<li class="lvl-3">
<p>继承构造函数无法初始化派生类数据成员。这很显然，因为继承来的构造函数仅对基类进行初始化。如果要初始化派生类变量，有两种做法。一是使用 <code>=</code> / <code>{}</code> 对非静态成员就地初始化，二是额外书写构造函数，两种做法各有优劣，第一种减少了代码量，第二种更加灵活，需根据具体应用场景进行选择。</p>
</li>
<li class="lvl-3">
<p>当派生类拥有多个基类时，如果多个基类中的部分构造函数的参数列表（中的类型与顺序）完全一致，那么派生类中的继承构造函数将产生冲突，比如：</p>
</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span><span class="token punctuation">,</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span> <span class="token comment">// 等价于 C(int i): A(i) {}</span>
  <span class="token keyword">using</span> B<span class="token double-colon punctuation">::</span>B<span class="token punctuation">;</span> <span class="token comment">// 等价于 C(int i): B(i) {}</span>
  <span class="token function">C</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">A</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">B</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 应显式声明会产生冲突的构造函数，会将上面两个"等价于"覆盖，阻止了隐式生成对应的构造函数，避免了冲突</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="3">
<li class="lvl-3">
<p>若基类构造函数声明为 <code>private</code>，则派生类无法使用该构造函数；若为 <code>public</code>，即便 <code>using</code> 处于 <code>private</code> 中，也能使用。比如：</p>
</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

B <span class="token function">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// OK! although using is private</span>
B <span class="token function">q</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! A(int, int) is private</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>网上好多文章提到两点：</p>
<p>一是若基类构造函数存在默认值，则无法继承该默认值；</p>
<p>二是若派生类是是从基类虚继承的，那么就不能在派生类中继承构造函数；</p>
<p>但这两点在实践中都被推翻，但我也无法判断是否是错，这两点存疑。代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token keyword">double</span> b <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">_a</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">_b</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> _a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> _b <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> _a<span class="token punctuation">;</span>
  <span class="token keyword">double</span> _b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> A<span class="token double-colon punctuation">::</span>A<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span><span class="token punctuation">,</span> <span class="token class-name">C</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> B<span class="token double-colon punctuation">::</span>B<span class="token punctuation">;</span>
  <span class="token keyword">using</span> C<span class="token double-colon punctuation">::</span>C<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  D <span class="token function">d</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 1 4</span>
<span class="token comment">// 3 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从输出易得 <code>B</code>，<code>C</code> 确实从 <code>A</code> 处继承来了构造函数，并且默认值也得到了继承。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 预置与弃置(Default &amp; Delete)</title>
    <url>/c/c-defaultanddelete/</url>
    <content><![CDATA[<p>C++11 中新增了 <strong><code>default</code></strong> 与 <strong><code>delete</code></strong> 这俩关键字。请不要误会，这里的 <code>delete</code> 并不是与 <code>new</code> 搭配使用释放内存的那个，而是跟 <code>default</code> 相对的用于类成员函数声明的关键字。</p>
<span id="more"></span>
<h2 id="default">default</h2>
<p>众所周知，如果用户自定义了一个类的构造函数，则编译器不会为其隐式生成默认构造函数。可能它觉得你想根据自己的需求定义构造函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A a<span class="token punctuation">;</span>  <span class="token comment">// ERROR! 已经有 A(int) 就不会生成 A()</span>
B b<span class="token punctuation">;</span>  <span class="token comment">// OK! 隐式生成默认构造函数</span>
C c<span class="token punctuation">;</span>  <span class="token comment">// OK! 所有形参都具有默认值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>默认构造函数</strong>是在没有显式提供初始化式时调用的构造函数。它由不带参数的构造函数，或者为所有的形参提供默认实参的构造函数定义。如果定义某个类的变量时没有提供初始化时就会使用默认构造函数。（抄自百科）</p>
<p>默认构造函数并非空函数，所以不能直接用 <code>{}</code> 草草了事。其主要做的工作就是对成员变量进行一些默认初始化，这些工作的具体实现由编译器决定，若完全交给用户实现则较为困难。</p>
<p>如果我们想在上面的代码中使 <code>A a</code> 通过编译，那么此刻 <code>default</code> 关键字就派上用场了。只要在函数后面加上 <code>= default</code>，则该函数会被视为<strong>预置</strong>(defaulted)，编译器就会为其自动生成默认版本。</p>
<p>需要<strong>注意</strong>的是，<code>default</code> <strong>只能</strong>用于<strong>六大特殊函数</strong>：默认构造、拷贝构造、拷贝赋值、移动构造、移动赋值、析构。毕竟用户自定义的函数不在"默认"范畴中。除此之外 <code>default</code> 既支持在类<strong>体内</strong>(in-line)声明，也支持<strong>体外</strong>(out-line)声明。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// in-line</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// ERROR!</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 尽管不加这句也会默认生成拷贝构造函数，但为了让"默认"表现地更直观</span>
<span class="token class-name">A</span><span class="token double-colon punctuation">::</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// out-line</span>

A a<span class="token punctuation">;</span> <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，就避免了程序员定义函数的繁重工作。同时，使用 <code>default</code> 修饰的函数也比用户自定义的函数拥有<strong>更高的执行效率</strong>，这也是该特性的一大优势。</p>
<h2 id="delete">delete</h2>
<p>在 C++11 以前，如果想要禁止类的某个成员函数被调用，只有两种策略：要么将其声明为私有函数，要么干脆定义为空函数，什么也不做。因为有些类从功能的角度考虑必然不能对某些函数进行实现甚至定义——总不能让程序员在 <code>human</code> 类中搞了个 <code>fly()</code> 函数吧。</p>
<p>但问题在于，第一种做法并不能阻止类内或友元类的调用，和第二种做法一样无法在调用时报错，程序员也就很难找到代码问题所在。两种做法并没有从根本上解决问题——<strong>这些函数不该被定义</strong>。</p>
<p>于是，<code>delete</code> 被提出。与 <code>default</code> 相对，后面加上 <code>= delete</code> 的函数会被视为<strong>弃置</strong>(deleted)，在编译器眼中这个函数<strong>禁止被定义</strong>，对该函数的调用会导致编译错误，继而从根本上解决了这个问题。与 <code>default</code> 不同，<code>delete</code> 可以用于修饰任何类成员函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  A<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A<span class="token operator">&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span> <span class="token comment">// OK! 如果不想使用这种构造函数，就将其弃置，这样外部也无法进行定义</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A a1<span class="token punctuation">,</span> a3<span class="token punctuation">;</span> <span class="token comment">// OK! 默认构造函数</span>
A <span class="token function">a2</span><span class="token punctuation">(</span>a1<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! 拷贝构造函数被弃置</span>
a3 <span class="token operator">=</span> a1<span class="token punctuation">;</span>  <span class="token comment">// ERROR! 拷贝赋值运算符被弃置</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>一个很常用的例子就是 <code>unique_ptr</code>，<code>unique_lock</code> 这些类通过 <code>delete</code> 修饰来禁止对象之间的拷贝。</p>
</blockquote>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 其它特性(Else)</title>
    <url>/c/c-else/</url>
    <content><![CDATA[<p>有些 C++11 特性比较琐碎，单纯用一篇文章描述浪费，还有灌水嫌疑(bushi)，于是整合到同一篇来讲。</p>
<span id="more"></span>
<h2 id="范围-for-循环">范围 for 循环</h2>
<p>允许 for 循环中使用 <code>for (范围变量声明 : 范围表达式)</code> 的形式进行遍历，无需 <code>for(...;...;...)</code> 式的写法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> v<span class="token punctuation">;</span>

<span class="token comment">// C++11 前</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> iter <span class="token operator">=</span> v<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> v<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">DoSomeThing</span><span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// C++11 起</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> item <span class="token operator">:</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// item 为 int&amp; 型</span>
  <span class="token function">DoSomeThing</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="constexpr">constexpr</h2>
<p><code>constexpr</code> 和 <code>const</code> 很像，两者的共同之处在于都是<strong>修饰词</strong>，可以用于修饰变量与函数，不同之处在于，<code>const</code> 修饰的对象仅包含一层 <strong>read-only</strong> 含义，即仅保证该对象在运行时不会被改变，但其仍有可能为动态变量。</p>
<p>而 <code>constexpr</code> 可以说是 <code>const</code> 的升华版本，用 <code>constexpr</code> 修饰的对象<strong>在编译时便能计算出来</strong>，整个运行过程中都不可以被改变，直接自带一层 <code>const</code> 语义。这可以说是一个非常强大的优化，有些操作能够直接在编译时完成，就不用再在运行时多次耗费时间。</p>
<blockquote>
<p>在 constexpr 出现之前，可以在编译期初始化的 const 都隐式为 constexpr，所以其实早就有了。直到 C++11，constexpr 才从 const 中<strong>细分</strong>出来成为一个关键字。作为一门效率敏感型的语言，应当尽可能地使用 <strong>constexpr</strong> 进行代码优化。</p>
</blockquote>
<h3 id="constexpr-变量">constexpr 变量</h3>
<p>用 <code>constexpr</code> 修饰的变量必须为<a href="https://zh.cppreference.com/w/cpp/named_req/LiteralType">字面类型</a>，并且必须立即被初始化，初始化时所调用的表达式必须为<a href="https://zh.cppreference.com/w/cpp/language/constant_expression">常量表达式</a>。</p>
<h3 id="constexpr-函数">constexpr 函数</h3>
<p>对于用 <code>constexpr</code> 修饰的函数，如果其传入的参数可以在编译时计算出来，那么这个函数就会产生编译时的值；反之，就和普通函数一样了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> res1 <span class="token operator">=</span> <span class="token function">calculate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// OK! 编译时完成计算</span>
  <span class="token comment">// constexpr int res2 = calculate(x, y); // ERROR! calculate 视为普通函数，除非改为 constexpr int x = 1, y = 2</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>虚函数由于是在运行时进行查表调用的，故无法声明为 <code>constexpr</code></p>
</blockquote>
<p>constexpr 函数也包含诸多限制：</p>
<ol>
<li class="lvl-3">
<p>其所有的参数类型及返回值类型都必须为字面类型；</p>
</li>
<li class="lvl-3">
<p>在不为构造函数时，有且仅能有一条 return 语句（允许包含 <code>typedef</code>、<code>using</code>、<code>static_assert</code>）；</p>
</li>
<li class="lvl-3">
<p>只能调用其它 constexpr 函数；</p>
</li>
</ol>
<p>可以用 constexpr 函数实现递归，科技为<strong>三元运算符</strong>。<code>fact(5)</code> 将在编译时得到运算，这也是与 <code>inline</code> 函数的一个显著区别。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">fact</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i <span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">?</span> i <span class="token operator">*</span> <span class="token function">fact</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="constexpr-构造函数">constexpr 构造函数</h3>
<p>若构造函数中所有参数均为 constexpr 变量，则该类的所有成员变量也均为 constexpr，这个对象也就为 constexpr 对象了。</p>
<p>需<strong>额外注意</strong>的是：</p>
<ol>
<li class="lvl-3">
<p>constexpr 构造函数所有初始化必须都放在初始化列表里，并且函数体为空；</p>
</li>
<li class="lvl-3">
<p>仅有 constexpr 对象可以调用声明为 <code>constexpr</code> 的成员函数；</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">constexpr</span> <span class="token function">Test</span><span class="token punctuation">(</span><span class="token keyword">int</span> val_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">val</span><span class="token punctuation">(</span>val_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> <span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> val<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> val<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token comment">// constexpr Test foo(x);            // ERROR! x 不是 constexpr 变量</span>
  Test <span class="token function">foo</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// OK! 视为普通构造函数</span>
  <span class="token comment">// constexpr int val = foo.get_val() // ERROR! 非 constexpr 对象</span>

  <span class="token keyword">constexpr</span> Test <span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment">// OK! 此时 bar 为 constexpr 对象</span>
  <span class="token keyword">constexpr</span> <span class="token keyword">int</span> val <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">get_val</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="nullptr">nullptr</h2>
<p>C++11 以前使用宏 <code>NULL</code> 来表示空指针。本质上它是 <code>#define NULL 0</code>，也就是一个数字 0，并不算真正意义上的指针。如果遇到以下代码，则会出现二义性：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<blockquote>
<p>函数 <code>func</code> 有两个重载形式，当调用 <code>func(NULL)</code> 时，两个函数都有充分的理由被调用，因为 NULL 可以视为 0 而调用 <code>func(int)</code>，二义性由此产生。</p>
</blockquote>
<p>C++11 引入的新关键词 <code>nullptr</code> 代表指针<strong>字面量</strong>，它是 <code>std::nullptr_t</code> 类型的纯右值，该类型可以隐式转换到任何指针类型及任何成员指针类型。注意这个转换是<strong>单向</strong>的！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">constexpr</span> T <span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> t<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数 func(int) 已调用\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"函数 func(int*) 已调用\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// OK!</span>
  <span class="token function">func</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// OK!</span>
  <span class="token comment">// func(NULL);         // ERROR! 二义性</span>

  <span class="token function">func</span><span class="token punctuation">(</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK!</span>
  <span class="token comment">//  func(clone(0));    // ERROR! 非字面量的零不能为空指针常量</span>
  <span class="token comment">//  func(clone(NULL)); // ERROR! 非字面量的零不能为空指针常量</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token comment">// 函数 func(int*) 已调用</span>
<span class="token comment">// 函数 func(int) 已调用</span>
<span class="token comment">// 函数 func(int*) 已调用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="override">override</h2>
<p><code>override</code> 用于修饰派生类中的<strong>虚函数</strong>，告诉编译器（与程序员）该函数进行了重写。如果一个函数声明为 <code>override</code> 但父类却没有这个虚函数，编译报错，故可以避免程序员在重写基类函数时无意产生的错误，提高代码规范性。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
    <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">A</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! A::foo 非 const，签名不匹配</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>       <span class="token comment">// OK!</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>       <span class="token comment">// ERROR! A::bar 非虚</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="final">final</h2>
<p><code>final</code> 用于指定某个<strong>虚函数</strong>不能在派生类中被重写，或者某个类不能被派生。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span><span class="token punctuation">;</span>    <span class="token comment">// OK! A::foo 为 final</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">final</span><span class="token punctuation">;</span>    <span class="token comment">// ERROR! A::bar 非虚，因此它不能是 final 的</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token keyword">final</span> <span class="token operator">:</span> A <span class="token punctuation">{</span>   <span class="token comment">// OK! B 为 final</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! foo 不能被重写，A::foo 为 final</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">B</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token comment">// ERROR! B 为 final，无法进一步派生</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于多态类，如果确定一个虚函数不会再被覆盖，或者该类不会再被继承，则推荐标上 <code>final</code>。这可以为编译器提供非常有价值的编译优化信息，总而将原本需要推迟到运行期才能确定的虚函数调用提前在编译期就已确定。如被调用的函数能与上层调用方一起进一步地做函数内联、常量折叠、无用代码消除等优化，则可以压榨出非常可观的性能提升。</p>
</blockquote>
<h2 id="enum-class">enum class</h2>
<p>C++11 以前，<strong>枚举</strong>并不限定作用域，所有枚举成员均暴露在外层作用域下，并且所有枚举值都可自动转换为整型。这也就导致：</p>
<ol>
<li class="lvl-3">
<p>不同枚举类型的枚举成员禁止重名；</p>
</li>
<li class="lvl-3">
<p>不同枚举类型能够相互比较；</p>
</li>
</ol>
<p>显然，这种传统的枚举并不安全。</p>
<p>C++11 引入了<strong>限定作用域的枚举</strong>来解决以上问题。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">enum</span> <span class="token class-name">Color</span> <span class="token punctuation">{</span> red<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">newColor</span> <span class="token punctuation">{</span> red<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green <span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 此限定域内自成一派，与其它枚举类型无影响</span>
<span class="token comment">// enum class newColor: typename {...};    // 枚举类型底层默认为 int，可以如此进行修改</span>

Color c1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>             <span class="token comment">// ERROR! C++11 起不能通过整型来初始化枚举类型</span>
Color c2 <span class="token operator">=</span> red<span class="token punctuation">;</span>           <span class="token comment">// OK! red 在该作用域中可访问，并且这里 red 的类型为 Color</span>
Color c3 <span class="token operator">=</span> Color<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span>    <span class="token comment">// OK! 可以通过 枚举类型::枚举成员名 访问成员</span>

newColor l1 <span class="token operator">=</span> red<span class="token punctuation">;</span>        <span class="token comment">// ERROR! red 为 Color 类型，不能用于初始化 newColor 类型</span>
newColor l2 <span class="token operator">=</span> Light<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span> <span class="token comment">// OK! 仅能通过 枚举类型::枚举成员名 访问成员</span>

<span class="token keyword">int</span> foo <span class="token operator">=</span> Color<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span>     <span class="token comment">// OK! 无限定作用域的枚举成员可转化为整数</span>
<span class="token keyword">int</span> bar <span class="token operator">=</span> newColor<span class="token double-colon punctuation">::</span>red<span class="token punctuation">;</span>  <span class="token comment">// ERROR! 限定作用域的枚举成员不可转化为整数</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span>red <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// output: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然限制很多，但也更安全。应当尽可能使用带限定域的枚举。</p>
<h2 id="static-assert">static_assert</h2>
<p>说到这个，就不得不提另一个很像的叫 <code>assert</code> 的玩意。这两者都起到<strong>断言</strong>的作用，区别在于：</p>
<p><code>static_assert</code> 作为 C++11 新引入的<strong>关键字</strong>，为<strong>静态断言</strong>，即编译时进行断言，若表达式为 false，则编译错误。这样一来不会生成目标代码，也不会影响程序性能。用法为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static_assert</span><span class="token punctuation">(</span>expr<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果 expr == false，则输出 msg</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>assert</code> 为<strong>动态断言</strong>，在运行时执行，不影响编译（其实就是一个<strong>宏</strong>）。通过 <code>static_cast&lt;bool&gt;</code> 把表达式转换成 <code>bool</code> 类型，从而实现断言。缺点在于影响程序性能，常用于 debug 模式，在 release 模式中一般会关掉。</p>
<h2 id="自定义字面量">自定义字面量</h2>
<p>C++ 自带如下字面量（及其对应引用）：</p>
<ol>
<li class="lvl-3">
<p>整数型，如 <code>1</code>；</p>
</li>
<li class="lvl-3">
<p>浮点型，如 <code>1.23</code>；</p>
</li>
<li class="lvl-3">
<p>字符型，如 <code>'1'</code>；</p>
</li>
<li class="lvl-3">
<p>字符串型，如 <code>"123"</code>；</p>
</li>
</ol>
<p>以整数型为例，字面量最后可以添加后缀来表示具体类型：</p>
<ol>
<li class="lvl-3">
<p><code>unsigned int</code>，如 <code>123u</code>；</p>
</li>
<li class="lvl-3">
<p><code>lont int</code>，如 <code>123l</code>；</p>
</li>
</ol>
<p>这些后缀就仿佛<strong>单位</strong>一般，能够告诉程序员一些关于类型的信息。</p>
<p>C++11 以前，我们如果希望定义一些描述时间相关的变量，或许会这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> time <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但问题在于，这里的 <code>time</code> 的单位是什么？秒？微秒？还是纳秒？如果不加以注释，则会为代码阅读带来不便。有没有一种手段，能够让我们编写以下代码，使得开发者能够直接得到想要的信息？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> time1 <span class="token operator">=</span> <span class="token number">30</span>_ms<span class="token punctuation">;</span>
<span class="token keyword">auto</span> time2 <span class="token operator">=</span> <span class="token number">40</span>_s<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>答案是<strong>肯定</strong>的，只需在上面的代码之前加上以下语句，就能成功编译并运行。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token string">""</span><span class="token function">_ms</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> time<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token string">""</span><span class="token function">_s</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span> time<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">1000</span> <span class="token operator">*</span> time<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当代码中出现了 <code>30_ms</code> 这样的字面量时，编译器认出这里有一个用户定义后缀 <code>_ms</code>，于是首先会去查找函数 <code>operator""_ms</code>，并检查前面的字面量 <code>30</code> 类型是否与函数形参类型匹配。若失败，则报错。</p>
<blockquote>
<p>为了不与 C++ 内置的自定义后缀混淆，用户定义的后缀通常以下划线开头。</p>
</blockquote>
<blockquote>
<p>有人会注意到上面的形参类型为 <code>unsigned long long</code>，这是由于自定义字面量存在<strong>限制</strong>——C++11 只允许字面量后缀函数的参数为以下类型，对应整数，浮点，字符以及字符串：</p>
<ul class="lvl-1">
<li class="lvl-2"><code>unsigned long long</code></li>
<li class="lvl-2"><code>long double</code></li>
<li class="lvl-2"><code>char</code> / <code>wchar_t</code> / <code>char8_t</code> / <code>char16_t</code> / <code>char32_t</code></li>
<li class="lvl-2"><code>const char*</code></li>
<li class="lvl-2"><code>const char*, std::size_t</code></li>
<li class="lvl-2"><code>const wchar_t*, std::size_t</code></li>
<li class="lvl-2"><code>const char16_t*, std::size_t</code></li>
<li class="lvl-2"><code>const char32_t*, std::size_t</code></li>
</ul>
</blockquote>
<p>如果希望在编译时就调用字面量后缀函数，则需要把函数定义为 <code>constexpr</code>。</p>
<h2 id="新的数据结构">新的数据结构</h2>
<h3 id="std-forward-list">std::forward_list</h3>
<blockquote>
<p>定义于头文件 <code>&lt;forward_list&gt;</code></p>
</blockquote>
<p>以前有双向链表 <code>std::list</code>，现在加入了新容器<strong>单向链表</strong> <code>std::forward_list</code>，每个节点节省了一个指针的空间。</p>
<p>forward_list 内部实现以下功能：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>begin()</code> /  <code>cbegin</code> / <code>end()</code> / <code>cend()</code></td>
<td style="text-align:center">返回指向起始/末尾的迭代器</td>
</tr>
<tr>
<td style="text-align:center"><code>before_begin()</code> / <code>cbefore_begin()</code></td>
<td style="text-align:center">返回指向第一个元素之前的迭代器（头节点）</td>
</tr>
<tr>
<td style="text-align:center"><code>empty()</code></td>
<td style="text-align:center">检查容器是否为空</td>
</tr>
<tr>
<td style="text-align:center"><code>max_size()</code></td>
<td style="text-align:center">返回可容纳最大元素数</td>
</tr>
<tr>
<td style="text-align:center"><code>clear()</code></td>
<td style="text-align:center">清空容器</td>
</tr>
<tr>
<td style="text-align:center"><code>insert_after(iter_pos, value)</code></td>
<td style="text-align:center">在某处之后插入元素</td>
</tr>
<tr>
<td style="text-align:center"><code>emplace_after(iter_pos, value)</code></td>
<td style="text-align:center">在某处之后构造元素</td>
</tr>
<tr>
<td style="text-align:center"><code>erase_after(iter_pos)</code></td>
<td style="text-align:center">移除某处之后的元素</td>
</tr>
<tr>
<td style="text-align:center"><code>push_front(value)</code></td>
<td style="text-align:center">在链表头部插入元素</td>
</tr>
<tr>
<td style="text-align:center"><code>emplace_front(value)</code></td>
<td style="text-align:center">在链表头部构造元素</td>
</tr>
<tr>
<td style="text-align:center"><code>pop_front()</code></td>
<td style="text-align:center">移除头部元素</td>
</tr>
<tr>
<td style="text-align:center"><code>merge(forward_list)</code></td>
<td style="text-align:center">合并两个已排序链表，默认升序，可自定义比较器</td>
</tr>
<tr>
<td style="text-align:center"><code>splice_after(iter_pos, forward_list)</code></td>
<td style="text-align:center">移动另一链表的元素到某处后，执行移动语义</td>
</tr>
<tr>
<td style="text-align:center"><code>remove(value)</code> / <code>remove_if(pred)</code></td>
<td style="text-align:center">移除满足特定标准的元素</td>
</tr>
<tr>
<td style="text-align:center"><code>reverse()</code></td>
<td style="text-align:center">倒转链表</td>
</tr>
<tr>
<td style="text-align:center"><code>unique()</code></td>
<td style="text-align:center">如果有多个连续的值相等的元素，则只保留第一个，移除后续所有，可自定义比较器</td>
</tr>
<tr>
<td style="text-align:center"><code>sort()</code></td>
<td style="text-align:center">排序链表，默认升序，可自定义比较器</td>
</tr>
</tbody>
</table>
<h3 id="std-unordered-map">std::unordered_map</h3>
<blockquote>
<p>定义于头文件 <code>&lt;unordered_map&gt;</code></p>
</blockquote>
<p><code>std::map</code> 底层采用红黑树实现，会对 key 进行排序，适用于对有序有要求的场景，缺点是内存占用大。</p>
<p><code>std::unordered_map</code> 底层采用哈希表实现，并不会进行排序，且查找时间几乎为 $O(1)$，适用于查找多的场景。用法几乎与 <code>std::map</code> 一样。</p>
<h3 id="std-unordered-set">std::unordered_set</h3>
<blockquote>
<p>定义于头文件 <code>&lt;unordered_set&gt;</code></p>
</blockquote>
<p>其之于 <code>std::set</code> 就好比 <code>std::unordered_map</code> 之于 <code>std::map</code>。略。</p>
<h3 id="std-array">std::array</h3>
<blockquote>
<p>定义于头文件 <code>&lt;array&gt;</code></p>
</blockquote>
<p><code>std::array</code> 是将静态的连续一维数组进行封装的容器，方便内存的管理与释放，遵循<strong>聚合初始化</strong>规则，使用<strong>初始化列表</strong>进行初始化。与 <code>std::vector</code> 的区别在于无法对数组大小进行修改，即没有 <code>push_back()</code> 之类的操作，因而更加精简。可以通过以下操作访问元素：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>at(index)</code>：访问指定下标的元素；</p>
</li>
<li class="lvl-2">
<p><code>operator[]</code>：访问指定下标的元素；</p>
</li>
<li class="lvl-2">
<p><code>front()</code>：等价于 <code>at(0)</code>；</p>
</li>
<li class="lvl-2">
<p><code>back()</code>：等价于 <code>at(size-1)</code>；</p>
</li>
<li class="lvl-2">
<p><code>data()</code> 返直接访问底层数组；</p>
</li>
<li class="lvl-2">
<p>全局函数 <code>std::get&lt;index&gt;(array)</code>；</p>
</li>
</ul>
<p>并且类内使用 <code>fill()</code> 函数来代替之前的 <code>memset()</code> 操作。</p>
<h3 id="std-tuple">std::tuple</h3>
<blockquote>
<p>定义于头文件 <code>&lt;tuple&gt;</code></p>
</blockquote>
<p>​	<code>std::tuple</code> 是固定大小的值集合，却不要求这些值都为相同类型。它是 <code>std::pair</code> 的拓展，<code>std::pair</code> 可以视为只容纳两个元素的 <code>std::tuple</code>。<code>std::tuple</code> 拥有从 <code>std::pair</code> 的转换赋值。</p>
<p>可以通过以下操作构造一个 tuple：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>常规初始化；</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> t1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 列表初始化</span>
std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">t2</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 拷贝初始化</span>
std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token function">t3</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 移动初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>函数模板 <code>make_tuple&lt;Types...&gt;(args...)</code> 创建一个 tuple 对象，并根据 <code>Types</code> 定义具体类型；</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> t <span class="token operator">=</span> <span class="token function">make_tuple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2.0</span><span class="token punctuation">,</span> <span class="token char">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 模板自动推导</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p><code>tie(args...)</code> 创建<strong>左值引用</strong>组成的 tuple，或将接收到的 tuple / pair 进行解包；</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unordered_set<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> s<span class="token punctuation">;</span>
<span class="token keyword">bool</span> result<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">tie</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>ignore<span class="token punctuation">,</span> result<span class="token punctuation">)</span> <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果一个函数需要返回多个值，则可以返回一个 tuple 或是 pair，然后用 <code>std::tie</code> 将收到的返回值 <code>[iterator, bool]</code> 解包为 <code>std::ignore</code> 与 <code>result</code>。这里 <code>std::ignore</code> 为一个常量，是一个<strong>占位符</strong>，表示这里不需要任何变量接收。</p>
<blockquote>
<p>相当于 Go 里面的 <code>_</code>。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><code>forward_as_tuple(args...)</code> 创建<strong>转发引用</strong>组成的 tuple；</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>unordered_map<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&gt;</span> m<span class="token punctuation">;</span>

<span class="token comment">// 插入 (1, "aa")</span>
m<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>piecewise_construct<span class="token punctuation">,</span>
          std<span class="token double-colon punctuation">::</span><span class="token function">forward_as_tuple</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>       <span class="token comment">// 1 转发给 int 初始化</span>
          std<span class="token double-colon punctuation">::</span><span class="token function">forward_as_tuple</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2, 'a' 转发给 string 初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p><code>tuple_cat(tuples...)</code> 连接任意数量的 tuple；</p>
</li>
</ul>
<p>并可以通过全局函数 <code>std::get&lt;index&gt;(tuple)</code> 访问 tuple 对象的第 index 个元素。</p>
<h2 id="新的算法">新的算法</h2>
<blockquote>
<p>定义于头文件 <code>&lt;algorithm&gt;</code></p>
</blockquote>
<h3 id="std-all-of-std-any-of-std-none-of">std::all_of / std::any_of / std::none_of</h3>
<p><code>std::all_of(first, last, pred)</code> 检查迭代器范围 <code>[first, last)</code> 内是否均满足 <code>pred</code>；</p>
<p><code>std::any_of(first, last, pred)</code> 检查迭代器范围 <code>[first, last)</code> 内是否存在一个元素满足 <code>pred</code>；</p>
<p><code>std::none_of(first, last, pred)</code> 检查迭代器范围 <code>[first, last)</code> 内是否均不满足 <code>pred</code>；</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">all_of</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="std-find-std-find-if-std-find-if-not">std::find / std::find_if / std::find_if_not</h3>
<p><code>std::find(first, last, value)</code> 返回迭代器范围 <code>[first, last)</code> 内第一个 <code>operator== (value)</code> 返回 true 的元素<strong>的迭代器</strong>；</p>
<p><code>std::find_if(first, last, pred)</code> 返回迭代器范围 <code>[first, last)</code> 内第一个满足 <code>pred</code> 的元素<strong>的迭代器</strong>；</p>
<p><code>std::find_if_not(first, last, pred)</code> 返回迭代器范围 <code>[first, last)</code> 内第一个不满足 <code>pred</code> 的元素<strong>的迭代器</strong>；</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>std<span class="token double-colon punctuation">::</span><span class="token function">find_if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">&gt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output: 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="std-copy-std-copy-if-std-copy-n">std::copy / std::copy_if / std::copy_n</h3>
<p><code>std::copy(first, last, begin)</code> 复制迭代器范围 <code>[first, last)</code> 内所有元素到 <code>begin</code> 开始的范围；</p>
<p><code>std::copy_if(first, last, begin, pred)</code> 与上面相比，仅复制满足 <code>pred</code> 的元素；</p>
<p><code>std::copy_n(first, count, begin)</code> 复制从 <code>first</code> 开始的 <code>count</code> 个元素到 <code>begin</code> 开始的范围；</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> new_nums<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">copy_n</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> new_nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// new_nums = {1, 2, 3, 4, 5}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="std-is-partitioned">std::is_partitioned</h3>
<p><code>std::is_partitioned(first, last, pred)</code> 检查迭代器范围 <code>[first, last)</code> 内是否所有满足 <code>pred</code> 的元素都在不满足 <code>pred</code> 的元素之前</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_partitioned</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> i <span class="token operator">&lt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="std-is-sorted">std::is_sorted</h3>
<p><code>std::is_sorted(first, last{, comp})</code> 检查迭代器范围 <code>[first, last)</code> 内是否有序。可自定义比较器 <code>comp</code>，默认为非降序，即 <code>comp &lt;=&gt; operator&lt;</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span><span class="token function">is_sorted</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// output: true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h3 id="std-minmax">std::minmax</h3>
<p><code>std::minmax(a, b{, comp})</code> 返回 <code>a</code>，<code>b</code> 中较小值与较大值<strong>的引用</strong>，并打包为 <code>std::pair</code> 返回，可自定义比较器 <code>comp</code>。</p>
<p>若需要返回至少三个元素中的最小值与最大值的引用，则改为版本 <code>std::minmax(initializer_list{, comp})</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> minm<span class="token punctuation">,</span> maxm<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">tie</span><span class="token punctuation">(</span>minm<span class="token punctuation">,</span> maxm<span class="token punctuation">)</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">minmax</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> minm <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> maxm<span class="token punctuation">;</span>
<span class="token comment">// output: 1 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="std-minmax-element">std::minmax_element</h3>
<p><code>std::minmax_element(first, last{, comp})</code> 返回迭代器范围 <code>[first, last)</code> 中较小值与较大值<strong>的迭代器</strong>，并打包为 <code>std::pair</code> 返回，可自定义比较器 <code>comp</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>iterator min_iter<span class="token punctuation">,</span> max_iter<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">tie</span><span class="token punctuation">(</span>min_iter<span class="token punctuation">,</span> max_iter<span class="token punctuation">)</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">minmax_element</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>min_iter <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>max_iter<span class="token punctuation">;</span>
<span class="token comment">// output: 1 5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="std-itoa">std::itoa</h3>
<p><code>std::itoa(first, last, value)</code> 以 value 为起始，并不断以 <code>++value</code> 填充迭代器范围 <code>[first, last)</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">nums</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">itoa</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 异常处理(Exception)</title>
    <url>/c/c-exception/</url>
    <content><![CDATA[<p><strong>异常</strong>，在操作系统中指的是指令内部出现的"<strong>内中断</strong>"，如除数为零，地址越界等。这些情况在程序中也时有发生，C++ 为了应对偶发的程序异常事件，引入了<strong>异常处理</strong>机制。其基于三个关键字：<code>try</code>，<code>throw</code> 与 <code>catch</code>。</p>
<span id="more"></span>
<h2 id="异常处理流程">异常处理流程</h2>
<p>一个完整的异常处理流程如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>异常处理</span></div><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token comment">/* code */</span>
  <span class="token keyword">throw</span> SomeException<span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ExceptionType_1<span class="token operator">&amp;</span> e1<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Response to exception */</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ExceptionType_2<span class="token operator">&amp;</span> e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Response to exception */</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ExceptionType_3<span class="token operator">&amp;</span> e3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Response to exception */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>try</code> 块会正常执行代码，而 <code>throw</code> 表达式则是针对性地抛出一个<strong>异常对象</strong>。</p>
<blockquote>
<p>理论上，你可以在 <code>try</code> 内任何地方使用 <code>throw</code> 语句抛出异常。</p>
</blockquote>
<p>一旦抛出了异常，则 <code>try</code> 块后续不再执行，而是进行<strong>栈回溯</strong>：</p>
<ol>
<li class="lvl-3">
<p>异常对象构造完成时，以当前 <code>try-catch</code> 层为起点；</p>
</li>
<li class="lvl-3">
<p>按出现顺序将当前层每个 <code>catch</code> 块的形参类型和异常对象类型进行比较，如果当前层存在匹配，那么控制流跳到匹配的 <code>catch</code> 块；</p>
</li>
<li class="lvl-3">
<p>反之，<strong>逃逸</strong>到外层，若此时依然处于 <code>try-catch</code> 块内，则重复步骤 2；</p>
</li>
<li class="lvl-3">
<p>调用 <code>std::terminate()</code> 终止程序。</p>
</li>
</ol>
<blockquote>
<p>匹配规则为：</p>
<ul class="lvl-1">
<li class="lvl-2">形参类型与抛出类型<strong>相同</strong>，或</li>
<li class="lvl-2">形参类型为抛出类型的<strong>左值引用</strong>、<strong>基类</strong>、<strong>基类引用</strong>；</li>
</ul>
<p>所以如果派生类的 <code>catch</code> 在基类的 <code>catch</code> 之后，那么按照顺序策略，派生类子句将永远无法执行——能被派生类接收的一定能被基类接收。</p>
<p><strong>注意</strong>，<code>throw</code> 出的异常对象类型取静态类型，即便存在运行时多态。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>取静态类型</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Base</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      Derived d<span class="token punctuation">;</span>
      Base<span class="token operator">*</span> b <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span>
      std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"make exception "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
      <span class="token keyword">throw</span> <span class="token operator">*</span>b<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Derived<span class="token operator">&amp;</span> d<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"catch "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" success"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>Base<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"catch "</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" success"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// make exception 6Derive</span>
<span class="token comment">// catch 4Base success</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管 <code>*b</code> 在 <code>typeid</code> 算子下为 <code>Derived</code> 类型，但抛出后仍被识别为 <code>type Base</code>，无法被 <code>Derived&amp;</code> 接收。于是栈回溯到外层，与 <code>catch(Base&amp;)</code> 子句匹配，执行对应的代码。</p>
</blockquote>
<p>当然，你甚至可以在 <code>try-catch</code> 外再套一层 <code>try-catch</code>，是为<strong>重抛</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>重抛</span></div><code class="language-cpp"><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> SomeException<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ExceptionType<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* Do somthing */</span>
    <span class="token comment">// throw e; // 复制本子句接受到的异常对象 e，然后抛出新的异常对象，e 被释放</span>
                <span class="token comment">// 这里的 e 可以改为其它任意新声明的异常对象，比如 ExceptionType e1; throw e1;</span>
    <span class="token keyword">throw</span><span class="token punctuation">;</span>      <span class="token comment">// 重抛出本子句接受到的异常对象 e，不会额外复制</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>ExceptionType<span class="token operator">&amp;</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* Do something */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>异常对象</strong>指的是由 <code>throw</code> 表达式在未指明的存储中构造的<strong>临时对象</strong>，不允许出现任何**<a href="https://zh.cppreference.com/w/cpp/language/type#.E4.B8.8D.E5.AE.8C.E6.95.B4.E7.B1.BB.E5.9E.8B">不完整类型</a><strong>、<strong>抽象类</strong>、<strong>右值引用</strong>或</strong>指向不完整类型的指针**（<code>void*</code> 除外）的异常对象。并且对于异常对象类，其构造、析构函数必须公开。</p>
<p>与其他临时对象不同，异常对象在初始化 <code>catch</code> 子句形参时被认为是左值，所以它可以用左值引用捕获、修改及重抛，并且将驻留在所有可能激活的 <code>catch</code> 语句都能访问到的内存空间中，在成功匹配的 <code>catch</code> 语句的结束处被自动析构。</p>
<p>异常对象存放在内存的<strong>特殊位置</strong>，既不是栈也不是堆，<strong>该对象由异常机制负责创建和释放</strong>，所以避免 <code>throw new</code> 的做法，存在内存泄漏的问题。bugfree 起见，<strong>强烈建议</strong>使用派生自 <code>std::exception</code> 的类型来抛出异常对象，并且按<strong>左值引用</strong>捕获！</p>
<h3 id="std-excecption">std::excecption</h3>
<p><code>std::exception</code> 是所有异常类的基类，提供统一接口，比如 <code>typeid</code>、<code>dynamic_cast</code>、<code>new</code> 抛出的异常都是派生自该类。如果希望自定义异常派生类，则需要实现的 public 函数有：</p>
<ol>
<li class="lvl-3">
<p>默认构造函数/初始化构造函数；</p>
</li>
<li class="lvl-3">
<p>拷贝构造函数；</p>
</li>
<li class="lvl-3">
<p>拷贝赋值运算符；</p>
</li>
</ol>
<p>基类有一个虚函数 <code>virtual const char* what() const noexcept</code>，用于返回解释该异常类型的字符串，一般通过重写该虚函数来实现表明不同异常的功能。</p>
<h2 id="noexcept">noexcept</h2>
<p>声明为 <code>noexcept</code> <strong>说明符</strong>的函数能够确定性地不抛出异常，也可以通过声明为 <code>noexcept(expr)</code> 的方式，若 <code>expr = true</code> 则等效于 <code>noexcept</code>；反之表明可能抛出异常。如果一个函数声明了 <code>noexcept</code> 还抛异常，编译能过，但会直接 <code>terminate()</code>。关于 <code>noexcept</code> 函数，有以下几点值得注意：</p>
<ol>
<li class="lvl-3">
<p>只有异常说明不同的函数无法实现重载。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>指向不会抛出的函数的指针能<strong>赋值</strong>给或<strong>隐式转换</strong>到指向可能抛出的函数的指针，反之不可；</p>
</li>
<li class="lvl-3">
<p>不抛异常的函数<strong>允许调用</strong>可能抛出的函数，如果该异常未被 <code>catch</code>，则 <code>terminate()</code>；</p>
</li>
<li class="lvl-3">
<p>如果基类虚函数不会抛出，那么所有派生类只要覆盖了该虚函数，无论声明还是定义，都必须不抛出；</p>
</li>
</ol>
<p>C<ins>17 以前还会用 <code>throw(类型列表)</code> 来显式列出函数可能抛出的异常，如果写作 <code>throw()</code> 则等效于 <code>noexcept</code>，但 C</ins>17 已将 <code>throw(类型列表)</code> 移除，且后面的 C++20 也把 <code>throw()</code> 给移除了，故不再深究。</p>
<p><code>noexcept</code> 还可以当成一个算子，如果 <code>expr</code> 不抛出异常，则 <code>noexcept(expr)</code> 返回 <code>true</code>，反之亦然。</p>
<p><strong>注意</strong>，<code>noexcept</code> 说明符不是一种编译时检查，只不过告知编译器函数是否会抛出异常。对于不会抛出的函数，编译器会进行更多优化。构造函数、析构函数、赋值运算符这些均隐式不抛出，除非其内部存在抛出的可能，也可以手动实现为可能抛出，而其它函数则不具备这一性质，所以如果明确知道某函数不抛异常，则可以显式指明 <code>noexcept</code>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 函数调用(Function Call)</title>
    <url>/c/c-function/</url>
    <content><![CDATA[<p>C++11 新增了若干使<strong>函数调用</strong>更加方便的特性。</p>
<span id="more"></span>
<h2 id="lambda-表达式">lambda 表达式</h2>
<p>lambda 表达式是<strong>闭包类型</strong>的<strong>纯右值</strong>变量，也可以称之为<a href="https://www.google.com.hk/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=&amp;ved=2ahUKEwijk6yxhNP8AhVY7XMBHQtYCeQQFnoECAwQAQ&amp;url=https%3A%2F%2Fzh.wikipedia.org%2Fwiki%2F%25E5%258C%25BF%25E5%2590%258D%25E5%2587%25BD%25E6%2595%25B0&amp;usg=AOvVaw0TjqSvvMd1ENd3yfCUYuz-"><strong>匿名函数</strong></a>。其基本用法为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> func <span class="token operator">=</span> <span class="token punctuation">[</span> 捕获 <span class="token punctuation">]</span> <span class="token punctuation">(</span> 参数列表 <span class="token punctuation">)</span> 可选说明符 <span class="token operator">-&gt;</span> 返回值类型 <span class="token punctuation">{</span> 函数体 <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h3 id="捕获">捕获</h3>
<p>换句话说就是能够在函数体内使用捕获的变量。lambda 表达式支持以下捕获方式：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>[]</strong>：不捕获任何变量，但 lambda 表达式能够直接使用全局变量以及函数形参；</p>
</li>
<li class="lvl-2">
<p><strong>[=]</strong>：<strong>值捕获</strong>，以拷贝方式捕获所有外部变量；</p>
</li>
<li class="lvl-2">
<p><strong>[&amp;]</strong>：<strong>引用捕获</strong>，以引用方式捕获所有外部变量；</p>
</li>
<li class="lvl-2">
<p><strong>[i]</strong>：仅值捕获指定变量 <code>i</code>；</p>
</li>
<li class="lvl-2">
<p><strong>[=, &amp;i]</strong>：值捕获所有外部变量，以引用方式捕获指定变量 <code>i</code>；</p>
</li>
<li class="lvl-2">
<p><strong>[this]</strong>：以引用方式捕获当前对象；</p>
<blockquote>
<p>事实上，若 lambda 表达式在类成员函数中，只要出现了捕获符，则隐式引用捕获当前类对象 <code>this</code>。</p>
</blockquote>
</li>
</ul>
<h3 id="可选说明符">可选说明符</h3>
<p>在 C++11 中，说明符只有 <code>mutable</code>。不加上该说明符，编译器会将值捕获的对象视为<strong>常量</strong>，只能调用其 const 成员函数；只有加上后，捕获对象的 const 限定消除，才能修改值捕获的对象，以及调用它们的非 const 成员函数。就像这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A a<span class="token punctuation">;</span>

<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// ERROR! 不能修改 const 对象 a 且调用非 const 成员函数 foo()</span>
  <span class="token operator">++</span>a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> g <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">mutable</span> <span class="token punctuation">{</span>  <span class="token comment">// OK! 加入 mutable 后禁制解除</span>
  <span class="token operator">++</span>a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> h <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// OK! 引用捕获不受影响</span>
  <span class="token operator">++</span>a<span class="token punctuation">.</span>i<span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  a<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="延迟调用">延迟调用</h3>
<p>在值捕获的情况下，除了会将捕获的对象视为 const，还会发生下面这种情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
a<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>从这个例子中不难发现，在捕获阶段 lambda 表达式的相关变量值就已经确定，尽管之后发生了修改，表达式内的变量也不会随之改变，这就是值捕获的<strong>延迟特性</strong>。如果希望值随着外部变化一起修改，则需要采用<strong>引用捕获</strong>。</p>
<h3 id="悬垂引用">悬垂引用</h3>
<p>值捕获存在这样那样的注意事项，但引用捕获也并不是完美的。当引用捕获的对象在 lambda 表达式调用之前就已经因生命周期结束而被回收时，此时若在 lambda 表达式中使用该对象，那么会发生<strong>未定义行为</strong>。比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A<span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span>a<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a<span class="token operator">-&gt;</span>x<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> a<span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 不一定报错，但 Undefined behavior</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>lambda 并不能延长对象的生命周期，这是值得注意的。</p>
<h3 id="思考">思考</h3>
<p>lambda 表达式作为一种变量存在，其又能通 <code>operator()</code> 来进行函数体的调用，不难发现，它与<strong>仿函数</strong>很像，即重载了 <code>operator()</code> 的类（<strong>函数对象</strong>），而该类的构造函数以及成员变量也由 lambda 表达式的捕获符来决定。</p>
<p>相比于传统函数，lambda 表达式胜在简洁方便，就地定义，让程序员更加灵活自由地在诸如 <code>std::sort</code> 等函数下编写自定义规则。由于不少语言都开始加入了匿名函数的特性，一定程度上揭示了未来编程的趋势。</p>
<h2 id="std-function">std::function</h2>
<blockquote>
<p>使用 <code>std::function</code> 需包含 <code>&lt;functional&gt;</code> 头文件。</p>
</blockquote>
<p><code>std::function</code> 是一个包装器，能够存储复制和调用任何<strong>可调用对象</strong>。函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">R</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">function</span><span class="token operator">&lt;</span><span class="token function">R</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其中 <code>R</code> 为返回值类型，<code>Args</code> 为参数包。</p>
<p>之所以新建这一个类，是为了起到"<strong>类型消除</strong>"的目的——将所有可调用对象的类型进行统一，从而方便编程。存储的可调用对象被称为 <code>std::function</code> 的<strong>目标</strong>。若 <code>std::function</code> 不含目标，则称它为<strong>空</strong>。对空实例的调用会抛出 <code>std::bad_function_call</code> 异常。</p>
<blockquote>
<p>跟秦始皇统一六国差不多(bushi</p>
</blockquote>
<h3 id="std-funtion-operator">std::funtion::operator()</h3>
<p>函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">R <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span> Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>等效于进行 <code>INVOKE&lt;R&gt;(f, std::forward&lt;Args&gt;(args)...) </code>，其中 <code>f</code> 是实例目标，相当于是将收到的参数包<strong>转发</strong>给目标可调用对象，实际操作依然为 <code>f(args)</code>。</p>
<h3 id="可调用对象">可调用对象</h3>
<p>先来说说什么是可调用对象。可调用对象简单来说就是给定合适的参数列表，其能够返回某个值。常见的可调用对象有以下几种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>函数/函数指针；</p>
</li>
<li class="lvl-2">
<p>lambda 表达式；</p>
</li>
<li class="lvl-2">
<p>函数对象；</p>
</li>
<li class="lvl-2">
<p>类成员函数/成员函数指针；</p>
</li>
<li class="lvl-2">
<p>类非静态成员变量指针；</p>
</li>
<li class="lvl-2">
<p><code>std::bind</code> 表达式；</p>
</li>
</ul>
<h3 id="使用方法">使用方法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p>存储<strong>函数</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>函数</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 存储 void(int) 类型的函数</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 1</span>
<span class="token comment">// or</span>
f <span class="token operator">=</span> <span class="token operator">&amp;</span>foo<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>存储<strong>模板函数</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>模板函数</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T i<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>foo<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>存储 <strong>lambda 表达式</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>lambda 表达式</span></div><code class="language-cpp">std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 3</span>

<span class="token comment">// 同时，可以利用其在 lambda 表达式中模拟递归</span>
<span class="token keyword">auto</span> factorial <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> fac <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> n<span class="token operator">*</span><span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 而 lambda 表达式 auto fac = [&amp;](int n){...}; 无法用于递归</span>
    <span class="token keyword">return</span> <span class="token function">fac</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// output: 24</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>存储<strong>函数对象</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>函数对象</span></div><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 必须是重载类型为 void operator() (int) 类型的函数对象</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>存储<strong>类成员函数</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>类成员函数</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">num_</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">foobar</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> num_ <span class="token operator">+</span> i<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> num_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Foo <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
 必须传入函数指针，视为 void(Foo::*)(int) 类型，
 否则会因为调用无实例的非静态成员函数而报错。
 由于成员函数通过一个名为 this 的额外隐式参数来访问调用它的那个对象，
 也就是第一个参数，
 故 const Foo&amp; 必须为第一个形参类型，视为 this
 */</span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> <span class="token operator">&amp;</span>Foo<span class="token double-colon punctuation">::</span>foobar<span class="token punctuation">;</span>
<span class="token function">f</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相当于调用 foo.foobar(3)</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式调用构造函数 Foo(123)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>🎈存储<strong>类成员变量访问器</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>类成员变量访问器</span></div><code class="language-cpp">std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span>Foo <span class="token keyword">const</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> g <span class="token operator">=</span> <span class="token operator">&amp;</span>Foo<span class="token double-colon punctuation">::</span>num_<span class="token punctuation">;</span> <span class="token comment">// 理由同上</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">g</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相当于调用 foo.num_</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>存储 <strong>std::bind 表达式</strong></p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>std::bind 表达式</span></div><code class="language-cpp"><span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> h<span class="token punctuation">;</span>

h <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span> <span class="token operator">&amp;</span>Foo<span class="token double-colon punctuation">::</span>foobar<span class="token punctuation">,</span> foo<span class="token punctuation">,</span> _1 <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 由于绑定了对象 foo，所以生成的可调用对象被 std::function&lt;void(int)&gt; 接收</span>
<span class="token comment">// 或者 h = std::bind( &amp;Foo::foobar, &amp;foo, _1 );</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 相当于调用 foo.foobar(4)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ul>
<h3 id="思考-2">思考</h3>
<p>于是乎，如果希望某一函数能够接受一个可调用对象的形参，实际传参时再也不用纠结是传函数指针还是 lambda 表达式了，一个 <code>std::function</code> 统统搞定。</p>
<h2 id="std-bind">std::bind</h2>
<p><code>std::bind</code> 将部分<strong>固定参数</strong> <code>args</code> 和可调用对象 <code>f</code> 绑定到一起生成一个新的可调用对象（或称<strong>转发器</strong>） <code>binder</code>，剩下的未绑定参数被 <code>std::placeholders</code> 的占位符 <code>_1, _2, _3...</code> 所替换。调用 <code>binder</code> 时，参数会被转发给 <code>f</code>，事实上调用的还是 <code>f</code>。</p>
<p>乍一眼看上去这与 <code>std::function</code> 相性非常相似，事实上 <code>std::bind</code> 生成的转发器可以由 <code>std::function</code> 接纳存储，以便随时调用，就和上面示例的那样。</p>
<h3 id="使用方法-2">使用方法</h3>
<p>先上例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">+</span> j <span class="token operator">+</span> k<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">;</span>
<span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>placeholders<span class="token double-colon punctuation">::</span>_3<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">void</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> f <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> _1<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>bar<span class="token punctuation">,</span> _3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 21  实际上调用了 foo(1, 2, bar(9)) 即 foo(1, 2, 18);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>来解释一下这个例子：</p>
<p><code>std::placeholders::_1</code> 对应了 <code>f()</code> 中的第一个参数，也就是 <strong>1</strong>。<code>std::placeholders::_3</code> 对应了 <code>f()</code> 中的第三个参数，也就是 <strong>9</strong>。而第二个参数 <strong>5</strong> 对应的占位符 <code>std::placeholders::_2</code> 由于并不在 <code>std::bind</code> 绑定的参数列表中，故无影响。</p>
<p>不难发现，<code>std::placeholders::_n</code> 会被实际传入的参数包中的第 n 个参数取代。但参数也不能乱传，还是要遵循可调用对象的实际情况，比如上面的 <code>foo</code> 需要 3 个参数，那么 <code>f</code> 就传 3 个，只不过这三个参数最终会被如何转发，就得看 <code>std::bind</code> 的规则（参数绑定情况）了。转发过程如下图所示：</p>
<img src="image-20230120005740049.png" alt="image-20230120005740049" style="zoom:67%;">
<p>对象 <code>f</code> 根据 <code>operator()</code> 收到的三个参数传回 <code>std::function</code> 类中，根据 <code>std::forward</code> 转发给目标可调用对象。由于存储的同样是一个转发器，故参数包会先发给 <code>std::bind</code>，其根据编写好的自定义规则经过处理后再次转发给其绑定的目标可调用对象 <code>foo</code>，完成最终函数调用。</p>
<blockquote>
<p>内层的 <code>std::bind(bar, 9)</code> 会先转发给可调用对象 <code>bar</code>，获取返回值后再让外层转发。</p>
</blockquote>
<h2 id="总结">总结</h2>
<p>以上三种特性让用户进行函数调用时更灵活自由，极大的提高了编程效率。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 泛型编程(Generics)</title>
    <url>/c/c-generics/</url>
    <content><![CDATA[<p><strong>泛型编程</strong>是程序设计语言的一种风格或范式，允许程序员在编写代码时使用一些以后才指定的类型，在实例化时作为参数指明这些类型。在 C++ 里，这是与 OOP 并列的一大分支，通过<strong>模板</strong>来实现。</p>
<span id="more"></span>
<h2 id="Why-模板？">Why 模板？</h2>
<p>现在有一个需求，就是写一个简单的 <code>swap</code> 函数，要求支持所有内置类型。在模板出来以前，C++ 允许同名函数重载，于是我们可以针对不同类型分别定义。<code>int</code>、<code>double</code>、<code>char</code>、……写着写着发现，我们最后需要实现的函数的数量是所有内置类型总数的平方！并且一旦后续添加了更多类型，我们又要编写更多函数！（不失为一个提高代码量的好方法，但毫无意义）并且维护代码的成本变得极高，一旦某一个 <code>swap</code> 函数出了问题，我们需要在巨大的头文件中找到那个出错的函数，仿佛大海捞针一般。</p>
<p>针对这些缺点，C++ 提出了<strong>泛型编程</strong>，也就是写一种与类型无关的代码，或者说是提供一个模板，提高代码的复用性。所谓<strong>模板</strong>，便是给定一套规范以及一定的占位符，根据用户后续对占位符进行不同形式的填充来产生不同的效果。C++ 里可以通过模板来定义一族函数、一族类，甚至是一族变量。</p>
<h2 id="函数模板">函数模板</h2>
<p><strong>函数模板</strong>定义一族函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>模板形参列表<span class="token operator">&gt;</span> 函数声明<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><strong>模板形参</strong>可以是以下项的任意排列组合：</p>
<ol>
<li class="lvl-3">
<p><strong>非类型形参</strong>：仅允许带有 cv 限定的左值引用、指针、整型、枚举类型，类对象以及字符串是不允许的，C++20 起还允许浮点型；</p>
</li>
<li class="lvl-3">
<p><strong>类型形参</strong>：形如 <code>typename|class T</code>，类型名 <code>T</code> 是可选的；</p>
</li>
<li class="lvl-3">
<p><strong>模板形参</strong>：形如 <code>template&lt;形参列表&gt; typename|class T</code>，类型名 <code>T</code> 是可选的；</p>
</li>
<li class="lvl-3">
<p>上述的<strong>形参包</strong>；</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>swap 函数可以写成这样</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> first<span class="token punctuation">,</span> T<span class="token operator">&amp;</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  T temp <span class="token operator">=</span> first<span class="token punctuation">;</span>
  first <span class="token operator">=</span> second<span class="token punctuation">;</span>
  second <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意</strong>，函数模板自身并不是类型、函数或任何其他实体，不会从只包含模板定义的源文件生成任何代码。函数模板只有<strong>实例化</strong>后才会有代码出现。所谓<strong>实例化</strong>，就是用实参填充模板形参列表，让编译器生成指定类型函数，不用定义函数实现。实例化一个函数模板需要知道它的所有模板实参，但不需要指定每个模板实参，允许编译器进行<strong>隐式实例化</strong>，即<strong>模板实参推导</strong>，即尽可能从函数实参推导缺失的模板实参。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>模板实参推导</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 隐式实例化。允许省略尖括号，编译器会自动进行模板实参推导</span>
              <span class="token comment">// 推导结果为 swap&lt;int&gt;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output: 2 1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>在模板出现以前，对同名函数的重载如果只有某些值的类型不同，那么需要为每一个值定义一遍函数，这是非常麻烦的。有了模板，就能直接在函数名后用尖括号带上特定的类型即可。</p>
</blockquote>
<p>对于特定的实现，我们或许不想要依照原来函数模板那样执行，而是自定义函数体，这也是可以的。<strong>函数模板特化</strong>能够将某一个或某几个要处理的数据类型进行单独处理，但需要额外定义对应数据类型的模板函数，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>函数模板特化</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> first<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"我不 swap，哎，就是玩\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> a <span class="token operator">=</span> <span class="token char">'a'</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token char">'b'</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">func</span><span class="token punctuation">(</span>a， b<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 推导结果为 func&lt;char&gt;，于是使用特化的函数模板</span>
<span class="token punctuation">}</span>
<span class="token comment">// output: 我不 swap，哎，就是玩</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果同时又加上一个这样的普通函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>优先识别为普通函数</span></div><code class="language-cpp"><span class="token keyword">char</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">&amp;</span> first<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> second<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"只因你太美\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>那么原来的代码会输出 <code>只因你太美</code>，这是因为在省略尖括号时，编译器在<strong>编译时</strong>会试图优先将其识别为普通函数，此时如果找到对应的普通函数，则直接调用，而不会进行后续的实参推导。如果希望优先识别为特化后的模板函数，则需要加上尖括号，这样才能让编译器知道噢原来这是个模板函数。</p>
<blockquote>
<p>实际上，调用顺序为<strong>普通函数 &gt; 模板特化函数 &gt; 模板函数</strong>。</p>
</blockquote>
<h2 id="类模板">类模板</h2>
<p>与函数模板一样，<strong>类模板</strong>定义一族类。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>模板形参列表<span class="token operator">&gt;</span> 类声明<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>模板形参列表与函数模板完全一致。<strong>注意</strong>，类模板自身并不是类型、对象或任何其他实体，不会从只包含模板定义的源文件生成任何代码。类模板同样只有<strong>实例化</strong>后才会有代码出现，并且也支持<strong>类模板实参推导</strong>，即尽可能从类构造函数实参推导缺失的模板实参。此外，类模板的<strong>特化</strong>还进一步分为了<strong>全特化</strong>与<strong>偏特化</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>类模板特化</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">First</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Second</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">MyPair</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">MyPair</span><span class="token punctuation">(</span>First f_<span class="token punctuation">,</span> Second s_<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">f</span><span class="token punctuation">(</span>f_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s</span><span class="token punctuation">(</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"No specialization: "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  First f<span class="token punctuation">;</span>
  Second s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">First</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Second</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token class-name">MyPair</span><span class="token operator">&lt;</span>First<span class="token punctuation">,</span> Second<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 类模板的函数在类外实现，需要加上模板参数列表</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 偏特化 1</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">First</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">MyPair</span><span class="token operator">&lt;</span>First<span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span> <span class="token comment">// 偏特化时需加上模板参数列表，以指明特化了哪个形参</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">MyPair</span><span class="token punctuation">(</span>First f_<span class="token punctuation">,</span> <span class="token keyword">char</span> s_<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">f</span><span class="token punctuation">(</span>f_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s</span><span class="token punctuation">(</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"specialization &lt;First, char&gt;: "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  First f<span class="token punctuation">;</span>
  <span class="token keyword">char</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 偏特化 2</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">Second</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">MyPair</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> Second<span class="token operator">&gt;</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">MyPair</span><span class="token punctuation">(</span><span class="token keyword">int</span> f_<span class="token punctuation">,</span> Second s_<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">f</span><span class="token punctuation">(</span>f_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s</span><span class="token punctuation">(</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"specialization &lt;int, Second&gt;: "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> f<span class="token punctuation">;</span>
  Second s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 全特化</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">MyPair</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">MyPair</span><span class="token punctuation">(</span><span class="token keyword">int</span> f_<span class="token punctuation">,</span> <span class="token keyword">char</span> s_<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">f</span><span class="token punctuation">(</span>f_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">s</span><span class="token punctuation">(</span>s_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"specialization &lt;int, char&gt;: "</span> <span class="token operator">&lt;&lt;</span> f <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> s <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> f<span class="token punctuation">;</span>
  <span class="token keyword">char</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  MyPair<span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">pair1</span><span class="token punctuation">(</span><span class="token number">3.14</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 显式实例化</span>
  MyPair <span class="token function">pair2</span><span class="token punctuation">(</span><span class="token number">2.7</span><span class="token punctuation">,</span> <span class="token char">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 推导结果为 MyPair&lt;double, char&gt;</span>
  MyPair <span class="token function">pair3</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment">// 推导结果为 MyPair&lt;int, char&gt;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// No specialization: 3.14 1</span>
<span class="token comment">// specialization &lt;First, char&gt;: 2.7 a</span>
<span class="token comment">// specialization &lt;int, char&gt;: 1 b</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与函数模板不同的是，类模板不能与普通同名类共存，即若上述代码中又定义了一个 <code>class MyPair</code>，则编译报错。</p>
<h2 id="派生">派生</h2>
<p>类模板、模板类和普通类之间可以互相派生。它们之间的派生关系有以下几种情况。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>模板类派生</span></div><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base1</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// case 1.1: 模板类派生类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive11</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base1</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> T val<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// case 1.2: 模板类派生普通类</span>
<span class="token keyword">class</span> <span class="token class-name">Derive12</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>类模板派生</span></div><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base2</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// case 2.1: 类模板派生类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive21</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base2</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>普通类派生</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base3</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// case 3.1: 普通类派生类模板</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive31</span><span class="token operator">:</span> <span class="token base-clause"><span class="token class-name">Base3</span></span> <span class="token punctuation">{</span> T val<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// case 3.2: 普通类派生普通类，略</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多态">多态</h2>
<p>子类和父类的模板参数列表可以不一样，但必须一一对应。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>模板中的多态</span></div><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>T<span class="token punctuation">,</span> U<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive1</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">char</span> b<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive1 foo():"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derive2</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">U</span><span class="token punctuation">,</span> <span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>U a<span class="token punctuation">,</span> T b<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive2 foo():"</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">char</span><span class="token operator">&gt;</span><span class="token operator">*</span> ptr1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derive1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 必须用 Base&lt;int, char&gt;* 指向，因为 Derive1 就是派生自该模板类</span>
  ptr1<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 调用 Derive1::foo(int, char)</span>

  Base<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">double</span><span class="token operator">&gt;</span><span class="token operator">*</span> ptr2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token generic-function"><span class="token function">Derive2</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">double</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 与继承顺序一一对应</span>
  ptr2<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">3.14</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 Derive2::foo(int, double)</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// Derive1 foo():1 2</span>
<span class="token comment">// Derive2 foo():3 3.14</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>上面代码写的不规范，按道理有虚函数的类应该为其设置一个虚析构函数，上面分别有两个特化的基类 <code>Base&lt;int, char&gt;</code> 与 <code>Base&lt;int, double</code>，就需要分别定义两个特化类并设置虚析构函数。</p>
</blockquote>
<h2 id="成员模板">成员模板</h2>
<p>任意类都可以在体内嵌套声明类模板/函数模板。规则：</p>
<ol>
<li class="lvl-3">
<p>析构函数和复制构造函数不能是模板；</p>
</li>
<li class="lvl-3">
<p>成员函数模板不能为虚，且派生类中的成员函数模板不能覆盖来自基类的虚成员函数；</p>
</li>
<li class="lvl-3">
<p>可以声明具有相同名字的非模板成员函数和模板成员函数。在冲突的情况下，执行效果如同之前讨论的函数模板那样；</p>
</li>
</ol>
<h2 id="形参包">形参包</h2>
<p>形参包分为两种：</p>
<ol>
<li class="lvl-3">
<p><strong>模板形参包</strong>是接受零个或更多个模板实参的模板形参；</p>
</li>
<li class="lvl-3">
<p><strong>函数形参包</strong>是接受零个或更多个函数实参的函数形参。</p>
</li>
</ol>
<p>至少有一个形参包的模板被称作<strong>变参模板</strong>。</p>
<p><strong>变参类模板</strong>可以用任意数量的模板实参实例化，以 <code>std::tuple</code> 为例，其定义为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>可变参类模板</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Types<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">tuple</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token operator">&gt;</span> t0<span class="token punctuation">;</span>           <span class="token comment">// Types 不包含实参</span>
std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> t1<span class="token punctuation">;</span>        <span class="token comment">// Types 包含一个实参：int</span>
std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&gt;</span> t2<span class="token punctuation">;</span> <span class="token comment">// Types 包含两个实参：int 与 float</span>
std<span class="token double-colon punctuation">::</span>tuple<span class="token operator">&lt;</span><span class="token number">0</span><span class="token operator">&gt;</span> error<span class="token punctuation">;</span>       <span class="token comment">// ERROR! 0 不是类型</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>变参函数模板</strong>也是同理，可以用任意数量的函数实参调用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>可变参函数模板</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Types<span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span>Types<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// OK：args 不包含实参</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// OK：args 包含一个实参：int</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK：args 包含两个实参：int 与 double</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="一些疑问">一些疑问</h2>
<h3 id="Why-非类型模板形参？">Why 非类型模板形参？</h3>
<blockquote>
<p>把非类型模板形参放到函数参数列表里，或者类的构造函数里，不是效果也差不多吗，为什么要多此一举设置一个非类型模板形参呢？</p>
</blockquote>
<p>首先要明确的一点是，非类型模板实参必须是 <code>constexpr</code> 且能转换为整类型的字面量，这就使得我们<strong>能够利用一个在编译时可知的自定义参数</strong>。而 <code>constexpr</code> 变量是不能用作函数形参的，如果是类构造函数，则无法进行自定义，所以总有缺陷。</p>
<p><code>std::tuple</code> 的 <code>get()</code> 函数正是采用了非类型模板形参，而不是将下标参数作为函数参数，因为我们需要确定返回值的类型，而这无法在运行时确定。借助非类型模板形参，就可以在编译时确定返回值类型，还能提高运行效率。</p>
<blockquote>
<p>本质上相当于是编译器为 <code>tuple</code> 里的每个元素都生成一个对应的获取函数。</p>
</blockquote>
<h3 id="类模板的声明和实现为什么不能放在不同的文件里？">类模板的声明和实现为什么不能放在不同的文件里？</h3>
<p>对于普通类而言，声明可以放在 <code>.h</code> 文件中，而成员函数的实现可以写在 <code>.cpp</code> 里。这是因为多个 <code>.cpp</code> 会先被编译成若干目标代码文件 <code>.obj</code>，最后链接到一起形成可执行文件。在编译的过程中，编译器能够知道足够信息，比如形参类型，从而根据 <code>.cpp</code> 里的成员函数实现生成目标代码。</p>
<blockquote>
<p>这也有利于对外隐藏实现，直接将实现文件打包成库，和头文件一起发布。</p>
</blockquote>
<p>而对于类模板，如果也将成员函数实现写在 <code>.cpp</code> 里，比如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>test.h</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">test</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">private</span><span class="token operator">:</span>
    T value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>test.cpp</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T test<span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  value <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后又在另一个 <code>.cpp</code> 文件里生成了 <code>test&lt;int&gt; t</code> 并且调用 <code>t.set(1)</code>，进行编译会报 <code>undefined reference</code> 错误。</p>
<p>《C++ 编程思想》第 15 章(P300)说明了原因：模板定义很特殊。由 <code>template&lt;…&gt;</code> 处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义。</p>
<p>意思就是说，在调用 <code>t.set(1)</code> 的时候，由于当前文件里没有这一函数的定义，所以编译器仅仅是生成一个符号，并寄希望于链接器在其他 <code>.obj</code> 文件中找到该函数的定义。然而，正如上面说的，在处理 <code>test.cpp</code> 的时候，<strong>编译器并不会对 <code>set()</code> 函数生成任何目标代码</strong>——因为编译器根本不知道 <code>T</code> 实际是什么！所以最后链接的时候只能在头文件 <code>test.h</code> 里找到答案。</p>
<p>很遗憾，头文件中只有声明，没有定义。我们不知道调用的这个函数具体应该做什么，也就产生了上面那个错误。</p>
<p>为了解决这一问题，有两种方法：</p>
<ol>
<li class="lvl-3">
<p>将声明和定义统一放在头文件中；</p>
</li>
<li class="lvl-3">
<p>将声明和定义分离，但在 <code>.cpp</code> 中显式实例化声明，比如下面这样：</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>test.cpp</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
T test<span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> v<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  value <span class="token operator">=</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token keyword">class</span> <span class="token class-name">test</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token comment">// 实例化声明</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样做的缺点就是必须为所有类型添加实例化声明，这样编译器才能在处理 <code>test.cpp</code> 时生成正确的目标代码。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 列表初始化(List Initialize)</title>
    <url>/c/c-init/</url>
    <content><![CDATA[<p>在 C++11 中，可以直接在变量名后面用 <strong><code>{初始化列表}</code></strong> 来进行对象的初始化。</p>
<span id="more"></span>
<h2 id="旧世界">旧世界</h2>
<p>C++11 以前，各种初始化方式如神仙打架，百花齐放，在同一个项目中，你或许可以看到如以下几种不同的初始化方式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">i_</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">i_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> i_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> nums<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 数组列表初始化</span>
A a0<span class="token punctuation">;</span>                    <span class="token comment">// 默认初始化</span>
A <span class="token function">a1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 值初始化</span>
A <span class="token function">a2</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment">// 直接初始化</span>
A a3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>                <span class="token comment">// 先通过调用 A(3) 构建临时对象，再复制初始化</span>
B b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token comment">// 聚合初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这使得程序员，或者初学者们经常会感到疑惑：这么多的对象初始化方式，怎样去初始化一个变量或者是一个对象？不仅增加了学习成本，也使得代码风格有较大出入，影响了代码的可读性和统一性。</p>
<blockquote>
<p>其中聚合初始化<strong>仅</strong>适用于<strong>聚合类型</strong>，通常为<strong>数组</strong>类型，或满足以下条件的<strong>类</strong>类型（通常是 <code>struct</code> 或 <code>union</code>）：</p>
<ol>
<li class="lvl-3">没有用户声明或继承的构造函数；</li>
<li class="lvl-3">没有 <code>protected</code> / <code>private</code> 的非静态数据成员；</li>
<li class="lvl-3">没有基类；</li>
<li class="lvl-3">没有虚函数；</li>
<li class="lvl-3">没有类内直接初始化的非静态数据成员；</li>
<li class="lvl-3">没有默认成员初始化器；</li>
</ol>
</blockquote>
<h2 id="新世界！列表初始化">新世界！列表初始化</h2>
<p>为了统一代码，C++11 将列表初始化的功能进行拓展，使其能够应用于绝大多数构造情况，同样的，<code>new</code> 操作符等可以用圆括号进行初始化的地方，也可以使用初始化列表。如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">i_</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">i_</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span>i_<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> i_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

A <span class="token function">a0</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
A a1<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
A a2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// ERROR! A(const A&amp;) 为 private</span>
A a3 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// OK! 列表初始化，私有拷贝函数无影响，直接应用于其数据 i_</span>
A<span class="token operator">*</span> a4 <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不仅如此，列表初始化还可以直接使用在函数的返回值上，亦可以用于 STL 中。自此，初始化代码规范得到了统一，程序员再也不用纠结于初始化方式的挑选了。</p>
<p>除了提高代码可读性这点优势，列表初始化还对基本数据类型的隐式转换作出了<strong>窄化限制</strong>，避免<strong>精度丢失</strong>，比如：</p>
<ol>
<li class="lvl-3">
<p>从浮点类型到整数类型的转换；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1.2</span><span class="token punctuation">;</span>   <span class="token comment">// OK!</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1.2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ERROR!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>从整数类型到浮点类型的转换，除非源是常量表达式且不发生截断；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// OK!</span>
<span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! -1 为 11..11，转换到 float 会将高位 1 截断</span>
<span class="token keyword">float</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// OK!</span>
<span class="token keyword">float</span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">long</span> <span class="token keyword">long</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>   <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>从整数或无作用域枚举类型到不能表示原类型所有值的整数类型的转换，除非源是常量表达式且不发生截断；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">char</span> c <span class="token operator">=</span> a<span class="token punctuation">;</span>   <span class="token comment">// OK!</span>
<span class="token keyword">char</span> d <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! 发生截断</span>

<span class="token keyword">char</span> e <span class="token operator">=</span> b<span class="token punctuation">;</span>   <span class="token comment">// OK!</span>
<span class="token keyword">char</span> f <span class="token operator">=</span> <span class="token punctuation">{</span>b<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// OK! 不发生截断，但如果去掉 const 属性，也报错</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>路线 <code>long double -&gt; double -&gt; float</code> 的转换，除非来源是常量表达式且不发生溢出；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">float</span> c <span class="token operator">=</span> <span class="token number">1e70</span><span class="token punctuation">;</span>   <span class="token comment">// OK!</span>
<span class="token keyword">float</span> d <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1e70</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! double -&gt; float</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 内联函数(Inline)</title>
    <url>/c/c-inline/</url>
    <content><![CDATA[<p><strong><code>inline</code></strong> 只能用于修饰函数，能够解决一些频繁调用的小函数大量消耗栈内存的问题，是一种提高程序运行效率的手段。</p>
<span id="more"></span>
<h2 id="inline-基本">inline 基本</h2>
<p>众所周知，函数的调用需要消耗栈内存，每次调用一个函数，就会在栈中分配一片函数所需内存（如参数压栈），但栈内存大小是有限的，频繁使用就会造成因栈内存不足而导致程序出错的问题（经典<strong>段错误</strong>），比如函数的死循环递归调用。</p>
<p>关键字 <code>inline</code> 所带来的就是在编译时期在函数调用处进行函数体内容展开（代码<strong>复制</strong>），换句话说就是不用执行正常的进入函数的步骤，直接执行函数体，这样一来就无需进行栈内存的分配。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"inline func1"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"non-inline func2"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// inline 必须与定义在一起，否则不生效</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 等价于写作 std::cout &lt;&lt; "inline";</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>乍一看跟宏定义 <code>#define</code> 很像，但 <code>inline</code> 修饰的函数具有<strong>类型检查</strong>功能，更加安全。</p>
<p>但 <code>inline</code> 也不是万能的，它只适用于短小精悍，最好只有没几行的函数，并且不能有 <code>while</code>、<code>switch</code> 这类结构控制语句，更不能是递归函数，因为这类函数最大的特点在于，执行函数体的开销小于调用函数的开销。</p>
<blockquote>
<p>毕竟如果调用函数开销相比于直接执行函数体的开销很小或忽略不计，那 <code>inline</code> 就收效甚微了，甚至可能因为代码的复制导致内存消耗反而进一步增大，这是适得其反的。</p>
</blockquote>
<p><code>inline</code> 还可以进行类成员函数的修饰。事实上，在类内定义的函数，除了虚函数以外，均会隐式地视作 <code>inline</code> 函数；类外定义的函数则需要程序员显式 <code>inline</code>，否则当作普通成员函数对待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>             <span class="token comment">// 类内定义，隐式 inline</span>
  <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>   <span class="token comment">// 类外定义，显式 inline</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>by the way，<code>inline</code> 只作为程序员对编译器的<strong>建议</strong>，具体是否进行内联还是由编译器来决定。如果它决定对一个函数进行内联，那它会执行以下操作：</p>
<ol>
<li class="lvl-3">将 inline 函数体复制到 inline 函数调用点处；</li>
<li class="lvl-3">为所用 inline 函数中的局部变量分配内存空间；</li>
<li class="lvl-3">将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中；</li>
<li class="lvl-3">如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 <code>goto</code>）。</li>
</ol>
</blockquote>
<p>上面说到，“在类内定义的函数，除了虚函数以外，均会隐式地视作 <code>inline</code> 函数”，那么，<strong>虚函数</strong>能否用 <code>inline</code> 修饰？</p>
<p>根据上面的讨论我们知道，<code>inline</code> 是编译时期的作为，而当虚函数表现为多态特性时，则需要在运行时进行虚表的查询以及调用，此时如果虚函数为 <code>inline</code> 那就不太合适了——编译器并不知道运行时会调用哪个版本的函数，也就无法执行代码复制。</p>
<p>仅当编译器能够确定调用函数的类时，才能对虚函数应用 <code>inline</code>，比如用对象实例而非指针或引用。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 内存分配(Memory Allocation)</title>
    <url>/c/c-memory/</url>
    <content><![CDATA[<p>众所周知，C++ 是一门与内存紧密相关的语言，本文就来聊聊 C++ 眼中的<strong>内存分配</strong>。</p>
<span id="more"></span>
<h2 id="内存布局">内存布局</h2>
<p>C++ 程序的内存分为 5 大区域，分别为<strong>代码区</strong>、<strong>常量存储区</strong>、<strong>全局/静态存储区</strong>、<strong>堆区</strong>、<strong>栈区</strong>，每个区域存放不同类型的数据：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>代码区(.text)</strong>：存放可执行程序(.exe)的机器码；</p>
</li>
<li class="lvl-2">
<p><strong>常量存储区(.rodata)</strong>：存放<strong>常量</strong>，不允许修改；</p>
</li>
<li class="lvl-2">
<p><strong>全局/静态存储区(.bss/.data)</strong>：<strong>全局变量</strong>与<strong>静态变量</strong>被分配到同一片内存；</p>
<blockquote>
<p>C 里会根据变量初始化与否细分为 data 和 bss，but C++ not。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>堆区(heap)</strong>：通过库函数 <code>malloc()</code> 动态分配的数据所在处，地址从低向高增长。如果堆区某片内存没有通过 <code>free()</code> 释放，则在程序结束后由操作系统自动回收，但如果不及时释放，那么后续很可能无法分配到足够的内存；</p>
<blockquote>
<p>C++ 里有个概念叫<strong>自由存储区</strong>，专指通过运算符 <code>new</code> 分配得到的内存区域。当使用默认 <code>new</code> 时，会分配堆区的内存，此时自由存储区=堆区，也可以进行运算符重载，改用其他内存来实现自由存储，例如全局变量做的对象池，这样自由存储区就不一定是堆区了。所以说是<strong>自由</strong>嘛(</p>
<p>总而言之，堆区是操作系统维护的一块内存，而自由存储区是 C++ 中通过 <code>new</code> 与 <code>delete</code> 动态分配和释放对象的抽象概念，与堆并不等价。</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>栈区(stack)</strong>：程序局部变量、函数参数值、函数返回值所在处，由编译器自动管理分配，地址从高向低增长；</p>
</li>
</ul>
<h2 id="内存分配-in-C">内存分配 in C</h2>
<p>在 C 中，使用 <code>alloc()</code> 系库函数来进行内存的动态分配。</p>
<h3 id="malloc">malloc()</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">malloc</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>size_t size <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>分配一片连续的 <code>size</code> 个字节的<strong>未初始化</strong>存储。成功时，返回指向分配的适合对任何标量类型对齐的内存块中，最低（首）字节的指针；反之，返回空指针。</p>
<blockquote>
<p>使用时需强转为所需类型的指针。</p>
</blockquote>
<p>🔔 调用 <code>malloc</code> 分配内存时，会有两种方式向操作系统申请</p>
<ol>
<li class="lvl-3">
<p>小于某个阈值（如 128KB）时，使用 <code>brk()</code> 系统调用在堆上分配内存；</p>
</li>
<li class="lvl-3">
<p>大于某个阈值时，使用 <code>mmap()</code> 系统调用在文件映射区上分配内存；</p>
</li>
</ol>
<h3 id="calloc">calloc()</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">calloc</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>size_t num<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t size <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>分配 <code>num</code> 个大小为 <code>size</code> 的对象的数组，并<strong>初始化</strong>所有 bit 为零。成功时，返回指向为任何对象类型适当对齐的，被分配内存块最低（首）字节的指针；反之，返回空指针。</p>
<blockquote>
<p>相当于初始化 + <code>malloc(num * size);</code></p>
</blockquote>
<h3 id="realloc">realloc()</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token function">realloc</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t new_size <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>重分配（扩张或收缩）给定的内存区域 <code>ptr</code> 大小至 <code>new_size</code>。注意这里的再分配不一定在原区域的基础上，而有可能重新分配一片新空间。成功时，返回指向新分配内存起始的指针；反之，返回空指针，且原指针保留。</p>
<blockquote>
<p>它必须是 <code>malloc()</code>、 <code>calloc()</code> 或 <code>realloc()</code> 先前分配的，且仍未被 <code>free()</code> 释放，否则 UB。</p>
</blockquote>
<h3 id="free">free()</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">free</span><span class="token punctuation">(</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>与 <code>alloc</code> 系搭配使用，用于手动释放动态分配的堆内存空间。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>若 <code>ptr</code> 为空指针，则什么也不做；</p>
</li>
<li class="lvl-2">
<p>若 <code>ptr</code> 并未指向经 <code>alloc</code> 动态分配的空间，则为 UB；</p>
</li>
<li class="lvl-2">
<p>对同一个 <code>ptr</code> 多次 <code>free</code> 的行为为 UB；</p>
</li>
<li class="lvl-2">
<p>对已 <code>free</code> 的 <code>ptr</code> 进行内存访问，为 UB；</p>
</li>
</ul>
<p>注意，<code>free</code> 仅仅是释放了指针指向的那片内存，并没有改变指针的指向，但 <code>free</code> 之后再次使用指针是 UB，应当置空。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"before free: %p\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"after free: %p\n"</span><span class="token punctuation">,</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// WARNING!</span>

ptr <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>                      <span class="token comment">// nullptr in C++</span>

<span class="token comment">// output:</span>
<span class="token comment">// before free: 000001EF641FCFB0</span>
<span class="token comment">// after free: 000001EF641FCFB0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="内存分配-in-C-2">内存分配 in C++</h2>
<p>而在 C++ 中，由于引入了<strong>类</strong>这一概念，<code>alloc</code> / <code>free</code> 这种只能分配/释放内存的函数并不足以满足需求——<code>alloc</code> 分配内存时并不会调用构造函数，并且如果 <code>free</code> 简单地释放了一个类对象的内存，那么其析构函数不会被调用，这搞不好会引发大灾难。于是，它俩被功能更强大的 <code>new</code> / <code>delete</code> 所取代。</p>
<h3 id="new-delete">new / delete</h3>
<blockquote>
<p>定义于头文件 <code>&lt;new&gt;</code></p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>use of new/delete</span></div><code class="language-cpp"><span class="token double-colon punctuation">::</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>布置参数<span class="token punctuation">)</span><span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">(</span>类型<span class="token punctuation">)</span> 初始化器<span class="token punctuation">(</span>opt<span class="token punctuation">)</span> <span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">*</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// p1 指向 int 变量，并初始化为 1</span>
<span class="token keyword">int</span><span class="token operator">*</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">}</span><span class="token punctuation">;</span>  <span class="token comment">// p2 指向数组 int[2]，并初始化为 {114, 514}</span>
<span class="token keyword">int</span><span class="token operator">*</span> p3 <span class="token operator">=</span> <span class="token keyword">new</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span> <span class="token keyword">int</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 定位 new，不需要额外分配内存，而是直接在已分配的内存(p1)处调用构造函数即可</span>
<span class="token keyword">int</span><span class="token operator">*</span> p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>nothrow<span class="token punctuation">)</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 分配失败时不抛出异常，而是返回 nullptr</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> p2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p3 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>p4<span class="token punctuation">;</span>

<span class="token keyword">delete</span> p1<span class="token punctuation">;</span>    <span class="token comment">// 单变量用 delete</span>
<span class="token keyword">delete</span><span class="token punctuation">[</span><span class="token punctuation">]</span> p2<span class="token punctuation">;</span>  <span class="token comment">// 数组用 delete[]</span>
<span class="token keyword">delete</span> p3<span class="token punctuation">;</span>
<span class="token keyword">delete</span> p4<span class="token punctuation">;</span>

<span class="token comment">// output: 3 114 514 3 4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>new</code> / <code>new[]</code> 主要完成两件事：</p>
<ol>
<li class="lvl-3">
<p>底层 <code>operator new()</code> 调用 <code>malloc()</code> 动态分配内存；</p>
</li>
<li class="lvl-3">
<p>在分配的动态内存块上调用构造函数以初始化对象。成功时返回首地址，否则抛出 <code>std::bad_alloc()</code> 异常（可以通过加 <code>std::nothrow</code> 改变）；</p>
</li>
</ol>
<p><code>delete</code> / <code>delete[]</code> 也主要完成两件事：</p>
<ol>
<li class="lvl-3">
<p>调用析构函数；</p>
</li>
<li class="lvl-3">
<p>底层 <code>operator delete()</code> 释放内存；</p>
</li>
</ol>
<h3 id="定位-new-placement-new">定位 new(placement new)</h3>
<p>上面的代码提到了一种叫<strong>定位 new</strong> 的操作，它的意义在于将内存的<strong>分配和构造分离</strong>。</p>
<blockquote>
<p>如果内存分配与构造不分离，则存在以下弊端：</p>
<ol>
<li class="lvl-3">可能会构造出我们用不到的对象；</li>
<li class="lvl-3">初始化与后续使用时各进行一次赋值，产生不必要的开销；</li>
</ol>
<blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> ptr <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// 默认初始化赋值一次</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token punctuation">;</span>       <span class="token comment">// 后续又进行了一次赋值</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<ol start="3">
<li class="lvl-3">
<p>没有默认初始化函数的类甚至执行不了 <code>new[]</code> 操作；</p>
</li>
</ol>
</blockquote>
<p>而借助定位 new 来进行对象的构建，上述弊端则迎刃而解：一方面可以避免频繁调用系统 <code>new</code> / <code>delete</code> 带来的开销，另一方面可以手动控制内存的分配和释放以及类的构造，更加自由。</p>
<blockquote>
<p>使用此法，则不一定会在<strong>堆</strong>上分配内存，而是在对应地址处直接构造。</p>
</blockquote>
<h3 id="重载-operator-new">重载 operator new()</h3>
<p><code>new</code> / <code>delete</code> 是关键字，我们无法修改其功能本身，但其底层所使用的运算符 <code>operator new()</code> / <code>operator delete()</code> 则能为我们根据需要所重载使用。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"operator new override\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token function">malloc</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo<span class="token operator">*</span> f <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span>
  <span class="token keyword">delete</span> f<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output: operator new override</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>遇到 <code>new Foo</code> 时，编译器首先在类和其基类中寻找 <code>operator new()</code>，找不到就在全局中找，再找不到就用默认的。我们在类中重载了该操作符，且对操作符的重载默认为 <code>static</code>，于是底层会调用 <code>Foo::operator new() (sizeof(Foo));</code></p>
<p>当然，重载形式也可以加入更多参数，但第一个参数必须为 <code>size_t</code> 类型，且返回值必须为 <code>void*</code> 类型。比如上面说的定位 new，就是在参数列表中加了一个 <code>void*</code> 的重载形式。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size_t size<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"placement new override\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> ptr<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo<span class="token operator">*</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> Foo<span class="token punctuation">;</span>
  Foo<span class="token operator">*</span> f <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>temp<span class="token punctuation">)</span> Foo<span class="token punctuation">;</span>
  <span class="token keyword">delete</span> temp<span class="token punctuation">;</span>
  <span class="token comment">// delete f;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output: placement new override</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>相当于底层调用了  <code>Foo::operator new() (sizeof(Foo), temp);</code>。此时就不用再 <code>delete f</code> 了，懂得都懂。</p>
<p>当然也可以加别的形参，比如 <code>void* operator new(size_t, int);</code>，使用时直接 <code>new(100) type;</code> 即可（圆括号里就是从除了 <code>size_t</code> 以外的实参列表）。之前提到的加上 <code>std::nothrow</code> 不会抛出异常则是使用了 <code>void* opertor new(size_t, nothrow_t&amp;)</code> 的重载形式。</p>
<h3 id="重载-operator-delete">重载 operator delete()</h3>
<p>重载 <code>operator delete()</code> 时需注意第一个参数必须为 <code>void*</code>，且返回值必须为 <code>void</code>。但并没有重载的必要，因为我们无法手动调用。但设置这个的意义在于与 <code>operator new()</code> 配套使用，只有 <code>operator new</code> 抛异常了，才会调用对应的 <code>operator delete</code>。若没有对应的 <code>operator delete</code>，则无法释放内存。</p>
<h3 id="其他">其他</h3>
<h4 id="delete-this-合法吗？">delete this 合法吗？</h4>
<p>合法，但必须保证：</p>
<ol>
<li class="lvl-3">
<p>this 对象是通过 <code>new</code> 在堆上分配的；</p>
</li>
<li class="lvl-3">
<p><code>delete this</code> 后没有人使用该对象/调用 this 了，使用成员变量/成员函数也不行；</p>
<blockquote>
<p>内存都没了还调用个 der</p>
</blockquote>
</li>
</ol>
<h4 id="如何定义一个只能在堆-栈上生成对象的类？">如何定义一个只能在堆/栈上生成对象的类？</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>只能在堆上</strong>：将析构函数设置为<strong>非公有</strong>。C++ 是静态绑定语言，编译器管理栈上对象的生命周期，编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性。若析构函数不可访问，则不能在栈上创建对象。</p>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>定义一个只能在堆上生成的类</span></div><code class="language-cpp"><span class="token comment">// Bad Example →_→</span>
<span class="token comment">// can't derive and inconvenient</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">Destory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// or delete this;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// Good Example ^_^</span>
<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> Bar<span class="token operator">*</span> <span class="token function">GetBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> Bar<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">Destory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p><strong>只能在栈上</strong>：将 <code>operator new()</code> 和 <code>operator delete()</code> 设置为<strong>私有</strong>。此时 <code>new</code> 的第一步操作（上面讲过）无法执行，进而无法在堆上生成。</p>
</li>
</ul>
<h4 id="为什么说-new-效率低">为什么说 new 效率低</h4>
<p><code>new</code> 的动态分配内存涉及到内核级行为，并且存在上锁的可能，会产生一定开销。进行分配时，如果不是定位 new，则会在任意位置进行分配，不易管理。</p>
<h2 id="分配器-Allocator">分配器 Allocator</h2>
<blockquote>
<p>定义于头文件 <code>&lt;memory&gt;</code></p>
</blockquote>
<p>C++ 的所有容器都是类模板，以 <code>std::vector</code> 为例，其在定义中包含了两个模板参数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>
  <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
  <span class="token keyword">class</span> <span class="token class-name">Allocator</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>allocator<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>第一个参数就是容器包含的元素类型，第二个参数就是下面要讲的<strong>分配器类</strong>，默认为 C++ 自带的 <code>std::allocator</code>。</p>
<p>所谓<strong>分配器</strong>，就是负责封装堆内存管理的对象，它们在整个标准库中使用，特别是 STL 容器使用它们来管理容器内部的所有内存分配。其最大的特点与意义在于，将内存分配与构造分离（正如定位 new 那样），这样就可以先分配大块内存，而只在真正需要时才执行对象创建操作。</p>
<p><code>std::allocator</code> 的成员函数如下：</p>
<blockquote>
<p>C++20 对分配器的成员函数进行了一些改动</p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>constexpr T* allocate(size_t n)</code>：分配足够的存储空间来存储 n 个实例，并返回指向它的指针；</p>
</li>
<li class="lvl-2">
<p><code>constexpr void deallocate(T* p, size_t n)</code>：释放分配的内存。p 必须是调用 <code>allocate()</code> 获得的指针，n 必须等于调用 <code>allocate()</code> 时传入的参数；</p>
</li>
<li class="lvl-2">
<p><code>void construct(T* p, Args ... args)</code>：使用参数 args 在 p 处构造一个对象。<strong>C++20 中移除</strong>；</p>
</li>
<li class="lvl-2">
<p><code>void destroy(T* p)</code>：调用 p 处对象的析构函数。<strong>C++20 中移除</strong>；</p>
</li>
</ul>
<blockquote>
<p>如果希望自定义分配器，可以直接继承自 <code>std::allocator</code>，然后重写分配/解分配策略。</p>
</blockquote>
<h2 id="未初始化内存算法">未初始化内存算法</h2>
<blockquote>
<p>定义于头文件 <code>&lt;memory&gt;</code></p>
</blockquote>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>constexpr void destroy_at(T*)</code>：销毁在给定地址的对象；</p>
</li>
<li class="lvl-2">
<p><code>constexpr void destroy(ForwardIt, ForwardIt)</code>：销毁一个范围中的对象；</p>
</li>
<li class="lvl-2">
<p><code>constexpr ForwardIt destroy_n( ForwardIt first, Size n )</code>：销毁范围中一定数量的对象；</p>
</li>
<li class="lvl-2">
<p><code>constexpr T* construct_at( T* p, Args&amp;&amp;... args )</code>：在给定地址创建对象；</p>
</li>
</ul>
<h2 id="智能指针">智能指针</h2>
<p>智能指针是针对裸指针进行封装的类，它能够更安全、更方便地使用动态内存。具体见 <a href="../../c/c-smartptr">C++11 の 智能指针</a>。</p>
<h2 id="内存泄漏及其常用工具">内存泄漏及其常用工具</h2>
<p>如果使用了 <code>malloc()/new</code> 分配内存却未调用 <code>free()/delete</code> 释放，那么指向该内存区域的指针（通常分配在栈上）将会因为生命周期结束而被释放，从而永远无法访问那片内存。在操作系统视角下，程序员没释放，那就是有可能使用，这块内存将被一直保留。一旦这种情况越来越多，那么后续再进行内存分配时，将会没有内存可用，这就是<strong>内存泄漏</strong>。</p>
<h3 id="Valgrind">Valgrind</h3>
<p>Valgrind 可以用来检测程序是否有非法使用内存的问题，例如访问未初始化的内存、访问数组时越界、忘记释放动态内存等问题。</p>
<p>构建项目时加上编译选项 <code>-g</code>，之后调用 <code>valgrind --tool=memcheck --leak-check=full  {可执行文件}</code> 即可进行内存问题检测。</p>
<h3 id="Address-Sanitizer">Address Sanitizer</h3>
<p>AddressSanitizer 是 Google 开发的一款用于检测内存访问错误的工具。它内置在 GCC 版本 &gt;= 4.8 中，适用于 C 和 C++ 代码。它能够检测：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>Heap buffer overflow</strong>：堆越界访问；</p>
</li>
<li class="lvl-2">
<p><strong>Stack buffer overflow</strong>：栈越界访问；</p>
</li>
<li class="lvl-2">
<p><strong>Global buffer overflow</strong>：全局缓冲区越界访问；</p>
</li>
<li class="lvl-2">
<p><strong>Use after free</strong>：访问指向<em>已释放内存</em>的野指针；</p>
</li>
<li class="lvl-2">
<p><strong>Use after return</strong>：访问指向<em>生命周期结束的局部变量</em>的野指针；</p>
</li>
<li class="lvl-2">
<p><strong>Use after scope</strong>：同上；</p>
</li>
<li class="lvl-2">
<p><strong>Initialization order bugs</strong>；</p>
</li>
<li class="lvl-2">
<p><strong>Memory leaks</strong>：内存泄漏，即分配但不释放；</p>
</li>
</ul>
<p>AddressSanitizer 可在使用运行时检测跟踪内存分配，这意味着必须使用 AddressSanitizer 构建代码才能利用它的功能。</p>
<p>构建项目时，用 <code>-fsanitize=address</code> 选项编译和链接（同时记得加上编译选项 <code>-g</code>）。此时可执行文件就进入 ASan 模式。在程序运行时首次检测到问题时，会打印错误信息并退出。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>main.c</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc <span class="token parameter variable">-fsanitize</span><span class="token operator">=</span>address <span class="token parameter variable">-g</span> main.c <span class="token parameter variable">-o</span> main
$ ./main
<span class="token comment">## 输出错误信息</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>和 Valgrind 相比，AddressSanitizer <strong>性能更高</strong>。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 可变说明符(Mutable)</title>
    <url>/c/c-mutable/</url>
    <content><![CDATA[<p><code>mutable</code> 意为<strong>可变的</strong>，可以在<strong>非引用非常量非静态</strong>数据成员的声明中出现，允许被常量类对象修改。</p>
<span id="more"></span>
<h2 id="类中的-mutable">类中的 mutable</h2>
<p>先聊聊一个有趣的话题，关于 <a href="../../c/c-const"><strong>const</strong></a> 类成员函数有两大观点流派：</p>
<ol>
<li class="lvl-3">
<p><strong>bitwise constness</strong>：主张成员函数只有在不更改对象的任何非静态成员变量时才被认为是 const，即<strong>绝对</strong>常量；</p>
<blockquote>
<p>事实上这正是 C++ 对<strong>常量性</strong>的定义。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>logical constness</strong>：主张 const 成员函数可以修改所处理对象内部的某些 bits，仅当用户看不出的情况才行，即<strong>自适应</strong>常量；</p>
</li>
</ol>
<p>对于第一种主张，有些成员函数并不具备 bitwise 特性，却能通过编译，一个很直观的例子便是，一个 const 类成员函数修改了类中某个指针指向的内容，却没有改变其指向：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>bitwise constness</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">TextBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> TextBlock <span class="token function">t</span><span class="token punctuation">(</span><span class="token string">"hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>t<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token char">'j'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>于是一个保有字符串 <code>"hello"</code> 的常量对象，并没有拿牢，而是被改为了 <code>"jello"</code>。</p>
<p>对于第二种主张，编译器并不支持这一做法，于是 <code>mutable</code> 关键字派上用场。如果将一个成员变量声明为 <code>mutable</code>（保证声明前提），则可以在 <code>const</code> 成员函数中对其进行修改，如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>logical constness</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">int</span> <span class="token function">AddAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token operator">++</span>bar<span class="token punctuation">;</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">mutable</span> <span class="token keyword">int</span> bar<span class="token punctuation">;</span> <span class="token comment">// 释放 bitwise constness 约束</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>主要用于指定不影响类的外部可观察状态的成员，通常在并发场景下搭配互斥锁使用。</p>
</blockquote>
<h2 id="lambda-表达式中的-mutable">lambda 表达式中的 mutable</h2>
<p>具体可参考<a href="../../c/c-function/#%E5%8F%AF%E9%80%89%E8%AF%B4%E6%98%8E%E7%AC%A6">本文</a>。</p>
<p>简单来说就是 lambda 表达式会将值捕获的变量视为 <code>const</code>，若想要对其进行修改需加上 <code>mutable</code> 说明符。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 面向对象(OOP)</title>
    <url>/c/c-oop/</url>
    <content><![CDATA[<p><strong>面向对象程序设计</strong>（Object-oriented programming, OOP）是种具有对象概念的程序编程典范，同时也是一种程序开发的抽象方针。</p>
<span id="more"></span>
<h2 id="封装">封装</h2>
<h3 id="装">装</h3>
<p><strong>装</strong>是指把数据与操作这些数据的函数绑定到一块，抽象成一个<strong>类</strong>。</p>
<p>C++11 引入移动语义之后，对于一个<strong>空类</strong>，编译器将为其默认生成以下 6 种特殊成员函数，且访问级别默认为 <code>public</code>（见下文）：<strong>默认构造函数</strong>、<strong>析构函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>、<strong>移动构造函数</strong>、<strong>移动赋值运算符</strong>。</p>
<h4 id="构造函数">构造函数</h4>
<p>所谓<strong>构造函数</strong>，便是以类名为函数名的一种特殊函数，无返回值，任意一个对象在<strong>创建</strong>时都会自动调用（在成员变量初始化之后），完成类成员变量的初始化以及基类（见下文）的初始化等工作。</p>
<p>其中，<strong>默认构造函数</strong>是初始化构造函数的一种特殊（无参）形式。所谓初始化构造函数，就是<strong>不以其他同类对象引用为参数</strong>的构造函数，即：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>用户可以自定义初始化构造函数，但会覆盖编译器原先生成的默认构造函数。如果需要使用默认构造函数，则需显式声明。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">Bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo a<span class="token punctuation">;</span> <span class="token comment">// ERROR! 默认构造函数被覆盖</span>
  Bar b<span class="token punctuation">;</span> <span class="token comment">// OK!</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>拷贝构造函数</strong>/<strong>移动构造函数</strong>就是仅以<strong>同类对象左值引用</strong>/<strong>同类对象右值引用</strong>为参数的构造函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>  <span class="token comment">// 拷贝构造，拷贝每一个 non-static 变量</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 移动构造，转移对象所有权</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>拷贝构造函数的形参也可以写为<strong>值传递</strong>，但这样会发生什么事呢？我们尝试调用值传递版本的拷贝构造函数 <code>Foo foo(another_foo)</code>，<code>another_foo</code> 因值传递而进行了一次形参拷贝，此时还需要调用一次拷贝构造函数，然后因值传递进行形参拷贝……直接死循环！而且值拷贝的过程也是申请内存的过程，接下来就看内存和 CPU 哪个先撑不住了~基于此，所有拷贝构造函数都应写为<strong>引用传递</strong>。</p>
<blockquote>
<p>关于<strong>移动语义</strong>，请参见<a href="../../c/c-value">此文</a>。</p>
</blockquote>
<p><strong>注意</strong>：想要用到的构造函数需声明为 <code>public</code>，否则创建对象时将报错，下面也是一样的~</p>
<h4 id="赋值运算符">赋值运算符</h4>
<p>与构造函数不同，赋值运算符仅在<strong>对象创建完毕</strong>后才能调用，拷贝语义/移动语义与前面提到的类似。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>  <span class="token comment">// 拷贝赋值</span>
  Foo<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Foo<span class="token operator">&amp;&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span> <span class="token comment">// 移动赋值</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>需要将返回值写为<strong>本类引用</strong>，以实现连锁赋值。</p>
</blockquote>
<p>那么下面这段代码，执行的是哪个函数呢？【<font color="white">拷贝构造函数</font>】</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Foo foo1 <span class="token operator">=</span> foo2<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="析构函数">析构函数</h4>
<p>析构函数以类名为函数名，需额外在前面加一个<code>~</code>，没有返回值，无需显式调用，一个对象的生命周期结束时，就会自动调用析构函数。析构函数主要完成释放对象内存的工作，但编译器默认生成析构函数只是尸位素餐，实际上什么都不干，真想利用析构函数做点什么的话，则需要自定义析构函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>注意</strong>：析构函数没有参数，不能被重载，因此一个类只能有一个析构函数~</p>
<p><strong>注意</strong>：<code>new</code> 出来的对象在堆上，如果不 <code>delete</code> 是不会自动执行析构函数的~</p>
<p><strong>注意</strong>：尽管某个类是多态类，但其默认生成的析构函数是 non-virtual 的，需手动声明~</p>
<blockquote>
<p>析构函数如果声明为 <code>private</code>，则<strong>无法在栈上创建对象</strong>。一般情况下都是要声明为 <code>public</code> 的。</p>
</blockquote>
<h3 id="封">封</h3>
<p><strong>封</strong>是指将这些数据与函数对外部隐藏，避免干扰与误用，从而确保安全。C++ 通过三大<strong>访问修饰符</strong>支持这一特性，可访问级别默认为 <code>private</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">可访问级别</th>
<th style="text-align:center">本类</th>
<th style="text-align:center">友元类/函数</th>
<th style="text-align:center">派生类</th>
<th style="text-align:center">其它</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>public</code></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center"><code>protected</code></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
</tr>
<tr>
<td style="text-align:center"><code>private</code></td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> value<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">value</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">int</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value is "</span> <span class="token operator">&lt;&lt;</span> foo<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token comment">// ERROR! Foo::value is private</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value is "</span> <span class="token operator">&lt;&lt;</span> foo<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK! Foo::getValue() is public</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="继承">继承</h2>
<p><strong>继承</strong>允许一个类（<strong>派生类</strong>）在另一个类（<strong>基类</strong>）的基础上进行设计，这使得创建和维护一个应用程序变得更容易，也达到了重用代码功能和提高执行效率的效果。</p>
<p>同样的，继承方式也有<strong>公有继承</strong>(public)，<strong>保护继承</strong>(protected)，<strong>私有继承</strong>(private)三种，如果未显式声明继承方式，则默认为私有继承。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>公有继承</strong>：基类的<strong>公有/保护</strong>成员将成为派生类的<strong>公有/保护</strong>成员，基类的<strong>私有</strong>成员仍不能直接被派生类访问；</p>
</li>
<li class="lvl-2">
<p><strong>保护继承</strong>：基类的<strong>公有/保护</strong>成员将成为派生类的<strong>保护</strong>成员。</p>
</li>
<li class="lvl-2">
<p><strong>私有继承</strong>：基类的<strong>公有/保护</strong>成员将成为派生类的<strong>私有</strong>成员。</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 将基类的 value 覆盖，如果要使用基类的成员变量 value，则需要加上 Base::</span>
  <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> Base<span class="token double-colon punctuation">::</span>value <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token comment">// 分别打印基类的 value 与自身的 value</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Derived d<span class="token punctuation">;</span>
  d<span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 1 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面展示了一个基本的继承过程。可以看到 <code>Derived</code> 可以将 <code>Base</code> 中的成员变量/函数进行覆盖，在 <code>Derived</code> 的命名空间中优先取 <code>Derived</code> 的成员。但覆盖后，基类的变量并不是消失了，而是依然可以通过 <code>Base::value</code> 进行访问，这是怎么做到的？类继承时，内存是如何分配的？不妨加入以下代码进行分析：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derived<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">&amp;</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
<span class="token comment">// output:</span>
<span class="token comment">// 4 8</span>
<span class="token comment">// 0x78fe10 1 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到，<code>Derived</code> 和 <code>Base</code> 的类大小分别为 4 和 8，恰好是 1 个 int 和 2 个 int 的大小，并且将 <code>Derived</code> 对象地址重新解读为 <code>int*</code> 时，发现有连续的一片内存分别存储了两个 int 值 1 与 2——这恰好是 <code>Base</code> 和 <code>Derived</code> 两个类对 <code>value</code> 初始化的值。这样一来就明朗许多——<code>Derived</code> 类对象的内存里最开始那一部分（4B）是专门分配给基类 <code>Base</code> 的，并且其内存布局为：</p>
<img src="image-20230215125309320.png" alt="image-20230215125309320" style="zoom:50%;">
<h3 id="虚继承">虚继承</h3>
<p>再来点更复杂的情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>菱形继承</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive1</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value1<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Base<span class="token double-colon punctuation">::</span>value <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive2</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value2<span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Base<span class="token double-colon punctuation">::</span>value <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Final</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Derive2</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Derive1</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">modify1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">Derive1</span><span class="token double-colon punctuation">::</span><span class="token function">modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">modify2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token class-name">Derive2</span><span class="token double-colon punctuation">::</span><span class="token function">modify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Final <span class="token operator">*</span>f <span class="token operator">=</span> <span class="token keyword">new</span> Final<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Base<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derive1<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Derive2<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Final<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

  <span class="token keyword">int</span> <span class="token operator">*</span>q <span class="token operator">=</span> <span class="token generic-function"><span class="token function">reinterpret_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Final<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>

  f<span class="token operator">-&gt;</span><span class="token function">modify1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Final<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token comment">// 4 8 8 16</span>
<span class="token comment">// 1 3 1 2</span>
<span class="token comment">// 1 3 2 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据上面的输出，我们发现，<code>Final</code> 分别继承了 <code>Derive1</code> 与 <code>Derive2</code>，也为这两个直接基类分配了各 8B 的内存空间。并且，<code>Final</code> 中的内存布局也是先 <code>Derive2</code> 后 <code>Derive1</code>，这与 <code>Final</code> 类声明中继承列表中的基类顺序是一致的。</p>
<p>但很快也就发现了问题：<code>Derive1</code> 与 <code>Derive2</code> 的基类 <code>Base</code> 并不位于同一片内存，这就导致对 <code>Derive1</code> 的那个 <code>Base</code> 进行修改时，并不会影响 <code>Derive2</code> 的 <code>Base</code>，还产生了二义性（上面这段代码中，<code>Final</code> 无法使用 <code>Base</code> 的变量）与数据冗余。这是我们不希望发生的——我们通常反而更希望 <code>Final</code> 的族谱中只有唯一的 <code>Base</code>。</p>
<p>如何解决这个问题？答案为使用关键字 <code>virtual</code> 的<strong>虚继承</strong>。对于每个指定为 <code>virtual</code> 的不同基类，最终派生对象中仅含有该类型的一个基类子对象，即使该类在继承层级中出现多次也是如此，只要它每次都以 <code>virtual</code> 继承。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>虚继承</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> value<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive1</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive2</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">virtual</span> <span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Final</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Derive2</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Derive1</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Final f<span class="token punctuation">;</span>
  f<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
  f<span class="token punctuation">.</span>Derive1<span class="token double-colon punctuation">::</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
  f<span class="token punctuation">.</span>Derive2<span class="token double-colon punctuation">::</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> f<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token comment">// 3</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>多继承在现实应用场景中容易出问题，尽量避免使用多继承。</p>
</blockquote>
<h3 id="派生类构造顺序">派生类构造顺序</h3>
<p>直接贴代码，有助于理解。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>派生类构造顺序</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B1</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B1 cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B1 des\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B2</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B2 cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B2 des\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B3</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B3 cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token function">B3</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B3 cons with "</span> <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B3 des\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B4</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B4 cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B4 des\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B5</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B3</span><span class="token punctuation">,</span> <span class="token class-name">B2</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  B4 b4<span class="token punctuation">;</span>
  B1 b1<span class="token punctuation">;</span>
  <span class="token function">B5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">b1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">b4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">B3</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B5 cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">B5</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"B5 des\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  B5 b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// B3 cons with 2</span>
<span class="token comment">// B2 cons</span>
<span class="token comment">// B4 cons</span>
<span class="token comment">// B1 cons</span>
<span class="token comment">// B5 cons</span>
<span class="token comment">// B5 des</span>
<span class="token comment">// B1 des</span>
<span class="token comment">// B4 des</span>
<span class="token comment">// B2 des</span>
<span class="token comment">// B3 des</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现，<strong>构造顺序</strong>为：</p>
<ol>
<li class="lvl-3">
<p>按继承列表顺序构造基类；</p>
</li>
<li class="lvl-3">
<p>按成员变量列出顺序初始化成员变量，如果成员变量为某个类的对象，则调用相应构造函数；</p>
</li>
<li class="lvl-3">
<p>调用自身构造函数；</p>
</li>
</ol>
<p>而初始化列表中对基类、成员变量的初始化不会影响相对顺序，只会影响调用构造函数的版本，比如 <code>B3(2)</code> 使得基类 <code>B3</code> 调用了构造函数 <code>B3(int)</code>。</p>
<blockquote>
<p>步骤 1, 2 中的类仍按同样的顺序递归构造。</p>
</blockquote>
<p><strong>析构顺序</strong>与构造顺序恰好相反。</p>
<h2 id="多态">多态</h2>
<p><strong>多态</strong>，即多种形态，能够使得不同的对象去完成同一件事时，产生不同的动作和结果。最常见的多态有<strong>静态多态</strong>与<strong>动态多态</strong>两种，</p>
<h3 id="静态多态">静态多态</h3>
<h4 id="重载">重载</h4>
<p><strong>重载</strong>可以实现<strong>静态多态</strong>。编译器编译的过程中，首先遇到函数的声明，此时会将函数的参数类型也加到函数符号中，而不仅仅是函数名，比如编译 <code>int foo(int a, char b)</code> 最后得到的符号可能类似于 <code>foo_int_char</code> 这样。编译器后续遇到函数调用时，根据传入实参类型，去符号表里找调用的是哪个函数。</p>
<blockquote>
<p>所以仅有返回值不一样的两个同名同参数列表函数并不构成重载。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>静态多态</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"int "</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">char</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"char "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Foo f<span class="token punctuation">;</span>
  f<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  f<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token char">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// int 1</span>
<span class="token comment">// char 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而 C 语言并不支持函数重载，因此编译 .c 的函数时不会带上函数的参数类型，一般只包括函数名。根据这一结论，如果想在 C++ 中调用 C 版本的函数，就需要用 <code>extern "C"</code> 进行修饰，来告诉编译器不要修改该函数名。</p>
<p>否则，它会按照重整后的名字去目标文件（.obj）中去寻找对应的函数，而目标文件中存放的却是不带参数类型的 C 版本的函数，名字对不上，就找不到。</p>
<h4 id="奇异返回模板模式-curiously-recurring-template-pattern-CRTP">奇异返回模板模式(curiously recurring template pattern, CRTP)</h4>
<p>CRTP 是一种 C++ 的设计模式，精巧地结合了继承和模板编程的技术，也可以用于实现静态多态。其原理可以由以下代码简述：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>CRTP</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// cout &lt;&lt; "Base::show()\n";</span>
      <span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">Derived</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived::show()\n"</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base<span class="token operator">&lt;</span>Derived<span class="token operator">&gt;</span><span class="token operator">*</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Derived</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  p<span class="token operator">-&gt;</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> p<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里 <code>Derived</code> 类继承自一个模板类，并且该模板类的模板参数恰好为 <code>Derived</code>。在 18 行，当我们用一个 <code>Base&lt;Derived&gt;</code> 指针指向一个 <code>Derived</code> 类对象内存，并在 19 行调用函数 <code>show()</code> 时，因为 <code>show()</code> 不是虚函数，所以会根据指针类型而非对象类型进行函数调用，易得此时调用的版本是 <code>Base::show()</code>。</p>
<p>而又因为 <code>Base::show()</code> 内部仅仅调用了 <code>Derived::show()</code>（此时已经将 <code>Base&lt;Derived&gt;</code> 进行实例化），所以尽管以基类指针指向派生类并调用了一个非虚函数，最终行为依然与调用了派生类的版本一致，给人一种动态多态的感觉，尽管实际上并没有。</p>
<p>🔔 CRTP 和虚函数相比，在编译器即可确定执行行为，省去了查虚函数表的操作，减少了一次访问内存的开销，进而性能更加优秀。像 clickhouse、boost 库都进行了大量 CRTP 的应用。</p>
<blockquote>
<p>一个很经典的例子就是：一个类可以从 <code>std::enable_shared_from_this&lt;&gt;</code> 中派生，继而获得了调用 <code>shared_from_this()</code> 的能力。即若一个类对象已经被若干 shared pointer 指向，那么调用该函数可以返回一个与这些 shared pointer 共享计数器的新 sp，而不是用 <code>std::make_shared(this)</code> 返回一个计数器为 1 的 sp，防止 double free。</p>
</blockquote>
<p>🔔 但不足之处在于，因为没有虚函数，就不会进行运行时动态绑定，也就无法生成虚函数表与获取 RTTI。</p>
<h3 id="动态多态">动态多态</h3>
<p><strong>动态多态</strong>依靠类的<strong>虚函数</strong>实现，在运行时完成绑定，编译器根据对象类型执行相应函数。</p>
<p>先来说说什么是虚函数。前面提到了虚继承，用到 <code>virtual</code> 关键字，事实上，如果一个函数被 <code>virtual</code> 修饰，那么这个函数就成为了<strong>虚函数</strong>。正常情况下，虚函数表现的和普通函数一样，而一旦通过<strong>基类指针</strong>或<strong>引用</strong>调用虚函数，多态发生了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>动态多态</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive1</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive1 foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derive2</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derive2 foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base base<span class="token punctuation">;</span>
  Derive1 derive1<span class="token punctuation">;</span>
  Derive2 derive2<span class="token punctuation">;</span>
  base<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  Base<span class="token operator">*</span> base_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>derive1<span class="token punctuation">;</span>
  base_ptr<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  Base<span class="token operator">&amp;</span> base_ref <span class="token operator">=</span> derive2<span class="token punctuation">;</span>
  base_ref<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// Base foo</span>
<span class="token comment">// Derive1 foo</span>
<span class="token comment">// Derive2 foo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现，<code>base_ptr</code> 与 <code>base_ref</code> 虽然为 <code>Base*</code> 与 <code>Base&amp;</code> 类型，但却能与派生类 <code>Derive1</code> / <code>Derive2</code> 绑定，并且这两者调用虚函数 <code>foo()</code> 时，执行的效果如同派生类对象执行的那样，并且进一步发现，<strong>调用哪个类型的虚函数，取决于基类指针指向或引用的对象是哪种类型的对象</strong>。这便实现了多态。</p>
<p>而不使用指针或引用直接调用，则与普通函数无异，就比如 <code>base.foo()</code> 表现的那样。</p>
<p>值得注意的是，需要派生类进行了虚函数的<strong>重写/覆盖</strong>才能达到这一效果，即要求<strong>派生类中有一个和基类完全相同的虚函数</strong>。在这里，<code>Base</code> 和 <code>Derived</code> 的 <code>foo()</code> 函数（不管 <code>virtual</code>）正是完全相同的。如果派生类并没有进行重写，则会按照派生类的直接基类来。在多继承语境下，需避免二义性。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Final</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Derived</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Final f<span class="token punctuation">;</span>

  Base <span class="token operator">*</span>base_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>f<span class="token punctuation">;</span>
  base_ptr<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// Derived foo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>有一个例外，就是<strong>协变</strong>，也就是基类和派生类的返回值类型的相对关系与基类和派生类的相对关系一样，并且继承方式也相同（即族谱路线都一样），此时也满足多态，不需要返回值类型相同。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>协变</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">C</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> A <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base foo\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  B <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived foo\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Final</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Derived</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  C <span class="token operator">*</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Final foo\n"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> C<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base b<span class="token punctuation">;</span>
  Final f<span class="token punctuation">;</span>

  Base <span class="token operator">*</span>base_ptr <span class="token operator">=</span> <span class="token operator">&amp;</span>f<span class="token punctuation">;</span>
  base_ptr<span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// Final foo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>继承族谱分别为 A-&gt;B-&gt;C 与 Base-&gt;Derived-&gt;Final，并且均为公有继承，于是<strong>协变</strong>成立。</p>
</blockquote>
<h3 id="纯虚函数">纯虚函数</h3>
<p>说了那么多，虚函数到底有啥用？</p>
<p>我们目前已经掌握的知识有，可以通过基类指针或引用绑定派生类，并在调用虚函数时实现多态，根据这一特性，如果希望一个函数形参面向目标为所有族谱成员的话，就不需要对所有成员挨个实现，直接将形参设为基类指针，在需要实现多态的功能处设为虚函数即可。这和 <code>std::function</code> 一样，都起到<strong>类型擦除</strong>的作用。</p>
<blockquote>
<p>这是最大的作用了。</p>
</blockquote>
<p>以及，还有一个特殊的虚函数，称为<strong>纯虚函数</strong>，声明为 <code>virtual type funcname() = 0;</code>。</p>
<p>拥有纯虚函数的类称为<strong>抽象类</strong>，无法实例化，而仅拥有纯虚函数的类称为<strong>接口类</strong>。纯虚函数只是一个接口（interface），是一个函数的声明而已，需要留给派生类去进行实现。只有实现了该接口的派生类才能进行实例化，否则依然是抽象类，无法实例化。</p>
<h3 id="注意">注意</h3>
<p>功能如此强大的特性，必然涉及到一些<strong>限制 or 注意事项</strong>，总的来说有以下几点：</p>
<ol>
<li class="lvl-3">
<p>普通函数（非类成员函数）不能为虚函数。这是显而易见的，因为实现虚函数的基础之一正是类的<strong>继承特性</strong>；</p>
</li>
<li class="lvl-3">
<p>静态函数不能是虚函数。毕竟是全类共享，不存在继承一说；</p>
</li>
<li class="lvl-3">
<p>构造函数不能是虚函数。因为在调用构造函数时，虚表指针并没有在对象的内存空间中，更别说去虚表中找对应的虚函数了，必须要构造函数调用完成后才会形成虚表指针；</p>
</li>
<li class="lvl-3">
<p>内联函数不能是表现多态性时的虚函数。这点在 inline 那篇文章中提到过了；</p>
</li>
<li class="lvl-3">
<p>当可能用到基类指针/引用绑定派生类时，基类的析构函数必须为虚函数。这是因为当出现 <code>Base* ptr = new Derived</code> 这样的代码时，虽然 <code>ptr</code> 是 <code>Base</code> 类的指针，但我们实际上还分配了一个 <code>Derived</code> 类的空间，如果析构函数非虚，则会执行 <code>Base</code> 类的析构函数，而属于 <code>Derived</code> 的那一部分并没有被析构。为了程序安全运行，我们应该要调用派生类的析构函数，也就是通过将基类析构函数设为虚函数来实现；</p>
</li>
</ol>
<h3 id="误区">误区</h3>
<p>之所以说动态多态是在运行时绑定，是因为编译器<strong>可能</strong>无法在编译时期确定指针指向的到底是哪个类型的对象，只有在运行时才能去对应的虚函数表中找到对应虚函数并执行，比如将指针或引用作为函数入参的情况。</p>
<p>但「虚函数一定是运行期间绑定」这一说法是<strong>错误</strong>的，如果基类 <code>B</code> 的指针 <code>B* foo</code> 指向的某个对象类型，其派生序列中某个祖先 <code>D</code>（同样为 <code>B</code> 的派生类）对虚函数 <code>func()</code> 增加了 <strong><code>final</code></strong> 关键字，那么调用 <code>Foo-&gt;func()</code> 时，编译器会在<strong>编译时期</strong>直接生成 <code>D</code> 类型的 <code>func()</code> 版本，而不是在运行时去查虚函数表。毕竟后面没法重写了，那只能看作调用 <code>D::func()</code> 了。直接用 <code>final</code> 关键字修饰类型 <code>D</code> 也是一样的。</p>
<p>同样的，如果<strong>指定了调用版本</strong>，如 <code>Foo-&gt;B::func()</code>，也会在<strong>编译时期</strong>生成 <code>B</code> 类型的 <code>func()</code> 版本。</p>
<p>归根结底，程序具体行为还是得看编译器是怎么生成汇编代码的。对于某些一眼就能看出来基类指针指向哪个派生类对象的情况，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>
Base <span class="token operator">*</span>b <span class="token operator">=</span> <span class="token operator">&amp;</span>d<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时还要傻乎乎地等到运行时才去查表，而不做任何优化，这样的编译器我认为是没有市场可言的。</p>
<p>具体见<a href="https://www.zhihu.com/question/491602524/answer/2165605549">此文</a>。</p>
<h2 id="与-struct-的异同">与 struct 的异同</h2>
<h3 id="相同之处">相同之处</h3>
<ol>
<li class="lvl-3">
<p>都能在体内定义成员变量、成员函数，以及六大特殊成员函数；</p>
</li>
<li class="lvl-3">
<p>都能进行派生与继承，以及实现运行时多态（虚函数）；</p>
</li>
<li class="lvl-3">
<p>都能实现三大访问级别控制；</p>
</li>
</ol>
<h3 id="不同之处">不同之处</h3>
<ol>
<li class="lvl-3">
<p><code>struct</code> 默认 public，而 <code>class</code> 默认 private；</p>
</li>
<li class="lvl-3">
<p>默认继承方式同上；</p>
</li>
<li class="lvl-3">
<p><code>struct</code> 无法实现泛型（即 template）；</p>
</li>
</ol>
<p><code>struct</code> 是不同数据类型的集合体，更多被认为是一种自定义复合数据类型，从而更注重数据整合与使用；而 <code>class</code> 则是一个对象的方法与属性的集合，更注重数据安全性。</p>
<h2 id="虚继承、虚函数的内存模型">虚继承、虚函数的内存模型</h2>
<h3 id="虚函数表">虚函数表</h3>
<p>现在有个很大的问题：C++ 是如何实现多态的？</p>
<p>先看下面这段代码。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>main.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base foo\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Derived foo\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base b<span class="token punctuation">;</span>
  Derived d1<span class="token punctuation">,</span> d2<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 gdb 查看内存分布</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ main.cpp <span class="token parameter variable">-g</span> <span class="token parameter variable">-o</span> m
$ gdb m
<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print b
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">{</span>_vptr.Base <span class="token operator">=</span> 0x555555557d68 <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> Base+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>, x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a <span class="token operator">&amp;</span>b
<span class="token variable">$2</span> <span class="token operator">=</span> 0x7fffffffe060

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">(</span>long*<span class="token punctuation">)</span>0x7fffffffe060
<span class="token variable">$3</span> <span class="token operator">=</span> 0x555555557d68 <span class="token operator">&lt;</span>_ZTV4Base+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>  <span class="token comment">## b 内存中前 8B 存放了一个 vptr</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a <span class="token operator">&amp;</span>b.foo
<span class="token variable">$4</span> <span class="token operator">=</span> 0x55555555527a <span class="token operator">&lt;</span>_ZN4Base3fooEv<span class="token operator">&gt;</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">(</span>void**<span class="token punctuation">)</span>0x555555557d68@1
<span class="token variable">$5</span> <span class="token operator">=</span> <span class="token punctuation">{</span>0x55555555527a <span class="token operator">&lt;</span>_ZN4Base3fooEv<span class="token operator">&gt;</span><span class="token punctuation">}</span>  <span class="token comment">## b.vptr 指向的内存的第一个元素就是 Base::foo() 的函数指针</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print d1
<span class="token variable">$6</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>Base<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>_vptr.Base <span class="token operator">=</span> 0x555555557d50 <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> Derived+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>, x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>, y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a <span class="token operator">&amp;</span>d1
<span class="token variable">$7</span> <span class="token operator">=</span> 0x7fffffffe070

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">(</span>long*<span class="token punctuation">)</span>0x7fffffffe070
<span class="token variable">$8</span> <span class="token operator">=</span> 0x555555557d50 <span class="token operator">&lt;</span>_ZTV7Derived+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>  <span class="token comment">## d1 内存中前 8B 也存放了一个 vptr，但和 b 的不同</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a <span class="token operator">&amp;</span>d1.foo
<span class="token variable">$9</span> <span class="token operator">=</span> 0x5555555552a6 <span class="token operator">&lt;</span>_ZN7Derived3fooEv<span class="token operator">&gt;</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">(</span>void**<span class="token punctuation">)</span>0x555555557d50@1
<span class="token variable">$10</span> <span class="token operator">=</span> <span class="token punctuation">{</span>0x5555555552a6 <span class="token operator">&lt;</span>_ZN7Derived3fooEv<span class="token operator">&gt;</span><span class="token punctuation">}</span>  <span class="token comment">## d1.vptr 指向的内存的第一个元素则是 Derived::foo() 的函数指针</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a d2
<span class="token variable">$11</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>Base<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>_vptr.Base <span class="token operator">=</span> 0x555555557d50 <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> Derived+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>, x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>, y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据上面的输出，我们不难发现，无论是 <code>b</code> 还是 <code>d1</code>/<code>d2</code>，在内存的前 8B 都有一个叫 <code>_vptr</code> 的指针，这个指针实际上是<strong>虚函数表指针</strong>，指向了一个叫<strong>虚函数表</strong>的东西，每一个表项都存放了类对应版本的虚函数，比如 <code>b</code> 的虚函数表里就存了 <code>B::foo()</code> 的函数指针，对应符号为 <code>_ZN4Base3fooEv</code>。</p>
<p>在虚函数表指针后，就是各自的成员变量了，按照派生顺序存放，先 <code>Base::x</code> 后 <code>Derived::y</code>，各 4B。</p>
<p>同时，我们还发现一个有趣的事是，<code>d2</code> 的虚函数表指针与 <code>d1</code> 一致，说明同一类的虚函数表是<strong>全局共享</strong>的，并且存放在<strong>全局存储区</strong>。</p>
<p>以上是派生类<strong>进行虚函数重写</strong>的情况，下面再来看看派生类<strong>未进行重写</strong>的情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>main.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Base foo\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 仅含一个成员变量 y，而未对 foo() 进行重写</span>
  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Base b<span class="token punctuation">;</span>
  Derived d<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ main.cpp <span class="token parameter variable">-g</span> <span class="token parameter variable">-o</span> m
$ gdb m
<span class="token punctuation">..</span>.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print b
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">{</span>_vptr.Base <span class="token operator">=</span> 0x555555557d68 <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> Base+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>, x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print *<span class="token punctuation">(</span>void**<span class="token punctuation">)</span>0x555555557d68@1
<span class="token variable">$2</span> <span class="token operator">=</span> <span class="token punctuation">{</span>0x55555555527a <span class="token operator">&lt;</span>Base::foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">}</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print d
<span class="token variable">$3</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>Base<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>_vptr.Base <span class="token operator">=</span> 0x555555557d50 <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> Derived+1<span class="token operator"><span class="token file-descriptor important">6</span>&gt;</span>, x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>, y <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> print *<span class="token punctuation">(</span>void**<span class="token punctuation">)</span>0x555555557d50@1
<span class="token variable">$4</span> <span class="token operator">=</span> <span class="token punctuation">{</span>0x55555555527a <span class="token operator">&lt;</span>Base::foo<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现此时虽然 <code>d</code> 指向了和 <code>b</code> 不同的虚函数表，但内容是完全一致的，都是 <code>Base::foo()</code> 的函数指针。</p>
<p>从而推断：</p>
<ol>
<li class="lvl-3">
<p>在继承自一个有虚函数的基类时，派生类会将基类的虚函数表进行一次深拷贝；</p>
</li>
<li class="lvl-3">
<p>当派生类未进行重写时，保留基类版本；</p>
</li>
<li class="lvl-3">
<p>当派生类对虚函数进行重写时，派生类指向的虚函数表中，重写的那几个虚函数对应的项会被改为派生类的版本，并且派生类和基类中的符号名也有所修改；</p>
</li>
</ol>
<blockquote>
<p>更详细的关于虚函数内存模型的机制可以看<a href="https://blog.twofei.com/496/">这篇文章</a>。</p>
</blockquote>
<h3 id="运行时决议">运行时决议</h3>
<p>我们现在知道，每个（派生关系中有虚函数的）类对象在实例化时都会有若干张虚函数表，当使用基类指针指向派生类对象并调用虚函数时，通过虚函数表可以查到对应的函数指针。那么问题来了，虚函数表的表项是通过何种方式进行索引的？或者说，调用 <code>base_ptr-&gt;foo()</code> 是怎么索引到虚函数表中正确的那一项呢？</p>
<p>那么需要引入一个概念，叫<strong>运行时决议</strong>，即运行时确定调用函数的地址。在多态场景下，就是编译完后通过指令，去对象中的虚表里找到相应虚函数并运行。这一决议是在汇编级别实现的，暂时只学到这。</p>
<h3 id="虚继承-2">虚继承</h3>
<p>虚继承是用于解决菱形继承问题的，通过共享虚基类来消除歧义。那么<strong>共享</strong>这一功能是如何实现的？且看代码。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>main.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child1</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Child2</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token keyword">virtual</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> c2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Child1</span><span class="token punctuation">,</span> <span class="token keyword">public</span> <span class="token class-name">Child2</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Derived d<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>依然通过 gdb 查看变量</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ g++ main.cpp <span class="token parameter variable">-g</span> <span class="token parameter variable">-o</span> main
$ gdb main

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> b <span class="token number">25</span>
Breakpoint <span class="token number">1</span> at 0x11b0: <span class="token function">file</span> main.cpp, line <span class="token number">25</span>.
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> r

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p d
<span class="token variable">$1</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>Child<span class="token operator"><span class="token file-descriptor important">1</span>&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token operator">&lt;</span>Base<span class="token operator">&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>, _vptr.Child1 <span class="token operator">=</span> 0x555555557ca0 <span class="token operator">&lt;</span>vtable <span class="token keyword">for</span> Derived+2<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span>, c1 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">}</span>, <span class="token operator">&lt;</span>Child<span class="token operator"><span class="token file-descriptor important">2</span>&gt;</span> <span class="token operator">=</span> <span class="token punctuation">{</span>_vptr.Child2 <span class="token operator">=</span> 0x555555557cb8 <span class="token operator">&lt;</span>VTT <span class="token keyword">for</span> Derived<span class="token operator">&gt;</span>, c2 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">}</span>, d <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">}</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a <span class="token operator">&amp;</span>d                           Child1 --<span class="token operator">&gt;</span>  +------------------+  <span class="token operator">&lt;</span>---- 0x7fffffffe050
<span class="token variable">$2</span> <span class="token operator">=</span> 0x7fffffffe050                                <span class="token operator">|</span> _vptr.Child1<span class="token punctuation">(</span>8B<span class="token punctuation">)</span> <span class="token operator">|</span>
                                                   +------------------+        0x7fffffffe058
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a sizeof<span class="token punctuation">(</span>d<span class="token punctuation">)</span>                                <span class="token operator">|</span>      c1<span class="token punctuation">(</span>4B<span class="token punctuation">)</span>      <span class="token operator">|</span>
<span class="token variable">$3</span> <span class="token operator">=</span> 0x28                                          +------------------+        0x7fffffffe05c
                                                   <span class="token operator">|</span>   _padding<span class="token punctuation">(</span>4B<span class="token punctuation">)</span>   <span class="token operator">|</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">(</span>long*<span class="token punctuation">)</span>0x7fffffffe050       Child2 --<span class="token operator">&gt;</span>  +------------------+        0x7fffffffe060
<span class="token variable">$4</span> <span class="token operator">=</span> 0x555555557ca0 <span class="token operator">&lt;</span>_ZTV7Derived+2<span class="token operator"><span class="token file-descriptor important">4</span>&gt;</span>              <span class="token operator">|</span> _vptr.Child2<span class="token punctuation">(</span>8B<span class="token punctuation">)</span> <span class="token operator">|</span>
                                                   +------------------+        0x7fffffffe068
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>int*<span class="token punctuation">)</span>0x7fffffffe050+2<span class="token punctuation">)</span>                <span class="token operator">|</span>      c2<span class="token punctuation">(</span>4B<span class="token punctuation">)</span>      <span class="token operator">|</span>
<span class="token variable">$5</span> <span class="token operator">=</span> 0x2                                           +------------------+        0x7fffffffe06c
                                                   <span class="token operator">|</span>       d<span class="token punctuation">(</span>4B<span class="token punctuation">)</span>      <span class="token operator">|</span>
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>int*<span class="token punctuation">)</span>0x7fffffffe050+3<span class="token punctuation">)</span>                +------------------+        0x7fffffffe070
<span class="token variable">$6</span> <span class="token operator">=</span> 0x0                                           <span class="token operator">|</span>       x<span class="token punctuation">(</span>4B<span class="token punctuation">)</span>      <span class="token operator">|</span>
                                                   +------------------+        0x7fffffffe074
<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x7fffffffe050+2                <span class="token operator">|</span>   _padding<span class="token punctuation">(</span>4B<span class="token punctuation">)</span>   <span class="token operator">|</span>
<span class="token variable">$7</span> <span class="token operator">=</span> 0x555555557cb8 <span class="token operator">&lt;</span>_ZTT7Derived<span class="token operator">&gt;</span>                 +------------------+

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>int*<span class="token punctuation">)</span>0x7fffffffe050+6<span class="token punctuation">)</span>
<span class="token variable">$8</span> <span class="token operator">=</span> 0x3

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>int*<span class="token punctuation">)</span>0x7fffffffe050+7<span class="token punctuation">)</span>
<span class="token variable">$7</span> <span class="token operator">=</span> 0x4

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>int*<span class="token punctuation">)</span>0x7fffffffe050+8<span class="token punctuation">)</span>
<span class="token variable">$9</span> <span class="token operator">=</span> 0x1

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>int*<span class="token punctuation">)</span>0x7fffffffe050+9<span class="token punctuation">)</span>
<span class="token variable">$10</span> <span class="token operator">=</span> 0x0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么没有虚函数，这里也出现了虚函数表？事实上，为了增加一些运行时信息，比如 <code>type_info</code>、<code>offset</code>（用来确定基类在派生类中的偏移量），将这些信息放在虚函数表的负值索引处，可以通过 <code>vptr[-?]</code> 的形式访问。let’s check it out!</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x555555557ca0-1<span class="token punctuation">)</span>
<span class="token variable">$11</span> <span class="token operator">=</span> 0x555555557d08 <span class="token operator">&lt;</span>_ZTI7Derived<span class="token operator">&gt;</span>   <span class="token comment">## 运行时信息，实际指向的对象类型</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x555555557ca0-2<span class="token punctuation">)</span>
<span class="token variable">$12</span> <span class="token operator">=</span> <span class="token number">0</span>                               <span class="token comment">## 对象实际地址相对于该基类的偏移量，Child1 在最开始，所以 offset=0</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x555555557ca0-3<span class="token punctuation">)</span>
<span class="token variable">$13</span> <span class="token operator">=</span> <span class="token number">32</span>                              <span class="token comment">## 虚基类相对于该基类的偏移量，Base 位于 0x7fffffffe070，而 Child1 位于 0x7fffffffe050，相减即得</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x555555557cb8-1<span class="token punctuation">)</span>
<span class="token variable">$14</span> <span class="token operator">=</span> 0x555555557d08 <span class="token operator">&lt;</span>_ZTI7Derived<span class="token operator">&gt;</span>   <span class="token comment">## 运行时信息，实际指向的对象类型</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x555555557cb8-2<span class="token punctuation">)</span>
<span class="token variable">$15</span> <span class="token operator">=</span> <span class="token parameter variable">-16</span>                             <span class="token comment">## Child2 在 0x7fffffffe060，减 16 得到实际指向对象首地址</span>

<span class="token punctuation">(</span>gdb<span class="token punctuation">)</span> p/a *<span class="token punctuation">((</span>long*<span class="token punctuation">)</span>0x555555557cb8-3<span class="token punctuation">)</span>
<span class="token variable">$16</span> <span class="token operator">=</span> <span class="token number">16</span>                              <span class="token comment">## 相减即得</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>又发现这两个虚表的地址差值为 24，刚好是 3 个 8B，说明它们俩是挨在一起的。那么可以得到虚表的内存模型如下：</p>
<pre class="line-numbers language-none"><code class="language-none">                 +------------------+  &lt;---- 0x555555557c88
                 |  offset to vbase |
                 +------------------+        0x555555557c90
                 |  offset to top   |
                 +------------------+        0x555555557c98
                 | runtime_typeinfo |
vptr_Child1 --&gt;  +------------------+        0x555555557ca0
                 |  offset to vbase |
                 +------------------+        0x555555557ca8
                 |  offset to top   |
                 +------------------+        0x555555557cb0
                 | runtime_typeinfo |
vptr_Child2 --&gt;  +------------------+        0x555555557cb8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以 <code>Child2* pc2 = pd</code> 为例，实际的代码可能是 <code>Child2* pc2 = pd == nullptr ? (Child2*)(pd + sizeof(Child1)) : 0</code>，它对应内存的首个元素就是 8B 的虚表指针，通过这一指针就可以访问到运行时信息。</p>
<p>在有虚函数&amp;&amp;虚继承的情况下，虚表向下填充函数指针即可。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 正则表达式(Regex)</title>
    <url>/c/c-regex/</url>
    <content><![CDATA[<p><strong>正则表达式</strong>，又称规则表达式（Regular Expression，常简写为 regex、regexp 或 RE），是一种<strong>文本模式/规则</strong>，包括普通字符和特殊字符（<strong>元字符</strong>）。通常使用单个字符串来表示正则表达式 <code>pattern</code>，并<strong>匹配</strong>一系列符合模式 <code>pattern</code> 的字符串。</p>
<span id="more"></span>
<h2 id="正则表达式基本知识">正则表达式基本知识</h2>
<h3 id="模糊匹配">模糊匹配</h3>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>.</code></td>
<td style="text-align:left">匹配换行符以外的任意一个字符</td>
<td><code>f.o</code>：foo / f0o / …</td>
</tr>
<tr>
<td style="text-align:left"><code>*</code></td>
<td style="text-align:left">匹配前一个字符<strong>零次或多次</strong></td>
<td><code>fo*</code>：f / foooo / …</td>
</tr>
<tr>
<td style="text-align:left"><code>+</code></td>
<td style="text-align:left">匹配前一个字符<strong>一次或多次</strong></td>
<td><code>fo+</code>：fo / foooo / …</td>
</tr>
<tr>
<td style="text-align:left"><code>?</code></td>
<td style="text-align:left">匹配前一个字符<strong>零次或一次</strong></td>
<td><code>fo?</code>：f / fo</td>
</tr>
<tr>
<td style="text-align:left"><code>{n}</code></td>
<td style="text-align:left">匹配前一个字符固定 n 次，n ≥ 0，下同</td>
<td><code>fo{2}</code>：foo</td>
</tr>
<tr>
<td style="text-align:left"><code>{n,}</code></td>
<td style="text-align:left">匹配前一个字符至少 n 次</td>
<td><code>fo{1,}</code>：fo / foo / …</td>
</tr>
<tr>
<td style="text-align:left"><code>{,m}</code></td>
<td style="text-align:left">匹配前一个字符至多 m 次</td>
<td><code>fo{,2}</code>：f / fo / foo</td>
</tr>
<tr>
<td style="text-align:left"><code>{n, m}</code></td>
<td style="text-align:left">匹配前一个字符至少 n 次，至多 m 次</td>
<td><code>fo{1, 2}</code>：fo / foo</td>
</tr>
<tr>
<td style="text-align:left"><code>[]</code></td>
<td style="text-align:left">匹配指定集合中的一个字符</td>
<td><code>[fF]oo</code>：foo / Foo</td>
</tr>
<tr>
<td style="text-align:left"><code>[^]</code></td>
<td style="text-align:left">匹配不在集合中的一个字符</td>
<td><code>[^0-9]ar</code>：Bar / car / …</td>
</tr>
<tr>
<td style="text-align:left">`x</td>
<td style="text-align:left">y`</td>
<td>匹配字符串 x <strong>或</strong> y，可连续用</td>
</tr>
<tr>
<td style="text-align:left"><code>(...)</code></td>
<td style="text-align:left">匹配括号内任意正则表达式</td>
<td>`(b</td>
</tr>
</tbody>
</table>
<blockquote>
<p>字符集可以只输入确定的几个字符，也可以用 <code>-</code> 表示范围</p>
</blockquote>
<h3 id="特殊序列">特殊序列</h3>
<table>
<thead>
<tr>
<th style="text-align:left">符号</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>\</code></td>
<td style="text-align:left">对下一个字符转义</td>
</tr>
<tr>
<td style="text-align:left"><code>\f</code></td>
<td style="text-align:left">匹配换页符</td>
</tr>
<tr>
<td style="text-align:left"><code>\n</code></td>
<td style="text-align:left">匹配换行符</td>
</tr>
<tr>
<td style="text-align:left"><code>\r</code></td>
<td style="text-align:left">匹配回车符</td>
</tr>
<tr>
<td style="text-align:left"><code>\t</code></td>
<td style="text-align:left">匹配制表符</td>
</tr>
<tr>
<td style="text-align:left"><code>\v</code></td>
<td style="text-align:left">匹配垂直制表符</td>
</tr>
<tr>
<td style="text-align:left"><code>\w</code></td>
<td style="text-align:left">匹配任意字母、数字及下划线，等价于 <code>[0-9a-zA-z_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\W</code></td>
<td style="text-align:left"><code>\w</code> 取非，等价于 <code>[^0-9a-zA-z_]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\d</code></td>
<td style="text-align:left">匹配任意一个数字，等价于 <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\D</code></td>
<td style="text-align:left"><code>\d</code> 取非，等价于 <code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\s</code></td>
<td style="text-align:left">匹配任意一个空白字符，等价于 <code>[\f\n\r\t\v]</code></td>
</tr>
<tr>
<td style="text-align:left"><code>\S</code></td>
<td style="text-align:left"><code>\s</code> 取非，等价于 <code>[^\f\n\r\t\v]</code></td>
</tr>
</tbody>
</table>
<h3 id="位置标记">位置标记</h3>
<table>
<thead>
<tr>
<th>符号</th>
<th>描述</th>
<th>例子</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>^</code></td>
<td>行首定位符</td>
<td><code>^foo</code>：以 “foo” 开头的行</td>
</tr>
<tr>
<td><code>$</code></td>
<td>行尾定位符</td>
<td><code>^bar</code>：以 “bar” 结尾的行</td>
</tr>
</tbody>
</table>
<h2 id="C-正则表达式支持">C++ 正则表达式支持</h2>
<p>C++11 为支持正则表达式新增了若干类，并将这些类封装在头文件 <code>&lt;regex</code> 中。</p>
<h3 id="主要模板类">主要模板类</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>basic_regex</code>：正则表达式对象，为基类，可以直接通过字符串或初始化列表进行构造，支持拷贝与移动；</p>
</li>
<li class="lvl-2">
<p><code>sub_match</code>：标识子表达式所匹配的字符序列；</p>
</li>
<li class="lvl-2">
<p><code>match_results</code>：维护表示正则表达式匹配结果的字符序列集合，可以通过 <code>str(int n = 0)</code> 返回第 n 个子匹配结果的字符序列 ；</p>
</li>
</ul>
<h3 id="匹配算法">匹配算法</h3>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>regex_match</code>：检查字符串是否完全匹配；</p>
</li>
<li class="lvl-2">
<p><code>regex_search</code>：检查字符串是否部分匹配，若存在匹配的子字符串，则只返回第一个；</p>
</li>
<li class="lvl-2">
<p><code>regex_replace</code>：以新字符串替换所有匹配的子字符串；</p>
</li>
</ul>
<h3 id="代码示例">代码示例</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>完全匹配</span></div><code class="language-cpp">std<span class="token double-colon punctuation">::</span>regex <span class="token function">r</span><span class="token punctuation">(</span><span class="token string">"\\w+day"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>smatch res<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"Monday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"Tuesday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s3</span><span class="token punctuation">(</span><span class="token string">"Weekend"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s4</span><span class="token punctuation">(</span><span class="token string">"day"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> boolalpha
          <span class="token operator">&lt;&lt;</span> <span class="token function">regex_match</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> res<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token function">regex_match</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> res<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token function">regex_match</span><span class="token punctuation">(</span>s3<span class="token punctuation">,</span> res<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token function">regex_match</span><span class="token punctuation">(</span>s4<span class="token punctuation">,</span> res<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

<span class="token comment">// output:</span>
<span class="token comment">// true Monday</span>
<span class="token comment">// true Tuesday</span>
<span class="token comment">// false</span>
<span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>部分匹配</span></div><code class="language-cpp">std<span class="token double-colon punctuation">::</span>regex <span class="token function">r</span><span class="token punctuation">(</span><span class="token string">"\\w+day"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>smatch res<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s1</span><span class="token punctuation">(</span><span class="token string">"MondayTuesdaySunday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s2</span><span class="token punctuation">(</span><span class="token string">"Monday and Tuesday and Sunday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> boolalpha
          <span class="token operator">&lt;&lt;</span> <span class="token function">regex_search</span><span class="token punctuation">(</span>s1<span class="token punctuation">,</span> res<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
          <span class="token operator">&lt;&lt;</span> <span class="token function">regex_search</span><span class="token punctuation">(</span>s2<span class="token punctuation">,</span> res<span class="token punctuation">,</span> r<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

<span class="token comment">// output:</span>
<span class="token comment">// true MondayTuesdaySunday</span>
<span class="token comment">// true Monday</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>子串替换</span></div><code class="language-cpp">std<span class="token double-colon punctuation">::</span>regex <span class="token function">r</span><span class="token punctuation">(</span><span class="token string">"\\w+day"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>smatch res<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>string <span class="token function">s</span><span class="token punctuation">(</span><span class="token string">"Monday and Tuesday and Sunday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token function">regex_replace</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> r<span class="token punctuation">,</span> <span class="token string">"Weekend"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// output:</span>
<span class="token comment">// Weekend and Weekend and Weekend</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 标准模板库(STL)</title>
    <url>/c/c-stl/</url>
    <content><![CDATA[<p>标准模板库(Standard Template Library, STL)是一个 C++ 软件库，大量影响了 C++ 标准程序库但并非是其的一部分。其中包含 5 个组件，分别为迭代器、容器、容器适配器、算法、函数。</p>
<span id="more"></span>
<h2 id="迭代器">迭代器</h2>
<h2 id="容器">容器</h2>
<h3 id="std-vector">std::vector</h3>
<p>底层维护了一个「在<strong>堆</strong>上的具有连续内存的<strong>数组</strong>」。</p>
<p>支持 $O(1)$ 的<strong>随机访问</strong>。</p>
<p>对于<strong>查找</strong>，无序 vector 为 $O(n)$，有序 vector 可以利用二分查找降低至 $O(\log n)$。</p>
<p>对于<strong>插入</strong>和<strong>删除</strong>操作，都是在尾部最快，头部最慢（是因为跟普通数组一样存在元素的移动）。</p>
<blockquote>
<p>特别的，标准库提供 <code>vector&lt;bool&gt;</code> 的特化，它使得每个元素占用一个单独的位，而非 <code>sizeof(bool)</code> 字节，从而对空间效率进行了优化。</p>
</blockquote>
<h4 id="迭代器-std-vector-iterator">迭代器 std::vector::iterator</h4>
<blockquote>
<p>vector 维护的是一个连续线性空间，所以不论其元素型别为何，普通指针都可以作为 vector 的迭代器而满足所有必要条件，因为 vector 迭代器所需要的操作行为，如 <code>operator*</code>, <code>operator-&gt;</code>, <code>operator++</code>, <code>operator--</code>, <code>operator+</code>, <code>operator-</code>, <code>operator+=</code>, <code>operator-=</code>，普通指针天生就具备。vector 支持随机存取，而普通指针正有着这样的能力。所以，vector 提供的是 Random Access Iterators。——选自《STL 源码剖析》</p>
</blockquote>
<p>vector 内部维护了三个迭代器，分别是:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>start</code>: 指向数组起始；</p>
</li>
<li class="lvl-2">
<p><code>finish</code>: 指向数组使用空间的尾部；</p>
</li>
<li class="lvl-2">
<p><code>end_of_storage</code>: 指向数组可用空间的尾部；</p>
</li>
</ul>
<blockquote>
<p><code>vector::size()</code> 指容器内数组元素个数，而 <code>vector::capacity()</code> 指当前已分配的数组大小。</p>
<p>计算方式为: <code>size</code> = finish - start；<code>capacity</code> = end_of_storage - start。</p>
</blockquote>
<p>通过直接使用指针的方式，vector 实现了随机访问与空间的快速计算。但是也正因为是指向数组某个位置的指针，存在<strong>迭代器失效</strong>的问题——在频繁的 CRUD 后，同一迭代器在操作前后指向的元素可能会不同，甚至会悬垂。</p>
<h4 id="扩容机制">扩容机制</h4>
<p><code>vector</code> 的核心在于其长度自动可变，即<strong>扩容机制</strong>: 当目前可用的空间不足（即 <code>size = capacity</code> 且有新元素要加入）时，分配目前空间的两倍或者目前空间加上所需的新空间大小（取较大值），将原有元素移动到新的内存空间后，释放原来的空间。</p>
<blockquote>
<p>由于二倍扩容机制可能会导致内存的浪费（无法重新利用原来的内存），内存不足时扩容的拷贝也会造成较大性能开销。如果使用者能对容量有预期，那么采用 <code>vector::reserve()</code> 来预先分配内存，将大大的提高性能。</p>
</blockquote>
<h4 id="如何手动释放-vector-内存？">如何手动释放 vector 内存？</h4>
<p><code>vector::clear()</code> 方法仅仅移除元素，实际上底层分配的内存并不会随之减少，调用 <code>vector::capacity()</code> 时依然能够得到一个正值。</p>
<p>那么如何释放内存呢？比如一个 <code>vector&lt;int&gt; nums</code>， 比较 hack 的一种方式是 <code>nums = {}</code>，这样既可以清空元素还会释放内存。正规的做法是令一个空 vector（右值）调用 <code>vector::swap()</code> 进行底层数组的交换，交换后 <code>nums</code> 指向一个空数组，而另一个右值会在当前作用域结束后被回收。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>一个手动释放 vector 内存的例子</span></div><code class="language-cpp"><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// nums 为待释放的 vector</span>
nums<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Error: Non-const lvalue reference to type 'vector&lt;...&gt;' cannot bind to a temporary of type 'vector&lt;...&gt;' 因为 swap 的形参类型是 T&amp;，不能传递右值</span>

<span class="token comment">// 第二种写法的解决方案如下</span>
<span class="token punctuation">{</span>
  vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> tmp<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  nums<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而当 <code>vector</code> 里面存了指针时，上面的做法并不会释放指针指向的那片内存，从而导致内存泄漏。应当首先遍历 <code>vector</code> 逐个 <code>delete</code>/<code>free()</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>释放每个指针</span></div><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> iter <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter <span class="token operator">!=</span> nums<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>iter<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">delete</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>
    <span class="token operator">*</span>iter <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="emplace-back-和-push-back-的异同">emplace_back() 和 push_back() 的异同</h4>
<p>两者都是在数组末尾追加元素。区别在于:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>前者是直接根据传入的参数列表，通过 <code>std::forward</code> + <code>placement new</code> 的方式在指定位置（数组末尾）进行<strong>初始化构造</strong>。</p>
</li>
<li class="lvl-2">
<p>后者则需要调用<strong>拷贝/移动构造函数</strong>，效率较前者更低。</p>
</li>
</ul>
<blockquote>
<p>当然，如果当前 <code>size == capacity</code>，则会触发扩容。</p>
</blockquote>
<h3 id="std-list">std::list</h3>
<p>底层维护了一个「<strong>环状双向链表</strong>」。</p>
<p>不支持随机访问，只能通过<strong>遍历</strong>的方式，复杂度为 $O(n)$。</p>
<p>查找也是一样的，需要通过 $O(n)$ 的<strong>遍历</strong>。</p>
<p>当已定位到待插入/删除的位置时，<strong>插入</strong>和<strong>删除</strong>只需要调整指针的指向，复杂度为 $O(1)$。</p>
<blockquote>
<p>list 的<strong>插入</strong>和<strong>删除</strong>并不会出现空间装满而重新扩容的情况，也不会引起迭代器失效——它对内存的控制是十分精准的，需要多少就分配多少，也就不会出现<strong>内部碎片</strong>（vector 有）。从而也可以思考出，调用 <code>clear()</code> 函数就能完整释放内存。</p>
</blockquote>
<h4 id="迭代器-std-list-iterator">迭代器 std::list::iterator</h4>
<blockquote>
<p>由于 STL list 是一个双向链表(double linked-list)，迭代器必须具备前移、后移的能力，所以 list 提供的是Bidirectional Iterators。——选自《STL 源码剖析》</p>
</blockquote>
<p>list 内部只维护了一个迭代器 <code>node</code>，即一个指向尾部空白节点的指针，这样就能够实现「前闭后开」的环状双向链表。</p>
<img src="list.png" style="zoom:50%">
<blockquote>
<p>一些计算/判断方式: <code>begin</code> = node-&gt;next；<code>end</code> = node；<code>front</code> = *(node-&gt;next)；<code>back</code> = *(node-&gt;prev)；<code>empty</code> = node-&gt;next == node ……其余均可依次推导。</p>
</blockquote>
<h3 id="std-deque">std::deque</h3>
<p>底层维护了一个「由<strong>分段连续空间</strong>构成的<strong>双向队列</strong>」以及一个「中控器指针」。</p>
<p>支持<strong>随机访问</strong>，但性能比 vector 要差。</p>
<p><strong>插入</strong>和<strong>删除</strong>操作在头/尾很快，为 $O(1)$，但是在中间「非常非常」慢。</p>
<h4 id="中控器">中控器</h4>
<p>所谓<strong>中控器</strong>，其实就是一个二级指针，或者说一个数组，存着指向每一个连续空间（或称<strong>缓冲区</strong>）的指针。deque 内部有一个变量表示这个中控数组的大小，当超载时也会触发和 vector 相似的扩容操作（但这里的元素仅仅是 64 位的指针，所以开销比较稳定）。每个缓冲区的大小是相同的（默认情况下缓冲区大小为 <code>512B</code>，可以通过模板参数自定义），所以随机访问时可以对缓冲区大小 buffer size 取模，求得去第几个缓冲区访问，然后通过中控数组定位即可。</p>
<blockquote>
<p>这也就是为什么说虽然 deque 支持随机访问，但是性能比 vector 差了——需要进行<strong>两次</strong>数组访问。</p>
</blockquote>
<img src="deque.png" style="zoom:50%">
<h4 id="迭代器-std-deque-iterator">迭代器 std::deque::iterator</h4>
<p>deque 内部维护了两个迭代器，分别是:</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>start</code>: 指向第一个缓冲区的第一个元素；</p>
</li>
<li class="lvl-2">
<p><code>finish</code>: 指向最后一个缓冲区的最后一个元素（的下一个位置）；</p>
</li>
</ul>
<p>和 vector 一样，这两个都是基于连续空间实现的容器，也就存在<strong>迭代器失效</strong>的问题。</p>
<p>同时，为了能让迭代器在执行 <code>operator++</code> 时，能从一个缓冲区的尾部跳转到下一个缓冲区的头部，其内部除了维护一个指向当前元素的指针 <code>cur</code> 外，还必须记录当前缓冲区的首尾指针 <code>first</code>/<code>last</code>，以及指向中控器数组相应位置的指针 <code>node</code>。</p>
<p>当需要进行缓冲区切换时，只需将 <code>node</code> 自增/自减，然后将 <code>first</code> 置为 <code>*node</code>，<code>last</code> 置为 <code>*node + buffer size</code> 即可。</p>
<h4 id="扩容机制-2">扩容机制</h4>
<p>deque 的扩容主要分为以下两种:</p>
<ol>
<li class="lvl-3">
<p><strong>缓冲区扩容</strong>: 当 <code>push_front()</code> 时第一块缓冲区满，或 <code>push_back()</code> 时最后一块缓冲区满会触发缓冲区扩容，新分配一片 buffser size 大小的缓冲区，然后在中控数组首/尾部添加指针，同时更新迭代器 <code>start</code>/<code>finish</code>；</p>
</li>
<li class="lvl-3">
<p><strong>中控器扩容</strong>: 当缓冲区扩容，无法往中控数组中加入缓冲区指针时触发，新分配一块更大的中控数组，将原数组内的缓冲区指针拷贝过去，同时更新迭代器 <code>start</code>/<code>finish</code>。在这之后，重新进行缓冲区扩容的步骤；</p>
</li>
</ol>
<blockquote>
<p>为了减少中控器扩容的次数，应尽可能将缓冲区指针放在中控器数组的居中位置，这样前后都有足够空间进行缓冲区的扩容。</p>
</blockquote>
<h4 id="内存释放">内存释放</h4>
<p>虽然当某个缓冲区为空时，不一定要立刻释放，因为后面可能还会通过 <code>push</code> 使得元素加入该缓冲区，但是 STL 为了实现简单，当 <code>pop</code> 操作使得某个缓冲区变空，就立刻将其释放。</p>
<h3 id="std-set-std-map">std::set/std::map</h3>
<p>这两位底层都是基于「<strong>红黑树</strong>」实现的，内部元素依照 key 值自动排序（允许自定义比较函数），不允许出现重复的 key 值（通过红黑树的 <code>insert_unique()</code> 实现）。<strong>增删查改</strong>的时间复杂度近似 $O(\log n)$。</p>
<blockquote>
<p>红黑树是一种弱平衡二叉搜索树，其性质如下:</p>
<ol>
<li class="lvl-3">每个结点非红即黑；</li>
<li class="lvl-3">根节点是黑的；</li>
<li class="lvl-3">如果一个结点是红色的，那么它的子节点必须得黑色的；</li>
<li class="lvl-3">任一结点到树尾结点(NIL)的路径上含有的黑色结点个数必须相同；</li>
<li class="lvl-3">尾结点(NIL)视为黑色；</li>
<li class="lvl-3">新增结点必须是红色的；</li>
</ol>
<p>通过以上定义的限制，红黑树确保没有一条路径会比其他路径多出两倍以上，但又不像 AVL 那样严格平衡，所以说是弱平衡的。</p>
<p>那么为什么不用<strong>平衡二叉树(AVL)<strong>呢？尽管 AVL 是高度平衡的，但频繁的插入和删除，会引起频繁的旋转操作，导致效率下降。而红黑树是一种弱平衡二叉树，相对于严格要求平衡的平衡二叉树来说，它的</strong>旋转次数更少</strong>（红黑树的插入最多两次旋转，删除最多三次旋转），所以对于插入、删除操作较多的情况下，通常使用红黑树。</p>
</blockquote>
<p>map 仅仅比 set 多了一个 value 字段，二者都不能通过迭代器修改 key 的值。并且因为红黑树的特性，所有 key 其实都对应一个树结点，和 list 很像，当进行插入和删除时，不会出现迭代器失效的情况。</p>
<h3 id="std-multi-set-std-multi-map">std::multi_set/std::multi_map</h3>
<p>和普通的 set/map 相比，他俩允许出现重复的 key 值（通过红黑树的 <code>insert_equal()</code> 实现）</p>
<h3 id="std-unordered-set-std-unordered-map">std::unordered_set/std::unordered_map</h3>
<p>这两位底层都是基于「<strong>哈希表</strong>」实现的，是<strong>无序</strong>的。最优情况<strong>增删查改</strong>的时间复杂度是 $O(1)$，最差情况为 $O(n)$，出现这种差异是因为数据的分布是否均匀会极大影响容器的性能。</p>
<h4 id="冲突处理">冲突处理</h4>
<p>以 <code>unordered_map</code> 为例，其底层哈希表采用<strong>桶+链法</strong>解决冲突，如下图:</p>
<img src="1.png" style="zoom:50%">
<p>每产生一次哈希冲突，就在当前 bucket 中链入新数据。而当同位置上的元素节点大于 <strong>8</strong> 个的时候，会自动转化为成一棵<strong>红黑树</strong>，用于降低长链表的查找压力。</p>
<blockquote>
<p>另外，哈希表存储结构还有一个重要的属性，称为<strong>负载因子</strong>，用于衡量容器存储键值对的空/满程度。负载因子越大，意味着容器越满，即各链表中挂载着越多的键值对，这无疑会降低容器查找目标键值对的效率；反之，负载因子越小，容器肯定越空，但并不一定各个链表中挂载的键值对就越少。如果设计的哈希函数不合理，使得各个键值对的键代入该函数得到的哈希值始终相同（所有键值对始终存储在同一链表上），这种情况下，即便增加桶数使得负载因子减小，该容器的查找效率依旧很差。</p>
</blockquote>
<h4 id="哈希函数-HashFcn-与去重规则-EqualKey">哈希函数 HashFcn 与去重规则 EqualKey</h4>
<p>默认情况下，unordered set/unordered map 使用了 STL 为我们提供的默认哈希函数 <code>std::hash</code> 对 key 进行哈希，与 <code>std::equal_to</code> 进行去重。这两者对一些常用类型如 <code>int</code>/<code>std::string</code> 做了特化，所以可以直接使用这些类型作为 key 值。</p>
<p>当我们需要设置自定义对象作为 key 时，就需要自行特化 <code>std::hash&lt;UserObject&gt;</code> 和 <code>std::equal_to&lt;UserObject&gt;</code>，否则构造 <code>unordered_*&lt;UserObject, *&gt;</code> 时会报错。而 value 则无此限制。</p>
<h2 id="容器适配器">容器适配器</h2>
<h3 id="std-stack-std-queue">std::stack/std::queue</h3>
<p>根据这两者的逻辑特性，并不需要特地实现新的容器，只需要在原有的容器基础上进行修改即可：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>对于 stack，底层容器最好能提供单端 <code>push</code>/<code>pop</code> 的功能，可以考虑使用 vector/list/deque；</p>
</li>
<li class="lvl-2">
<p>对于 queue，底层容器最好能提供双端 <code>push</code>/<code>pop</code> 的功能，但是考虑到 vector 在首部进行增删的效率极低，所以推荐使用 list/deque；</p>
</li>
</ul>
<p>默认情况下，二者都基于 deque 进行实现。</p>
<p>以 <code>stack&lt;T, deque&lt;T&gt;&gt;</code> 为例，<code>push()</code> 实际上就是调用了 <code>deque::push_back()</code>，说明是在尾端进行增删，那么取栈顶元素和弹出栈顶元素的操作也显而易见了。</p>
<p>⚠️需要注意的是，这两者本身不提供遍历功能，也就<strong>都没有</strong>实现各自的迭代器类型。</p>
<h3 id="std-priority-queue">std::priority_queue</h3>
<p>默认以 vector 作为底层容器，以「<strong>堆</strong>」作为处理规则。与 queue 不同，它虽然也允许元素以任意顺序加入容器，但每次取出的一定是「优先级最高」的元素，而非 FIFO。</p>
<h4 id="比较规则-comp">比较规则 comp</h4>
<p>priority_queue 允许自定义比较规则，其应当是一个实现了 <code>bool operator()(const &amp;a, const &amp;b)</code> 的结构体/类，返回值为 true 表示 lhs 的优先级比 rhs 的优先级小。</p>
<p>默认情况下使用 <code>std::less&lt;T&gt;</code> 作为比较规则，其实现形式可能是下面这样，也就意味着<strong>元素值越「小」，优先级越低</strong>。所以当我们使用 <code>priority_queue&lt;int&gt;</code> 时，总是能取到优先队列中的最大值。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>std::less 的可能实现形式</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">less</span> <span class="token punctuation">{</span>
  <span class="token keyword">bool</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> a <span class="token operator">&lt;</span> b<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>如果不想实现比较规则，也可以考虑重载对象的 <code>operator&lt;</code> 函数，效果是一样的。</p>
</blockquote>
<h2 id="算法">算法</h2>
<h3 id="std-sort">std::sort</h3>
<p><code>std::sort</code> 考虑了不同 workload 下的排序性能，并将其结合，表现为：数据量大时，使用 Quick Sort 分段递归排序；一旦分段后的数据量小于某个阈值，改用 Insertion Sort；若递归层数过深（当数据量大且基本有序时容易发生），还会改用 Heap Sort。当然，它只接受<strong>随机存取迭代器(RandomAccessIterators)</strong>（通常是 <code>begin()</code> 与 <code>end()</code>），允许用户自定义比较规则，其应当是一个实现了 <code>bool operator()(const &amp;a, const &amp;b)</code> 的结构体/类，返回值为 true 表示 lhs 小于 rhs。默认情况下使用 <code>std::less&lt;T&gt;</code> 作为比较规则，所以当我们仅传入前两个参数时，函数会将容器进行递增排序。</p>
<blockquote>
<p>下面默认只传入前两个参数。</p>
</blockquote>
<h4 id="Insertion-Sort">Insertion Sort</h4>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Insertion Sort</span></div><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">__insertion_sort</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span>
                      RandomAccessIterator last<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">==</span> last<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>RandomAccessIterator i <span class="token operator">=</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">!=</span> last<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    <span class="token function">__linear_insert</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 将迭代器 i 指向的元素插入区间 [first, i) 中</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__linear_insert</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span>
                            RandomAccessIterator last<span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  T value <span class="token operator">=</span> <span class="token operator">*</span>last<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token operator">*</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">copy_back_ward</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> last <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 直接将区间整体右移</span>
    <span class="token operator">*</span>first <span class="token operator">=</span> value<span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span>
    <span class="token function">__unguarded_linear_insert</span><span class="token punctuation">(</span>last<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证不会越界</span>
                                            <span class="token comment">// 否则每次循环都需要判断一下是否越界，在数据量大的情况下影响还是可观的</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">__unguarded_linear_insert</span><span class="token punctuation">(</span>RandomAccessIterator last<span class="token punctuation">,</span> T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里就不断循环交换即可，直至 value &gt;= next 指向的元素</span>
  RandomAccessIterator next <span class="token operator">=</span> last<span class="token punctuation">;</span>
  <span class="token operator">--</span>next<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> <span class="token operator">*</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span>last <span class="token operator">=</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    last <span class="token operator">=</span> next<span class="token punctuation">;</span>
    <span class="token operator">--</span>next<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token operator">*</span>last <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Quick-Sort">Quick Sort</h4>
<p>上面是 Insertion Sort 的部分，当数据量小时性能优于 Quick Sort，但是当数据量增大时其 $O(n^2)$ 的时间复杂度还是令人摇头。这种情况下就需要 Quick Sort 来解决了。</p>
<p><code>std::sort</code> 对 Quick Sort 做的第一个优化是，以 Median-of-Three 的方式选出合适的 pivot，即取整个序列的头、尾、中央三个位置的元素，以其**中值(median)**作为 pivot，这样能够保证在划分时不会出现空的子区间。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Median-of-Three</span></div><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> <span class="token function">__median</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> b<span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>       <span class="token comment">// a &lt; b &lt; c</span>
      <span class="token keyword">return</span> b<span class="token punctuation">;</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>  <span class="token comment">// a &lt; c &lt;= b</span>
      <span class="token keyword">return</span> c<span class="token punctuation">;</span>
    <span class="token keyword">else</span>             <span class="token comment">// c &lt; a &lt; b</span>
      <span class="token keyword">return</span> a<span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>    <span class="token comment">// b &lt;= a &lt; c</span>
    <span class="token keyword">return</span> a<span class="token punctuation">;</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>b <span class="token operator">&lt;</span> c<span class="token punctuation">)</span>    <span class="token comment">// b &lt; c &lt;= a</span>
    <span class="token keyword">return</span> c<span class="token punctuation">;</span>
  <span class="token keyword">else</span>
    <span class="token keyword">return</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来就是**划分(partion)**了，通过线性遍历将序列中小于 pivot 的放到左侧，大于 pivot 的放到右侧，就完成了划分操作。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>partion</span></div><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
RandomAccessIterator <span class="token function">__unguarded_partion</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span>
                                         RandomAccessIterator last<span class="token punctuation">,</span> T pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">*</span>first <span class="token operator">&lt;</span> pivot<span class="token punctuation">)</span> <span class="token operator">++</span>first<span class="token punctuation">;</span>
    <span class="token operator">--</span>last<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span>pivot <span class="token operator">&lt;</span> <span class="token operator">*</span>last<span class="token punctuation">)</span> <span class="token operator">--</span>last<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>first <span class="token operator">&lt;</span> last<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> first<span class="token punctuation">;</span> <span class="token comment">// 说明划分完毕</span>
    <span class="token function">iter_swap</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">// 交换元素值</span>
    <span class="token operator">++</span>first<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>第二个优化是，不会只让 Quick Sort 将数据就这么排好，而是令其某个大小的子序列达到某个「差不多排好」的状态，然后用一次 Insertion Sort 将这个子序列做一次完整的排序。原理自然是因为面对基本有序的数组，Insertion Sort 的性能远远超过 Quick Sort。</p>
<p>接下来就是完整的 <code>std::sort</code> 实现了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>sort</span></div><code class="language-cpp"><span class="token keyword">const</span> <span class="token keyword">int</span> __stl_threshold <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">__introsort_loop</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">__lg</span><span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__final_insertion_sort</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Size</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">__introsort_loop</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span> RandomAccessIterator last<span class="token punctuation">,</span> T<span class="token operator">*</span><span class="token punctuation">,</span>
                      Size depth_limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 全局定义了 const int __stl_threashold = 16;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&gt;</span> __stl_threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>depth_limit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">partial_sort</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 改用 Heap Sort</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">--</span>depth_limit<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  RandomAccessIterator cut <span class="token operator">=</span> <span class="token function">__unguareded_partition</span><span class="token punctuation">(</span>
      first<span class="token punctuation">,</span> last<span class="token punctuation">,</span>
      <span class="token function">T</span><span class="token punctuation">(</span><span class="token function">__median</span><span class="token punctuation">(</span><span class="token operator">*</span>first<span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>first <span class="token operator">+</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>last <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">__introsort_loop</span><span class="token punctuation">(</span>cut<span class="token punctuation">,</span> last<span class="token punctuation">,</span> <span class="token function">value_type</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span><span class="token punctuation">,</span>
                   depth_limit<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 先对右半部分递归排序</span>
  last <span class="token operator">=</span> cut<span class="token punctuation">;</span>  <span class="token comment">// 然后在下个循环对左半部分递归排序</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">RandomAccessIterator</span><span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">__final_insertion_sort</span><span class="token punctuation">(</span>RandomAccessIterator first<span class="token punctuation">,</span>
                                   RandomAccessIterator last<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">-</span> first <span class="token operator">&gt;</span> __stl_threshold<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">__insertion_sort</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> first <span class="token operator">+</span> __stl_threshold<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">__unguarded_insertion_sort</span><span class="token punctuation">(</span>first <span class="token operator">+</span> __stl_threshold<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">__insertion_sort</span><span class="token punctuation">(</span>first<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 智能指针(Smart Pointer)</title>
    <url>/c/c-smartptr/</url>
    <content><![CDATA[<p>C++ 不像 Java 那样有虚拟机动态的管理内存，如果使用裸指针，在程序运行过程中可能就会出现内存泄漏等问题，然而这种问题其实都可以通过 C++11 引入的<strong>智能指针</strong>来解决。</p>
<span id="more"></span>
<h2 id="裸指针的内存泄漏问题">裸指针的内存泄漏问题</h2>
<p>前面提到使用<strong>裸指针</strong>会存在内存泄漏等问题。这里用具体代码来说明：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>裸指针的内存泄漏</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> p <span class="token operator">=</span> <span class="token keyword">new</span> A<span class="token punctuation">;</span> <span class="token comment">// 定义 p 为指向 A 对象的裸指针</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token function">exception</span><span class="token punctuation">(</span>SomeExceptionReason<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">delete</span> p<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>func()</code> 运行过程中抛出异常或其他原因中途退出，则 <code>new</code> 出来的内存得不到释放，随着函数退出，<code>p</code> 的生存周期结束，之后这片内存就永远无法被访问，导致<strong>内存泄漏</strong>。</p>
<h2 id="智能指针">智能指针</h2>
<p><strong>智能指针</strong>设计出来就是为了解放程序员，使其无需担心是否释放内存的问题。其本质上是对裸指针进行封装，利用 RAII 思想在构造函数中 <code>new</code>，在析构函数中 <code>delete</code>，保证了内存不泄露。</p>
<p>根据不同特性，智能指针分为以下三种。</p>
<h2 id="std-unique-ptr">std::unique_ptr</h2>
<p><code>unique_ptr</code> 是一个<strong>独占型</strong>的智能指针，它<strong>不允许</strong>其它 <code>unique_ptr</code> 共享其管理的内部指针，故不允许<strong>拷贝构造</strong>与<strong>拷贝赋值</strong>，只能通过<strong>移动语义</strong>来获得资源。</p>
<p><code>unique_ptr</code> 有两个版本：</p>
<ol>
<li class="lvl-3">
<p>管理单个对象（例如以 <code>new</code> 分配）；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span>
    <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    <span class="token keyword">class</span> <span class="token class-name">Deleter</span> <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>default_delete<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span>
<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">unique_ptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>管理动态分配的对象数组（例如以 <code>new[]</code> 分配）；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span>
    <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span>
    <span class="token keyword">class</span> <span class="token class-name">Deleter</span>
<span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">unique_ptr</span><span class="token operator">&lt;</span>T<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> Deleter<span class="token operator">&gt;</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>其中 <code>Deleter</code> 指定删除器类型，即析构函数中调用的对内存进行释放的可调用对象。一旦某个 <code>unique_ptr</code> 对象以<strong>移动</strong>方式将资源转移给另一个 <code>unique_ptr</code>，或是在生命周期结束后被系统回收时，其关联的删除器会释放内部指针的所有权（即赋值为 <code>nullptr</code>）。</p>
<blockquote>
<p><code>unique_ptr</code> 的<strong>删除器</strong>要求必须是能且仅能够传入 <code>T*</code> 类型参数的左值可调用对象，而不能是 lambda 表达式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">struct</span> <span class="token class-name">deleter</span> <span class="token punctuation">{</span>
  <span class="token keyword">void</span> <span class="token keyword">operator</span><span class="token punctuation">(</span>T<span class="token operator">*</span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

deleter<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> deleter<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">,</span> d<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</blockquote>
<p>用法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>unique_ptr</span></div><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~A\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Print\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// 两种版本</span>
<span class="token keyword">auto</span> ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> ptrs <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> A<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 移动语义</span>
<span class="token keyword">auto</span> new_ptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">unique_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此时 ptr 失去了关联对象指针的所有权</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// operator bool 检查是否有关联的管理对象</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"ptr is empty"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

<span class="token comment">// 成员函数，最常用的就是 get()</span>
<span class="token keyword">auto</span> raw <span class="token operator">=</span> new_ptr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// get() 返回 A 类型的指针</span>
raw<span class="token operator">-&gt;</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 管理单个对象的 unique_ptr</span>
new_ptr<span class="token operator">-&gt;</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 可以通过 operator-&gt; 解引用，看起来就像一个裸指针一样</span>
<span class="token punctuation">(</span><span class="token operator">*</span>new_ptr<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 可以通过 operator* 解引用</span>

<span class="token comment">// 管理对象数组的 unique_ptr 可以通过 operator[] 以下标访问对象（而非指针）</span>
ptrs<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">Print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/*
 * output:
 * ptr is empty
 * Print
 * Print
 * Print
 * Print
 * ~A
 * ~A
 * ~A
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="std-shared-ptr">std::shared_ptr</h2>
<p>与 <code>unique_ptr</code> 相反，<code>shared_ptr</code> 是一个<strong>共享型</strong>的智能指针，它<strong>允许</strong>其它 <code>shared_ptr</code> 共享其管理的内部指针，故实现了<strong>拷贝构造</strong>与<strong>拷贝赋值</strong>，并通过这两种方式进行资源共享。</p>
<p>既然允许共享，那就存在多个 <code>shared_ptr</code> 使用同一片内存，故不能直接在析构时释放内存。在典型的实现中，<code>std::shared_ptr</code> 只保有两个指针：<strong>数据指针</strong> <code>_M_ptr</code> 以及<strong>计数器指针</strong> <code>_M_refcount</code>。</p>
<blockquote>
<p>计数器包含：</p>
<ul class="lvl-1">
<li class="lvl-2">指向被管理对象的指针或被管理对象本身；</li>
<li class="lvl-2">删除器；</li>
<li class="lvl-2">分配器；</li>
<li class="lvl-2">被管理对象的 shared_ptr 的数量（<strong>引用计数</strong>）；</li>
<li class="lvl-2">被管理对象的 weak_ptr 的数量；</li>
</ul>
</blockquote>
<p>每当以拷贝的形式新建了一个 <code>shared_ptr</code>，则指向同一片内存的所有 <code>shared_ptr</code> 的引用计数都会加一，每次析构的时候引用计数减一，在最后一个 <code>shared_ptr</code> 析构的时候（也就是引用计数归零时），对应的内存才会释放。</p>
<p>同为智能指针家族，<code>shared_ptr</code> 也实现了以下功能：</p>
<ol>
<li class="lvl-3">
<p><code>get()</code>：获取内部关联的对象指针。</p>
</li>
<li class="lvl-3">
<p><code>operator*</code> / <code>operator-&gt;</code>：解引用关联的指针；</p>
</li>
<li class="lvl-3">
<p><code>operator bool</code>：检查是否有关联的管理对象；</p>
</li>
</ol>
<p>除此之外，其还对外公开了一个 <code>use_count()</code> 函数，用于返回引用计数值。</p>
<p><code>shared_ptr</code> 还可以自定义<strong>删除器</strong>，在引用计数为零的时候自动调用删除器来释放对象的内存，这里删除器只需要是传入 <code>T*</code> 参数的可调用对象即可：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">ptr</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">delete</span> p<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>shared_ptr</code> 实现上较 <code>unique_ptr</code> 更为宽松，但代价为存在一些安全隐患，需要注意的是：</p>
<ol>
<li class="lvl-3">
<p>不用同一个裸指针初始化多个 <code>shared_ptr</code>，也不要对 <code>get()</code> 返回的裸指针进行 <code>delete</code>，否则会出现 <strong>double free</strong> 导致出问题；</p>
</li>
<li class="lvl-3">
<p>不将 <code>this</code> 指针初始化 <code>shared_ptr</code> 并返回，否则会出现 <strong>double free</strong>，比如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>this 的 double free</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>A 本身会调用析构函数，函数返回值由于关联了 <code>this</code> 指针，进行 <code>delete this</code> 时还会调用一遍析构函数。如果非要实现这一功能，请继承自 <code>std::enable_shared_from_this&lt;A&gt;</code>，之后就可以调用 <code>shared_from_this()</code> 来获取一个指向自身的 shared ptr 了。</p>
</li>
<li class="lvl-3">
<p>尽量用 <code>make_shared</code> 代替 <code>new</code>，比如：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  <span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> <span class="token function">p</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> q <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 等价于上面那种，but better</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>make_shared()</code> 为我们提供了一个新的创建共享指针的方法，其函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">&gt;</span>
shared_ptr<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> <span class="token function">make_shared</span><span class="token punctuation">(</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>以 <code>args</code> 为 <code>T</code> 的构造函数参数列表，构造 <code>T</code> 类型对象并将它包装于 <code>shared_ptr</code>。</p>
<p>等价于用表达式 <code>new T(std::forward&lt;Args&gt;(args)...)</code> 构造，其中 <code>pv</code> 是内部指向适合保有 <code>T</code> 类型对象的存储的 <code>void*</code> 指针。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>避免<strong>循环引用</strong>。所谓循环引用，就是存在一个引用通过一系列的引用链，最后引用回自身，且看代码：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>循环引用</span></div><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> other<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> other<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> aptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// aptr.count = 1</span>
  <span class="token keyword">auto</span> bptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bptr.count = 1</span>
  aptr<span class="token operator">-&gt;</span>other <span class="token operator">=</span> bptr<span class="token punctuation">;</span>                <span class="token comment">// 由于 copy，bptr.count++</span>
  bptr<span class="token operator">-&gt;</span>other <span class="token operator">=</span> aptr<span class="token punctuation">;</span>                <span class="token comment">// 由于 copy，aptr.count++</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里 aptr 指向了 A 类对象，随后 aptr.other 又与另一个指向 B 类对象的共享指针 bptr 通过拷贝的方式共享了指针，并且 bptr.other 也通过拷贝的方式与 aptr 共享了指针。这样一来 aptr 的 other 指向的对象 bptr，其 other 又指回了自身，从而存在<strong>循环引用</strong>，并且此时两者的引用计数值均为 2。</p>
<p>当程序结束时，aptr, bptr 调用析构函数，引用计数值减一，但此时两块内存的引用计数值仍然大于零，永远得不到释放。糟糕透了！</p>
</li>
</ol>
<h2 id="std-weak-ptr">std::weak_ptr</h2>
<p>为了解决共享指针可能存在的<strong>循环引用</strong>问题，<code>weak_ptr</code> 被提出。</p>
<p><code>weak_ptr</code> 用来表达<strong>临时所有权</strong>的概念：它不管理指针，也就没有 <code>get()</code> 函数，只能通过 <code>weak_ptr</code> / <code>shared_ptr</code> 进行构造。其拷贝与析构都不会影响引用计数，纯粹是作为一个<strong>旁观者</strong>监视 <code>shared_ptr</code> 中管理的资源是否存在，该功能可以通过成员函数 <code>expire()</code> 实现——检查被引用的对象是否已删除。</p>
<blockquote>
<p>当某个对象只有存在时才需要被访问，而且随时可能被他人删除时，可以使用 <code>weak_ptr</code> 来监视该对象。</p>
</blockquote>
<p>当真正需要通过<code> weak_ptr</code> 去调用那片内存时，需创建一个新的<strong>临时</strong> <code>shared_ptr</code> 来共享被管理对象的所有权，此时如果原来的 <code>shared_ptr</code> 被销毁，则该对象的生命周期将被延长至这个临时的 <code>shared_ptr</code> 同样被销毁为止。</p>
<p>具体用法为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>weak_ptr</span></div><code class="language-cpp"><span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">shared_p</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> weak_p <span class="token operator">=</span> shared_p<span class="token punctuation">;</span> <span class="token comment">// weak_ptr 不共享所有权，仅作监视用</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> shared_p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> weak_p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

<span class="token keyword">auto</span> q <span class="token operator">=</span> weak_p<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// lock() 创建新的 std::shared_ptr 对象</span>
std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> shared_p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> weak_p<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> q<span class="token punctuation">.</span><span class="token function">use_count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// output:</span>
<span class="token comment">// 1 1</span>
<span class="token comment">// 2 2 2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在这样的基础上，<code>weak_ptr</code> 也就能够打破 <code>shared_ptr</code> 中所存在的循环引用现象——令循环中的其中一个指针为 <code>weak_ptr</code> 即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>解决循环引用</span></div><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">A</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> other<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>weak_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> other<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> aptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// aptr.count = 1</span>
  <span class="token keyword">auto</span> bptr <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// bptr.count = 1</span>
  aptr<span class="token operator">-&gt;</span>other <span class="token operator">=</span> bptr<span class="token punctuation">;</span>
  bptr<span class="token operator">-&gt;</span>other <span class="token operator">=</span> aptr<span class="token punctuation">;</span>
  <span class="token comment">// 不存在 shared_ptr 之间的拷贝，故引用计数值不会发生变化。</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="如何手撕一个简单的-shared-ptr">如何手撕一个简单的 shared ptr</h2>
<p>首先思考的是：shared ptr 需要支持哪些特性？</p>
<ol>
<li class="lvl-3">
<p>类模板，支持所有类型及其构造函数参数；</p>
</li>
<li class="lvl-3">
<p>线程安全的计数器；</p>
</li>
<li class="lvl-3">
<p>拷贝/赋值/移动构造函数；</p>
</li>
<li class="lvl-3">
<p>支持用派生类构造；</p>
</li>
<li class="lvl-3">
<p>正确释放指针；</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>实现 shared_ptr</span></div><code class="language-cpp">
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SharedPointer</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">class</span> <span class="token class-name">Counter</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">Counter</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">ptr_</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">cnt_</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">Counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">delete</span> ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cnt_<span class="token punctuation">.</span><span class="token function">fetch_add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">void</span> <span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cnt_<span class="token punctuation">.</span><span class="token function">fetch_sub</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    <span class="token keyword">int</span> <span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> cnt_<span class="token punctuation">.</span><span class="token function">load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
    T<span class="token operator">*</span> ptr_<span class="token punctuation">;</span>

   <span class="token keyword">private</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> cnt_<span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SharedPointer</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> counter_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Counter</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">// copy constructor</span>
  <span class="token function">SharedPointer</span><span class="token punctuation">(</span><span class="token keyword">const</span> SharedPointer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counter_ <span class="token operator">=</span> sp<span class="token punctuation">.</span>counter_<span class="token punctuation">;</span>
    counter_<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  SharedPointer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> SharedPointer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counter_ <span class="token operator">=</span> sp<span class="token punctuation">.</span>counter_<span class="token punctuation">;</span>
    counter_<span class="token operator">-&gt;</span><span class="token function">addRef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// move constructor</span>
  <span class="token function">SharedPointer</span><span class="token punctuation">(</span>SharedPointer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counter_ <span class="token operator">=</span> sp<span class="token punctuation">.</span>counter_<span class="token punctuation">;</span>
    sp<span class="token punctuation">.</span>counter_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  SharedPointer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>SharedPointer<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span> sp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counter_ <span class="token operator">=</span> sp<span class="token punctuation">.</span>counter_<span class="token punctuation">;</span>
    sp<span class="token punctuation">.</span>counter_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// derived constructor</span>
  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
  <span class="token function">SharedPointer</span><span class="token punctuation">(</span>U<span class="token operator">*</span> derive<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">assert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>is_base_of<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> U<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    counter_ <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Counter</span><span class="token punctuation">(</span>derive<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">SharedPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    counter_<span class="token operator">-&gt;</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>counter_<span class="token operator">-&gt;</span><span class="token function">getCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> counter_<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> counter_<span class="token operator">-&gt;</span>ptr_<span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">bool</span> <span class="token function">isNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  Counter<span class="token operator">*</span> counter_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 静态修饰符(Static)</title>
    <url>/c/c-static/</url>
    <content><![CDATA[<p><strong><code>static</code></strong> 是 C++ 中很常用的修饰符，它被用来控制变量的存储方式和可见性。</p>
<span id="more"></span>
<h2 id="static-普通变量">static 普通变量</h2>
<p><code>static</code> 修饰的普通变量存储在<strong>静态区</strong>，其生命周期延长至整个程序结束。只有第一次会执行初始化，若无初始值，则用默认值进行初始化。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"~Foo\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">static</span> Foo f<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Start\n"</span><span class="token punctuation">;</span>
  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 初始化 Foo f</span>
  <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不再对 f 初始化</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"End\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output:</span>
<span class="token comment">// Start</span>
<span class="token comment">// Foo</span>
<span class="token comment">// End</span>
<span class="token comment">// ~Foo</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>特别的，<code>static</code> 修饰<strong>全局变量</strong>时，这个全局变量只能在本文件中访问，不能在其它文件中访问，即便是 <code>extern</code> 外部声明也不可以。</p>
<h2 id="static-函数">static 函数</h2>
<p><code>static</code> 修饰的函数仅在定义该函数的文件内才能使用。一般在多人开发项目时，为了防止与他人命名空间里的函数重名，可以这么做。</p>
<h2 id="static-类成员变量-类成员函数">static 类成员变量/类成员函数</h2>
<p><code>static</code> 修饰的类成员变量/类成员函数提供一层<strong>类共享</strong>语义，即该成员变量/函数<strong>不属于任一对象，而是属于整个类</strong>，在内存中只占用一份空间，可直接通过 <code>类名::成员变量名</code> 或 <code>类名::成员函数名</code> 访问，而不需要先创建对象。根据这一特点，静态函数中也就不存在 <code>this</code> 指针，也无法使用非静态成员变量。</p>
<blockquote>
<p>非静态成员变量依附于特定的对象，而静态成员函数在类实例化之前就已经分配空间，此时非静态成员变量连个影子都见不到，更别说使用了。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> non_static<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 静态函数既可在类内定义，也可在类外定义</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> non_static<span class="token punctuation">;</span> <span class="token comment">// ERROR! 不能在静态函数中使用非静态变量</span>
    <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// ERROR! 不能在静态函数中调用非静态函数</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>   <span class="token comment">// OK! 可以在非静态函数中调用静态函数，这里的 func1 并不会隐式使用 this</span>

  <span class="token keyword">static</span> <span class="token keyword">int</span> val1；
  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> val2<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// 静态常量可以在类内定义</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> val3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">int</span> Foo<span class="token double-colon punctuation">::</span>val1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">// 静态非常量只能在类外定义</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> Foo<span class="token double-colon punctuation">::</span>val3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// 静态常量也能在类外定义</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span>
  <span class="token class-name">Foo</span><span class="token double-colon punctuation">::</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! 不能用此法调用非静态函数</span>

  Foo f<span class="token punctuation">;</span>
  f<span class="token punctuation">.</span><span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// OK! 既然 func1 属于 Foo 类，那么任一对象均可调用该函数</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>需要注意的是：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>静态成员变量必须先初始化；</p>
</li>
<li class="lvl-2">
<p>构造函数与析构函数、运算符重载这类特殊函数不能用 <code>static</code> 进行修饰；</p>
</li>
<li class="lvl-2">
<p>⚠️如果在类内初始化静态常量，并且采用声明与实现分离的方式编码，则此时在 <code>.cpp</code> 文件中访问 <code>.h</code> 中初始化的 <code>static const</code> 变量则可能报 「undefined reference」 的链接错误。如果遇到这种情况，有两种解决方案</p>
<ul class="lvl-2">
<li class="lvl-4">
<p>改为类外初始化；</p>
</li>
<li class="lvl-4">
<p>改用 <code>constexpr</code> 在类内初始化；</p>
<blockquote>
<p>之所以说「<strong>可能</strong>」，是因为在某些情况下编译器可能会直接进行对 <code>.cpp</code> 中的 <code>static const</code> 变量直接用值进行替换，这样就不会用到符号了，也就不会在链接器种报错。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++ の 流(Stream)</title>
    <url>/c/c-stream/</url>
    <content><![CDATA[<p>C++ 程序常用 <code>cin</code> ， <code>cout</code> 进行标准 I/O（从键盘读取数据，或输出数据到屏幕），当然也可以进行文件 I/O （基于文件的数据读写）。这些行为本质上都是进行数据传输——数据向水流一样从一个地方流到另一个地方。C++11 中，将这些操作统一为"流( <strong>stream</strong> )"。</p>
<span id="more"></span>
<p>整个"流式家族"的类继承图长这样：</p>
<img src="image-20230114162631819.png" alt="Stream 继承结构" style="zoom:67%; ">
<blockquote>
<p>其中 istream 与 ostream 共同派生了 iostream，为了避免"菱形继承"，其对 ios 的继承采用虚继承。</p>
</blockquote>
<h2 id="抽象-I-O">抽象 I/O</h2>
<h2 id="ios-base">ios_base</h2>
<p>作为所有输入/输出流类的基类，维护多个数据如状态信息</p>
<h3 id="iostate">iostate</h3>
<p>静态变量，指定流状态标志，为 <strong>bit mask</strong> ，即出现情况时将对应 bit 置位。有以下四种标志：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>goodbit</strong></td>
<td style="text-align:center"><strong>0x0</strong> ，表示输入输出无错误</td>
</tr>
<tr>
<td style="text-align:center"><strong>badbit</strong></td>
<td style="text-align:center"><strong>0x1</strong> ，表明出现了无法挽回的致命错误</td>
</tr>
<tr>
<td style="text-align:center"><strong>eofbit</strong></td>
<td style="text-align:center"><strong>0x2</strong> ，表示操作已到达缓冲区末尾</td>
</tr>
<tr>
<td style="text-align:center"><strong>failbit</strong></td>
<td style="text-align:center"><strong>0x4</strong> ，表明出现了可挽回的失败操作，比如格式化错误（如试图读取整数变量却遇到字母）</td>
</tr>
</tbody>
</table>
<blockquote>
<p>当非 goodbit 状态位被打开时，一切读取会被阻塞。</p>
</blockquote>
<h3 id="fmtflags">fmtflags</h3>
<p>指定流格式控制标志，为 <strong>bit mask</strong> 。通过 <code>setf()</code> / <code>unsetf()</code> 函数进行开关。常见有以下五种标志：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>boolalpha</strong></td>
<td style="text-align:center"><strong>0x1</strong> ，控制 <code>true</code> / <code>false</code> 与真值/非真值的互相解析</td>
</tr>
<tr>
<td style="text-align:center"><strong>dec</strong></td>
<td style="text-align:center"><strong>0x2</strong> ，修改输出数据为十进制表示</td>
</tr>
<tr>
<td style="text-align:center"><strong>hex</strong></td>
<td style="text-align:center"><strong>0x8</strong> ，修改输出数据为十六进制表示</td>
</tr>
<tr>
<td style="text-align:center"><strong>oct</strong></td>
<td style="text-align:center"><strong>0x40</strong> ，修改输出数据为八进制表示</td>
</tr>
<tr>
<td style="text-align:center"><strong>skipws</strong></td>
<td style="text-align:center"><strong>0x1000</strong> ，默认为开启状态，使得输入流跳过前导空白字符</td>
</tr>
</tbody>
</table>
<h3 id="openmode">openmode</h3>
<p>指定流打开标志，为 <strong>bit mask</strong> 。有以下六种标志：</p>
<table>
<thead>
<tr>
<th style="text-align:center">标志</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>app</strong></td>
<td style="text-align:center"><strong>0x1</strong> ，每次写入前将指针定位到流结尾，即 append</td>
</tr>
<tr>
<td style="text-align:center"><strong>ate</strong></td>
<td style="text-align:center"><strong>0x2</strong> ，将指针定位到流结尾处，即 at end</td>
</tr>
<tr>
<td style="text-align:center"><strong>bin</strong></td>
<td style="text-align:center"><strong>0x4</strong> ，以二进制模式打开，即 binary</td>
</tr>
<tr>
<td style="text-align:center"><strong>in</strong></td>
<td style="text-align:center"><strong>0x8</strong> ，以读模式打开</td>
</tr>
<tr>
<td style="text-align:center"><strong>out</strong></td>
<td style="text-align:center"><strong>0x10</strong> ，以写模式打开</td>
</tr>
<tr>
<td style="text-align:center"><strong>trunc</strong></td>
<td style="text-align:center"><strong>0x20</strong> ，在打开时清空流的内容，即 truncate</td>
</tr>
</tbody>
</table>
<h2 id="basic-ios">basic_ios</h2>
<p>类模板，直接与缓冲区打交道，并提供若干 api。基于父类 ios_base 的状态标志，其提供了若干状态函数：</p>
<table>
<thead>
<tr>
<th style="text-align:center">状态函数</th>
<th style="text-align:center">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>good()</strong></td>
<td style="text-align:center">若流的 goodbit 置位，则返回 true</td>
</tr>
<tr>
<td style="text-align:center"><strong>eof()</strong></td>
<td style="text-align:center">若流的 eofbit 置位，则返回 true</td>
</tr>
<tr>
<td style="text-align:center"><strong>fail()</strong></td>
<td style="text-align:center">若流的 failbit 置位，则返回 true</td>
</tr>
<tr>
<td style="text-align:center"><strong>bad()</strong></td>
<td style="text-align:center">若流的 badbit 置位，则返回 true</td>
</tr>
<tr>
<td style="text-align:center"><strong>operator !</strong></td>
<td style="text-align:center">等同于 !fail()</td>
</tr>
<tr>
<td style="text-align:center"><strong>operator bool</strong></td>
<td style="text-align:center">等同于 fail()</td>
</tr>
<tr>
<td style="text-align:center"><strong>rdstate()</strong></td>
<td style="text-align:center">返回当前状态</td>
</tr>
<tr>
<td style="text-align:center"><strong>setstate()</strong></td>
<td style="text-align:center">设置状态信息</td>
</tr>
<tr>
<td style="text-align:center"><strong>clear()</strong></td>
<td style="text-align:center">清空状态信息</td>
</tr>
</tbody>
</table>
<h2 id="istream-ostream-iostream">istream / ostream / iostream</h2>
<p>分别为用于输入与输出的流类，头文件 <code>&lt;iostream&gt;</code> 中定义了四个全局变量对象 <code>cin</code> ， <code>cout</code> ， <code>cerr</code> ， <code>clog</code> 。</p>
<h3 id="cin">cin</h3>
<p>标准输入流对象，主要用于标准输入，即键盘的输入。用户在键盘上敲入字符串后，需按下回车键后，该字符串才会进入所谓 <strong>缓冲区</strong> 的区域，并且回车会被转为换行符 <code>\n</code> 。以 cin 为例，其读取数据就是从缓冲区获取数据，当缓冲区为空时，它会自我阻塞，直至用户将字符串冲入缓冲区。</p>
<p>其输入函数主要有以下几种：</p>
<h4 id="operator">operator &gt;&gt;</h4>
<p>该函数原型有以下两种重载形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span> Type<span class="token operator">&amp;</span> value <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 特化为 int, short, char 等基本类型</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span> IOtype<span class="token operator">&amp;</span> <span class="token punctuation">(</span>func<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>IOtype<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// IOtype 主要指 istream 及其所有基类</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>第一种重载模式支持仅基本类型，而第二种重载模式参数为函数指针，常见有 I/O 操纵符，如 <code>std::boolalpha</code>。</p>
<p>可以看到所有返回值类型都为引用，实际上返回值为自身引用 <code>*this</code>，这也很好的支持了连续输入：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b<span class="token punctuation">;</span> <span class="token comment">// 等价于 (cin.operator&gt;&gt;(a)).operator&gt;&gt;(b);</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>注意，当 cin 用运算符 <strong>&gt;&gt;</strong> 从缓冲区中读取数据时，会不断忽略并清除缓冲区开始的空白字符（空格、回车、制表符），直至读取成功，读取时也会将字符从缓冲区中取出。剩余部分残留在缓冲区中，不作处理。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">double</span> b<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string c<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> c<span class="token punctuation">;</span>

    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>

<span class="token punctuation">}</span>

<span class="token comment">// input: [回车][回车]1 1.2 foo bar</span>
<span class="token comment">// output: 1 1.2 foo[回车]bar</span>
<span class="token comment">// 根据 output 的表现易得，第一个 cin 读至 "foo" 后的空格后暂停，此时缓冲区中剩下{'b', 'a', 'r'}，继续被第二个 cin 读取</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="get">get</h4>
<p>该函数主要有以下四种重载形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 从缓冲区中读并取出单个字符</span>
<span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> ch <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这两种形式均判断给定字符是否可用，若可用，第一种返回字符 ASCII 码值，否则返回 <code>Traits::eof()</code> 并设置 failbit 和 eofbit；第二种将字符赋给 ch，否则，返回 <code>Traits::eof()</code> 并设置 failbit 和 eofbit。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 从缓冲区中读并取出多个字符，结束符会保留在缓冲区中</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>streamsize count <span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>streamsize count<span class="token punctuation">,</span> <span class="token keyword">char</span> delim <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这两种形式均读取至多 <code>count-1</code> 个字符并将其存储到 s 中（字符串最后为 <code>\0</code>，下同），直至满足任一以下条件：</p>
<ol>
<li class="lvl-3">
<p>已读取 <code>count-1</code> 个字符；</p>
</li>
<li class="lvl-3">
<p>到达文件末尾，此时调用 <code>setstate(eofbit)</code>；</p>
</li>
<li class="lvl-3">
<p>下一个字符为结束符，第一种的结束符为 <code>\n</code>，第二种的结束符为用户指定字符 <code>delim</code>。此条件下，结束符会保留在缓冲区中；</p>
</li>
</ol>
<h4 id="getline">getline</h4>
<p>该函数主要有以下两种重载形式，以及一个同名的全局函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 从缓冲区中读并取出多个字符</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token function">getline</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>streamsize count <span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token function">getline</span><span class="token punctuation">(</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>streamsize count<span class="token punctuation">,</span> <span class="token keyword">char</span> delim <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这两种形式均读取至多 <code>count-1</code> 个字符并将其存储到 s 中，直至满足任一以下条件：</p>
<ol>
<li class="lvl-3">
<p>已读取 <code>count-1</code> 个字符；</p>
</li>
<li class="lvl-3">
<p>到达文件末尾，此时调用 <code>setstate(eofbit)</code>；</p>
</li>
<li class="lvl-3">
<p>下一个字符为结束符。此条件下，结束符会被取出；</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 从缓冲区中读并取出多个字符</span>
std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> input<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>basic_string<span class="token operator">&amp;</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span><span class="token function">getline</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> input<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>basic_string<span class="token operator">&amp;</span> str<span class="token punctuation">,</span> <span class="token keyword">char</span> delim <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p><code>std::string</code> 其实是 <code>std::basic_string</code> 的特化，即 <code>std::basic_string&lt;char, std::char_traits&lt;char&gt;, std::allocate&lt;char&gt;&gt;</code>。</p>
</blockquote>
<p>这两种形式均读取多个字符并将其存储到 s 中，直至满足任一以下条件：</p>
<ol>
<li class="lvl-3">
<p>到达文件末尾，此时调用 <code>setstate(eofbit)</code>；</p>
</li>
<li class="lvl-3">
<p>下一个字符为结束符。此条件下，结束符会被一并存入 <code>string</code> 中，再转换为 <code>\0</code>；</p>
</li>
</ol>
<h4 id="ignore">ignore</h4>
<p>该函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token function">ignore</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>streamsize count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">int</span> delim <span class="token operator">=</span> <span class="token class-name">Traits</span><span class="token double-colon punctuation">::</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>其从输入流中提取并舍弃元素，直至满足任一以下条件：</p>
<ol>
<li class="lvl-3">
<p>已提取 <code>count</code> 个字符。在 <code>count = std::numeric_limits&lt;std::stream_size&gt;::max()</code> 的特殊情况下忽略此条件；</p>
</li>
<li class="lvl-3">
<p>到达文件末尾，此时调用 <code>setstate(eofbit)</code>；</p>
</li>
<li class="lvl-3">
<p>遇到结束符。此条件下，ignore 会将结束符舍弃；</p>
</li>
</ol>
<p>根据这一特性，可以利用该函数来清空缓冲区。</p>
<h3 id="cout">cout</h3>
<p>标准输出流对象，主要用于标准输出，即将数据输出到屏幕上。</p>
<p>其输出函数主要有以下几种：</p>
<h4 id="operator-2">operator &lt;&lt;</h4>
<p>该函数主要有以下两种重载形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span> Type<span class="token operator">&amp;</span> value <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 特化为 int, short, char 等基本类型</span>
std<span class="token double-colon punctuation">::</span>basic_istream<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span> IOtype<span class="token operator">&amp;</span> <span class="token punctuation">(</span>func<span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span>IOtype<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// IOtype 主要指 istream 及其所有基类</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>两种重载模式和 <code>cin.operator&gt;&gt;</code> 大体相同。</p>
<h4 id="put">put</h4>
<p>该函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&amp;</span> <span class="token function">put</span><span class="token punctuation">(</span> <span class="token keyword">char</span> ch <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>写字符 <code>ch</code> 到输出流。若输出因任何原因失败，则调用 <code>setstate(badbit)</code> 。</p>
<h3 id="cerr">cerr</h3>
<p>标准错误输出流，用于向屏幕输出出信息。</p>
<h3 id="clog">clog</h3>
<p>标准错误输出流，用于向屏幕输出日志信息。</p>
<h2 id="字符串-I-O">字符串 I/O</h2>
<h2 id="istringstream-ostringstream-stringstream">istringstream / ostringstream / stringstream</h2>
<p>分别实现基于 <strong>字符串</strong> 的流输入与输出操作，可以直接以字符串为参数构造对象，同时也可以指定打开标志 <code>std::ios_base::openmode</code> 。此外，也可以通过 <code>str()</code> 函数获取对象底层数据结构中的字符串，亦可以通过重载的 <code>str(std::basic_string)</code> 函数修改底层字符串内容。</p>
<p>下面是一个示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>

    std<span class="token double-colon punctuation">::</span>istringstream <span class="token function">iss</span><span class="token punctuation">(</span><span class="token string">"123 1.23 abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">int</span> a<span class="token punctuation">;</span>
    <span class="token keyword">double</span> b<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string c<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"before: "</span> <span class="token operator">&lt;&lt;</span> iss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>  <span class="token comment">// 利用 str() 获取流中字符串</span>
    iss <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    iss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token string">"456 4.56 def"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token comment">// 利用 str(string) 修改流中字符串</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"after: "</span> <span class="token operator">&lt;&lt;</span> iss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    iss <span class="token operator">&gt;&gt;</span> a <span class="token operator">&gt;&gt;</span> b <span class="token operator">&gt;&gt;</span> c<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> b <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>ostringstream <span class="token function">oss1</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ios_base<span class="token double-colon punctuation">::</span>ate<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 指定打开模式，指针定位到末尾</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> oss1<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>ostringstream <span class="token function">oss2</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// 控制变量</span>
    oss2 <span class="token operator">&lt;&lt;</span> <span class="token string">"bar"</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> oss2<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>

<span class="token punctuation">}</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后输出如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">before<span class="token operator">:</span> <span class="token number">123</span> <span class="token number">1.23</span> abc
<span class="token number">123</span> <span class="token number">1.23</span> abcabc
after<span class="token operator">:</span> <span class="token number">456</span> <span class="token number">4.56</span> def
<span class="token number">123</span> <span class="token number">1.23</span> abc
foobar
bar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里不难发现，stringstream 提供了一种将字符串转化为其他不同数据类型的新方式。</p>
<h2 id="文件-I-O">文件 I/O</h2>
<h2 id="ifstream-ofstream-fstream">ifstream / ofstream / fstream</h2>
<p>分别实现基于 <strong>文件</strong> 的流输入与输出操作，通过文件名构造对象，同时也可以指定打开标志 <code>std::ios_base::openmode</code> 。通过 <code>open()</code> / <code>close()</code> 来打开/取消关联文件，并可以通过 <code>is_open()</code> 检查流是否有关联文件。</p>
<h2 id="I-O-操纵符">I/O 操纵符</h2>
<p>操纵符是令代码能以 <code>operator&lt;&lt;</code> 或 <code>operator&gt;&gt;</code> 控制流输入/输出格式的帮助函数，相当于一个"开关"。其函数原型统一如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>ios_base<span class="token operator">&amp;</span> std<span class="token double-colon punctuation">::</span> <span class="token function">CONTROL_TYPE</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>ios_base<span class="token operator">&amp;</span> str <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>这些操纵符的函数名与 <code>ios_base</code> 类中的 <code>fmtflags</code> 标志名几乎一致，但所处命名空间不同：操纵符直接在 <code>std</code> 下，而 <code>fmtflags</code> 在 <code>std::ios_base</code> 下。</p>
</blockquote>
<p>传入  <code>operator&lt;&lt;</code> 或 <code>operator&gt;&gt;</code> 后，实际行为如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 以 std::cin 为例</span>
<span class="token keyword">operator</span><span class="token operator">&gt;&gt;</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>CONTROL_TYPE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">CONTROL_TYPE</span><span class="token punctuation">(</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对 * this 进行一些流控制比特位的设置，效果等同于 cin.setf(std::ios_base::CONTROL_TYPE)</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="endl">endl</h2>
<p>此为仅用于输出的控制符，其函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">CharT</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Traits</span> <span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span>CharT<span class="token punctuation">,</span> Traits<span class="token operator">&gt;</span><span class="token operator">&amp;</span> <span class="token function">endl</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>basic_ostream<span class="token operator">&lt;</span>CharT<span class="token punctuation">,</span> Traits<span class="token operator">&gt;</span><span class="token operator">&amp;</span> os <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>其作用为将换行符插入输出流。效果等同于 <code>\n</code>，但开销相对而言更高。</p>
<h2 id="boolalpha-noboolalpha">boolalpha / noboolalpha</h2>
<p><code>boolalpha</code> 启用流中的布尔控制开关，表现为：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>输入流中将 <code>true</code> 解析为真值，其余均为非真值；</p>
</li>
<li class="lvl-2">
<p>输出流中将所有真值表达为 <code>true</code>，非真值为 <code>false</code>。</p>
</li>
</ul>
<p>而 <code>noboolalpha</code> 则关闭这一开关。示例如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改输出</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>boolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"boolalpha: "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>noboolalpha <span class="token operator">&lt;&lt;</span> <span class="token string">"noboolalpha: "</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">true</span> <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span>  <span class="token boolean">false</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 解析输入</span>
    <span class="token keyword">bool</span> b1<span class="token punctuation">,</span> b2<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>istringstream <span class="token function">iss</span><span class="token punctuation">(</span><span class="token string">"true false"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    iss <span class="token operator">&gt;&gt;</span> std<span class="token double-colon punctuation">::</span>boolalpha <span class="token operator">&gt;&gt;</span> b1 <span class="token operator">&gt;&gt;</span> b2<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> iss<span class="token punctuation">.</span><span class="token function">str</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">": "</span> <span class="token operator">&lt;&lt;</span> b1 <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> b2<span class="token punctuation">;</span>

    <span class="token keyword">return</span> EXIT_SUCCESS<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">boolalpha<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token boolean">false</span>
noboolalpha<span class="token operator">:</span> <span class="token number">1</span> <span class="token number">0</span>
<span class="token boolean">true</span> <span class="token boolean">false</span><span class="token operator">:</span> <span class="token number">1</span> <span class="token number">0</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="skipws-noskipws">skipws / noskipws</h2>
<p><code>skipws</code> 默认为开启状态，使得输入流跳过前导空白字符；而使用 <code>noskipws</code> 后不会跳过。示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> c1<span class="token punctuation">,</span> c2<span class="token punctuation">,</span> c3<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">istringstream</span><span class="token punctuation">(</span><span class="token string">"a b c"</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> c1 <span class="token operator">&gt;&gt;</span> c2 <span class="token operator">&gt;&gt;</span> c3<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"skipws: "</span> <span class="token operator">&lt;&lt;</span> c1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c2 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c3 <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">istringstream</span><span class="token punctuation">(</span><span class="token string">"a b c"</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> std<span class="token double-colon punctuation">::</span>noskipws <span class="token operator">&gt;&gt;</span> c1 <span class="token operator">&gt;&gt;</span> c2 <span class="token operator">&gt;&gt;</span> c3<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"noskipws: "</span> <span class="token operator">&lt;&lt;</span> c1 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c2 <span class="token operator">&lt;&lt;</span> <span class="token string">" "</span> <span class="token operator">&lt;&lt;</span> c3<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">skipws<span class="token operator">:</span> a b c
noskipws<span class="token operator">:</span> a   b
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="oct-dec-hex">oct / dec / hex</h2>
<p>开启后修改输入输出数的进制表示，分别对应八/十/十六进制。示例：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sstream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 修改输出</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"octal:   "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>oct <span class="token operator">&lt;&lt;</span> <span class="token number">42</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"decimal: "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>dec <span class="token operator">&lt;&lt;</span> <span class="token number">42</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"hex:     "</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>hex <span class="token operator">&lt;&lt;</span> <span class="token number">42</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>

    <span class="token comment">// 解析输入</span>
    <span class="token keyword">int</span> n<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">istringstream</span><span class="token punctuation">(</span><span class="token string">"2A"</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> std<span class="token double-colon punctuation">::</span>hex <span class="token operator">&gt;&gt;</span> n<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>dec <span class="token operator">&lt;&lt;</span> <span class="token string">"hex to dec: "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>oct <span class="token operator">&lt;&lt;</span> <span class="token string">"hex to oct: "</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">octal<span class="token operator">:</span>   <span class="token number">52</span>
decimal<span class="token operator">:</span> <span class="token number">42</span>
hex<span class="token operator">:</span>     <span class="token number">2</span>a
hex to dec<span class="token operator">:</span> <span class="token number">42</span>
hex to oct<span class="token operator">:</span> <span class="token number">52</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>C++11 の 左值与右值(Lvalue &amp; Rvalue)</title>
    <url>/c/c-value/</url>
    <content><![CDATA[<p>早年的 C++ 中已经出现了<strong>左值</strong>与<strong>右值</strong>这两个基本概念，但并不重要，平时也不怎么会用到。直到 C++11 引入了<strong>右值引用</strong>等新特性，这俩概念终于翻身做起了主人——它们是理解<strong>移动</strong>与<strong>转发</strong>语义的重要基础。</p>
<span id="more"></span>
<h2 id="值">值</h2>
<p>所有<strong>值类别</strong>可用以下韦恩图描述：</p>
<img src="image-20230120230912975.png" style="zoom:50%;">
<h3 id="左值-Lvalue-，右值-Rvalue">左值(Lvalue)，右值(Rvalue)</h3>
<p>先来谈谈什么是<strong>左值</strong>与<strong>右值</strong>。</p>
<p>一般来说，可以放在等号左边的就是左值，只能放在等号右边的就是右值。</p>
<p>更准确的说，可以取地址并具有变量名的是左值，左值 <strong>L-value</strong> 中的 <strong>L</strong> 既可以认为是 <strong>Left</strong>，也可以理解为 <strong>Location</strong>，即<strong>地址</strong>，换句话说就是其在内存中有<strong>可访问</strong>的地址。</p>
<p>相反，不是左值的值，就是右值，其只存在于<strong>临时寄存器</strong>中，无法在内存中寻址，不具有持久性，因而无法放在等号左侧进行赋值操作，并且同一个作用域里的两个相等的右值事实上是两个<strong>不同</strong>的右值。例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">char</span> <span class="token operator">*</span>ch <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span> <span class="token comment">// ch 是左值，"hello" 是字符串字面量，也是左值</span>
<span class="token keyword">int</span> b <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token comment">// b, c 是左值，1, 2 是右值</span>
<span class="token keyword">int</span> a <span class="token operator">=</span> b <span class="token operator">+</span> c<span class="token punctuation">;</span>      <span class="token comment">// a 是左值，b + c 是右值</span>
a <span class="token operator">=</span> b<span class="token punctuation">;</span> a <span class="token operator">+=</span> c<span class="token punctuation">;</span> <span class="token operator">++</span>a<span class="token punctuation">;</span> <span class="token comment">// 这些表达式都是左值</span>
a<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token comment">// 自增后置返回的是一个自增前的临时副本，故为右值</span>
<span class="token keyword">int</span> <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token operator">&amp;</span>a<span class="token punctuation">;</span>        <span class="token comment">// a 的地址不在内存中存着，故 &amp;a 为右值</span>

<span class="token number">3</span> <span class="token operator">=</span> a<span class="token punctuation">;</span>              <span class="token comment">// ERROR! 3 是右值，不能放在等号左边</span>
b <span class="token operator">+</span> c <span class="token operator">=</span> <span class="token operator">&amp;</span><span class="token number">3</span><span class="token punctuation">;</span>         <span class="token comment">// ERROR! 右值不能放左边，且不能取地址</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="亡值-Xvalue-，纯右值-PRvalue-，泛左值-GLvalue">亡值(Xvalue)，纯右值(PRvalue)，泛左值(GLvalue)</h3>
<p>右值又分为<strong>亡值</strong>与<strong>纯右值</strong>。</p>
<p>在 C<ins>11 之前，右值与纯右值就是同个概念，<strong>亡值</strong>是随着 C</ins>11 的<strong>右值引用</strong>概念引入的。如果用左值初始化对象，则会调用<strong>复制构造函数</strong>或 <code>operator=(const type &amp;)</code> 来进行一次数据的拷贝；而如果用右值初始化，则会调用<strong>移动构造函数</strong>或 <code>operator=(const type &amp;&amp;)</code> 来移动数据，避免了拷贝，提高了效率。当数据移动完成后，用于初始化的右值已经完成了任务，马上消亡，故称其为<strong>亡值</strong>。亡值常见的有以下两种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>返回类型为对象右值引用的表达式，如 <code>std::move(x)</code>；</p>
</li>
<li class="lvl-2">
<p>转换到对象右值引用类型的表达式，例如 <code>static_cast&lt;char&amp;&amp;&gt;(x)</code>；</p>
</li>
</ul>
<p><strong>纯右值</strong>就是右值中不属于亡值的那一部分值，也就是常见的（除字符串外的）字面量、运算表达式、<strong>lambda 表达式</strong>、非引用类型的函数返回值等无法在内存中占据存储空间的值。</p>
<p><strong>泛左值</strong>就是<strong>亡值</strong>+<strong>左值</strong>。</p>
<h2 id="左值引用，右值引用">左值引用，右值引用</h2>
<h3 id="左值引用">左值引用</h3>
<p>C++11 以前，所有的引用都是<strong>左值引用</strong>，用 <code>Type&amp;</code> 表示，只能用左值进行初始化，初始化时即绑定，不能更改绑定对象，其效果相当于为指定变量起"别名"，对引用变量的所有操作都会等效地施加在原变量上（对应内存中的实际数据是一致的），例如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> ref_a <span class="token operator">=</span> x<span class="token punctuation">;</span>          <span class="token comment">// ref_a 为 int&amp; 型，绑定在 int 型的 x 上。这里 x 是否初始化不影响</span>
ref_a<span class="token operator">++</span><span class="token punctuation">;</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> x<span class="token punctuation">;</span> <span class="token comment">// output: 1  通过引用修改原变量</span>

<span class="token keyword">int</span><span class="token operator">&amp;</span> ref_b<span class="token punctuation">;</span>              <span class="token comment">// ERROR! 引用类型必须初始化</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> ref_c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>          <span class="token comment">// ERROR! 左值引用必须用左值进行初始化</span>
<span class="token keyword">int</span><span class="token operator">&amp;</span> ref_d <span class="token operator">=</span> y<span class="token punctuation">;</span>          <span class="token comment">// ERROR! 常量类型只能绑定到常量引用（确实很符合直觉）</span>

<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ref_d <span class="token operator">=</span> x<span class="token punctuation">;</span>    <span class="token comment">// OK! 但常量引用可以绑定非常量变量</span>
<span class="token keyword">const</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> ref_e <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token comment">// OK! 常量引用甚至还可以用右值初始化，此时 3 存储在内存中的一个临时变量。但由于是 const，无法通过 ref_e 修改。</span>
                         <span class="token comment">// 相当于 const int temp = 3; const int&amp; ref_r = temp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意，<strong>引用不是对象</strong>，其不必占用存储，尽管编译器会在需要实现所需语义的情况下分配存储（如引用类型的非静态数据成员），所以<strong>不存在</strong>引用的数组、指向引用的指针、引用的引用。</p>
</blockquote>
<p>由于引用只是取别名，为引用变量初始化绑定对象的过程并不发生拷贝操作，能大大提高程序运行效率，故函数形参常采用<strong>引用传值</strong>的方式，避免不必要的拷贝操作。</p>
<blockquote>
<p>另一个很相似的概念是<strong>指针</strong>，它也可以提供修改原变量的另一种途径，但引用的优势在于更安全，引用变量必须被初始化，故不像指针会出现 <code>nullptr</code> 或野指针的情况。</p>
</blockquote>
<h3 id="右值引用">右值引用</h3>
<p>上面说到常量左值引用可以被右值初始化，但无法修改变量；非常量左值引用可以修改，但无法被右值初始化。如果我们在写某个函数时出现了实参为右值，并且函数体内还需要对该参数进行一定修改的情况，现有的工具无法满足可行性，如果在传参前将右值赋给左值后再传入左值，则增加了内存开销。C++ 作为一门对内存开销非常敏感的语言，在这一点上提出了优化，那就是<strong>右值引用</strong>。</p>
<p>右值引用类型用 <code>Type&amp;&amp;</code> 表示，与左值引用相反，其只能用<strong>右值</strong>进行初始化，即便是常量右值引用也不例外。在引入了右值引用后，函数就可以写为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> num <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">++</span>num<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">func</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: 7</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样函数就可以以右值为实参传入函数 <code>func(int&amp;&amp;)</code> 中。在引入右值引用这一概念之前，传统常量左值引用传递 <code>func(const int&amp;)</code> 无法实现这一功能。</p>
<p>当右值绑定给一个右值引用 <code>rref</code> 时，该右值的生命周期就会被延长至与 <code>rref</code> 相同。</p>
<blockquote>
<p>以右值参数调用函数时优先选择接收右值引用参数的重载版本。</p>
</blockquote>
<h3 id="引用折叠">引用折叠</h3>
<p>通过模板或 <code>typedef</code> / <code>using</code> 中的类型操作可以构成引用的引用，即右值引用的右值引用折叠成右值引用，其余组合均折叠成左值引用：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">using</span> lref <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token punctuation">;</span>
<span class="token keyword">using</span> rref <span class="token operator">=</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> n<span class="token punctuation">;</span>
lref<span class="token operator">&amp;</span>  r1 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// r1 的类型是 int&amp;</span>
lref<span class="token operator">&amp;&amp;</span> r2 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// r2 的类型是 int&amp;</span>
rref<span class="token operator">&amp;</span>  r3 <span class="token operator">=</span> n<span class="token punctuation">;</span> <span class="token comment">// r3 的类型是 int&amp;</span>
rref<span class="token operator">&amp;&amp;</span> r4 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// r4 的类型是 int&amp;&amp;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="万能引用">万能引用</h3>
<p>对于模板函数，希望传入的参数类型既能是左值，又能是右值，对于初学者而言，或许会通过以下代码实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span> T<span class="token operator">&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>  <span class="token comment">// 接受左值</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span> T<span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 接受右值</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以上为两种重载形式，显得很累赘。一种简化代码的方式是<strong>万能引用</strong>，只需一个函数就能实现既能接受左值又能接受右值：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span> T<span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>看似只保留了初始版本形参为右值引用的那一个重载版本，但事实上如果一个变量或者参数被声明为 <code>T&amp;&amp;</code>，其中 <code>T</code> 是<strong>被推导</strong>的类型，那这个变量或者参数就会被视为<strong>万能引用</strong>——当传入参数为左值时，模板类型推导会将 <code>T&amp;&amp;</code> 推导为左值引用；当传入参数为右值时，模板类型推导会将 <code>T&amp;&amp;</code> 推导为右值引用。从而大大提高了编程灵活性以及代码的简洁程度。</p>
<blockquote>
<p>虽然为初学者加大了代码理解的难度</p>
</blockquote>
<h2 id="移动语义">移动语义</h2>
<h3 id="深浅拷贝">深浅拷贝</h3>
<p>谈移动语义，就绕不开先谈<strong>深浅拷贝</strong>。C++11 之前，当我们要进行字符数组 <code>char*</code> 的拷贝操作时，只有这两种拷贝方式。</p>
<p><strong>浅拷贝</strong>是指，将新字符数组 <code>char* dst</code> 指针指向原字符数组 <code>char* src</code> 所在地址，开销低，但容易产生<strong>重复释放同一片内存</strong>的糟糕情况，不安全。</p>
<p><strong>深拷贝</strong>是指，为新字符数组 <code>char* dst</code> 分配一片新的等大内存，然后将原字符数组 <code>char* src</code> 的所有字符依次拷贝，缺点是时间开销大，并且存在原字符数组。</p>
<h3 id="移动拷贝">移动拷贝</h3>
<p>C++11 引入了移动语义，旨在进行一些<strong>转移所有权</strong>的操作，顾名思义就是资源转为己有，而另一方则失去资源所有权，采用 <code>std::move()</code> 函数实现。</p>
<h3 id="std-move">std::move</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 一个示例实现</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
<span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span> T<span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> ReturnType <span class="token operator">=</span> remove_referece_t<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;&amp;</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ReturnType<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>它仅仅做了一件事，那就是<strong>将实参转换为右值引用</strong>，其中 <code>std::remove_reference</code> 相当于是做了一个去除引用保留原始数据类型的操作。</p>
<h3 id="移动构造函数">移动构造函数</h3>
<p>引入移动语义这一新特性之后，移动构造函数也随之产生，其接收同类型右值引用的实参，进行资源的迁移，将深浅拷贝两者的优势集中，既减少了开销，也无需担心出现 double free 的情况。</p>
<h2 id="完美转发">完美转发</h2>
<p><strong>完美转发</strong>指的是利用一个接受任意实参的函数模板将参数转发到其它函数，目标函数会收到与转发函数完全相同的实参，从而转发调用。转发函数实参是左值那目标函数实参也是左值，转发函数实参是右值那目标函数实参也是右值。</p>
<p>由于万能引用的存在，函数模板 <code>func(Type&amp;&amp;)</code> 内部无法知道形参对应的实参到底是个左值还是右值，如果要用到该形参作为其他函数实参，就会出现问题，这里就要用到 <code>std::forward</code>。</p>
<h3 id="std-forward">std::forward</h3>
<p>函数原型如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;</span> t <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
T<span class="token operator">&amp;&amp;</span> <span class="token function">forward</span><span class="token punctuation">(</span> <span class="token keyword">typename</span> <span class="token class-name">std</span><span class="token double-colon punctuation">::</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其作用就是返回参数对应的引用形式：传入左值返回左值引用，传入右值返回右值引用。</p>
<h3 id="转发函数">转发函数</h3>
<p>直接上例子：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"lvalue\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span> <span class="token keyword">int</span><span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"rvalue\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">T</span> <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">FORWARD</span><span class="token punctuation">(</span> T<span class="token operator">&amp;&amp;</span> t <span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">func</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// t 因为能被取地址，故认为是左值，恒定输出 lvalue</span>
  <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 此处 T 会按实际传参类型进行推导</span>
  <span class="token function">func</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// std::move 转为右值，恒定输出 rvalue</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">FORWARD</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// output: lvalue lvalue rvalue</span>
<span class="token function">FORWARD</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// output: lvalue rvalue rvalue</span>

<span class="token comment">/*
 * std::forward&lt;int&gt;(a), std::forward&lt;int&amp;&gt;(a), std::forward&lt;int&amp;&amp;&gt;(a) 分别会被转为
 * 右值引用、左值引用、右值引用
 */</span>
<span class="token function">FORWARD</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// output: lvalue rvalue rvalue</span>
<span class="token function">FORWARD</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// output: lvalue lvalue rvalue</span>
<span class="token function">FORWARD</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">forward</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// output: lvalue rvalue rvalue</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
  </entry>
  <entry>
    <title>CS149 の 笔记</title>
    <url>/note/cs149/</url>
    <content><![CDATA[<p>并行计算。<a href="https://gfxcourses.stanford.edu/cs149/fall23">&gt;&gt;&gt; 传送门 &lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="Lecture-1-Why-Parallelism">Lecture 1: Why Parallelism</h2>
<p>很早以前实现并行的性价比并不高，因为人们只需要等最新的 CPU 出来就行。厂商通过以下两种方式提升 CPU 性能：</p>
<ol>
<li class="lvl-3">
<p>提升时钟频率；</p>
</li>
<li class="lvl-3">
<p>实现指令级别的并行(ILP, Instruction Level Parallelism)；</p>
</li>
</ol>
<p>然而时钟频率因为 energy wall 达到瓶颈，ILP 也受限于指令流的设计，我们迫切地需要其他手段来提升程序执行效率，所以需要我们编写代码提高性能。</p>
<p>所谓并行(Parallelism)，其实可以理解为，在原来<strong>单个时钟周期</strong>内执行单条指令处理单个数据的基础上，实现多个处理器/线程进行合作，从而更快地解决问题。在 CPU 性能一定的情况下，并行能最大化利用 CPU，提升程序执行效率。</p>
<h2 id="Lecture-2-A-Modern-Multi-Core-Processor">Lecture 2: A Modern Multi-Core Processor</h2>
<h3 id="并行执行">并行执行</h3>
<p>目前有以下几种并行执行的方式：</p>
<h4 id="超标量-Superscalar">超标量(Superscalar)</h4>
<p>一个时钟周期内执行多条 independent 的指令（其实就是 ILP）。所谓 independent，就是指指令之间不 load/store 同一内存地址/寄存器里的数据。像下面这两条指令就是不 independent 的。</p>
<img src="1.png" style="zoom:40%">
<blockquote>
<p>ILP 的实现需要在一个 CPU core 内包含多个 Data Fetch/Instruction Decode 模块。</p>
</blockquote>
<h4 id="多核-Multi-core">多核(Multi-core)</h4>
<p>多核确实能提高执行效率，如果不与其他策略配合使用，只会是堆砌成本的下下策，依然没有改变单核效率低下的问题。</p>
<img src="2.png" style="zoom:40%">
<h4 id="单个指令处理多个数据-SIMD-Single-Instruction-Multiple-Data">单个指令处理多个数据(SIMD, Single Instruction Multiple Data)</h4>
<p>通过向量的方式进行数据处理。</p>
<img src="3.png" style="zoom:40%">
<blockquote>
<p>SIMD 的实现需要在一个 CPU core 内包含多个 ALU 模块。配合多核能够实现一条指令处理 #core * #ALU 个数据</p>
</blockquote>
<p>然而，遇到条件指令(if)时，因为所有 ALU 共享 Decode 模块，所以会出现某些 ALU 不满足条件而无法利用的情况，导致并不能达到 peak performance。最好能进行数据层面的优化，使得同一组 ALU 处理的数据能够满足同一条件。</p>
<h3 id="其他瓶颈">其他瓶颈</h3>
<h4 id="时延-latency">时延(latency)</h4>
<p>当遇到 load/store 等访问内存的指令时，因为数据传输需要时间，称为 <strong>Stall</strong>，只有当数据到达 CPU 后才指令才能继续运行。</p>
<p><strong>解决方案</strong>：</p>
<ol>
<li class="lvl-3">
<p>通过多级 Cache 来加快数据获取；</p>
</li>
<li class="lvl-3">
<p>通过 Interleaving Multi-thread，当某一线程 Stall 时，由操作系统进行线程切换（调度），将 CPU 资源分给另一线程，从而提高 CPU 利用率；</p>
<blockquote>
<p>整体的效率提升了，但单个任务的效率会因为等待调度减慢。同时需要一些存储空间来存储每个线程的上下文。</p>
</blockquote>
</li>
</ol>
<h4 id="带宽-bandwidth">带宽(bandwidth)</h4>
<p>CPU 依靠总线(bus)单位时间内最多可以从内存中获取的数据量。一旦某次计算所需数据量过大，带宽也将成为限制。</p>
<p><strong>解决方案</strong>：</p>
<p>减少数据从内存读取的次数，比如用 Cache。</p>
<h2 id="Lecture-3-Parallel-Programming-Abstractions">Lecture 3: Parallel Programming Abstractions</h2>
<h3 id="Abstractions-vs-implementation">Abstractions vs implementation</h3>
<h3 id="Three-models-of-communication">Three models of communication</h3>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>CS144 Lab Note</title>
    <url>/lab/cs144lab/</url>
    <content><![CDATA[<p>CS144 lab 记录过程。</p>
<span id="more"></span>
<h2 id="环境配置">环境配置</h2>
<p>本课程所有 lab 均需要在 Linux 环境下运行，课程组提供了 4 种运行方式，直接照着 <a href="https://stanford.edu/class/cs144/vm_howto/">Instructions</a> 来就好了。我这里因为实验室自带 Ubuntu 工作站，所以用了第三种方式，按照清单一个个 <code>sudo apt-get install</code> 下来就完事了。</p>
<h2 id="lab0-Networking-Warmup">lab0 Networking Warmup</h2>
<p>之前有用 http 访问某网站并获取文本、用 smtp 发邮件的一些小操作，跟着走一遍基本没啥问题，就是熟悉一下基本的命令。现在要真正上手敲 C++ 了。</p>
<h3 id="准备工作">准备工作</h3>
<p>首先是把代码拉下来，我先在自己的 github 下<a href="https://github.com/new">新建</a>了一个仓库，命名为 <strong>CS144</strong>，为了尊重课程协议，我设为了 <code>private</code>。拉代码就直接 <code>git clone --bare https://github.com/CS144/sponge.git</code>，后面所有的 lab 都是在这一套文件下实现的。</p>
<p>随后，执行</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> your_repository_name
$ <span class="token function">git</span> push git@github.com:your_github_name/your_repository_name.git <span class="token parameter variable">--all</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时课程代码及其所有分支已经移植到我们自己的仓库里了，接着 <code>cd .. &amp;&amp; rm -rf sponge</code> 将课程仓库删除，最后把我们自己的仓库拉下来即可。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">## If you pull / push over HTTPS</span>
$ <span class="token function">git</span> clone https://github.com/your_github_name/your_repository_name.git

<span class="token comment">## If you pull / push over SSH</span>
$ <span class="token function">git</span> clone git@github.com:your_github_name/your_repository_name.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以输入 <code>git remote -v</code> 查看本地与远程是否对应。ok，现在可以将所有更改 push 到自己的代码仓库里了。</p>
<h3 id="coding">coding</h3>
<blockquote>
<p>课程 lab 代码仓库一共有 8 个分支，每个 lab 前都需要 <code>git merge lab?-startercode</code> 来合并分支。</p>
</blockquote>
<p>执行如下命令构建项目</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token function">mkdir</span> build
$ <span class="token builtin class-name">cd</span> build
$ cmake <span class="token punctuation">..</span>
$ <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们的代码要写在 <code>/apps/webget.cc</code> 里的 <code>Your code here</code> 处。写之前要认真看看 <code>socket.hh</code>，<code>address.hh</code>，<code>file_descriptor.hh</code> 这三个头文件，尽管本 lab 要用到的类只有 <code>TCPSocket</code> 和 <code>Address</code> 这俩。</p>
<p><code>Address</code> 类决定了连接的目标 host 以及协议类型，这里应为 <code>Address(host, "http")</code>。</p>
<p><code>TCPSocket</code> 提供了 <code>write(string)</code> 方法，等效于在 terminal 输入相应的命令；<code>read()</code> 方法则返回获取到的字节流；<code>eof()</code> 方法判断是否抵达字节流末尾。</p>
<blockquote>
<p>注意，每一行末尾都要加上 <code>'\r\n'</code>，最后的 <code>Connection: close</code> 后要加两个这玩意。</p>
<p>注意，请用 while(!socket.eof()) 来循环读字节流，而非 single call to read。</p>
</blockquote>
<p>写完代码后，可以执行如下命令来检查输出结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> build
$ ./apps/webget cs144.keithw.org /hello <span class="token comment">## 可执行文件, host, path</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果看到结果如下，则输出正确。</p>
<pre class="line-numbers language-none"><code class="language-none">HTTP/1.1 200 OK
Date: Tue, 21 Mar 2023 10:16:57 GMT
Server: Apache
Last-Modified: Thu, 13 Dec 2018 15:45:29 GMT
ETag: "e-57ce93446cb64"
Accept-Ranges: bytes
Content-Length: 14
Connection: close
Content-Type: text/plain

Hello, CS144!<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后用课程组给的测试代码进行跑分:</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> build
$ <span class="token function">make</span> check_webget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>看到如下输出，则通过。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Testing webget<span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build
    Start <span class="token number">31</span>: t_webget
<span class="token number">1</span>/1 Test <span class="token comment">#31: t_webget .........................   Passed    6.05 sec</span>

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">1</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">6.05</span> sec
<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target check_webget<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="An-in-memory-reliable-byte-stream">An in-memory reliable byte stream</h3>
<p>lab0 的最后一个任务是实现一个处理字节流的有限容量 buffer，writer 负责将字节流写入 buffer 中，reader 从中读取。文件位于 <code>libsponge/byte_stream.cc</code> 以及 <code>libsponge/byte_stream.hh</code>。</p>
<p>writer 的工作很简单，写数据(write)、终止写入(end_input)以及获取 buffer 剩余容量(remaining_capacity)，需要注意的是如果写入的数据大小超过了剩余容量，则应尽可能写入，比如剩余容量 3 的情况下要写 <code>"abcdefg"</code>，则只写入 <code>"abc"</code>。</p>
<p>reader 有三种输出方式，只读(peek_output)，只写(pop_output)以及读写(read_output)，注意后两种方法都意味着增加<strong>已读取的字节数</strong>。</p>
<p>以及一些通用的接口，这些接口的实现需要我们额外添加一些 private 成员变量，不再赘述。这里课程组已经为我们提供了一个名为 <code>BufferList</code> 的数据结构</p>
<p>执行以下命令进行测试：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ <span class="token builtin class-name">cd</span> build
$ <span class="token function">make</span> <span class="token function">format</span>
$ <span class="token function">make</span>
$ <span class="token function">make</span> check_lab0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Testing Lab <span class="token number">0</span><span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build
    Start <span class="token number">26</span>: t_byte_stream_construction
<span class="token number">1</span>/9 Test <span class="token comment">#26: t_byte_stream_construction .......   Passed    0.00 sec</span>
    Start <span class="token number">27</span>: t_byte_stream_one_write
<span class="token number">2</span>/9 Test <span class="token comment">#27: t_byte_stream_one_write ..........   Passed    0.00 sec</span>
    Start <span class="token number">28</span>: t_byte_stream_two_writes
<span class="token number">3</span>/9 Test <span class="token comment">#28: t_byte_stream_two_writes .........   Passed    0.00 sec</span>
    Start <span class="token number">29</span>: t_byte_stream_capacity
<span class="token number">4</span>/9 Test <span class="token comment">#29: t_byte_stream_capacity ...........   Passed    0.36 sec</span>
    Start <span class="token number">30</span>: t_byte_stream_many_writes
<span class="token number">5</span>/9 Test <span class="token comment">#30: t_byte_stream_many_writes ........   Passed    0.02 sec</span>
    Start <span class="token number">31</span>: t_webget
<span class="token number">6</span>/9 Test <span class="token comment">#31: t_webget .........................   Passed    3.45 sec</span>
    Start <span class="token number">53</span>: t_address_dt
<span class="token number">7</span>/9 Test <span class="token comment">#53: t_address_dt .....................   Passed    0.01 sec</span>
    Start <span class="token number">54</span>: t_parser_dt
<span class="token number">8</span>/9 Test <span class="token comment">#54: t_parser_dt ......................   Passed    0.00 sec</span>
    Start <span class="token number">55</span>: t_socket_dt
<span class="token number">9</span>/9 Test <span class="token comment">#55: t_socket_dt ......................   Passed    0.01 sec</span>

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">9</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">3.86</span> sec
<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target check_lab0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lab1-Stream-Reassembler">lab1 Stream Reassembler</h2>
<p>本 lab 要求在 lab0 的基础上实现一个字节流整合器。</p>
<img src="1.png" style="zoom:67%;">
<p>lab1 ~ lab4 均围绕此图进行。在 lab0 中，我们实现了有序字节流，而事实上真实的网络并不会按顺序向我们发送数据包，我们需要利用一个整合器将收到的无序字节流片段以正确顺序拼接并写到 <code>ByteStream</code> 中。数据包以 <code>{data, index}</code> 的形式被接收，其中 <code>data</code> 为 <code>std::string</code>，<code>index</code> 为 <code>data</code> 作为子串在原始字节流中的下标，如</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">                     <span class="token number">1</span>         <span class="token number">2</span>
           <span class="token number">01234567890123456789012345</span>
原始字符串<span class="token operator">:</span> abcdefghijklmnopqrstuvwxyz<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

收到的数据包可能为 <span class="token punctuation">{</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token string">"efghij"</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span> 等<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一旦整合器收到了正确的数据包（需要我们维护一个 <code>next_index</code>），它就会将其写入 <code>ByteStream</code>；而那些顺序错乱的，整合器会将其缓存，但丢弃那些超过 <code>capacity</code> 的部分。关于 <code>capacity</code>，guide 里有了一个比较明确的介绍：</p>
<img src="2.png" style="zoom:67%;">
<blockquote>
<p>即 <code>ByteStream</code> 中未读取的部分加上 <code>Reassembler</code> 中无序的部分大小不能超过 <code>capacity</code>。</p>
</blockquote>
<p>一些注意事项都写在 FAQ 里了：</p>
<h3 id="数据结构设计">数据结构设计</h3>
<p>本来想用 <code>std::vector&lt;char&gt;</code> 模拟循环队列的，但实际操作起来发现开销奇高，后来决定用 <code>std::map&lt;uint32_t, std::string&gt;</code> 的索引表的方式，记录每个字符串及其索引，并做好去重工作。每次收到一个 <code>{index, data}</code> 对时，遍历索引表，如果有重复的部分，则修改 <code>data</code> 的有效字节区间，并进行适当插入。完成插入操作后，不断判断 <code>table.find(next_index)</code> 是否有效，若有效则删除条目并将对应字符串拼接至返回结果末尾。</p>
<blockquote>
<p>有点像 <code>map reduce</code>，然后我的函数签名就是 map 和 reduce 了。</p>
</blockquote>
<p>需要注意的是，收到的子串并非每个字符都要写入，我们要写入的部分应为</p>
<p><code>[max(index, next_index), min(next_index + capacity - ByteStream.buffer_size(), index + data.length())]</code></p>
<p>这样就能忽略已写入 <code>ByteStream</code> 的部分以及超出 <code>capacity</code> 的部分。</p>
<blockquote>
<p>上面的索引为流索引，还需要转换为数组下标。</p>
</blockquote>
<p>需要注意的是，当收到一个 <code>eof = true</code> 的 <code>{index, data}</code> 对时，可能并不会立刻 <code>end_input</code>，而是在后续的 reduce 阶段收集到所有字节流再 <code>end_input</code>，这就需要我们存一个 <code>eof_index</code> 变量，当 <code>next_index == eof_index</code> 时进行 <code>end_input</code>。</p>
<p>部分代码如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/stream_reassembler.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>data<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">uint64_t</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 只取 data 的 [start_index, last_index) 区间</span>
  size_t start_index <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> _next_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  size_t last_index <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span>_next_index <span class="token operator">+</span> _capacity <span class="token operator">-</span> _output<span class="token punctuation">.</span><span class="token function">buffer_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> index <span class="token operator">+</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>entry <span class="token operator">:</span> _buffer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>start_index <span class="token operator">&gt;=</span> last_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    size_t end_index <span class="token operator">=</span> entry<span class="token punctuation">.</span>first <span class="token operator">+</span> entry<span class="token punctuation">.</span>second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>entry<span class="token punctuation">.</span>first <span class="token operator">&gt;</span> start_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>last_index <span class="token operator">&lt;=</span> entry<span class="token punctuation">.</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        _buffer<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start_index <span class="token operator">-</span> index<span class="token punctuation">,</span> last_index <span class="token operator">-</span> start_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        start_index <span class="token operator">=</span> last_index<span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        _buffer<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start_index <span class="token operator">-</span> index<span class="token punctuation">,</span> entry<span class="token punctuation">.</span>first <span class="token operator">-</span> start_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        start_index <span class="token operator">=</span> end_index<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      start_index <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> end_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 仍有有效部分</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>start_index <span class="token operator">&lt;</span> last_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _buffer<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>start_index<span class="token punctuation">,</span> data<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span>start_index <span class="token operator">-</span> index<span class="token punctuation">,</span> last_index <span class="token operator">-</span> start_index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">StreamReassembler</span><span class="token double-colon punctuation">::</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>string res<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>_buffer<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>_next_index<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> entry <span class="token operator">=</span> _buffer<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>_next_index<span class="token punctuation">)</span><span class="token punctuation">;</span>
    res<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>entry<span class="token operator">-&gt;</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _next_index <span class="token operator">+=</span> entry<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _size <span class="token operator">-=</span> entry<span class="token operator">-&gt;</span>second<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _buffer<span class="token punctuation">.</span><span class="token function">erase</span><span class="token punctuation">(</span>entry<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>res<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _output<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_next_index <span class="token operator">==</span> _eof_index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _output<span class="token punctuation">.</span><span class="token function">end_input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Testing the stream reassembler<span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build
      Start <span class="token number">18</span>: t_strm_reassem_single
 <span class="token number">1</span>/16 Test <span class="token comment">#18: t_strm_reassem_single ............   Passed    0.00 sec</span>
      Start <span class="token number">19</span>: t_strm_reassem_seq
 <span class="token number">2</span>/16 Test <span class="token comment">#19: t_strm_reassem_seq ...............   Passed    0.00 sec</span>
      Start <span class="token number">20</span>: t_strm_reassem_dup
 <span class="token number">3</span>/16 Test <span class="token comment">#20: t_strm_reassem_dup ...............   Passed    0.01 sec</span>
      Start <span class="token number">21</span>: t_strm_reassem_holes
 <span class="token number">4</span>/16 Test <span class="token comment">#21: t_strm_reassem_holes .............   Passed    0.00 sec</span>
      Start <span class="token number">22</span>: t_strm_reassem_many
 <span class="token number">5</span>/16 Test <span class="token comment">#22: t_strm_reassem_many ..............   Passed    0.20 sec</span>
      Start <span class="token number">23</span>: t_strm_reassem_overlapping
 <span class="token number">6</span>/16 Test <span class="token comment">#23: t_strm_reassem_overlapping .......   Passed    0.00 sec</span>
      Start <span class="token number">24</span>: t_strm_reassem_win
 <span class="token number">7</span>/16 Test <span class="token comment">#24: t_strm_reassem_win ...............   Passed    0.20 sec</span>
      Start <span class="token number">25</span>: t_strm_reassem_cap
 <span class="token number">8</span>/16 Test <span class="token comment">#25: t_strm_reassem_cap ...............   Passed    0.08 sec</span>

<span class="token punctuation">..</span>.

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">16</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">1.77</span> sec
<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target check_lab1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lab2-TCP-Receiver">lab2 TCP Receiver</h2>
<p>本 lab 需要实现 TCP 协议的接收端。</p>
<p>此时接受端收到的就是 <code>{TCP Header, IP Datagram}</code> 组成的报文段(TCP segment)了，该数据结构定义在 <code>/libsponge/tcp_helpers/tcp_segment.hh</code> 中，其中首部(TCP header)字段定义在 <code>/libsponge/tcp_helpers/tcp_header.hh</code> 中。</p>
<h3 id="Task-1-Translate-between-64-bit-indexes-and-32-bit-seqnos">Task 1: Translate between 64-bit indexes and 32-bit seqnos</h3>
<p>第一个任务是编写用于 <code>seqno</code> 与 <code>absolute seqno</code> 互相转换的 <code>wrap()</code> 与 <code>unwrap()</code> 函数。guide 中其实已经说的比较详细了。</p>
<img src="3.png" style="zoom:67%;">
<h4 id="wrap-n-isn">wrap(n, isn)</h4>
<p>给定 <code>isn</code> 和绝对序列号 <code>n</code>，求相应的序列号，易得</p>
<p>$$
seqno = (isn + n\ &amp;\ \text{uint32_max})\ %\ \text{uint32_max}
$$</p>
<h4 id="unwrap-n-isn-checkpoint">unwrap(n, isn, checkpoint)</h4>
<p>给定序列号 <code>n</code> 和 <code>isn</code>，以及用于消除多义性的检查点 <code>checkpoint</code>，求距离 <code>checkpoint</code> 最近的绝对序列号。显然，最后的结果应该为</p>
<p>$$
abs_seqno = n - isn + i\times offset,\quad offset = 2^{32}, \ i \in [0, 2^{32}-1]
$$</p>
<p>如果将 <code>checkpoint</code> 分为高 32 位与低 32 位，那么 <code>checkpoint</code> 必然能表示为 $\text{high32}\times offset + \text{low32}$</p>
<p>从而存在三种绝对序列号可能，分别为 <code>i = high32-1, high32, high32+1</code></p>
<ol>
<li class="lvl-3">
<p>如果 <code>n-isn &lt; low32</code>，则 <code>i</code> 取 <code>high32-1, high32</code>；</p>
</li>
<li class="lvl-3">
<p>如果 <code>n-isn == low32</code>，则 <code>i</code> 取 <code>high32</code>；</p>
</li>
<li class="lvl-3">
<p>如果 <code>n-isn &gt; low32</code>，则 <code>i</code> 取 <code>high32, high32+1</code>；</p>
</li>
</ol>
<p>不难发现，令 <code>i = high32</code> 一定是可能的选择之一，但还有一些边界条件需要考虑：</p>
<ol>
<li class="lvl-3">
<p>如果 <code>high32 == 0</code>，那么 case1 下 <code>high32-1</code> 无法取得；</p>
</li>
<li class="lvl-3">
<p>如果 <code>high32 == 11..11</code>，那么 case3 下 <code>high32+1</code> 无法取得；</p>
</li>
</ol>
<p>故得到</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/wrapping_integers.cc</span></div><code class="language-cpp"><span class="token keyword">uint64_t</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>WrappingInt32 n<span class="token punctuation">,</span> WrappingInt32 isn<span class="token punctuation">,</span> <span class="token keyword">uint64_t</span> checkpoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">uint64_t</span> c_high32 <span class="token operator">=</span> checkpoint <span class="token operator">&gt;&gt;</span> <span class="token number">32</span><span class="token punctuation">;</span>
  <span class="token keyword">uint64_t</span> offset <span class="token operator">=</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span>
  <span class="token keyword">uint64_t</span> lower_bound <span class="token operator">=</span> <span class="token number">1ul</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span>
  <span class="token keyword">uint64_t</span> upper_bound <span class="token operator">=</span> <span class="token punctuation">(</span>lower_bound<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">;</span>
  <span class="token keyword">uint64_t</span> res <span class="token operator">=</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">uint64_t</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n <span class="token operator">-</span> isn<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>c_high32 <span class="token operator">&lt;&lt;</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&gt;</span> checkpoint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&gt;</span> lower_bound <span class="token operator">&amp;&amp;</span> res <span class="token operator">-</span> checkpoint <span class="token operator">&gt;=</span> offset <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res <span class="token operator">-=</span> offset<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> checkpoint<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">&lt;</span> upper_bound <span class="token operator">&amp;&amp;</span> checkpoint <span class="token operator">-</span> res <span class="token operator">&gt;=</span> offset <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res <span class="token operator">+=</span> offset<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>有一个坑点在于，头文件中对 <code>WrappintInt32 - WrappingInt32</code> 的重载返回值为 <code>int64_t</code> 而非 <code>uint_64t</code>，这就导致上面的 <code>res</code> 在 <code>n = UINT32_MAX, isn = 0</code> 的时候出现计算错误，需要修改头文件。</p>
</blockquote>
<h3 id="Task-2-Implenting-the-TCP-receiver">Task 2:  Implenting the TCP receiver</h3>
<p>该 task 主要完成三件事</p>
<ol>
<li class="lvl-3">
<p>从其对等方接收 TCPsegment；</p>
</li>
<li class="lvl-3">
<p>使用 <code>StreamReassembler</code> 重新整合字节流；</p>
</li>
<li class="lvl-3">
<p>计算确认号(ackno)和窗口大小，ackno 和窗口大小最终将在 TCPsegment 中传回对等方；</p>
</li>
</ol>
<p>窗口大小很好理解，就是 lab1 中的 <code>capacity - ByteStream.buffer_size()</code>。</p>
<p>对于确认号而言，则对应的是"下一个希望接收到的 seqno"。已知标志位 <code>SYN</code> 和 <code>FIN</code> 也各占一个 seqno，则根据下面那张转换图，不难发现有</p>
<p>$$
\text{ackno} = wrap(\text{next_index},\ \text{isn}) + 1 + \text{ByteStream.input_ended()}
$$</p>
<img src="3.png" style="zoom:67%;">
<p>其中，<code>ByteStream.input_ended()</code> 表示 <code>FIN=1</code> 的 segment 已完全写入 <code>ByteStream</code>。</p>
<blockquote>
<p>需要注意的是，在收到第一个 <code>SYN=1</code> 的 segment 之前，ackno 应返回空值，表现为 <code>return std::optional&lt;WrappintInt32&gt;{}</code>。由于 isn 仅在 <code>SYN=1</code> 的 segment 到来时才会被正确初始化，故需要一个变量来表示 isn 是否被赋值。</p>
</blockquote>
<p>最后就是接收 segment 的 api <code>segment_received(TCPsegment)</code> 了，该 api 主要工作就是将 segment 中的 IP 层数据包写入 Reassembler 中，难点在于流索引的计算。根据转换图可以得知</p>
<p>$$
\text{stream_index} =
\begin{cases}
\qquad\qquad\qquad\qquad 0 \qquad\qquad\qquad\qquad \text{SYN}=1
\[2ex]
unwrap(\text{seqno}, \text{isn}, \text{next_index}) - 1 \qquad \text{else}
\end{cases}
$$</p>
<p>而写入的子串可通过 <code>segment.payload().copy()</code> 获取。其中 <code>payload()</code> 其实就是 IP 层数据包部分。</p>
<blockquote>
<p>需要考虑的 corner case 比较多，比如仅仅 <code>SYN=1</code> / <code>FIN=1</code> 或两个标志位同时为 <code>1</code> 但无数据的情况。</p>
</blockquote>
<p>测试结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Testing the TCP receiver<span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build
      Start  <span class="token number">1</span>: t_wrapping_ints_cmp
 <span class="token number">1</span>/26 Test  <span class="token comment">#1: t_wrapping_ints_cmp ..............   Passed    0.00 sec</span>
      Start  <span class="token number">2</span>: t_wrapping_ints_unwrap
 <span class="token number">2</span>/26 Test  <span class="token comment">#2: t_wrapping_ints_unwrap ...........   Passed    0.00 sec</span>
      Start  <span class="token number">3</span>: t_wrapping_ints_wrap
 <span class="token number">3</span>/26 Test  <span class="token comment">#3: t_wrapping_ints_wrap .............   Passed    0.00 sec</span>
      Start  <span class="token number">4</span>: t_wrapping_ints_roundtrip
 <span class="token number">4</span>/26 Test  <span class="token comment">#4: t_wrapping_ints_roundtrip ........   Passed    0.15 sec</span>
      Start  <span class="token number">5</span>: t_recv_connect
 <span class="token number">5</span>/26 Test  <span class="token comment">#5: t_recv_connect ...................   Passed    0.00 sec</span>
      Start  <span class="token number">6</span>: t_recv_transmit
 <span class="token number">6</span>/26 Test  <span class="token comment">#6: t_recv_transmit ..................   Passed    0.05 sec</span>
      Start  <span class="token number">7</span>: t_recv_window
 <span class="token number">7</span>/26 Test  <span class="token comment">#7: t_recv_window ....................   Passed    0.00 sec</span>
      Start  <span class="token number">8</span>: t_recv_reorder
 <span class="token number">8</span>/26 Test  <span class="token comment">#8: t_recv_reorder ...................   Passed    0.00 sec</span>
      Start  <span class="token number">9</span>: t_recv_close
 <span class="token number">9</span>/26 Test  <span class="token comment">#9: t_recv_close .....................   Passed    0.00 sec</span>
      Start <span class="token number">10</span>: t_recv_special
<span class="token number">10</span>/26 Test <span class="token comment">#10: t_recv_special ...................   Passed    0.00 sec</span>

<span class="token punctuation">..</span>.

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">26</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">1.18</span> sec
<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target check_lab2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lab3-TCP-Sender">lab3 TCP Sender</h2>
<p>本 lab 需要实现 TCP 协议的发送端。</p>
<h3 id="数据结构">数据结构</h3>
<p>一个 TCPSender 应该完成以下事情：</p>
<ol>
<li class="lvl-3">
<p>跟踪接收方的窗口（处理传入的 ackno 和窗口大小）；</p>
</li>
<li class="lvl-3">
<p>尽可能填充窗口，方法是从 ByteStream 读取，创建新的 TCP 段（如果需要，包括 SYN 和 FIN 标志），然后发送它们。发送方应继续发送段，直到窗口已满或 ByteStream 为空；</p>
</li>
<li class="lvl-3">
<p>跟踪哪些段已发送但尚未被接收方确认——我们称这些为"未完成"的段；</p>
</li>
<li class="lvl-3">
<p>如果自发送以来经过了足够长的时间且尚未确认，则重新发送最早未完成的段；</p>
</li>
</ol>
<p>这就需要我们添加一系列成员变量，我的数据结构设计如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TCPSender</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token comment">// (new!) 定时器</span>
  Timer _timer<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//! our initial sequence number, the number for our SYN.</span>
  WrappingInt32 _isn<span class="token punctuation">;</span>
  <span class="token comment">//! outbound queue of segments that the TCPSender wants sent</span>
  std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TCPSegment<span class="token operator">&gt;</span> _segments_out<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// (new!) 发送但尚未被确认的段队列，每发送一个段，都会将其副本添加到该队列中</span>
  <span class="token comment">// 每收到一个正确的确认，都会将队首弹出</span>
  std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>TCPSegment<span class="token operator">&gt;</span> _outstanding_segments<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//! retransmission timer for the connection</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> _initial_retransmission_timeout<span class="token punctuation">;</span>
  <span class="token comment">// (new!) 重传时限</span>
  <span class="token keyword">unsigned</span> <span class="token keyword">int</span> _rto<span class="token punctuation">;</span>
  <span class="token comment">// (new!) 重传次数</span>
  <span class="token keyword">uint16_t</span> _retransmission_times<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">//! outgoing stream of bytes that have not yet been sent</span>
  ByteStream _stream<span class="token punctuation">;</span>
  <span class="token comment">//! the (absolute) sequence number for the next byte to be sent</span>
  <span class="token keyword">uint64_t</span> _next_seqno<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// (new!) 确认号(绝对序列号)</span>
  <span class="token keyword">uint64_t</span> _ackno<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// (new!) 接收侧的窗口大小</span>
  <span class="token keyword">uint64_t</span> _rws<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// (new!) 是否已发送 FIN=1 的段</span>
  <span class="token keyword">bool</span> closed<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="定时功能">定时功能</h3>
<p>这是本 lab 的第一个任务。随着时间流逝，如果最早发送的段在一定时间内未得到确认，则需要进行<strong>超时重传</strong>，而定时器的作用就是告诉 sender “超时了”，它应该有以下功能：</p>
<ol>
<li class="lvl-3">
<p><code>start()</code>，包括设置 rto 以及重置时间进度为 0，并将定时器状态设为 <code>WORK</code>；</p>
</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Timer</span><span class="token double-colon punctuation">::</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> rto<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _rto <span class="token operator">=</span> rto<span class="token punctuation">;</span>
  _current_time <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  _state <span class="token operator">=</span> TimerState<span class="token double-colon punctuation">::</span>WORK<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ol start="2">
<li class="lvl-3">
<p><code>stop()</code>，将定时器状态设为 <code>IDLE</code>；</p>
</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Timer</span><span class="token double-colon punctuation">::</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _state <span class="token operator">=</span> TimerState<span class="token double-colon punctuation">::</span>IDLE<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<ol start="3">
<li class="lvl-3">
<p><code>tick()</code>，增加时间进度，并在超过 rto 时向调用者传递信息(true/false)；</p>
</li>
</ol>
  <pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">Timer</span><span class="token double-colon punctuation">::</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> interval<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// true for timeout, false else</span>
  _current_time <span class="token operator">+=</span> interval<span class="token punctuation">;</span>
  <span class="token keyword">return</span> _current_time <span class="token operator">&gt;=</span> _rto<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据 guide，<code>TCPSender::tick()</code> 会被自动调用，其传入参数为距离上一次调用该方法经过的时长，那么在 <code>TCPSender::tick()</code> 中，我们就需要调用 <code>Timer::tick()</code> 并根据返回值判断是否需要重传。重传时需要做的事有：</p>
<ol>
<li class="lvl-3">
<p>重传尚未被 TCP 接收方<strong>完全确认</strong>的最早的段（如果没有的话后面啥也不用做）；</p>
</li>
<li class="lvl-3">
<p>如果窗口大小不为零：</p>
<ul class="lvl-2">
<li class="lvl-5"><strong>增加连续重传的次数</strong>：因为重传次数对应的就是最早未确认的段，故无需建立 <code>序列号-&gt;重传次数</code> 的映射;</li>
<li class="lvl-5"><strong>指数退避</strong>：将 RTO 翻倍，从而减慢糟糕网络上的重传速度，以避免进一步破坏工作；</li>
</ul>
</li>
<li class="lvl-3">
<p>重启定时器，使其在 RTO 后到期；</p>
</li>
</ol>
<p>故 <code>TCPSender::tick()</code> 部分代码很容易能写出来</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">tick</span><span class="token punctuation">(</span><span class="token keyword">const</span> size_t ms_since_last_tick<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_outstanding_segments<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> _timer<span class="token punctuation">.</span><span class="token function">tick</span><span class="token punctuation">(</span>ms_since_last_tick<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_rws <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _retransmission_times<span class="token operator">++</span><span class="token punctuation">;</span>
      _rto <span class="token operator">*=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_retransmission_times <span class="token operator">&lt;=</span> TCPConfig<span class="token double-colon punctuation">::</span>MAX_RETX_ATTEMPTS<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>_outstanding_segments<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      _timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>_rto<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="收到确认后要做什么">收到确认后要做什么</h3>
<p>当收到一个正确的 ackno 时：</p>
<ol>
<li class="lvl-3">
<p>将 RTO 设置回其"初始值"（即 <code>_initial_retransmission_timeout</code>）；</p>
</li>
<li class="lvl-3">
<p>如果发送方有任何未完成的数据，重启定时器，使其在 RTO 毫秒（对于 RTO 的当前值）后到期；</p>
</li>
<li class="lvl-3">
<p>反之，如果所有未完成的数据都被确认，停止定时器；</p>
</li>
<li class="lvl-3">
<p>将重传次数重置为零；</p>
</li>
</ol>
<p>怎样算正确的 ackno 呢？对于一个段而言，当且仅当下式满足时，该段被成功确认。</p>
<p>$$
\text{abs_ackno} \geq \text{abs_seqno} + \text{length_in_sequence_space}
$$</p>
<blockquote>
<p>也就是说，只有部分确认的段依然被认为是"完全未确认"。</p>
</blockquote>
<p>与此同时，还应满足 $\text{abs_ackno}\leq \text{abs_next_seqno}$，否则会被认为是无效确认号。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">ack_received</span><span class="token punctuation">(</span><span class="token keyword">const</span> WrappingInt32 ackno<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">uint16_t</span> window_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">uint64_t</span> abs_ackno <span class="token operator">=</span> <span class="token function">unwrap</span><span class="token punctuation">(</span>ackno<span class="token punctuation">,</span> _isn<span class="token punctuation">,</span> _next_seqno<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>abs_ackno <span class="token operator">&gt;</span> _next_seqno <span class="token operator">||</span> abs_ackno <span class="token operator">&lt;</span> _ackno<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">bool</span> flag<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  _ackno <span class="token operator">=</span> abs_ackno<span class="token punctuation">;</span>  <span class="token comment">// abs ackno</span>
  _rws <span class="token operator">=</span> window_size<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>_outstanding_segments<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    TCPSegment <span class="token operator">&amp;</span>seg <span class="token operator">=</span> _outstanding_segments<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    size_t seq_length <span class="token operator">=</span> seg<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>seqno <span class="token operator">+</span> seq_length <span class="token operator">&gt;</span> ackno<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    _outstanding_segments<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _rto <span class="token operator">=</span> _initial_retransmission_timeout<span class="token punctuation">;</span>
    _outstanding_segments<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> _timer<span class="token punctuation">.</span><span class="token function">stop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> _timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>_rto<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _retransmission_times <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> flag<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="如何发送段">如何发送段</h3>
<p>可以简单地认为，将 segment 插入 <code>_segments_out</code> 队列中就算将它发出去了。</p>
<p>但事实上，原始代码里并没有修改 segment 首部和负载字段的 api，需要修改头文件，加上几个 <code>set_syn()</code>，<code>set_fin()</code> 之类的，方便正确创建段。</p>
<p>最开始(abs_next_seqno=0)的时候，由于尚未建立连接，<code>_rws</code> 字段会被初始化为 1 而非 0，此时要发送的段仅仅为 <code>{SYN=1, data=""}</code> 的同步请求段。在收到确认之后，<code>_rws</code> 字段会被重置，我们就需要发送数据以尽可能填满该窗口，同时数据大小又不能超过 <code>TCPConfig::MAX_PAYLOAD_SIZE</code>。</p>
<p>已经发过的数据部分在未超时的情况下不用重复发送，那么理论上 <code>ackno</code> 会小于等于 <code>next_seqno</code>，而我们之后要发的数据部分应从 <code>next_seqno</code> 部分开始，于是乎这里就有了<strong>发送窗口</strong>的概念，即</p>
<p>$$
\text{send_window_size} = \text{abs_ackno} + \text{_rws} - \text{abs_next_seqno}
$$</p>
<p>这里需要注意的点是，<code>send_window_size</code> 指的是还可以发送多少序列号，而 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 指明了数据部分的字符数量，这两者的区别影响了是否需要在发送端的 <code>ByteStream</code> 数据读完后将 <code>FIN</code> 设置为 <code>1</code>。</p>
<blockquote>
<p>如果 <code>ByteStream</code> 已经 eof 且 <code>data.length() &lt; send_window_size</code>，说明还能容纳一个 <code>FIN</code> 的序列号，此时应当将 <code>FIN</code> 设为 <code>1</code>。很可能的一个情况是剩下的数据刚好有 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 这么多，而 <code>send_window_size</code> 恰好为 <code>TCPConfig::MAX_PAYLOAD_SIZE+1</code> 甚至更多，那么不加 <code>FIN</code> 是不合适的，违背了<strong>尽可能填满</strong>的规则。</p>
</blockquote>
<p>关于 <code>FIN</code> 还有个坑点，就是收到对 <code>{FIN=1}</code> 段的确认后，很可能依然满足发 <code>FIN</code> 段的要求，从而源源不断地发送，这就需要有一个变量来记录是否已经发过 <code>FIN</code> 段了，也就是上文中提到的 <code>TCPSender::close</code> 变量。</p>
<p>由于数据有大小上限，那么极有可能出现 <code>ByteStream</code> 还有大量数据，<code>_rws</code> 也还很大的情况，单独发一个 <code>TCPConfig::MAX_PAYLOAD_SIZE</code> 的段远远不够"填满"，此时要利用循环来不断尝试直至只能生成空段。</p>
<p>最后实现如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_sender.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPSender</span><span class="token double-colon punctuation">::</span><span class="token function">fill_window</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_timer<span class="token punctuation">.</span><span class="token function">state</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> TimerState<span class="token double-colon punctuation">::</span>IDLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _timer<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span>_rto<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">bool</span> syn<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">bool</span> fin<span class="token punctuation">{</span><span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>string data<span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">in_closed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 尚未发过 seg</span>
      syn <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      size_t read_size <span class="token operator">=</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">send_window_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> TCPConfig<span class="token double-colon punctuation">::</span>MAX_PAYLOAD_SIZE<span class="token punctuation">)</span><span class="token punctuation">;</span>
      data <span class="token operator">=</span> <span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>read_size<span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>fin_sent <span class="token operator">&amp;&amp;</span> <span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> data<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token function">send_window_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
        fin_sent <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

    TCPSegment seg <span class="token operator">=</span> TCPSegment<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">with_syn</span><span class="token punctuation">(</span>syn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_fin</span><span class="token punctuation">(</span>fin<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_data</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_seqno</span><span class="token punctuation">(</span><span class="token function">next_seqno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    size_t seq_length <span class="token operator">=</span> seg<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>seq_length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _segments_out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>seg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _outstanding_segments<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>seg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    _next_seqno <span class="token operator">+=</span> seq_length<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Testing the TCP sender<span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build

<span class="token punctuation">..</span>.

      Start <span class="token number">11</span>: t_send_connect
<span class="token number">11</span>/33 Test <span class="token comment">#11: t_send_connect ...................   Passed    0.00 sec</span>
      Start <span class="token number">12</span>: t_send_transmit
<span class="token number">12</span>/33 Test <span class="token comment">#12: t_send_transmit ..................   Passed    0.09 sec</span>
      Start <span class="token number">13</span>: t_send_retx
<span class="token number">13</span>/33 Test <span class="token comment">#13: t_send_retx ......................   Passed    0.00 sec</span>
      Start <span class="token number">14</span>: t_send_window
<span class="token number">14</span>/33 Test <span class="token comment">#14: t_send_window ....................   Passed    0.06 sec</span>
      Start <span class="token number">15</span>: t_send_ack
<span class="token number">15</span>/33 Test <span class="token comment">#15: t_send_ack .......................   Passed    0.00 sec</span>
      Start <span class="token number">16</span>: t_send_close
<span class="token number">16</span>/33 Test <span class="token comment">#16: t_send_close .....................   Passed    0.00 sec</span>
      Start <span class="token number">17</span>: t_send_extra
<span class="token number">17</span>/33 Test <span class="token comment">#17: t_send_extra .....................   Passed    0.00 sec</span>

<span class="token punctuation">..</span>.

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">33</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">1.30</span> sec
<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target check_lab3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lab4-TCP-Connection">lab4 TCP Connection</h2>
<p>本 lab 可以说是最难搞的一个了，我们需要结合 lab2 和 lab3 来实现一个真实的 TCP 协议，协调 sender 和 receiver 的所有操作，并完成三次握手和四次挥手。</p>
<h2 id="发送">发送</h2>
<p>什么时候要发送报文段？这是值得思考的一个问题，总的来说有以下几种情况是需要发送的：</p>
<ol>
<li class="lvl-3">
<p>主动向服务器发起连接请求。此时会发送一个 <code>SYN=1</code> 的段；</p>
</li>
<li class="lvl-3">
<p>收到一个至少占据一个序列号的段。此时我们<strong>应尽可能</strong>发送一个 ack 段，即便是不占序列号的空段；</p>
</li>
<li class="lvl-3">
<p>调用 <code>tick()</code> 引发超时重传。此时如果超过最大重传次数，则转而发送一个 <code>RST=1</code> 的段；</p>
</li>
<li class="lvl-3">
<p>上层写入字节流。此时接收窗口可能足够大，只是没数据，一旦数据到了，就应立即调用 <code>sender.fill_window()</code> 并发送段；</p>
</li>
<li class="lvl-3">
<p>上层停止写入，即调用 <code>end_input_stream()</code>。此时可能还有空闲窗口让我们能够发送 <code>FIN=1</code> 的段，毕竟结束符也占一个序列号；</p>
</li>
<li class="lvl-3">
<p>对象调用析构函数，但连接仍未终止。此时也需要发送一个 <code>RST=1</code> 的段；</p>
</li>
</ol>
<p>发送操作很简单，<code>sender</code> 调用相应函数然后从 <code>segment_out</code> 中取出来再插到发送队列即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_connection.cc</span></div><code class="language-cpp"><span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>_sender<span class="token punctuation">.</span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  TCPSegment <span class="token operator">&amp;</span>seg <span class="token operator">=</span> _sender<span class="token punctuation">.</span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">auto</span> ackno <span class="token operator">=</span> _receiver<span class="token punctuation">.</span><span class="token function">ackno</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ackno<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 说明 receiver 至少进入了 SYN_RECV 阶段</span>
    seg<span class="token punctuation">.</span><span class="token function">with_ack</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with_ackno</span><span class="token punctuation">(</span>ackno<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  seg<span class="token punctuation">.</span><span class="token function">with_win</span><span class="token punctuation">(</span>_receiver<span class="token punctuation">.</span><span class="token function">window_size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ack <span class="token operator">||</span> seg<span class="token punctuation">.</span><span class="token function">length_in_sequence_space</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>seg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  _sender<span class="token punctuation">.</span><span class="token function">segments_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="接收">接收</h2>
<p>接收是一个比较麻烦的事情，有一个细节是连接处于 <code>LISTEN</code> 阶段时只处理 <code>SYN=1</code> 的段，也就是会忽略 <code>RST=1</code> 段。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_connection.cc</span></div><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>_receiver<span class="token punctuation">.</span><span class="token function">in_listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> _sender<span class="token punctuation">.</span><span class="token function">in_closed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>seg<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>syn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  _receiver<span class="token punctuation">.</span><span class="token function">segment_received</span><span class="token punctuation">(</span>seg<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其他时候，如果收到（或发送） <code>RST=1</code> 段后，会引发 <code>unclean_shutdown</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_connection.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">TCPConnection</span><span class="token double-colon punctuation">::</span><span class="token function">unclean_shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// cerr &lt;&lt; "[unclean_shutdown]\n\n";</span>
    _sender<span class="token punctuation">.</span><span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _receiver<span class="token punctuation">.</span><span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set_error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    _active <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>除了上面这两种情况，剩下的时候都是正常对段进行接收处理，如果是 ack 段（事实上大部分都是 ack 段）还需要更新 sender。receiver 在收到段后，状态很有可能发生改变，一旦输入流结束，但是输出流尚未到达 eof，说明这一方是被动关闭，后续输出流结束，发出 <code>FIN=1</code> 并收到 ack 后可以直接关闭，因为这必然能确保另一方已经收到了 <code>FIN=1</code>（但不能保证对方知道自己收到了 ack）。</p>
<p>反之，说明输出流先结束，是主动结束连接的一方，此时在后续收到对方的 <code>FIN=1</code> 并发出 ack 后，不能立刻关闭连接，而是需要等待 10 倍的重传时限后才关闭连接，因为一旦对方没收到 ack，会对 <code>FIN=1</code> 进行重传，如果 <code>10*timeout</code> 内再也没收到 <code>FIN=1</code>，则可以视为对方收到，此时才能进行关闭。</p>
<p>变量 <code>_linger_after_streams_finish</code> 就是用于标识哪一方需要等待 <code>10*timeout</code> 才关闭。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/tcp_connection.cc</span></div><code class="language-cpp"><span class="token comment">// after receive a segment</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>_receiver<span class="token punctuation">.</span><span class="token function">stream_out</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">input_ended</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>_sender<span class="token punctuation">.</span><span class="token function">stream_in</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">eof</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  _linger_after_streams_finish <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token comment">// anytime need check if shutdown</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>_receiver<span class="token punctuation">.</span><span class="token function">in_fin_recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> _sender<span class="token punctuation">.</span><span class="token function">in_fin_acked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
  <span class="token punctuation">(</span><span class="token operator">!</span>_linger_after_streams_finish <span class="token operator">||</span> _time_since_last_segment_received <span class="token operator">&gt;=</span> <span class="token number">10</span> <span class="token operator">*</span> _cfg<span class="token punctuation">.</span>rt_timeout<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">clean_shutdown</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>总的来说难度在于许多测试并没有给出具体的测试样例，而是模拟了真实的网络环境。唯一一个让我 de 了好多天 bug 的是 timeout 我一开始写成了默认时限，也就是 1s，而测试的时限是 10s，就导致了绝大多数测试 <strong>TimeOut</strong>，后来改成 <code>cfg.rt_timeout</code> 才过。</p>
<p>另外不知道什么原因，在到 <code>t_ipv4_client_send</code> 这样的测试之后都因为服务器网络不可达的原因收不到任何回复，所以后面基本都 Failed 了，这也是一个比较遗憾的地方。</p>
<blockquote>
<p>如果遇到像 <code>... neq ... or ...</code> 这样的报错，需要把所有 <code>cerr</code> 注释掉才正常通过。因为这里是将输出结果写到文件里，然后和标准结果文件进行哈希值比较。</p>
</blockquote>
<h2 id="lab5-Network-Interface">lab5 Network Interface</h2>
<p>本 lab 要求我们实现路由器的接口部分，负责维护目的 IP 地址到 MAC 地址的映射，并将 IP 层数据包转发到下一跳。</p>
<blockquote>
<p>lab5 lab6 都很简单，一下午就都搞定了。</p>
</blockquote>
<h3 id="发送-2">发送</h3>
<p>当转发数据包时，目的 IP 地址是已知的（就是<strong>下一跳</strong>），但对于链路层的 MAC 地址则可能未知，这就需要我们广播一个目的 MAC 地址为 <code>ff:ff:ff:ff:ff:ff</code> 的 ARP 请求来获取位于目的 IP 地址的设备的 MAC 地址。发送后，<code>{datagram, next_hop}</code> 会被缓存直至收到 ARP 答复。如果对目的 IP 地址的请求在 5s 内已经被发过一次，则只需等待答复即可，不用再发一遍。如果目的 MAC 地址已知，那事情就简单很多，直接将数据包包装成链路层帧发送即可。复杂点在于各个字段要完全设置好。</p>
<blockquote>
<p>包装操作应使用 <code>serialize()</code> 方法转换为 <code>string</code>，再隐式转换为 <code>Buffer</code>。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/network_interface.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">NetworkInterface</span><span class="token double-colon punctuation">::</span><span class="token function">send_datagram</span><span class="token punctuation">(</span><span class="token keyword">const</span> InternetDatagram <span class="token operator">&amp;</span>dgram<span class="token punctuation">,</span> <span class="token keyword">const</span> Address <span class="token operator">&amp;</span>next_hop<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token keyword">uint32_t</span> next_hop_ip <span class="token operator">=</span> next_hop<span class="token punctuation">.</span><span class="token function">ipv4_numeric</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> next_ipv4_addr <span class="token operator">=</span> next_hop<span class="token punctuation">.</span><span class="token function">ipv4_numeric</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  EthernetFrame frame<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>_mp<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>next_ipv4_addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 目的 MAC 地址已知</span>
    EthernetAddress next_ethernet_addr <span class="token operator">=</span> _mp<span class="token punctuation">[</span>next_ipv4_addr<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// make frame</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 广播 ARP</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>_time_since_last_send<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>next_hop_ip<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> _time_since_last_send<span class="token punctuation">[</span>next_hop_ip<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token number">5000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    _time_since_last_send<span class="token punctuation">[</span>next_hop_ip<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token comment">// make frame</span>
    <span class="token comment">// 这里有一个坑点，ARPMessage 的目的 MAC 地址为空，因为帧头处已经设置为广播地址 ff:ff:ff:ff:ff:ff</span>

    _waiting_for_arp_reply<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>dgram<span class="token punctuation">,</span> next_hop<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  _frames_out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="接收-2">接收</h3>
<p>当收到帧时，首先判断这是否为正常的数据交互，若是，则将其有效负载解析为数据包，作为返回值交付给调用者。</p>
<p>反之，检查这是一个 ARP 请求还是 ARP 答复。如果是前者，并其目的 IP 地址是否与自身一致，则发回一个 ARP 答复；反之，发送等待答复的数据包。同时，还要根据发送方的信息更新 IP/MAC 映射表，对应条目保持 30s，时间到后删除条目。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/network_interface.cc</span></div><code class="language-cpp">optional<span class="token operator">&lt;</span>InternetDatagram<span class="token operator">&gt;</span> <span class="token class-name">NetworkInterface</span><span class="token double-colon punctuation">::</span><span class="token function">recv_frame</span><span class="token punctuation">(</span><span class="token keyword">const</span> EthernetFrame <span class="token operator">&amp;</span>frame<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> EthernetHeader <span class="token operator">&amp;</span>f_header <span class="token operator">=</span> frame<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>f_header<span class="token punctuation">.</span>dst <span class="token operator">!=</span> _ethernet_address <span class="token operator">&amp;&amp;</span> f_header<span class="token punctuation">.</span>dst <span class="token operator">!=</span> ETHERNET_BROADCAST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 说明发错人了，直接不处理</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f_header<span class="token punctuation">.</span>type <span class="token operator">==</span> EthernetHeader<span class="token double-colon punctuation">::</span>TYPE_IPv4<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    InternetDatagram dgram<span class="token punctuation">;</span>
    ParseResult parse_res <span class="token operator">=</span> dgram<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>frame<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parse_res <span class="token operator">==</span> ParseResult<span class="token double-colon punctuation">::</span>NoError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 成功解析则返回，否则丢弃</span>
      <span class="token keyword">return</span> optional<span class="token operator">&lt;</span>InternetDatagram<span class="token operator">&gt;</span><span class="token punctuation">{</span>dgram<span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>f_header<span class="token punctuation">.</span>type <span class="token operator">==</span> EthernetHeader<span class="token double-colon punctuation">::</span>TYPE_ARP<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    ARPMessage msg<span class="token punctuation">;</span>
    ParseResult parse_res <span class="token operator">=</span> msg<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>frame<span class="token punctuation">.</span><span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>parse_res <span class="token operator">==</span> ParseResult<span class="token double-colon punctuation">::</span>NoError<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      _mp<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender_ip_address<span class="token punctuation">,</span> msg<span class="token punctuation">.</span>sender_ethernet_address<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      _holding_time<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span><span class="token function">make_pair</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>sender_ip_address<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>target_ip_address <span class="token operator">==</span> _ip_address<span class="token punctuation">.</span><span class="token function">ipv4_numeric</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>opcode <span class="token operator">==</span> ARPMessage<span class="token double-colon punctuation">::</span>OPCODE_REQUEST<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          EthernetFrame reply<span class="token punctuation">;</span>
          <span class="token comment">// make reply</span>
          _frames_out<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>reply<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>opcode <span class="token operator">==</span> ARPMessage<span class="token double-colon punctuation">::</span>OPCODE_REPLY<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token function">send_datagram</span><span class="token punctuation">(</span>_waiting_for_arp_reply<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>first<span class="token punctuation">,</span> _waiting_for_arp_reply<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>second<span class="token punctuation">)</span><span class="token punctuation">;</span>
          _waiting_for_arp_reply<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Testing Lab <span class="token number">5</span><span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build
    Start <span class="token number">31</span>: t_webget
<span class="token number">1</span>/2 Test <span class="token comment">#31: t_webget .........................   Passed    1.22 sec</span>
    Start <span class="token number">32</span>: arp_network_interface
<span class="token number">2</span>/2 Test <span class="token comment">#32: arp_network_interface ............   Passed    0.01 sec</span>

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">2</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">1.24</span> sec
Built target check_lab5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="lab6-Router">lab6 Router</h2>
<p>本 lab 要求我们实现路由表中的最长前缀匹配。路由表我采用的是 <code>std::unordered_map&lt;uint32_t, std::tuple&lt;uint8_t, std::optional&lt;Address&gt;, size_t&gt;&gt;</code>，存储 <code>route_prefix -&gt; {prefix_length, next_hop, interface_num}</code> 的映射对。</p>
<p>有以下注意点：</p>
<ol>
<li class="lvl-3">
<p>当需要转发的数据包的 <code>ttl &lt;= 1</code> 时，丢弃，反之，将其减一；</p>
</li>
<li class="lvl-3">
<p>一般有一个默认网关为 <code>0.0.0.0/0</code>，如果将一个 32 位整数移位 32 位是未定义行为，需要考虑到这种情况；</p>
</li>
<li class="lvl-3">
<p>数据包必然是能发出去的，实在没有匹配到的也会发至默认网关，如果有其他匹配的网段可能是 direct 直达的，此时 <code>next_hop</code> 不一定有值，此时将发送的下一跳设置为数据包的 <code>dst ip_addr</code> 即可；</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>libsponge/router.cc</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Router</span><span class="token double-colon punctuation">::</span><span class="token function">route_one_datagram</span><span class="token punctuation">(</span>InternetDatagram <span class="token operator">&amp;</span>dgram<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>dgram<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>ttl<span class="token operator">--</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">uint8_t</span> longest_match_length<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">uint32_t</span> ipv4_addr <span class="token operator">=</span> dgram<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>dst<span class="token punctuation">;</span>
  optional<span class="token operator">&lt;</span>Address<span class="token operator">&gt;</span> next_hop<span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  size_t interface_num<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> <span class="token operator">&amp;&amp;</span>entry <span class="token operator">:</span> _route_table<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// find Longest-Match Prefix</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>next_hop<span class="token punctuation">.</span><span class="token function">has_value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    _interfaces<span class="token punctuation">[</span>interface_num<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">send_datagram</span><span class="token punctuation">(</span>dgram<span class="token punctuation">,</span> next_hop<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">// 可直接发送至目的 IP 地址</span>
    _interfaces<span class="token punctuation">[</span>interface_num<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">send_datagram</span><span class="token punctuation">(</span>dgram<span class="token punctuation">,</span> <span class="token class-name">Address</span><span class="token double-colon punctuation">::</span><span class="token function">from_ipv4_numeric</span><span class="token punctuation">(</span>ipv4_addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>测试结果如下。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Testing Lab <span class="token number">6</span><span class="token punctuation">..</span>.
Test project <span class="token punctuation">..</span>./CS144/build
    Start <span class="token number">32</span>: arp_network_interface
<span class="token number">1</span>/2 Test <span class="token comment">#32: arp_network_interface ............   Passed    0.00 sec</span>
    Start <span class="token number">33</span>: router_test
<span class="token number">2</span>/2 Test <span class="token comment">#33: router_test ......................   Passed    0.02 sec</span>

<span class="token number">100</span>% tests passed, <span class="token number">0</span> tests failed out of <span class="token number">2</span>

Total Test <span class="token function">time</span> <span class="token punctuation">(</span>real<span class="token punctuation">)</span> <span class="token operator">=</span>   <span class="token number">0.03</span> sec
<span class="token punctuation">[</span><span class="token number">100</span>%<span class="token punctuation">]</span> Built target check_lab6<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>设计模式</title>
    <url>/note/designpatterns/</url>
    <content><![CDATA[<p>设计模式是软件设计中常见问题的典型解决方案。每个模式就像一张蓝图，可以通过对其进行定制来解决代码中的特定设计问题。</p>
<span id="more"></span>
<h2 id="创建型">创建型</h2>
<h3 id="单例模式">单例模式</h3>
<p><strong>单例模式</strong>保证一个类只有一个全局共享的实例，并提供一个访问该实例的全局 API。</p>
<p>所有单例的实现都包含以下两个相同的步骤：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>将默认构造函数设为私有，防止其他对象在某些地方进行单例类的构造；</p>
</li>
<li class="lvl-2">
<p>使用静态构建方法创建对象，并将其保存在一个静态成员变量中。此后所有对于该函数的调用都将返回这一对象；</p>
</li>
</ul>
<h4 id="懒汉式-lazy">懒汉式(lazy)</h4>
<p>用到的时候才创建实例。C<ins>11 以前容易产生线程安全的问题，但 C</ins>11 标准之后的最佳的选择是「<strong>Meyers’ Singleton</strong>」，它利用了局部静态变量在第一次使用时才初始化的特性。并且由于 C++11 标准解决了局部静态变量的线程安全问题，使得它成为当前<strong>最优雅</strong>的实现方式。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Meyers' Singleton</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> Singleton<span class="token operator">&amp;</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> Singleton instance<span class="token punctuation">;</span>  <span class="token comment">// so elegent</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="饿汉式-eager">饿汉式(eager)</h4>
<p>指单例实例在程序运行时被立即执行初始化，也能保证线程安全。但如果用不到的话可能会浪费不必要的资源，同时如果一个单例依赖另一个单例，此时这两个单例的构造先后顺序是不确定的，存在隐患。</p>
<p>推荐用 Meyers’ Singleton。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>饿汉式</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> instance<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token operator">~</span><span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  Singleton<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> Singleton<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>

  <span class="token keyword">static</span> Singleton<span class="token operator">*</span> instance<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Singleton<span class="token operator">*</span> Singleton<span class="token double-colon punctuation">::</span>instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="工厂模式">工厂模式</h3>
<p><strong>工厂模式</strong>通过使用一个全局共享的接口来创建新的对象。终极目的是为了<strong>解耦</strong>，实现创建者和调用者的分离。</p>
<p>它利用了面向对象中<strong>多态</strong>的特性，将存在着继承关系的类，通过一个工厂类创建对应的派生类对象。</p>
<h4 id="简单工厂">简单工厂</h4>
<p>简单工厂的工厂类里封装了创建具体产品对象的函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>简单工厂</span></div><code class="language-cpp"><span class="token keyword">enum</span> <span class="token keyword">class</span> <span class="token class-name">ProductType</span> <span class="token punctuation">{</span>
  TYPEA<span class="token punctuation">,</span>
  TYPEB
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  Product<span class="token operator">*</span> <span class="token function">CreateProduct</span><span class="token punctuation">(</span>ProductType type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">switch</span> <span class="token punctuation">(</span>type<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> ProductType<span class="token double-colon punctuation">::</span>TYPEA<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">case</span> ProductType<span class="token double-colon punctuation">::</span>TYPEB<span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      <span class="token keyword">default</span><span class="token operator">:</span>
        <span class="token keyword">return</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>缺陷在于扩展性差：一旦需要新增产品，则必须修改 <code>ProductType</code> 以及工厂类的创建函数。</p>
<h4 id="工厂方法">工厂方法</h4>
<p>工厂方法将工厂类进行抽象，仅提供创建具体产品的接口，而具体实现交由子类（即具体工厂）去完成。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>工厂方法</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> Product<span class="token operator">*</span> <span class="token function">CreateProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">AbstractFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteFactory1</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractFactory</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> Product<span class="token operator">*</span> <span class="token function">CreateProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ProductA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">ConcreteFactory2</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractFactory</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> Product<span class="token operator">*</span> <span class="token function">CreateProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ProductB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同样，每新增一个产品，就需要增加一个对应的产品的具体工厂类。相比简单工厂而言，工厂方法模式需要更多的类定义。</p>
<h4 id="抽象工厂">抽象工厂</h4>
<p>在工厂方法基础上，为抽象类增加多个接口，若子类支持某接口，则进行 override，否则什么也不做。这样就实现了创建多个产品族中的产品对象。代码略。</p>
<h4 id="模板工厂">模板工厂</h4>
<p>以上三种方式，在新增产品时，要么修改工厂类，要么需新增具体的工厂类，说明工厂类的封装性还不够好。模板工厂是将工厂方法模式封装成模板工厂类，那么这样在新增产品时，是不需要新增具体的工厂类，减少了代码的编写量。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>抽象模板工厂 &amp; 具体模板工厂</span></div><code class="language-cpp"><span class="token comment">// 抽象模板工厂类</span>
<span class="token comment">// AbstractProduct_t 产品抽象类</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">AbstractProduct_t</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">AbstractFactory</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> AbstractProduct_t<span class="token operator">*</span> <span class="token function">CreateProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">AbstractFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 具体模板工厂类</span>
<span class="token comment">// AbstractProduct_t 产品抽象类，ConcreteProduct_t 产品具体类</span>
<span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">AbstractProduct_t</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteProduct_t</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">ConcreteFactory</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">AbstractFactory</span><span class="token operator">&lt;</span><span class="token class-name">AbstractProduct_t</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  AbstractProduct_t<span class="token operator">*</span> <span class="token function">CreateProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">ConcreteProduct_t</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，也可以在创建产品时通过某种 primary key 将其注册进 <code>std::map</code>/<code>std::unordered_map</code> 中，后续可以通过该 key 直接获取之前创建过的产品，这就实现了「<strong>反射</strong>」。</p>
<h2 id="行为型">行为型</h2>
<h3 id="状态模式-策略模式">状态模式 &amp; 策略模式</h3>
<p>使用<strong>状态模式</strong>的类需要在内部设置一个「状态变量」，该变量会随函数调用而<strong>被动</strong>切换，类似于自动状态机，并且根据不同状态执行不同的行为。</p>
<p>而使用<strong>策略模式</strong>的类需要在内部设置一个「策略变量」，该变量会被开发者<strong>手动</strong>设置，从而根据不同策略执行不同的行为。</p>
<p>不难发现，这两种模式都涉及将具体的行为封装到不同的类中，以便在运行时选择不同的行为，但区别在于是被动修改还是主动修改。更严格地说，切换这一内部变量的函数是 private 的还是 public 的。</p>
<blockquote>
<p>通常会搭配<strong>单例模式</strong>实现，因为特定行为应当是全局一致的。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>状态模式</span></div><code class="language-cpp"><span class="token comment">/**
 * 这段代码可以通过声明与实现分离的形式编写，这里就简单写到一起了。
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">StateBase</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span><span class="token keyword">const</span> StateBase<span class="token operator">*</span> newState<span class="token punctuation">)</span> <span class="token punctuation">{</span> state <span class="token operator">=</span> newState<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">const</span> StateBase<span class="token operator">*</span> state<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StateBase</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">StateBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StateA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">StateBase</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> StateA<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> StateA state<span class="token punctuation">;</span>
    <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StateB</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">StateBase</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> StateB<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> StateB state<span class="token punctuation">;</span>
    <span class="token keyword">return</span> state<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">StateA</span><span class="token double-colon punctuation">::</span><span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"here is stateA"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  obj<span class="token operator">-&gt;</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">StateB</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移到 stateB</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">StateB</span><span class="token double-colon punctuation">::</span><span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"here is stateB"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  obj<span class="token operator">-&gt;</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">StateA</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 状态转移到 stateA</span>
<span class="token punctuation">}</span>

<span class="token class-name">Object</span><span class="token double-colon punctuation">::</span><span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">state</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">StateA</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token class-name">Object</span><span class="token double-colon punctuation">::</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> state<span class="token operator">-&gt;</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">// 利用多态，根据不同状态执行不同行为</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object obj<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// here is stateA</span>
  obj<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// here is stateB</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>策略模式</span></div><code class="language-cpp"><span class="token comment">/**
 * 这段代码可以通过声明与实现分离的形式编写，这里就简单写到一起了。
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">StrategyBase</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token keyword">const</span> StrategyBase<span class="token operator">*</span> newStrategy<span class="token punctuation">)</span> <span class="token punctuation">{</span> strategy <span class="token operator">=</span> newStrategy<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> StrategyBase<span class="token operator">*</span> strategy<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StrategyBase</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">StrategyBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StrategyA</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">StrategyBase</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"here is strategyA"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> StrategyA<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> StrategyA strategy<span class="token punctuation">;</span>
    <span class="token keyword">return</span> strategy<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">StrategyB</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">StrategyBase</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>Object<span class="token operator">*</span> obj<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"here is strategyB"</span> <span class="token operator">&lt;&lt;</span> std<span class="token double-colon punctuation">::</span>endl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> <span class="token keyword">const</span> StrategyB<span class="token operator">&amp;</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> StrategyB strategy<span class="token punctuation">;</span>
    <span class="token keyword">return</span> strategy<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Object</span><span class="token double-colon punctuation">::</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> strategy<span class="token operator">-&gt;</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object obj<span class="token punctuation">;</span>
  obj<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">StrategyA</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主动切换策略到 StrategyA</span>
  obj<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// here is strategyA</span>

  obj<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token class-name">StrategyB</span><span class="token double-colon punctuation">::</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 主动切换策略到 StrategyB</span>
  obj<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment">// here is strategyB</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="命令模式">命令模式</h3>
<p><strong>命令模式</strong>可将请求转换为一个包含与请求相关的所有信息的独立对象，这允许用户根据不同的请求将方法参数化、延迟请求执行或将其放入队列中，同时支持「撤销」操作。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>命令模式</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;queue&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">Dummy</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Dummy: ("</span> <span class="token operator">&lt;&lt;</span> a <span class="token operator">&lt;&lt;</span> <span class="token string">".)\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Command</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 简单命令的执行不和其它对象交互</span>
<span class="token keyword">class</span> <span class="token class-name">SimpleCommand</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Command</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">SimpleCommand</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>s<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">str</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"SimpleCommand: ("</span> <span class="token operator">&lt;&lt;</span> str <span class="token operator">&lt;&lt;</span> <span class="token string">")\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string str<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 复杂命令的执行可能会需要其他对象参与</span>
<span class="token keyword">class</span> <span class="token class-name">ComplexCommand</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Command</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">ComplexCommand</span><span class="token punctuation">(</span>Dummy <span class="token operator">*</span>d<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>a<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
      <span class="token operator">:</span> <span class="token function">dummy</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strA</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">strB</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    dummy<span class="token operator">-&gt;</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>strA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    dummy<span class="token operator">-&gt;</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>strB<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  Dummy <span class="token operator">*</span>dummy<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string strA<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string strB<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 请求发起者 与 命令执行者 的中间层，用于存储命令</span>
<span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>cmdQ<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">delete</span> cmdQ<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cmdQ<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">addCmd</span><span class="token punctuation">(</span>Command <span class="token operator">*</span>command<span class="token punctuation">)</span> <span class="token punctuation">{</span> cmdQ<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>cmdQ<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      cmdQ<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">delete</span> cmdQ<span class="token punctuation">.</span><span class="token function">front</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      cmdQ<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>queue<span class="token operator">&lt;</span>Command <span class="token operator">*</span><span class="token operator">&gt;</span> cmdQ<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Invoker <span class="token operator">*</span>invoker <span class="token operator">=</span> <span class="token keyword">new</span> Invoker<span class="token punctuation">;</span>
  Dummy <span class="token operator">*</span>dummy <span class="token operator">=</span> <span class="token keyword">new</span> Dummy<span class="token punctuation">;</span>
  invoker<span class="token operator">-&gt;</span><span class="token function">addCmd</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">SimpleCommand</span><span class="token punctuation">(</span><span class="token string">"Hi"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  invoker<span class="token operator">-&gt;</span><span class="token function">addCmd</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">ComplexCommand</span><span class="token punctuation">(</span>dummy<span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  invoker<span class="token operator">-&gt;</span><span class="token function">invoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">delete</span> invoker<span class="token punctuation">;</span>
  <span class="token keyword">delete</span> dummy<span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这里没有实现「撤销」操作，如果需要的话，可以将 <code>Invoker</code> 类中的命令队列改为双向链表，并用指针指向当前命令，从而支持<strong>撤销</strong>（当前命令执行 <code>cancel()</code>，指针前移）与<strong>重做</strong>（指针后移，并令当前命令执行 <code>execute()</code>）操作。</p>
</blockquote>
<p>不难发现，命令模式的优越性在于，将「请求进行一个操作的对象」，和「知道如何执行该操作的对象」进行解耦，同时可以很方便地对命令类型进行扩展。</p>
<h3 id="观察者模式">观察者模式</h3>
<p><strong>观察者模式</strong>允许用户定义一种「订阅」机制，可在某一事件发生时通知多个订阅该类型事件的其他对象。拥有一些值得关注的状态的对象通常被称为「目标」，由于它要将自身的状态改变通知给其他对象，我们也将其称为<strong>发布者(publisher)</strong>，所有希望关注发布者状态变化的其他对象被称为<strong>订阅者(subscriber)</strong>。</p>
<p>我们可以在发布者类中实现两个机制：</p>
<ol>
<li class="lvl-3">
<p>一个存储订阅者对象引用的列表成员变量 <code>subscribers</code>；</p>
</li>
<li class="lvl-3">
<p>一些用于添加或删除该列表中订阅者的公有方法（如 <code>subscribe()</code> 与 <code>unsubscribe()</code>）；</p>
</li>
</ol>
<p>这样，一旦发布者类有事件发生，就可以通过遍历 <code>subscribers</code> 的方式通知所有订阅者。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>观察者模式</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;list&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">SubscriberBase</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">SubscriberBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>message_from_Publisher<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">PublisherBase</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">PublisherBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">default</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>SubscriberBase <span class="token operator">*</span>Subscriber<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span>SubscriberBase <span class="token operator">*</span>Subscriber<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>str<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Publisher</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">PublisherBase</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>SubscriberBase <span class="token operator">*</span>Subscriber<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    subscribers<span class="token punctuation">.</span><span class="token function">push_back</span><span class="token punctuation">(</span>Subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span>SubscriberBase <span class="token operator">*</span>Subscriber<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    subscribers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>Subscriber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>message<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span> subscriber <span class="token operator">:</span> subscribers<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      subscriber<span class="token operator">-&gt;</span><span class="token function">update</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>SubscriberBase <span class="token operator">*</span><span class="token operator">&gt;</span> subscribers<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Subscriber</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">SubscriberBase</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Subscriber</span><span class="token punctuation">(</span>Publisher <span class="token operator">*</span>publisher<span class="token punctuation">)</span> <span class="token punctuation">{</span> publisher<span class="token operator">-&gt;</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>message<span class="token punctuation">)</span> <span class="token keyword">override</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> message<span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token keyword">void</span> <span class="token function">subscribe</span><span class="token punctuation">(</span>Publisher <span class="token operator">*</span>publisher<span class="token punctuation">)</span> <span class="token punctuation">{</span> publisher<span class="token operator">-&gt;</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">unsubscribe</span><span class="token punctuation">(</span>Publisher <span class="token operator">*</span>publisher<span class="token punctuation">)</span> <span class="token punctuation">{</span> publisher<span class="token operator">-&gt;</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Publisher Publisher<span class="token punctuation">;</span>
  Subscriber <span class="token function">Subscriber1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Publisher<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Subscriber <span class="token function">Subscriber2</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Publisher<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Publisher<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">"Hello World! :D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Subscriber2<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Publisher<span class="token punctuation">)</span><span class="token punctuation">;</span>

  Publisher<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token string">"The weather is hot today! :p"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Subscriber1<span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Publisher<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种机制还可以进一步扩展。比如我们可以为事件设置不同类型，允许订阅者关注不同类型的事件，这样就可以根据事件类型通知特定的订阅者。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>.C 文件の编译过程(Compile Process)</title>
    <url>/note/compileprocess/</url>
    <content><![CDATA[<p>对于一个程序员而言，不仅仅要知道代码是怎么写的，还得知道你的源代码文件是怎么经过一系列操作变成可执行文件的。</p>
<blockquote>
<p>参考神书《CSAPP》</p>
</blockquote>
<span id="more"></span>
<h2 id="整体流程">整体流程</h2>
<p>本文将以以下程序为基础进行分析。</p>
<pre class="line-numbers language-c" data-language="c"><div class="caption"><span>main.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> array<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> val <span class="token operator">=</span> <span class="token function">sum</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-c" data-language="c"><div class="caption"><span>sum.c</span></div><code class="language-c"><span class="token keyword">int</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> i<span class="token punctuation">,</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    s <span class="token operator">+=</span> a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> s<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这个示例程序由两个源文件组成，<code>main.c</code> 和 <code>sum.c</code>。</p>
<p><code>main()</code> 初始化一个整数数组，然后调用 <code>sum()</code> 来对数组元素求和。如果要用 GNU 编译系统构造示例程序，我们就要通过在 shell 中输入下列命令来调用 GCC 驱动程序：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc main.c sum.c <span class="token parameter variable">-o</span> prog<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<blockquote>
<p>在 Unix 系统上，从源文件到目标文件的转化是由编译器驱动程序完成的。编译器驱动程序读取源程序文件 .c，并把它翻译成一个可执行目标文件 .exe。这个翻译过程分为四个阶段：<strong>预处理(Preprocessing)</strong>、<strong>编译(Compilation)</strong>、<strong>汇编(Assembly)</strong>、<strong>链接(Linking)</strong>（如下图所示）。执行这四个阶段的程序(预处理器、编译器、汇编器、链接器)一起构成了编译系统。</p>
<p>通常，前三个阶段都会直接合并到一起，也就是直接从源文件生成目标文件。</p>
</blockquote>
<img src="1.png" style="zoom:80%">
<h2 id="预处理阶段">预处理阶段</h2>
<p>预处理器(cpp)处理所有的以 <code>#</code> 起始的预编译指令，比如</p>
<ol>
<li class="lvl-3">
<p>将宏定义 <code>#define</code> 出现的所有位置进行文本替换；</p>
</li>
<li class="lvl-3">
<p>处理所有条件预编译指令如 <code>#ifdef</code>、<code>#endif</code>；</p>
</li>
<li class="lvl-3">
<p>将 <code>#include</code> 的文件直接插入到预编译指令的位置；</p>
</li>
<li class="lvl-3">
<p>删除所有的注释；</p>
</li>
<li class="lvl-3">
<p>添加行号和文件标识，以便编译时产生调试用的行号及编译错误警告行号；</p>
</li>
<li class="lvl-3">
<p>保留所有的 <code>#pragma</code> 编译器指令，因为编译器需要使用它们；</p>
</li>
</ol>
<blockquote>
<p>通过运行 <code>gcc -E ??.c -o ??.i</code> 命令来进行预处理，我们将得到一个 <code>.i</code> 结尾的预处理文件。</p>
</blockquote>
<h2 id="编译阶段">编译阶段</h2>
<p>编译器(ccl)将预处理完的文本文件 <code>.i</code> 进行处理，检查语法规范性（包括词法分析、语法分析、语义分析），并进行一定优化，最后生成一个由汇编语言进行描述的文件 <code>.s</code>。</p>
<blockquote>
<p>通过运行 <code>gcc -S ??.i -o ??.s</code> 命令来进行预处理，我们将得到一个 <code>.s</code> 结尾的汇编文件。</p>
</blockquote>
<h2 id="汇编阶段">汇编阶段</h2>
<p>汇编器(as)把编译阶段生成的 <code>.s</code> 文件转化成目标文件 <code>.o</code>。从文件结构上来讲，目标文件已经是二进制文件，本身就是按照可执行文件格式存储的，只是有些变量和函数的地址还未确定，且各 <code>.o</code> 文件地址空间相互独立（从地址 0x0 开始生成代码和数据节），程序还不能执行，需要依靠下一步的链接来找到这些变量和函数的地址并进行重定位。</p>
<blockquote>
<p>通过运行 <code>gcc -c ??.s -o ??.o</code> 命令来进行预处理，我们将得到一个 <code>.o</code> 结尾的目标文件。</p>
</blockquote>
<h3 id="可执行文件格式-ELF">可执行文件格式 ELF</h3>
<p>以 Linux 为例，其可执行文件的格式为 <strong>ELF(Executable Linkable Format)</strong>，即<strong>可执行可链接格式</strong>。</p>
<p>Linux 将采用的 ELF 格式的文件分为四类，分别是：</p>
<ol>
<li class="lvl-3">
<p><strong>可重定位文件(Relocatable File)</strong>：如 <code>.o</code>；</p>
</li>
<li class="lvl-3">
<p><strong>可执行文件(Executable File)</strong>：如 <code>.exe</code>；</p>
</li>
<li class="lvl-3">
<p><strong>共享目标文件(Shared Object File)</strong>：如 <code>.so</code>；</p>
</li>
<li class="lvl-3">
<p><strong>核心转储文件(Core Dump File)</strong>：当进程意外终止时，系统可以将该进程的地址空间的内容及终止时的一些其它信息转储到核心转储文件，如 <code>core dump</code>。</p>
</li>
</ol>
<blockquote>
<p>Linux下使用 file 命令可以查看相应的文件格式：<code>file test.o</code></p>
</blockquote>
<h3 id="可重定位文件">可重定位文件</h3>
<p>下图就是一个经典的 ELF 可重定位目标文件格式</p>
<img src="1.webp" style="zoom:80%">
<h4 id="ELF-Header">ELF Header</h4>
<p>**ELF 头(ELF Header)**描述了一些目标文件的信息，包括 ELF 头的大小、目标文件类型、机器类型、节头部表的文件偏移，以及节头部表项的大小和数量。</p>
<h4 id="Sections">Sections</h4>
<p>接下来一直到节头表之前就是若干**节(Section)**了。一般都有以下这些节：</p>
<ol>
<li class="lvl-3">
<p><code>.text</code>：代码节，即已编译程序的指令码；</p>
</li>
<li class="lvl-3">
<p><code>.rodata</code>：只读数据节，比如常量；</p>
</li>
<li class="lvl-3">
<p><code>.data</code>：存放<strong>已初始化</strong>的全局变量和静态变量；</p>
</li>
<li class="lvl-3">
<p><code>.bss</code>：存放<strong>未初始化</strong>全局变量和静态变量；</p>
</li>
<li class="lvl-3">
<p><code>.symtab</code>：符号表，它存放在程序中定义和引用的<strong>函数和全局变量</strong>的信息。它不包含对应于 <strong>non-static 局部变量</strong>的任何符号，因为这些符号在运行时在<strong>栈</strong>中被管理，链接器对此类符号不感兴趣；</p>
<blockquote>
<p>一些程序员错误地认为必须通过 <code>-g</code> 选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在 <code>.symtab</code> 中都有一张符号表（除非程序员特意用 <code>STRIP</code> 命令去掉它）。然而，和编译器中的符号表不同，<code>.symtab</code> 符号表<strong>不</strong>包含局部变量的条目。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><code>.rel.text</code>：描述 <code>.text</code> 节中需重定位的符号位置信息；</p>
</li>
<li class="lvl-3">
<p><code>.rel.data</code>：描述 <code>.data</code> 节中需重定位的符号位置信息；</p>
</li>
<li class="lvl-3">
<p><code>.debug</code>：调试用符号表，其条目是程序中定义的<strong>局部变量</strong>和<strong>类型定义</strong>，程序中定义和引用的<strong>全局变量</strong>，以及源文件；</p>
</li>
<li class="lvl-3">
<p><code>.line</code>：源文件中的行号和 <code>.text</code> 节中机器指令之间的映射；</p>
</li>
<li class="lvl-4">
<p><code>.strtab</code>：字符串表，其内容包括 <code>.symtab</code> 和 <code>.debug</code> 节中的符号名，以及节头部中的节名字，以 null 结尾；</p>
</li>
</ol>
<h4 id="Section-Header-Table">Section Header Table</h4>
<p>**节头表(Section Header Table)**中的每一条目都按序对应前面节的信息。</p>
<h3 id="可执行文件">可执行文件</h3>
<p>下图就是一个经典的 ELF 可执行文件格式</p>
<img src="2.webp" style="zoom:80%">
<p>最后被加载到内存中。在 Linux 86-64 系统中，代码段总是从地址 <code>0x400000</code> 处开始，后面是数据段。</p>
<img src="3.webp" style="zoom:80%">
<h4 id="ELF-Header-2">ELF Header</h4>
<p><strong>ELF 头(ELF Header)<strong>除了描述文件的总体格式，还包括程序的</strong>入口</strong>（entry point），也就是当程序运行时要执行的第一条指令的地址。</p>
<h4 id="Program-Header-Table">Program Header Table</h4>
<p>**程序头部表(Program Header Table)**将连续的 sections 映射到内存段中。通过 <code>objdump</code> 可以查看 <code>prog</code> 的 PHT，部分表项如下所示。字段都已标注，不再赘述。</p>
<pre class="line-numbers language-S" data-language="S"><code class="language-S">Program Header:
    PHDR off    0x0000000000000040 vaddr 0x0000000000000040 paddr 0x0000000000000040 align 2**3  ## PHDR: 给出头部表自身的大小与位置
         filesz 0x00000000000002d8 memsz 0x00000000000002d8 flags r--
  INTERP off    0x0000000000000318 vaddr 0x0000000000000318 paddr 0x0000000000000318 align 2**0  ## INTERP: 解释器的位置
         filesz 0x000000000000001c memsz 0x000000000000001c flags r--
    LOAD off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**12 ## LOAD: 可加载到内存的段
         filesz 0x00000000000005f0 memsz 0x00000000000005f0 flags r--<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="Segments">Segments</h4>
<h3 id="符号与符号表">符号与符号表</h3>
<p>每个可重定位目标模块 m 都有一个符号表，它包含 m 定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：</p>
<ol>
<li class="lvl-3">
<p><strong>全局(global)链接器符号</strong>：由模块 m 定义并能被其他模块引用。对应于 non-static 函数和全局变量；</p>
</li>
<li class="lvl-3">
<p><strong>外部(external)符号</strong>：由其他模块定义并被模块 m 引用。对应于在其他模块中定义的 non-static 函数和全局变量；</p>
</li>
<li class="lvl-3">
<p><strong>本地(local)符号</strong>：只被模块 m 定义和引用，不能被其他模块引用，m 中任何位置都可见。对应于 static 函数和全局变量；</p>
</li>
</ol>
<p>编译器会为这些定义在 <code>.bss</code>/<code>.data</code> 中分配空间，并生成唯一符号，写入符号表中。符号的数据结构定义如下：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {
  int     name;      /* String table offset */
  char    type:4,    /* Function or data (4 bits) */
          binding:4; /* Local or global (4 bits) */
  char    reserved;  /* Unused */
  short   section;   /* Section header index */
  long    value;     /* Section offset or absolute address */
  long    size;      /* Object size in bytes */
} Elf64_Symbol;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>name</code> 是字符串表 <code>.strtab</code> 中对应字符串的字节偏移量；
<code>type</code> 表明该符号对应的是函数还是变量；
<code>binding</code> 表明该符号是本地(local)的还是全局(global)的；
<code>value</code> 是符号的地址，对于可重定位文件而言，这是段偏移量，对于可执行文件而言，这是绝对运行时地址；
<code>size</code> 是目标变量的大小。</p>
<p>以文章最开始的程序为例，执行 <code>gcc main.c -o main.o</code> 后，<code>main.o</code> 符号表中会出现以下三个条目：</p>
<table>
<thead>
<tr>
<th style="text-align:center">Idx</th>
<th style="text-align:center">type</th>
<th style="text-align:center">binding</th>
<th style="text-align:center">value</th>
<th style="text-align:center">size</th>
<th style="text-align:center">Ndx</th>
<th style="text-align:center">Section</th>
<th style="text-align:center">符号名</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">8</td>
<td style="text-align:center">FUNC</td>
<td style="text-align:center">GLOBAL</td>
<td style="text-align:center">0</td>
<td style="text-align:center">24</td>
<td style="text-align:center">1</td>
<td style="text-align:center">.text</td>
<td style="text-align:center">main</td>
</tr>
<tr>
<td style="text-align:center">9</td>
<td style="text-align:center">DATA</td>
<td style="text-align:center">GLOBAL</td>
<td style="text-align:center">0</td>
<td style="text-align:center">8</td>
<td style="text-align:center">3</td>
<td style="text-align:center">.data</td>
<td style="text-align:center">array</td>
</tr>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">NOTYPE</td>
<td style="text-align:center">GLOBAL</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">Undefined</td>
<td style="text-align:center">sum</td>
</tr>
</tbody>
</table>
<p>易得，<code>main</code> 为 <code>.text</code> 节中偏移 0 的 24 字节 GLOBAL 函数。同理，<code>array</code> 为 <code>.data</code> 节中偏移 0 的 8 字节 GLOBAL 变量。<code>sum</code> 由于只有声明没有定义，故被视为一个外部符号，交给链接器处理。</p>
<blockquote>
<p>READELF 用一个整数索引来标识每个节。Ndx=1 表示 <code>.text</code> 节，而 Ndx=3 表示 <code>.data</code> 节。</p>
</blockquote>
<blockquote>
<p>前 8 个条目为链接器内部使用的符号。</p>
</blockquote>
<h2 id="链接阶段">链接阶段</h2>
<p>链接器(ld)将各个 <code>.o</code> 目标文件按一定规则进行整合（符号解析、重定位），为各个符号生成最终虚拟地址，结果得到了一个拥有完整的虚拟地址空间的可执行文件 <code>.exe</code>，可以被加载到内存中运行。</p>
<blockquote>
<p>它使得<strong>分离编译</strong>（separate compilation）成为可能，我们不用将一个大型的应用程序组织成一个巨大的源文件，而是可以把它分解成为更小、更好管理的模块，可以独立的修改和编译这些模块。当我们改变这些模块中的一个时，只需要简单的重新编译它，并重新链接应用，而不必重新编译其他文件。</p>
</blockquote>
<h3 id="符号解析">符号解析</h3>
<p>每个<strong>符号</strong>对应一个函数/变量，符号解析的目的是将每个符号引用正好和一个符号定义关联起来。对那些和引用定义在相同模块中的符号的引用是非常简单明了的，毕竟编译器只允许每个模块中每个局部符号有一个定义。而对于外部符号，链接器会在它的所有输入模块中寻找，如果找到，就把这个符号的地址填到符号表的相应条目中，反之则报链接错误。</p>
<p>那么如果产生冲突呢？比如在多个模块中定义了同名全局符号，编译系统会怎么做呢？</p>
<h4 id="链接器如何解析多重定义的全局符号">链接器如何解析多重定义的全局符号</h4>
<p>对于全局符号，编译系统以<strong>强(strong)/弱(weak)<strong>进行区分，函数和已初始化的全局变量为</strong>强符号</strong>，其余为<strong>弱符号</strong>。汇编器会把这个信息隐含地编码在可重定位目标文件的符号表里。那么知道这个信息后，链接器就可以根据一定规则处理多重定义的符号：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>规则 1</strong>：不允许有多个同名的强符号；</p>
</li>
<li class="lvl-2">
<p><strong>规则 2</strong>：如果有一个强符号和多个弱符号同名，优先选择强符号进行关联；</p>
</li>
<li class="lvl-2">
<p><strong>规则 3</strong>：如果有多个弱符号同名，则任意选择一个进行关联；</p>
</li>
</ul>
<p>上面的情况默认这些同名符号类型是相同的，并且已经提出了解决方案。那么如果出现多个类型不同的符号定义，则会是一场灾难！考虑下面这个例子，其中 <code>x</code> 不幸地在一个模块中定义为 <code>int</code>，而在另一个模块中定义为 <code>double</code>：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>foo.c</span></div><code class="language-C">#include &lt;stdio.h&gt;
void f(void);

int y = 111;
int x = 222;

int main() {
  f();
  printf("x = 0x%x, y = 0x%x\n", x, y);
  printf("&amp;x = %p, &amp;y = %p\n", &amp;x, &amp;y);
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>bar.c</span></div><code class="language-C">double x;

void f() {
  x = -0.0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 64 位系统下，<code>double</code> 类型变量为 8B，而 <code>int</code> 为 4B，且在上面的例子中，<code>x</code> 的地址为 <code>0x562c051f3010</code>，<code>y</code> 的地址为 <code>0x562c051f3014</code>，那么在调用 <code>f()</code> 时，语句 <code>x=-0.0</code> 将用负零的双精度浮点表示覆盖内存中 <code>x</code> 和 <code>y</code> 的位置，从而得到以下结果：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc <span class="token parameter variable">-Wall</span> <span class="token parameter variable">-Og</span> foo.c bar.c <span class="token parameter variable">-o</span> foobar
/usr/bin/ld: Warning: alignment <span class="token number">4</span> of symbol <span class="token string">'x'</span> <span class="token keyword">in</span> /tmp/cclUFK5g.o is smaller than <span class="token number">8</span> <span class="token keyword">in</span> /tmp/ccbTLcb9.o
$ ./foobar
x <span class="token operator">=</span> 0x0 y <span class="token operator">=</span> 0x80000000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>这 bug 还蛮难 de 的，毕竟编译器只会抛出一个 Who-cares 的警告。对于我们 coder 来讲，最好的做法是使用编译器的 <code>-Werror</code> 选项将所有警告变为报错。</p>
<h3 id="重定位">重定位</h3>
<p>一旦链接器完成了符号解析这一步，就把代码中的每个符号引用和正好一个符号定义（即它的一个输入目标模块中的一个符号表条目）关联起来。与此同时，链接器还知道了它的输入目标模块中的代码节和数据节的确切大小，就可以开始重定位步骤了。重定位由两步组成：</p>
<ol>
<li class="lvl-3">
<p><strong>重定位节和符号定义</strong>。链接器将所有相同类型的节合并为同一类型的新的聚合节（例如来自所有输入模块的 <code>.data</code> 节被合并成为可执行目标文件的 <code>.data</code> 节）。然后，链接器将运行时内存地址赋给输入模块定义的每个节与每个符号。此时，程序中的每条指令和全局变量都有唯一的运行时内存地址了；</p>
</li>
<li class="lvl-3">
<p><strong>重定位节中的符号引用</strong>。链接器根据输入模块中 <code>.rel.text</code>/<code>.rel.data</code> 的<strong>重定位条目</strong>，修改 <code>.text</code>/<code>.data</code> 中对每个符号的引用，使得它们指向正确的运行时地址；</p>
</li>
</ol>
<h4 id="重定位条目">重定位条目</h4>
<p>前面讲 <a href="#sections">Sections</a> 的时候已经提到了两个与重定位信息相关的节。事实上，当汇编器生成一个目标模块时，它并不知道数据和代码最终将放在内存中的什么位置，也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个重定位条目，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。重定位条目的数据结构定义如下：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">typedef struct {
  long offset;    /* Offset of the reference to relocate */
  long type:32,   /* Relocation type */
       symbol:32; /* Symbol table index */
  long addend;    /* Constant part of relocation expression */
} Elf64_Rela;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>offset</code> 是需要进行重定位的符号引用在节中的偏移；
<code>type</code> 告知链接器进行重定位的方式；
<code>symbol</code> 表示引用在符号表中的条目索引；
<code>addend</code> 是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。</p>
<p>我们可以通过 <code>objdump -dx main.o</code> 来查看最开始示例中 <code>main.o</code> 的反汇编代码，如下所示：</p>
<pre class="line-numbers language-S" data-language="S"><code class="language-S">Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
   c:   be 02 00 00 00          mov    $0x2,%esi
  11:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax       ## %rip = &amp;array
                        14: R_X86_64_PC32       array-0x4   ## Relocation entry
  18:   48 89 c7                mov    %rax,%rdi
  1b:   e8 00 00 00 00          call   20 &lt;main+0x20&gt;       ## sum()
                        1c: R_X86_64_PLT32      sum-0x4     ## Relocation entry
  20:   89 45 fc                mov    %eax,-0x4(%rbp)
  23:   b8 00 00 00 00          mov    $0x0,%eax
  28:   c9                      leave
  29:   c3                      ret<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>main()</code> 中引用了两个全局符号：<code>array</code> 和 <code>sum</code>。汇编器为每个引用产生一个重定位条目，分别为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">offset</th>
<th style="text-align:center">type</th>
<th style="text-align:center">symbol</th>
<th style="text-align:center">addend</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0x14</td>
<td style="text-align:center">R_X86_64_PC32</td>
<td style="text-align:center">array</td>
<td style="text-align:center">-0x4</td>
</tr>
<tr>
<td style="text-align:center">0x1c</td>
<td style="text-align:center">R_X86_64_PLT32</td>
<td style="text-align:center">sum</td>
<td style="text-align:center">-0x4</td>
</tr>
</tbody>
</table>
<p>这就告诉链接器，需要对节偏移 <code>0x14</code> 处的引用 <code>array</code> 和节偏移 <code>0x1c</code> 处的引用 <code>sum</code> 进行重定位，这样在运行时就能正确执行语句。</p>
<p>其中 <strong>R_X86_64_PC32</strong> 表示 PC 以增量 <code>符号表中的地址 + addend - 符号引用的地址</code> 进行相对寻址；
<strong>R_X86_64_PLT32</strong> 表示 PC 以增量 <code>过程链接表(PTL)中的地址 + addend - 符号引用的地址</code> 进行相对寻址。</p>
<p>符号表内容如下：</p>
<pre class="line-numbers language-S" data-language="S"><code class="language-S">SYMBOL TABLE:
...
0000000000004010 g     O .data	0000000000000008              array
...
0000000000001153 g     F .text	0000000000000049              sum
...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>符号引用地址 <code>ADDR(ref)</code> 其实就是 <code>(符号引用所处的)节起始地址 + 偏移量offset</code>。</p>
<p>在上面的例子中，最终链接器确定的该模块 <code>.text</code> 起始地址为 <code>ADDR(.text) = 0x1129</code>，<code>array</code> 在符号表中的地址为 <code>0x4010</code>。</p>
<p>那么有 <code>ADDR(array_ref) = ADDR(.text) + array.offset = 0x1129 + 0x14 = 0x113d</code>。</p>
<p>最终链接器将会以增量 <code>0x4010 + (-0x4) - 0x113d = 0x2ecf</code> 进行相对寻址。其中取 array 的指令为</p>
<pre class="line-numbers language-S" data-language="S"><code class="language-S">113a:  48 8d 05 cf 2e 00 00 	lea    0x2ecf(%rip),%rax        ## 4010 &lt;array&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>PC 正好是以 CS:IP 进行确认的，其实就是这里的 <code>rip</code>，增量为 <code>0x2ecf</code>，验证成功。</p>
</blockquote>
<blockquote>
<p>而 <code>sum</code> 在过程链接表中的地址为 <code>0x1020</code>。这里重定位表项虽然为 <code>R_X86_64_PLT32</code>，但事实上会以 <code>R_X86_64_PC32</code> 方式进行重定位。</p>
<blockquote>
<p>“On x86-64, for 32-bit PC-relative branches, we can generate PLT32 relocation, instead of PC32 relocation, which can also be used as a marker for 32-bit PC-relative branches. Linker can always reduce PLT32 relocation to PC32 if function is defined locally. Local functions should use PC32 relocation.” (<a href="https://sourceware.org/git/?p=binutils-gdb.git;a=commitdiff;h=bd7ab16b4537788ad53521c45469a1bdae84ad4a;hp=80c96350467f23a54546580b3e2b67a65ec65b66">Related Commit</a>)</p>
</blockquote>
<p>那么有 <code>ADDR(sum_ref) = ADDR(.text) + sum.offset = 0x1129 + 0x1c = 0x1145</code></p>
<p>查表得 <code>sum</code> 在符号表中的地址为 <code>0x1153</code>（这其实就是最终函数地址）。最终链接器将会以增量 <code>0x1153 + (-0x4) - 0x1145 = 0xa</code> 进行相对寻址。其中调用 sum 的指令为</p>
<pre class="line-numbers language-S" data-language="S"><code class="language-S">1144:  e8 0a 00 00 00       	call   1153 &lt;sum&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>取完 call 指令时，PC 值为 <code>0x1149</code>，然后 <code>PC &lt;- PC + 0xa = 0x1149 + 0xa = 0x1153</code>，验证成功。</p>
</blockquote>
<h3 id="静态链接">静态链接</h3>
<p>静态链接是指将所有相关的目标模块打包成为一个单独的文件，即<strong>静态库</strong>，它可以用做链接器的输入。这样一些公司在发布函数库时，只需要提供静态库即可，而不需要提供源文件让用户自行编译，同时还能起到隐藏源文件的效果。</p>
<blockquote>
<p>以 ISO C99 为例，它定义了一组广泛的标准 I/O、字符串操作和整数数学函数，例如 <code>atoi()</code>、<code>printf()</code> 和 <code>scanf()</code>，它们在 <code>libc.a</code> 库中，对每个 C 程序来说都是可用的。ISO C99 还在 <code>libm.a</code> 库中定义了一组广泛的浮点数学函数，例如 <code>sin()</code>、<code>cos()</code> 和 <code>sqrt</code>。</p>
<p>如果不采用库，那么如果还想为用户提供标准函数的话，要么在编译阶段将标准函数识别为关键字，并生成对应代码，要么提供一个包含所有函数的 <code>.o</code> 文件给用户，让用户自行链接。</p>
<p>然而，前者的缺陷在于，这给编译器带来了显著的复杂性，一旦修改一个标准函数，就需要一个新的编译器版本。</p>
<p>后者的缺陷在于，尽管用户可能不需要用到某些函数，这些函数的实现仍然被链接到了可执行文件中，并在运行时映射到内存，这是对内存的极度浪费，以及一旦修改一个标准函数，都需要库开发人员重新编译生成新的 <code>.o</code> 文件，这是个非常耗时的操作。</p>
<p>那有没有可能为每个标准函数单独生成 <code>.o</code> 呢？可以，但这加大了程序员编译的难度——这种方法要求应用程序员显式地链接合适的目标模块到它们的可执行文件中，这是一个容易出错而且耗时的过程。</p>
</blockquote>
<p>在静态库的手段下，相关的函数可以被编译为独立的目标模块，然后封装成一个单独的静态库文件。在链接时，链接器将只复制被程序引用的目标模块，这就减少了可执行文件在磁盘和内存中的大小。我们只需要在源文件 <code>#include</code> 相关头文件并调用函数，编译器才会识别出这是已声明的符号，最后链接阶段链接器会帮我们寻找到相关符号定义并关联。</p>
<p>我们可以通过 <code>ar</code> 指令进行静态库的生成，比如</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc <span class="token parameter variable">-c</span> addvec.c multvec.c             <span class="token comment">## 这一步生成 addvec.o 和 multvec.o</span>
$ ar rcs libvector.a addvec.o multvec.o <span class="token comment">## 将 addvec.o multvec.o 打包成静态库 libvector.a</span>
<span class="token comment">## r for 写入/更新目标模块</span>
<span class="token comment">## c for 建立库文件</span>
<span class="token comment">## s for 写入/更新索引</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果我们在 <code>main.c</code> 中调用 <code>addvec.c</code> 内定义的函数，就要编译和链接输入文件 <code>main.o</code> 和 <code>libvector.a</code>。</p>
<pre class="line-numbers language-c" data-language="c"><div class="caption"><span>main.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"addvec.h"</span></span>

<span class="token keyword">int</span> x<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> y<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> z<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">addvec</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// function defined in addvec.c</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"z = [%d %d]\n"</span><span class="token punctuation">,</span> z<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> z<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc <span class="token parameter variable">-c</span> main.c
$ gcc main.o <span class="token parameter variable">-static</span> ./libvector.a <span class="token parameter variable">-o</span> main
<span class="token comment">## or</span>
$ gcc main.o <span class="token parameter variable">-static</span> -L. <span class="token parameter variable">-lvector</span> <span class="token parameter variable">-o</span> main
<span class="token comment">## -L[dir] for 在目录 dir 下寻找静态库</span>
<span class="token comment">## -l[name] for 寻找 lib{name}.a 进行链接</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>整体流程如下图：</p>
<img src="2.png" style="zoom:80%">
<p>当链接器运行时，它判定 <code>main.o</code> 引用了 <code>addvec.o</code> 中定义的符号，所以复制 <code>addvec.o</code> 到可执行文件。因为程序不引用任何由 <code>multvec.o</code> 定义的符号，所以链接器就不会复制这个模块到可执行文件。链接器还会复制 <code>libc.a</code> 中的 <code>printf.o</code> 模块，以及其他许多 C 运行时系统中的其他模块。</p>
<h3 id="动态链接">动态链接</h3>
<p>静态库和所有的软件一样，需要定期维护和更新。如果程序员想要使用一个库的最新版本，他们必须以某种方式了解到该库的更新情况，然后显式地将他们的程序与某个特定版本的库重新链接。另一个问题是，诸如 <code>printf()</code> 这类几乎所有程序都会使用的函数，在运行时，这些函数的代码会被拷贝到每个运行进程的 <code>.text</code> 段中，这很浪费内存。</p>
<blockquote>
<p>像这种只读代码段，最好的做法是映射到内存中的某个特定区域，所有进程都能以某种方式访问到该区域，这就避免了不必要的拷贝。</p>
</blockquote>
<p>**共享库(shared library)**就是被设计出来解决静态库缺陷的。在 Linux 系统中通常用 <code>.so</code> 后缀来表示，Windows 中则是 <code>.dll</code>。</p>
<p>共享库是一个目标模块，在任何给定的文件系统中，一个库对应一个 <code>.so</code> 文件，所有引用该库的可执行目标文件共享这个 <code>.so</code> 文件中的代码和数据，从内存视角看，一个共享库会在运行/加载时拷贝到某一特定内存地址，从而可以被不同进程共同访问。把共享库拷贝到内存，并在程序运行时进行链接的过程称为<strong>动态链接(dynamic linking)</strong>，由**动态链接器(dynamic linker)**执行。</p>
<img src="3.png" style="zoom:80%">
<p>以<a href="#%E9%9D%99%E6%80%81%E9%93%BE%E6%8E%A5">静态链接</a>中的两个文件为例，生成并链接共享库的命令如下：</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ gcc addvec.c multvec.c <span class="token parameter variable">-shared</span> <span class="token parameter variable">-fpic</span> <span class="token parameter variable">-o</span> libvector.so <span class="token comment">## 生成共享库，fpic for 生成位置无关代码 PIC</span>
$ gcc main2.c ./libvector.so <span class="token parameter variable">-o</span> prog2l                 <span class="token comment">## 与共享库一起链接生成可执行文件 prog</span>
<span class="token comment">## or</span>
$ gcc main2.c -L. <span class="token parameter variable">-lvector</span> <span class="token parameter variable">-o</span> prog2l                   <span class="token comment">## 更常用的做法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时仅仅拷贝了 <code>libvector.so</code> 的重定位表和符号表信息，使得运行时可以解析外部符号并正确寻址。当加载器(exec)加载和运行可执行文件 <code>prog2l</code> 时，它注意到 <code>prog2l</code> 包含一个 <code>.interp</code> 节，这一节包含<strong>动态链接器</strong>的路径名，于是它首先加载和运行动态链接器。动态链接器会将所有共享库（这里是 <code>libvector.so</code>）的代码和数据节重定位到某个内存段，并且重定位可执行文件（这里是 <code>prog2l</code>）中所有对由共享库定义的符号的引用。此时共享库在内存中的位置就确定了，这才正式开始进入 <code>prog2l</code>。</p>
<p>上面提到了静态链接的缺陷：浪费内存、更新麻烦。但也不是一无是处，静态链接在链接时就获得了所有所需信息，故运行时速度更快。</p>
<p>而动态链接的优势在于解决了静态链接的弊端，因为把链接推迟到了程序运行时，所以每次执行程序都需要进行链接，所以性能会有一定损失。但和节省的内存相比，这点损失其实微不足道。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>Effective C++ の Note</title>
    <url>/note/effectivec-note/</url>
    <content><![CDATA[<p>久仰本书大名，花了若干时间入门 C++ 后，终于可以拜读一下这部经典作品。</p>
<blockquote>
<p>当 C++ 律师！</p>
</blockquote>
<span id="more"></span>
<h2 id="1-视-C-为一个语言联邦">1. 视 C++ 为一个语言联邦</h2>
<p>C++ 高效编程守则视情况而变化，取决于使用 C++ 的哪一部分。</p>
<blockquote>
<p><code>C++</code> = <code>C</code> + <code>Object-Oriented C++</code> + <code>Template C++</code> + <code>STL</code>。</p>
</blockquote>
<h2 id="2-尽量以-const-enum-inline-替换-define">2. 尽量以 const, enum, inline 替换 #define</h2>
<p>或可以说"尽量用编译器代替预处理器"。</p>
<ol>
<li class="lvl-3">
<p>对于常量，尽量以 <code>const</code>, <code>enum</code> 替换。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.1415926</span></span></span>
<span class="token comment">// 改为</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果在代码出现 <code>PI</code> 的地方产生了编译错误，编译器只会看到被预处理器替换掉的文本 <code>3.1415926</code>，而察觉不到 <code>PI</code> 的存在，只会在报错信息中给出一串数字。此时很难定位到出错位置，尤其是将 <code>#define</code> 写在其它头文件中的时候——这太糟糕了！</p>
<p>最大的原因还是在于，编译器看不到 <code>PI</code>，因为已经被替换掉了，故无法在<strong>符号表</strong>中找到它。同时预处理器盲目进行文本替换还会可能导致目标代码中出现多份 <code>3.1415926</code> 这样的数字。</p>
<p>而替换为 <code>const</code> 则不会出现这一问题，编译器会将 <code>const</code> 变量加入符号表，避免了上述错误。<code>const</code> 还能进行常量指针的定义，并且 <code>const</code> 还能为一个类创建专属常量，自由控制访问级别以及静态与否。这些都是 <code>#define</code> 做不到的，毕竟 <code>#define</code> 不存在作用域这一说法，也不会进行类型检查。</p>
<blockquote>
<p>具体区别请看<a href="../../c/c-const/#%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>此处</strong></a>。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>对于形似函数的宏，尽量以 <code>inline</code> 替换。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FUNC_MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">// 改为</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func_max</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用宏定义函数属于是最<strong>丑陋</strong>的行为了，因为你需要时刻关心是否正确添加括号。并且有些调用还不一定得到正确反馈，比如下面 <code>a++</code> 的调用次数取决于比较的对象：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">FUNC_MAX</span><span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a++ 调用 2 次</span>
<span class="token function">FUNC_MAX</span><span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a++ 调用 1 次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>而<a href="../../c/c-inline"><strong>内联函数</strong></a>则不会出现上述问题。<code>func_max()</code> 成为了真正的函数，遵循作用域和访问规则，能利用泛型的同时，增加了类型检查，同时和 <code>const</code> 一样能在类内大显身手，故更为推荐。</p>
</li>
</ol>
<p>但这并不是说预处理器就一无是处了，我们依然需要依靠 <code>#include</code> 来引入头文件，以及依赖 <code>#ifdef</code>，<code>#ifndef</code> 来控制编译。就像最开始说的那样，<strong>尽量用编译器代替预处理器</strong>。</p>
<h2 id="3-尽可能使用-const">3. 尽可能使用 const</h2>
<p>关于 <code>const</code> 具体可参考<a href="../../c/c-const"><strong>本文</strong></a>。</p>
<p><code>const</code> 更像是一种约束，只要某个变量确定性地能保持不变，我们应该尽可能加上这一约束，以取得编译器的优化。反之，则容易被玩坏，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们或许可以宽容地接受 <code>a * b = c</code> 本来是想执行比较，但因为某些原因少打了一个 <code>=</code> 这一事实。如果 <code>operator*</code> 返回值没有声明为 <code>const</code>，编译器并不会因此报错，毕竟非 const 变量允许被赋值。不考虑这一点，对函数返回值进行赋值也是个糟糕的行为——右值是不能被赋值的。即便假设编译器忽视了所有问题，程序能够成功运行下去，最终结果也可能并不如人意——该 if 子句很难保证能进去。</p>
<p>将返回值声明为 <code>const</code> 则可以预防上面一系列令人头疼的问题，我们需要做的不过是多打几个字符罢了。</p>
<p>另外，虽然对于成员函数而言，const 与 non-const 是两种重载形式，但如果仅有约束不同，也是一件不好的事。我们拿 <a href="../../c/c-mutable/#%E7%B1%BB%E4%B8%AD%E7%9A%84-mutable">C++のMutable</a> 里的 <code>TextBlock</code> 的例子来说：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">TextBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们实现了 const 与 non-const 两个重载版本，供不同常量性的对象调用。但细心的人会发现，除了是否 const 以外，其他部分几乎完全一致！这就存在一个问题：一旦往某个函数中加各种比如并发支持、完整性检查等功能，另一个函数也必须要加上同样的代码——为了保证我们希望的一致性——从而导致文件变得臃肿，反而降低可读性。尽管 ctrl cv 降低了编码难度，但总归不太方便。</p>
<p>一个<strong>明智</strong>的做法是利用 non-const 版本调用 const 版本，从而避免<strong>代码重复</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">TextBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 non-const 版本中将 <code>*this</code> 转型为 const，便能调用 const 函数，最后通过 <code>const_cast</code> 移除常量性。代码瞬间精简不少！尽管，使用 cast 是一个糟糕的想法，但在这里，很安全。</p>
<p>而另一种做法，即通过 const 函数调用 non-const 函数，则是一种错误行为，为了不冒 const 风险，不建议采取这种做法。</p>
<h2 id="4-确定对象被使用前已先被初始化">4. 确定对象被使用前已先被初始化</h2>
<p>C++ 并不能保证变量在所有语境下声明时都能得到初始化，但能保证读取未初始化的值会导致 <strong>UB</strong>。</p>
<p>与其记忆哪些语境下会初始化，哪些语境下不会，不如选择<strong>永远在使用对象前将其初始化</strong>。</p>
<p>对于内置类型，我们应当手动初始化；而对于非内置类型，则需要用到构造函数，并保证初始化每一个成员变量，此时只有两种方式：要么赋值，要么初始化列表。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 赋值</span>
<span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    myName <span class="token operator">=</span> name<span class="token punctuation">;</span>
    myAddress <span class="token operator">=</span> address<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string myName<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string myAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化列表</span>
<span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Entry</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> name<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> address<span class="token punctuation">)</span>
  <span class="token operator">:</span><span class="token function">myName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token function">myAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string myName<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string myAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>第二个版本比第一个版本效率更高</strong>。事实上，类成员变量的初始化行为发生在构造函数之前（见<a href="../../c/c-oop/#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><strong>构造顺序</strong></a>），所以对于大多数类型而言，赋值行为会先调用默认构造函数，然后再使用赋值运算符，这样就导致默认构造函数的操作被浪费，增加无意义的开销并不是一件好事。并且如果某个变量的默认构造函数被<strong>弃置</strong>，编译器还会报错。</p>
<p>而使用初始化列表的方式，则只会影响这些成员变量调用构造函数的版本，相当于是拿着指定的实参去调用构造函数，不用担心顺序问题（但最好还是按照成员变量列出顺序来）。此时只需调用一次构造，比起赋值的方法高效许多。对于内置类型，两种方式开销一样，但为了一致性还是通过初始化列表来初始化。</p>
<p>最后需要关心的事就是<strong>定义于不同编译单元内的 non-local static 变量</strong>了，即定义在作用域外的其它文件的静态变量。因为 C++ 对于这类变量的初始化顺序并未明确定义，甚至根本无解。所以我们在使用一个 <code>extern</code> 标识的变量时，它极有可能未被初始化！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Tool.h</span>
<span class="token keyword">class</span> <span class="token class-name">Tool</span> <span class="token punctuation">{</span>
 <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Human.h</span>
<span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
 <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> Tool theTool<span class="token punctuation">;</span>

Human <span class="token function">Jack</span><span class="token punctuation">(</span>theTool<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果 theTool 未被初始化，则该语句的实现效果将是非确定性的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个<strong>好的设计</strong>是将 static 变量移到成员函数中，该函数返回一个该变量的引用，用户通过调用该函数来获取变量的访问权，而非直接使用——这就是<a href="https://zh.wikipedia.org/zh-hans/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><strong>单例模式</strong></a>的常用实现手法。</p>
<p>为什么说它好？因为函数内部的 static 变量会在调用函数首次遇到定义式时进行初始化，且仅初始化这一次。所以只要调用该函数，便能保证变量必然被初始化。furthermore，如果不调用函数，则变量永远不会被初始化，构造和析构的开销也降低了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Tool.h</span>
<span class="token keyword">class</span> <span class="token class-name">Tool</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Human.h</span>
<span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
 <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Tool<span class="token operator">&amp;</span> <span class="token function">getTool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> Tool globalTool<span class="token punctuation">;</span>
  <span class="token keyword">return</span> globalTool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Human <span class="token function">Jack</span><span class="token punctuation">(</span><span class="token function">getTool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证得到初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="5-了解-C-默默编写并调用哪些函数">5. 了解 C++ 默默编写并调用哪些函数</h2>
<p><a href="../../c/c-oop/#%E8%A3%85"><strong>见此处</strong></a></p>
<blockquote>
<p>C++11 引入移动语义之后，对于一个<strong>空类</strong>，编译器将为其默认生成以下 6 种特殊成员函数，且访问级别默认为 <code>public</code>（见下文）：<strong>默认构造函数</strong>、<strong>析构函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>、<strong>移动构造函数</strong>、<strong>移动赋值运算符</strong>。</p>
</blockquote>
<h2 id="6-若不想使用编译器自动生成的函数，就该明确拒绝">6. 若不想使用编译器自动生成的函数，就该明确拒绝</h2>
<p>通常来说，如果不希望使用某函数，则不声明即可。但上面那点提到，尽管你可能没声明，但一旦尝试调用，编译器就会自动帮你声明。</p>
<p>所以希望完全阻止这种调用行为，可以加上 <a href="../../c/c-defaultanddelete/#delete"><code>delete</code> 说明符</a>。</p>
<blockquote>
<p>与 <code>default</code> 相对，后面加上 <code>= delete</code> 的函数会被视为<strong>弃置</strong>(deleted)，在编译器眼中这个函数<strong>禁止被定义</strong>，对该函数的调用会导致编译错误，继而从根本上解决了这个问题。</p>
</blockquote>
<h2 id="7-为多态基类声明-virtual-析构函数">7. 为多态基类声明 virtual 析构函数</h2>
<p>见<a href="../../c/c-oop/#%E6%B3%A8%E6%84%8F"><strong>此处</strong></a>第 5 条。</p>
<blockquote>
<p>当可能用到基类指针/引用绑定派生类时，基类的析构函数必须为虚函数。这是因为当出现 <code>Base* ptr = new Derived</code> 这样的代码时，虽然 <code>ptr</code> 是 <code>Base</code> 类的指针，但我们实际上还分配了一个 <code>Derived</code> 类的空间，如果析构函数非虚，则只会执行 <code>Base</code> 类的析构函数，而属于 <code>Derived</code> 的那一部分并没有被析构。为了程序安全运行，我们应该要调用派生类的析构函数，也就是通过将基类析构函数设为虚函数来实现；</p>
</blockquote>
<h2 id="8-别让异常逃离析构函数">8. 别让异常逃离析构函数</h2>
<p>C++ 虽然并不禁止析构函数吐出异常，但<strong>不建议</strong>。考虑这种情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 存在抛出异常的可能 */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span> widgets<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>widgets</code> 销毁时，会调用每一个 <code>Widget</code> 对象的析构函数，一旦某个对象析构时抛出异常，并且没有得到正确处理，整个程序可能因此发生一些 UB。</p>
<p>析构函数必须对此异常进行处理，以防止它逃逸到外层，造成不必要的危害。此时有两种做法：</p>
<ol>
<li class="lvl-3">
<p>直接终止</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment">/* 调用某些可能抛出异常的函数 */</span> <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 记录调用失败 */</span>
      std<span class="token double-colon punctuation">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>吞下异常</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment">/* 调用某些可能抛出异常的函数 */</span> <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 记录调用失败 */</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>两种做法均能阻止异常的逃逸，这是好的。另外，如果客户需要对某个函数运行期间抛出的异常做出响应，那么类应该提供一个普通函数（而不是在析构函数中）执行该响应。</p>
<h2 id="9-绝不在构造和析构过程中调用-virtual-函数">9. 绝不在构造和析构过程中调用 virtual 函数</h2>
<p>假设有一个 transaction 类体系，用于模拟股市的买卖等操作，每次创建一个交易对象时，都会根据交易类型进行一次适当的记录。比如下面这个看起来挺好的做法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 创建一份因类型不同而不同的交易日志</span>
  <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Transaction</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SellTransaction</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Transaction</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

BuyTransation buyTxn<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 <code>buyTxn</code> 时，根据<a href="../../c/c-oop/#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><strong>构造顺序</strong></a>，其基类的构造一定会更早被调用，然后才是派生类的专属部分。而其基类的构造函数中出现了一个纯虚函数 <code>logTxn()</code>，这是万恶之源！</p>
<p>我们本意是希望通过该虚函数完成派生类版本的构造，但事实上，构造 <code>BuyTransaction</code> 对象时，优先构造的是对象中的基类部分，也就是 <code>Transaction</code> 部分，此时调用的 <code>logTxn()</code> 尽管为虚，但其无法表现出多态性质，相当于将其视为了 non-virtual，执行的还是 <code>Transaction</code> 版本的函数，并不会下降到派生类 <code>BuyTransaction</code>。毕竟，此时派生类专属部分尚未得到初始化，如果派生类版本的 <code>logTxn()</code> 将用到其成员变量，那将成为"<strong>通往彻夜调试的直达车票</strong>"——C++ 不允许你使用对象内部尚未初始化的部分。</p>
<p>还有一个更根本的原因是，在基类部分构造期间，对象类型会被视为基类而非派生类，请看：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  D d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 1Bcons</span>
<span class="token comment">// 1Dcons</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以就算能实现多态，也不会使用派生类的版本——那不就相当于没有多态么(笑</p>
<p>更何况，基类 <code>logTxn()</code> 还是 pure virtual，压根无法调用，故本条款也是为了防止这种情况发生。</p>
<p>上面说的所有原因也同样适用于析构函数。</p>
<p>如果非要实现"<strong>根据不同类型使用不同构造函数</strong>"，一个好的做法是，将基类的 <code>logTxn()</code> 设为 non-virtual，然后要求为该函数传入必要的信息，如:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token keyword">const</span> TransactionInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> TransactionInfo <span class="token function">createInfo</span><span class="token punctuation">(</span> <span class="token comment">/* params */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Transaction</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">BuyTransaction</span><span class="token punctuation">(</span> <span class="token comment">/* params */</span><span class="token punctuation">)</span>
    <span class="token operator">:</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">createInfo</span><span class="token punctuation">(</span> <span class="token comment">/* params */</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就由<strong>令派生类将必要的信息向上传递</strong>代替了<strong>使用虚函数向下调用</strong>。</p>
<h2 id="10-令-operator-返回一个-reference-to-this">10. 令 operator= 返回一个 reference to *this</h2>
<p>关于赋值，可以写为如下形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
a <span class="token operator">=</span> b <span class="token operator">=</span> c <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token comment">// 由于赋值遵循右结合律，故被解析为</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了实现<strong>连锁赋值</strong>，<code>operator=</code> 必须返回一个自身的引用。这同样适用于 <code>+=</code>、<code>-=</code>、<code>后++</code> 等运算符。</p>
<h2 id="11-在-operator-中处理-自我赋值">11. 在 operator= 中处理"自我赋值"</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object ob<span class="token punctuation">;</span>
ob <span class="token operator">=</span> ob<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是的这很蠢，但为了演示，没办法（摊手）。当然这种写法是被允许的，只不过自我赋值增加了无意义的开销——这还算能接受，但如果类的赋值运算符写成这样，那就要当心点了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>rhs == *this</code> 会发生什么？<code>this-&gt;name</code> 与 <code>rhs.name</code> 实际上就是同一个指针，指向同一块内存。那么此时 <code>name</code> 首先被 delete，然后再通过 <code>operator*</code> 获取 <code>name</code> 指向的字符串……接下来懂的都懂了吧~</p>
<p>为了避免这种危害，<strong>传统做法</strong>是在最开始执行<strong>证同测试</strong>，实现<strong>自我赋值安全性</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 比较地址比比较对象本身更好</span>

  <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但该做法无法保证<strong>异常安全性</strong>，也就是说，如果 <code>new</code> 操作中出现异常（内存不够 or 构造函数异常），最后还是会得到一份<strong>不安全</strong>的反馈——<code>name</code> 可能因此被永久 delete，既无法删除，也无法读取。看 solution！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即便 <code>new</code> 或构造函数出现异常，<code>name</code> 也不会因此被贸然 delete——该做法保证了先分配再释放。同样的，这也解决了最开始<strong>自我赋值安全性</strong>的问题。</p>
<p>上一方案的替代做法是 <strong>copy and swap</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 交换 *this 和 rhs 的数据 */</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object <span class="token function">tmp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者直接这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 交换 *this 和 rhs 的数据 */</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>当然可以在这些方案的最开始加上证同测试，但需要在自我赋值开销与目标代码、CPU 控制流之间做出 trade-off。</p>
</blockquote>
<h2 id="12-复制对象时勿忘其每个成分">12. 复制对象时勿忘其每个成分</h2>
<p>本来编译器会为你默认生成一个完美的拷贝构造/拷贝赋值，但不一定是你想要的，所以此时你进行了一些自定义。</p>
<p>结果后面类加入了新的成员变量，你就需要时刻警醒自己：别忘了修改自定义的拷贝构造与拷贝赋值。否则就会出现违背<a href="#4.-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>条款 4</strong></a> 的结果。</p>
<p>当然这还好说，但一旦出现继承，另一个噩梦又来了……</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Customer</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> priority<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面看起来没啥问题，但实际上，<code>PriorityCustomer</code> 类对象进行拷贝时，仅仅对派生类部分的变量进行了拷贝，而忽略了基类部分的 <code>std::string name</code>。这是致命的！此时 <code>name</code> 会用默认的方式进行构造，那么得到的新 <code>PriorityCustomer</code> 对象就变成无名氏了~</p>
<blockquote>
<p>因为如果让编译器来干，它会毫不犹豫地将基类部分也一并拷贝，怎么到你这就拉垮了？尽管如此，编译器不会给你报错，哎就是玩，毕竟这也不是啥大问题嘛，万一你真的不想拷贝呢~</p>
</blockquote>
<p>所以通过拷贝的方式进行构造时，一定不要忘了调用所有基类的适当的拷贝函数，拷贝赋值也是同理的。就像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Customer</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token operator">:</span><span class="token function">Customer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Customer<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> priority<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后要注意的是，如果拷贝构造与拷贝赋值出现了重复部分，可以将这些重复的部分写入新的函数(eg.<code>init()</code>)，然后让它俩一起调用，从而消除冗余。而不是让一个拷贝调用另一个拷贝——<a href="../../c/c-oop/#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">构造跟赋值不能混为一谈</a>！</p>
<h2 id="13-以对象管理资源">13. 以对象管理资源</h2>
<p>关于本条款，可以阅读 <a href="https://zhuanlan.zhihu.com/p/34660259"><strong>RAII</strong></a> 与<a href="../../c/c-smartptr"><strong>智能指针</strong></a> 相关内容。</p>
<blockquote>
<p>构造时获取资源，析构时释放资源。</p>
</blockquote>
<h2 id="14-在资源管理类中小心-coping-行为">14. 在资源管理类中小心 coping 行为</h2>
<p>资源管理类的核心是 RAII 技术，而智能指针则将其表现在了 heap-based 资源上。但并非所有资源都是 heap-based，一个很常见的例子就是<strong>互斥锁</strong>，获取资源相当于进行 <code>lock()</code>，而释放资源则相当于 <code>unlock()</code>。我们希望利用 RAII 来管理这种资源，则可以很容易写出以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">Lock</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">*</span> pm_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">pm</span><span class="token punctuation">(</span>pm_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pm<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    pm<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">*</span> pm<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">*</span> m<span class="token punctuation">;</span>
<span class="token punctuation">{</span>
  Lock <span class="token function">lock1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 锁定互斥体</span>
  <span class="token comment">/* 访问临界区 */</span>
<span class="token punctuation">}</span> <span class="token comment">// 作用域末尾，通过析构函数释放互斥体</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但如果 <code>Lock</code> 对象被拷贝，会发生什么事？（不言而喻了）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Lock <span class="token function">lock2</span><span class="token punctuation">(</span>lock1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>大部分情况下，我们有以下做法：</p>
<p>第一，<strong>禁止拷贝</strong>，即设为 <code>=delete</code>，正如<a href="#6.-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><strong>条款 6</strong></a> 所说的那样；</p>
<p>第二，<strong>引用计数法</strong>，正如 <a href="../../c/c-smartptr/#std::shared_ptr"><strong>shared_ptr</strong></a> 做的那样，直到该资源的最后一个使用者被销毁后才释放；</p>
<p>第三，<strong>拷贝底部资源</strong>，注意这里的拷贝是指深拷贝，即不仅仅拷贝指针，同时拷贝一份指针指向的内存；</p>
<p>第四，<strong>转移底部资源所有权</strong>，即实现<a href="../../c/c-value/#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><strong>移动语义</strong></a>；</p>
<h2 id="15-在资源管理类中提供对原始资源的访问">15. 在资源管理类中提供对原始资源的访问</h2>
<p>或通过 api 来提供对原始资源的显式访问，或通过在类内自定义类型转换提供隐式访问。一般而言显示访问比较安全，而隐式访问比较方便，需要根据实际应用场景作出 trade-off。</p>
<h2 id="16-成对使用-new-和-delete-时采取相同形式">16. 成对使用 new 和 delete 时采取相同形式</h2>
<p>游戏规则很简单：如果你调用 new 时使用 <code>[]</code>，你必须在对应调用 delete 时也使用 <code>[]</code>。如果你调用 new 时没有使用 <code>[]</code>，那么也不该在对应调用 delete 时使用 <code>[]</code>。</p>
<h2 id="17-以独立语句将-newed-对象置入智能指针">17. 以独立语句将 newed 对象置入智能指针</h2>
<p>考虑这样一个函数 <code>foo()</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> pInt<span class="token punctuation">,</span> <span class="token keyword">int</span> someint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> Object<span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像这样调用是不行的，因为 <code>shared_ptr</code> 尽管有形参为裸指针的构造函数，但却是声明为 <code>explicit</code>，没法如此隐式转换，也就无法通过编译。或许我们可以如此做来通过编译：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Object<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但不同编译器做出的反应也不一样，或许存在某个编译器给出了以下指令执行顺序：</p>
<ol>
<li class="lvl-3">
<p>new Object；</p>
</li>
<li class="lvl-3">
<p>bar()；</p>
</li>
<li class="lvl-3">
<p>shared_ptr 构造函数；</p>
</li>
</ol>
<p>设想一下，如果 <code>bar()</code> 抛出一个异常，导致程序终止，会发生什么？new 出来的 <code>Object</code> 指针将无家可归，它并没有被 shared_ptr 保有，而我们依赖后者来防止资源泄漏，但很遗憾，资源泄漏发生了。解决方案很简单，就像条款说的，<strong>以独立语句将 newed 对象置入智能指针</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> <span class="token function">pObj</span><span class="token punctuation">(</span><span class="token keyword">new</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>pObj<span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// perfect! 绝不会引发泄漏</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="18-让接口容易被正确使用，不易被误用">18. 让接口容易被正确使用，不易被误用</h2>
<p>促进正确使用很简单，只需要满足 api 的一致性，以及与内置类型的行为兼容即可。</p>
<p>但误用却时有发生。任何一个 api 如果要求客户必须记得做某些事，就是有着"不正确使用"的倾向，因为客户可能会忘记。比如<a href="https://refactoringguru.cn/design-patterns/factory-method"><strong>工厂函数</strong></a>如果在内部 new 了一个指针并将其返回，则客户很容易忘记 delete，或是 delete 多次。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">*</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或许你会想到将该指针托付给一个智能指针，比如 <code>std::shared_ptr&lt;Object&gt; pObj(factory());</code>，但客户也很可能会忘记使用智能指针。事实上，一个好的设计是令该 api 返回一个智能指针，即</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这便消除了上面这些问题发生的可能性。</p>
<h2 id="19-设计-class-犹如设计-type">19. 设计 class 犹如设计 type</h2>
<p>C++ 就像其他 OOP 语言一样，当我们定义一个新 class，也就定义了一个新 type。身为 C++ 程序员，我们并不只是 class 设计者，还是 type 设计者，重载(overloading)函数和操作符、控制内存的分配和归还、定义对象的初始化和终结……全都由我们负责。因此我们应该带着和"语言设计者当初设计语言内置类型时"一样的谨慎来研讨 class 的设计。</p>
<p>为了搞清"<strong>如何设计高效的类</strong>"这一问题，我们必须想明白以下几件事：</p>
<ol>
<li class="lvl-3">
<p><strong>新 type 的对象应该如何创建和销毁？</strong>——好好设计构造、析构函数以及 <code>new</code>，<code>delete</code> 运算符；</p>
</li>
<li class="lvl-3">
<p><strong>对象的初始化与对象的赋值有什么区别？</strong>——别混淆初始化与赋值，它们对应了两个不同的函数调用；</p>
</li>
<li class="lvl-3">
<p><strong>新 type 对象如果被值传递，意味着什么？</strong>——这由拷贝构造函数决定；</p>
</li>
<li class="lvl-3">
<p><strong>什么是新 type 的"合法值"？</strong>——对类成员变量而言，只有某些数值组成的集合是有效的，而这也决定了类的约束条件，以及需要在成员函数中做的错误检查工作；</p>
</li>
<li class="lvl-3">
<p><strong>新 type 需要配合某个继承图系吗？</strong>——如果该类继承自其他类，那么其设计就受到其他类 virtual 与 non-virtual 函数等的影响。如果允许该类派生其他类，那么需要关注析构函数是否为虚；</p>
</li>
<li class="lvl-3">
<p><strong>新 tyoe 需要什么样的转换？</strong>——好好设计自定义转换函数，并且思考构造函数需不需要 <code>explicit</code>；</p>
</li>
<li class="lvl-3">
<p><strong>什么样的操作符和函数对此新 type 而言是合理的？</strong>——这决定了该类所相关的函数设计；</p>
</li>
<li class="lvl-3">
<p><strong>什么样的标准函数应当被驳回？</strong>——好好思考哪些该 <code>=delete</code>；</p>
</li>
<li class="lvl-3">
<p><strong>谁该取用新 type 的成员？</strong>——好好思考访问级别、友元以及是否让该类对象成为其他类的成员变量相关问题；</p>
</li>
<li class="lvl-4">
<p><strong>什么是新 type 的未声明接口？</strong>——它对效率、异常安全性以及资源运用提供何种保证？</p>
</li>
<li class="lvl-4">
<p><strong>新 type 有多么一般化？</strong>——实现一般化的最好做法是定义一个类模板；</p>
</li>
<li class="lvl-4">
<p><strong>真的需要新 type 吗？</strong>——如果只是为了给基类添加新功能而定义派生类，那不如直接加点成员函数或模板；</p>
</li>
</ol>
<h2 id="20-宁以引用传递代替值传递">20. 宁以引用传递代替值传递</h2>
<p>说白了就是降低因<strong>构造/析构</strong>新的局部对象带来的额外开销，毕竟传引用的开销可以忽略不计，也没有生成新对象。</p>
<blockquote>
<p>至于引用是否需要加 <code>const</code>，则需要根据具体应用场景灵活变化。</p>
</blockquote>
<p>还有一个隐性好处是，可以通过将派生类传递给基类引用来实现多态——如果是值传递，那么就容易造成<strong>对象切割</strong>。</p>
<p>最后要注意的是，C++ 里的引用常以指针的形式实现，意味着引用传递实际上传的是指针，那么对于内置类型、迭代器和函数对象而言，值传递的效率往往比引用传递的高——引用传递则还多了一步地址寻址的操作。</p>
<h2 id="21-必须返回对象时，别妄想返回其-reference">21. 必须返回对象时，别妄想返回其 reference</h2>
<p>尽管我们了解了引用传递的优势，但也不能一味追求引用传递，尤其是传递一些 reference 指向实际不存在的对象，这可不是件好事。</p>
<p>以<a href="#3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><strong>条款 3</strong></a> 中 <code>Rational</code> 类为例，它内含一个函数用于计算两个有理数的乘积。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
           <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> n<span class="token punctuation">,</span> d<span class="token punctuation">;</span> <span class="token comment">// 分子和分母</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然返回值是以值传递，但这点开销是值得且必要的。如果我们试图通过引用传递来逃避这一开销，那必然要有一个已经存在的 <code>Rational</code> 对象来给引用绑定，这是引用的刚需。事实上这并不合理，如果我们有以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rational <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此时希望在运算之前就存在一个表示 <code>3/10</code> 的 <code>Rational</code> 对象是不现实的。如果 <code>operator*</code> 要返回一个 reference 指向该数值，它必须自己创建该对象，在 stack 上或 heap 上。</p>
<p>在 stack 上创建的对象会因为函数的退出而消亡，显然是无法作为引用返回值的。任何调用者甚至只是对此函数的返回值做任何一点点运用，都将立刻坠入"无定义行为"的恶地。事情的真相是，任何函数如果返回一个 reference 指向某个局部变量，都将一败涂地（指针亦是如此）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// on-the-stack</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Rational <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 糟糕的代码！</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么在 heap 上创建呢？只会更糟！还带来了一个额外的问题——如何 delete？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// on-the-heap</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Rational <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更糟糕的代码！</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管你可能非常小心谨慎，但还是无法在以下代码中幸存：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rational w<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
w <span class="token operator">=</span> x <span class="token operator">*</span> y <span class="token operator">*</span> z<span class="token punctuation">;</span> <span class="token comment">// 等价于 operator*(operator*(x, y), z);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时同一个语句调用了两次 <code>operator*</code>，也就调用了两次 new，便需要两次 delete。但遗憾的是，我们没有合理的方法进行 delete 调用，因为我们没有合理的方法取得返回值背后隐藏的那个指针，从而导致了内存泄漏。</p>
<p>或许会想到返回 <code>static</code> 变量来避免上述情况，我只能说没有任何区别，就像下面这串代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// static</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> Rational result<span class="token punctuation">;</span>
  result <span class="token operator">=</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>a * b</code> 与 <code>c * d</code> 返回了同一个 <code>static</code> 变量的引用，表达式难道不是永远返回 <code>true</code>？</p>
<p>至于其它一些想法，梅耶懒得一一驳斥了，他的想法很简单：对于一个"必须返回新对象"的函数，就让那个函数返回一个新对象呗！就像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                                 <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们已经探讨过，在 on-the-stack，on-the-heap，static 这些思路中，都难免存在构造/析构一个新的对象带来的开销，既然逃不过，那不如选择最稳妥的做法，更何况这只不过是一个非常小的代价罢了。</p>
<h2 id="22-将成员变量声明为-private">22. 将成员变量声明为 private</h2>
<p>就<strong>语法一致性</strong>而言，如果 public 下全是成员函数，客户就无需思考某个成员后面是否需要加圆括号。</p>
<p>另外，使用函数可以对成员变量的处理有着更精确的<strong>访问控制</strong>。如果将成员变量设为 public，那么可以很轻易地直接读写，而通过函数，则可以人为控制读写权限，就像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">AccessLevels</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> <span class="token function">getReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readOnly<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">setReadWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> readWrite <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">int</span> <span class="token function">getReadWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readWrite<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">setWriteOnly</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> writeOnly <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> noAccess<span class="token punctuation">;</span>   <span class="token comment">// 无访问操作</span>
  <span class="token keyword">int</span> readOnly<span class="token punctuation">;</span>   <span class="token comment">// 只读</span>
  <span class="token keyword">int</span> readWrite<span class="token punctuation">;</span>  <span class="token comment">// 可读写</span>
  <span class="token keyword">int</span> WriteOnly<span class="token punctuation">;</span>  <span class="token comment">// 只写</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，考虑整个类的<strong>封装性</strong>，将成员变量隐藏在函数接口的背后，可以为"所有可能的实现"提供弹性，并且可以确保类的约束条件总是会获得维护，因为只有成员函数可以影响它们。</p>
<h2 id="23-宁以-non-member、non-friend-替换-member-函数">23. 宁以 non-member、non-friend 替换 member 函数</h2>
<p>考虑一个网页浏览器的例子，它拥有清理缓存、清理访问历史，以及清理所有 cookies 的功能</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">clearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">clearCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可能很多人会想要添加一个这样的功能：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">clearEverything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 clearCache, clearHistory, clearCookies</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，这一功能也可以通过一个 non-member 函数调用适当的成员函数实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">clearBrowser</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  wb<span class="token punctuation">.</span><span class="token function">clearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  wb<span class="token punctuation">.</span><span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  wb<span class="token punctuation">.</span><span class="token function">clearCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好的设计中，如果能够实现相同功能，那么会优先考虑 non-member 函数。为什么？</p>
<p>首先，non-member non-friend 函数能够提供<strong>更大的封装性</strong>。前一条款曾说过，成员变量应该是 private，否则将有无限的函数可以访问它们，它们也就毫无封装性。而一个 non-member non-friend 函数并不会增加"能够访问类内 private 成分"的函数数量。</p>
<p>其次，non-member 函数也可以是其他类的成员函数。比较自然的做法是让它俩处于同一命名空间。不仅如此，我们还应意识到，命名空间不像 classes，前者可以跨越多个源码文件，而后者不行。将所有像 <code>clearBrowser()</code> 的这些 <strong>utility 函数</strong>放在多个头文件内但隶属同一个命名空间，意味客户可以轻松扩展这一组 utility 函数，<strong>增加包裹弹性</strong>，<strong>降低编译耦合度</strong>。他们需要做的就是添加更多 non-member non-friend 函数到此命名空间内，这允许客户只对他们所用的那一小部分系统形成编译耦合——毕竟如果我们想要用 <code>&lt;vector&gt;</code> 相关 utility 函数，无需 <code>#include&lt;memory&gt;</code>。</p>
<h2 id="24-若所有参数皆需类型转换，请为此采用-non-member-函数">24. 若所有参数皆需类型转换，请为此采用 non-member 函数</h2>
<p><a href="#21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><strong>条款 21</strong></a> 中的 <code>Rational</code> 类对象的构造函数并没有声明为 <code>explicit</code>，也就意味着允许隐式的转换。梅耶在导读中已经提过"令 class 支持隐式转换是一种糟糕的行为"，但有例外。<code>Rational</code> 中便是梅耶刻意为之，那么为什么？</p>
<p>注意到，类中进行乘积的函数被设为 non-member 函数。当然也可以写成成员函数，比如这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但这样写却忽略了一种混合式乘法场景：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rational <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational result<span class="token punctuation">;</span>
result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// OK! oneHalf.operator* (Rational(2));</span>
result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span>  <span class="token comment">// ERROR! int 并没有运算符 operator* (Rational) 的实现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>result = oneHalf * 2</code> 这一语句能编译通过的原因便是 <code>Rational</code> 类支持来自 <code>int</code> 的隐式转换。如果声明为了 <code>explicit</code>，那同样编译不过。此时我们最开始提出的那个问题已经得到了回答。</p>
<p>而即便构造函数为 non-explicit，<code>result = 2 * oneHalf</code> 这句依然无法编译通过，本质原因在于我们实现的是 <code>Rational::operator* (const Rational&amp;)</code>，而运算符左侧为 <code>int</code> 型，该类型并不支持 <code>int::operator* (const Rational&amp;)</code> 这样的运算。</p>
<p>定理为，<strong>只有当参数被列于参数列表时，该参数才是隐式类型转换的合格参与者，而 this 不是</strong>。一个好的设计应当满足所有的应用场景，为了解决这一问题，我们要做的便是像条款 21 中的那样，将 <code>operator*</code> 定义为 non-member，并（可以）令其为 <code>friend</code>——以便访问 lhs, rhs 的 private 变量。</p>
<p>这样一来，<code>result = 2 * oneHalf</code> 便可以被编译器视为 <code>result = operator*(Rational(2), oneHalf)</code>。编译通过！</p>
<h2 id="25-考虑写出一个不抛出异常的-swap-函数">25. 考虑写出一个不抛出异常的 swap 函数</h2>
<p>当 <code>std::swap</code> 的缺省实现版，或对其全特化无法满足需求（无法访问 private 成员）时，考虑添加一个 <code>swap</code> 成员函数，并确保其不抛出异常。为了方便，可以在同一个命名空间中提供一个 non-member non-std <code>swap</code> 来调用前者。调用成员函数 <code>swap</code> 时，应针对 <code>std::swap</code> 使用 <code>using</code> 声明，然后不带任何作用域运算符 <code>::</code> 地来为具体的成员变量调用 <code>swap</code>。就像这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WidgetStuff <span class="token punctuation">{</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>      <span class="token comment">// 令 std::swap 在此函数内可用</span>
      <span class="token function">swap</span><span class="token punctuation">(</span>impl<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为 impl 调用最佳版本，而不是憨憨地 std::swap(impl, rhs.impl);</span>
    <span class="token punctuation">}</span>

   <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">/* 可能有许多数据 */</span>
    WidgetImpl<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> impl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lhs<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//namespace WidgetStuff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>千万不要试图通过偏特化 <code>std::swap</code> 的方式来实现目标，因为 C++ 禁止对函数模板进行偏特化。或许可以通过添加重载版本来逃避，但尽量不要忘 <code>std</code> 里添加新东西。</p>
<h2 id="26-尽可能延后变量定义式的出现时间">26. 尽可能延后变量定义式的出现时间</h2>
<p>这一条款的提出是源于这样一个场景：如果某个变量定义后，在其真正使用之前，同个作用域内抛出了异常，那么该变量的定义将白白浪费了一次构造与一次析构的开销。</p>
<p>当然，基于<a href="#4-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>条款 4</strong></a> 的讨论，我们也不容易写出先定义，然后使用到的时候再赋值这种行为，这比直接在构造时指定初值效率低太多了。所以，不应该只延后变量的定义，而是直到非用该变量不可的前一刻为止，甚至是尝试延后这份定义知道能给它初值实参为止，这不仅能避免构造/析构不必要的对象，还可以避免无意义的默认构造行为。更深一层说，以"具有明显意义的处置"进行初始化还可以附带说明变量的目的。</p>
<p>那么，在循环中，我们可能容易产生疑虑：如果变量只在循环内使用，那么是定义在循环外，然后每次循环迭代时赋值，还是定义在循环内，每次循环构造一个新的 on-the-stack 变量？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 方法 A：循环外定义</span>
Widget w<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  w <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法 B：循环内定义</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Widget w <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方法 A 的开销为：1 次构造 + 1 次析构 + n 次赋值；</p>
<p>方法 B 的开销为：n 次构造 + n 次析构；</p>
<p>所以，如果赋值的开销比一组构造/析构的开销小，那么自然选择方法 A；反之，选择方法 B。但方法 A 造成名称 w 的作用域比方法 B 更大，有时会对程序的可理解性和易维护性造成冲突，这也是需要考虑在内的因素。</p>
<h2 id="27-尽量少做转型动作">27. 尽量少做转型动作</h2>
<p>文章 <a href="../../c/c-cast"><strong>C++ の Cast</strong></a> 中已经介绍过 C++ 中类型转换的内容。尽量避免转型，特别是在注重效率的代码中避免 <code>dynamic_cast</code>。如果非要转型，也尽可能使用 C+±style 转型。</p>
<h2 id="28-避免返回-handles-指向对象内部成分">28. 避免返回 handles 指向对象内部成分</h2>
<p>通常我们认为，对象的"内部"就是指它的成员变量，但其实 non-public 成员函数也是对象"内部"的一部分，因此也应该留心不要返回它们的 handles，这意味你绝对不该令成员函数返回一个指针/引用指向"访问级别较低"的成员函数。如果你那么做，后者的实际访问级别就会提高如同访问级别较高者，因为客户可以取得一个指针指向那个"访问级别较低"的函数，然后通过那个指针调用它。这无形中相当于将 private 变量变成了 public，就跟之前提到的那样，这降低了封装性。</p>
<p>此外，handles 也可能出现<strong>悬空</strong>的情况，即获取一个对象内部变量的指针/引用后，该对象在真正使用之前销毁，那么该指针/引用实际上指向了一个未知的变量，这极为糟糕。毕竟，handles 并不能延长变量的生命周期。这和 <a href="../../c/c-function/#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><strong>lambda 表达式</strong></a>中提到的有异曲同工之妙。</p>
<h2 id="29-为-异常安全-而努力是值得的">29. 为"异常安全"而努力是值得的</h2>
<p>关于异常可见<a href="../../c/c-exception"><strong>此文</strong></a>。</p>
<p><strong>异常安全函数</strong>提供以下三个保证之一：</p>
<ol>
<li class="lvl-3">
<p><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构因此被破坏，所有对象都处于内部前后一致的状态；</p>
</li>
<li class="lvl-3">
<p><strong>强烈保证</strong>：如果异常被抛出，程序状态不变。即要么成功，要么回滚；</p>
</li>
<li class="lvl-3">
<p><strong>不抛保证</strong>：承诺绝不抛出异常，因为它们总能完成原先承诺的功能；</p>
</li>
</ol>
<h2 id="30-透彻了解-inlining-的里里外外">30. 透彻了解 inlining 的里里外外</h2>
<p>关于 inline，请看<a href="../../c/c-inline"><strong>此文</strong></a>。</p>
<blockquote>
<p>inline 函数背后的整体观念是，将"对此函数的每一个调用"都以函数本体替换之。优点是能够免除函数调用成本，比宏多了类型检查，以及其他编译器优化。缺点是增加了目标码大小，导致程序体积太大，可能导致额外的换页行为，降低 cache 命中率，以及隐性的其他效率降低。</p>
</blockquote>
<h2 id="31-将文件之间的编译耦合度降至最低">31. 将文件之间的编译耦合度降至最低</h2>
<p>我们不希望仅仅修改某个头文件后，重新 make 项目还要花大量时间将所有文件重新编译链接一遍。问题出在 C++ 并没有把接口从实现很好地分离。类的定义式不仅有各种 api，还有各种数据的实现条目。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string theName<span class="token punctuation">;</span>
  Date theBirthdate<span class="token punctuation">;</span>
  Address theAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有取得合适的定义式，则编译失败。事实上，文件的最开始总会有下面这样的语句。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"date.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"address.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这便是一种编译耦合关系。一旦上述任何一个头文件被改变，那么所有 include 该头文件，包括含有/使用 <code>Person</code> 类的文件就得重新编译，这很容易造成级联依存关系。</p>
<p>好的设计是<strong>前置声明</strong>，并将所有实现条目由指向其实现类的指针代替，即 <strong>pimpl</strong>(pointer to implementation)，这样也方便令编译器计算出所需分配空间的大小。如果仅修改了前者，则编译器很难在不了解定义式的前提下知道一个 Data，一个 Address 应该分配的空间是多少。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">PersonImpl</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Address</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>PersonImpl<span class="token operator">&gt;</span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时，<code>Person</code> 便真正做到了<strong>接口与实现分离</strong>，将编译耦合度降至了最低——它只需要将实现的内容交付给 <code>PersonImpl</code> 类，而用户只需要 <code>#include "Person.h"</code> 即可，无需在意 impl 里是怎么做的。当然，改变 <code>"date.h"</code> 这些头文件也仅仅影响 <code>PersonImpl</code> 类罢了——关键在于，以<strong>声明依存性</strong>替换<strong>定义依存性</strong>，这正是本质所在。下面还有一些其它重要的策略：</p>
<ol>
<li class="lvl-3">
<p>如果可以，尽量用对象引用/对象指针代替对象；</p>
</li>
<li class="lvl-3">
<p>如果可以，尽量用类声明式代替类定义式；</p>
</li>
<li class="lvl-3">
<p>为声明式和定义式提供不同的头文件；</p>
</li>
</ol>
<p>像 <code>Person</code> 这样使用 pimpl 的类一般称为 <strong>handle class</strong>，它必须要通过调用 pImpl 的成员函数来真正做点事情。当然，在调用 <code>pImpl-&gt;</code> 函数时，必须先引入 <code>"PersonImpl.h"</code>（定义式），否则无法调用其成员函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"PersonImpl.h"</span></span>

<span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span>
  <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">PersonImpl</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string <span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> pImpl<span class="token operator">-&gt;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个策略是，令 <code>Person</code> 成为<strong>抽象基类</strong>（即<strong>接口类</strong>），它仅需描述派生类的接口，而将具体实现交给派生类去完成，因此其不带成员变量，也没有构造函数，只有一个虚析构函数，以及一组纯虚函数。此时，某些函数的参数就得用 <code>Person*</code> 或 <code>Person&amp;</code> 来撰写。就像 handle class 一样，除非接口被改写，否则无需重新编译。</p>
<p>在这种接口类中，往往有一个静态的<strong>工厂函数</strong>来创建新对象。尽管接口类不存在构造函数，无法实例化，但它完全可以通过实例化派生类来达成目的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">RealPerson</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">theBirthdate</span><span class="token punctuation">(</span>birthday<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">theAddress</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string theName<span class="token punctuation">;</span>
  Date theBirthdate<span class="token punctuation">;</span>
  Address theAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span>
                               <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span>
                               <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>RealPerson<span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现实中，<code>create</code> 会根据实现代码创建不同类型的派生类，取决于额外参数值、环境变量等。</p>
<p>上面两种策略，handle class 也好，接口类也好，也是会为了降低耦合度而付出少许代价的。</p>
<p>对前者而言，成员函数必须通过 pimpl 获取数据，这会为每一次访问添加一层间接性，并且每一个对象所需内存增加了一个指针大小，这在 64 位机器上为 8B。最后， pimpl 的初始化必须经历动态内存分配带来的困扰——<code>new</code> 的开销，以及 <code>bad_alloc</code> 的可能性。</p>
<p>至于后者，由于每个函数都是虚函数，所以每次函数调用都会在运行时带来查找虚表的开销，当然，所有派生类也增加了（至少）一个 vptr 的大小。</p>
<p>我们进行效率分析时必须进行代价分析，但这些代价，之于降低耦合度带来的好处，则可以忽略不计了。</p>
<h2 id="32-确定你的-public-继承塑模出-is-a（是一种）关系">32. 确定你的 public 继承塑模出 is-a（是一种）关系</h2>
<p>如果令 <code>class Derived</code> 以 public 继承自 <code>class Base</code>，这就是告诉编译器与读者，每个 Derived 对象同时也是一个 Base 对象，Derived 是 Base 的特殊化，而 Base 是 Derived 的一般化，Base 能派上用场的地方，Derived 一定也可以。因为<strong>每个 Derived 都 is-a（是一种） Base 对象</strong>，而反之不成立。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>把 Student 和 Person 分别代入上面的 Derived 和 Base，则很轻易地就能得到符合直觉的结论——每个 Student 都是 Person，而反之不一定。于是，综上所述，C++ 中，任何函数如果希望获得一个 <code>Person*</code> / <code>Person&amp;</code> 实参，也愿意接受一个 <code>Student*</code> / <code>Student&amp;</code> 对象。</p>
<p>当然，上述结论，<strong>仅仅</strong>针对 <strong>public 继承</strong>时成立。</p>
<blockquote>
<p>尽管如此，直觉往往会误导我们的设计——企鹅属于鸟类，但企鹅不会飞；正方形属于矩形，但矩形可以仅仅修改长或宽中的其中一个变量，正方形仅有<strong>边长</strong>这一个属性……许多继承可能接近事实真相，也可能不。我们要做的就是尽可能实现 <strong>is-a</strong> 这一特质。</p>
</blockquote>
<h2 id="33-避免遮掩继承而来的名称">33. 避免遮掩继承而来的名称</h2>
<p>众所周知，当编译器遇到某个名称时，它会从内向外逐个作用域去查找是否有匹配的"东西"，因为内层作用域的名称会<strong>遮掩</strong>外层作用域的名称。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">double</span> x<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span> <span class="token comment">// 用的是 double x</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在继承中亦是如此。当在派生类成员函数内指涉某个基类成员时，编译器很容易能找到，因为派生类继承了基类的所有东西，就好像派生类的作用域嵌套在基类作用域内一样。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>

 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Derived</span><span class="token double-colon punctuation">::</span><span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就像上面这串代码中，编译器看到 <code>Derived</code> 调用 <code>mf2()</code>，首先在 <code>Derived</code> 里找，然后去其所有基类中找，本例中为 <code>Base</code>。很幸运，找到了，如果没找到，还会继续向外到内含 <code>Base</code> 的那个命名空间，最后往 global 去找。</p>
<p>上面只是提供了一个简单的例子，下面这个才是我们真正想讨论的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这很难不能称为一种💩的代码，但无关紧要，之前提到的<strong>名称遮掩规则</strong>并没有改变。因此 <code>Base::mf1(int)</code> 与 <code>Base::mf3(double)</code> 都被 <code>Derived::mf1()</code> 与 <code>Derived::mf3()</code> 掩盖了。换个角度来讲，<code>mf1(int)</code> 与 <code>mf3(double)</code> 并没有得到继承。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>

d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf1()</span>
d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! Derived::mf1() 遮掩了 Base::mf1(int)</span>
d<span class="token punctuation">.</span><span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Base::mf2()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf3()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! Derived::mf3() 遮掩了 Base::mf3(double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不幸的是，我们通常会想继承重载函数，但上面这种继承又不继承的写法实际上是在破坏 is-a 关系。可以通过 using 声明达成目标。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>mf1<span class="token punctuation">;</span> <span class="token comment">// 让 Base 内名为 mf1 和 mf3 的所有东西</span>
  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>mf3<span class="token punctuation">;</span> <span class="token comment">// 在 Derived 作用域内都可见，且 public</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，继承机制正常运转。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>

d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf1()</span>
d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 调用 Base::mf1(int)</span>
d<span class="token punctuation">.</span><span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Base::mf2()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf3()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 调用 Base::mf3(double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可问题又产生了——我们只希望继承 <code>mf1()</code> 的无参版本！这在 public 继承下没有意义，因为破坏了 is-a 关系，但在 private 继承下值得讨论。既然 using 声明并不能满足要求，那我们干脆实现一个<strong>转发函数</strong>好了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Derived d<span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>

d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Base::mf1()</span>
d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! Base::mf1(int) 被掩盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="34-区分接口继承和实现继承">34. 区分接口继承和实现继承</h2>
<p>public 继承实际上由两部分组成：<strong>函数接口继承</strong>与<strong>函数实现继承</strong>。</p>
<p>基于 is-a，函数接口总是会被继承，毕竟如果某个函数可用于基类，那么必然可用于派生类。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声明一个 pure virtual 函数的目的是为了让派生类<strong>只</strong>继承<strong>接口</strong>；</p>
<blockquote>
<p>你必须 override，否则无法实例化，但我不干涉你怎么实现它。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>声明一个 impure virtual 函数的目的是为了让派生类继承<strong>接口和缺省实现</strong>；</p>
<blockquote>
<p>如果你不想或忘了 override，可以使用基类提供的缺省版本。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>声明一个 non-virtual 函数的目的是为了让派生类继承<strong>接口和强制性实现</strong>；</p>
<blockquote>
<p>non-virtual 函数意味着不变性凌驾于特异性，所以其绝不该在派生类中被 override。</p>
</blockquote>
</li>
</ul>
<p>这三个函数之间的差异，使得我们需要精确指定希望派生类继承的东西：只继承接口，继承接口和缺省实现，还是继承接口和强制性实现。必须谨慎选择。或许能够避免犯下以下两个错误：</p>
<ol>
<li class="lvl-3">
<p>将所有函数声明为 non-virtual。这使得派生类没有空间进行特化工作；</p>
</li>
<li class="lvl-3">
<p>将所有函数声明为 virtual。但某些函数并不该在派生类中被 override，对这部分函数最好的做法是声明为 non-virtual；</p>
</li>
</ol>
<h2 id="35-考虑-virtual-函数以外的其他选择">35. 考虑 virtual 函数以外的其他选择</h2>
<p>假设你正在写一个暴力砍杀类型的游戏，你打算为游戏内的人物设计一个继承体系，人物会因被伤害或其他因素而扣血。你因此决定提供一个成员函数 <code>healthValue()</code>，它会返回一个整数，表示人物的血量。由于不同的人物可能以不同的方式计算他们的血量，将 <code>healthValue()</code> 声明为 virtual 似乎是再明白不过的做法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面想讨论一些其它代替方案。</p>
<ol>
<li class="lvl-3">
<p>通过 <strong>NVI</strong>(Non-Virtual Interface) 手法实现 <strong>Template Method 设计模式</strong>。该模式主张令 virtual 函数称为 private，然后通过一个称为 <strong>wrapper</strong> 的 public non-virtual 函数来调用它。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 事前准备 */</span>
    <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 事后工作 */</span>
    <span class="token keyword">return</span> retValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> <span class="token comment">// 允许 override</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>NVI 手法的一个优点在于，它确保在一个 virtual 函数调用前后完成一些工作。虽然它涉及在派生类中对 virtual 函数进行 override，但这仅仅影响"如何"被完成，而基类中的 wrapper 则决定了"何时"被完成。</p>
</li>
<li class="lvl-3">
<p>通过函数指针实现 <strong>Strategy 设计模式</strong>。该方案主张"人物血量计算与人物类型无关"，而是在构造函数中接受一个函数指针指向一个"血量计算"函数，通过调用该函数实现效果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">defaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalFunc hcf <span class="token operator">=</span> defaultHealthCalc<span class="token punctuation">)</span>
   <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  HealthCalFunc healthFunc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这使得同一人物类型下不同实体也可以拥有不同"血量计算"函数，并且某人物的计算函数可以在运行时期变化，比如可以通过提供一个 <code>setHealthCalculator</code> 来替换"血量计算"函数。但缺点在于，如果"血量计算"所需信息为 non-public，那就比较危险，或许可能要适当降低封装性，比如提供一些 public 访问接口或将函数设为 friend。其优点是否足以弥补缺点，这是需要进行仔细考虑的。</p>
</li>
<li class="lvl-3">
<p>通过 <code>std::function</code> 实现 <strong>Strategy 设计模式</strong>。上面的函数指针本质上是一个<strong>可调用对象</strong>。C++11 已经将所有的可调用对象进行了统一，推出了新特性 <code>std::function</code>（见<a href="../../c/c-function">此文</a>），那用此新特性进行替换，提高了更多的实现弹性，不是吗？只要函数签名与需求端兼容，那么就是可行的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">defaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalFunc hcf <span class="token operator">=</span> defaultHealthCalc<span class="token punctuation">)</span>
   <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  HealthCalFunc healthFunc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么，接下来表演个戏法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数</span>
<span class="token keyword">short</span> <span class="token function">calcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 仿函数</span>
<span class="token keyword">struct</span> <span class="token class-name">HealthCalculator</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 成员函数</span>
<span class="token keyword">class</span> <span class="token class-name">GameLevel</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">float</span> <span class="token function">calcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 两个人物类型</span>
<span class="token keyword">class</span> <span class="token class-name">EvilBadGuy</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">GameCharacter</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">EyeCandyCharacter</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">GameCharacter</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

GameLevel currentLevel<span class="token punctuation">;</span>

EvilBadGuy <span class="token function">ebg1</span><span class="token punctuation">(</span>calcHealth<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 1. 使用函数计算</span>

EyeCandyCharacter <span class="token function">ecc1</span><span class="token punctuation">(</span><span class="token function">HealthCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 使用仿函数计算</span>

EvilBadguy <span class="token function">ebg2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>GameLevel<span class="token double-colon punctuation">::</span>health<span class="token punctuation">,</span>      <span class="token comment">// 3. 使用某个类的成员函数计算</span>
                          currentLevel<span class="token punctuation">,</span>
                          std<span class="token double-colon punctuation">::</span>placeholder<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>传统 <strong>Strategy 设计模式</strong>。它会将函数做成一个分离的继承体系中的 virtual 成员函数。构造函数接受一个 <code>HealthCalcFunc</code> 类指针，通过传入不同派生类地址实现效果。</p>
</li>
</ol>
<h2 id="36-绝不-override-继承来的-non-virtual-函数">36. 绝不 override 继承来的 non-virtual 函数</h2>
<p>记住就行了。</p>
<h2 id="37-绝不重新定义继承来缺省参数值">37. 绝不重新定义继承来缺省参数值</h2>
<p>基于上条，这里就只考虑带缺省参数的 virtual 函数。这种情况下，本条款成立的理由就非常直接而明确了：virtual 函数为动态绑定，而缺省参数值却是静态绑定。那么在用基类指针指向派生类时，指针的静态类型必然为基类，则就会出现"调用一个定义于派生类的虚函数，却使用了基类指定的缺省参数值"这一情况。这也就直接宣告派生类对缺省值的重新定义无效化了。</p>
<h2 id="38-通过复合塑模出-has-a-或-根据某物实现出">38. 通过复合塑模出 has-a 或"根据某物实现出"</h2>
<p>当某种类型的对象内含另一种类型的对象，这就是复合关系。如同 public 含有 is-a 意义一样，复合关系也有着 has-a（有一个）或"根据某物实现出"的意义。就比如想实现一个 set 数据结构，复用 <code>std::set</code> 是最方便的，但是其为了提高时间效率，提高了空间开销，每个元素额外有三个指针的空间占用。加一条限制：我们希望空间比时间重要。那么复用 <code>std::set</code> 就并不可取。于是在万千种替代方法中，随机挑选了一个用 <code>std::list</code> 实现，决定复用它。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Set</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">list</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>看起来很美好，但实际上这违背了 is-a 准则。<code>std::list</code> 允许重复元素，而我们想实现的 set 不允许，该冲突决定了这一设计是糟糕的——public 继承并不适合这种情况。正确的做法是，令 <code>std::list</code> 作为我们 <code>Set</code> 类的底层数据结构，用于存放数据，即根据 <code>std::list</code> 实现出，就像这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">bool</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> rep<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="39-明智而审慎地使用-private-继承">39. 明智而审慎地使用 private 继承</h2>
<p>public 继承可以实现 is-a 语义，这是前文讨论过的。那么 private 继承呢？首先要明确几点规则，如果一个类之间的继承关系为 private，那么：</p>
<ol>
<li class="lvl-3">
<p>编译器不会将一个派生类对象转换为基类对象，也就是无法用基类指针/引用去指向；</p>
</li>
<li class="lvl-3">
<p>基类的所有成员在派生类中均变为 private，纵使在基类中原本是 public 或 protected；</p>
</li>
<li class="lvl-3">
<p>意味着"根据某物实现出"——使用 private 继承的用意是为了采用某些基类特性，而不是因为基类和派生类存在任何观念上的关系（如 is-a），这纯粹是一种实现技术；</p>
</li>
</ol>
<p>第三个事实令人感到不安，因为复合关系也能实现这一层语义。如果非得选一个，还是<strong>复合关系更胜一筹</strong>，因为复合更容易理解，只有必要时采用 private 继承。何为必要？即需要访问基类 protected 成员，或需要 override virtual 函数时。</p>
<h2 id="40-明智而审慎地使用多重继承">40. 明智而审慎地使用多重继承</h2>
<p>关于多继承的事，请看<a href="../../c/c-oop/#%E7%BB%A7%E6%89%BF"><strong>此文</strong></a>。</p>
<p>多重继承容易引发歧义，且带来了虚继承的需求。虚继承还会带来一系列成本，除非虚基类不带任何数据。</p>
<p>但多重继承也不是一无是处，在 public 继承某个接口类，并且 private 继承某个协助类时才发挥出正当用途。</p>
<h2 id="41-了解隐式接口和编译期多态">41. 了解隐式接口和编译期多态</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 隐式接口</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">doProcessing</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">!=</span> someNastyWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T <span class="token function">temp</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>w 必须支持在 <strong>template</strong> 中指定需要 w 进行执行的操作，这里是 <code>size()</code>，<code>operator!=()</code>，<code>normalize()</code> 和 <code>swap()</code>，还有一个拷贝构造函数。如果某个类型 <code>T</code> 不支持这些功能，那么编译失败。这些就是所谓的<strong>隐式接口</strong>。</p>
<p>而一旦支持了，就会根据 <code>T</code> 的不同，调用不同类型的这些函数。这种实例化在编译期决定，就是所谓的<strong>编译期多态</strong>。</p>
<p>而对于 <strong>class</strong> 而言，接口都是<strong>显式</strong>的，以函数签名为中心，通过 virtual 函数实现<strong>运行时多态</strong>。</p>
<h2 id="42-了解-typename-的双重意义">42. 了解 typename 的双重意义</h2>
<p>在 template 中，<code>typename</code> 和 <code>class</code> 具有同样的含义。就比如下面这两种声明方式，其实是没有区别的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然而在这两者并不总是等价，有时候我们不得不用 <code>typename</code>。比如下面一个函数模板，接受一个 STL 容器作为模板参数，该容器内持有的对象可被赋值为 int，函数功能是打印容器内的第二个元素。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    C<span class="token double-colon punctuation">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>iter<span class="token punctuation">;</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>变量 <code>iter</code> 的的类型为 <code>const_iterator</code>，具体是什么取决于传入的模板参数 <code>C</code>。这种依赖于某个模板参数的名称称为<strong>从属名称</strong>，像 <code>C::const_iterator</code> 这种存在嵌套关系的又进一步被称为<strong>嵌套从属名称</strong>，同理还有 <code>std::vector&lt;C&gt;</code> 这样的。而 <code>int</code> 则为<strong>非从属名称</strong>。</p>
<p>如果传入的参数恰好是内含该类型迭代器的 STL 容器，那万事大吉，函数正常运转。但如果 <code>const_iterator</code> 是类型 <code>C</code> 的一个成员变量呢？编译器此时就会解析错误，毕竟不能把一个变量作为类型吧。事实上，在知道 <code>C</code> 是什么之前，没有任何方法知道 <code>C::const_iterator</code> 是什么东西，C++ 提供了一个规则来消除歧义：如果解析器在模板中遇到一个嵌套从属名称，除非我们明确指出这是一个类型，否则编译器就会默认它不是。也就是说，上面那份代码中的第四行，<code>C::const_iterator</code> 被认为是"非类型"。</p>
<p>此时我们发现应该明确指出这是一个类型，做法很简单，只要在前面加上一个关键字 <code>typename</code> 即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token double-colon punctuation">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而这个做法也有例外，即，<code>typename</code> 不可以出现在基类继承列表中的嵌套从属名称前，也不可以在成员初始化列表中作为基类的修饰符，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token class-name">Nested</span></span> <span class="token punctuation">{</span>         <span class="token comment">// 继承列表，不允许 typename</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">DErived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 初始化列表，不允许 typename</span>
    <span class="token keyword">typename</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Nested temp<span class="token punctuation">;</span>              <span class="token comment">// 允许，且必须</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="43-学习处理模板化基类内的名称">43. 学习处理模板化基类内的名称</h2>
<p>如果一个派生类模板继承自基类模板，并且派生类试图调用基类中的函数，那么极有可能无法通过编译：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// ERROR!</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是因为，在 Template C++ 中，任何一个模板均存在被<strong>特化</strong>的可能性，而那个特化版本可能并不提供和一般性 template 相同的接口。也就是说我们可以实现一个 <code>Base&lt;int&gt;</code>，它不包含 <code>foo()</code> 这个函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Derived<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// ERROR! Base&lt;int&gt; 不存在函数 foo()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>考虑到这种可能性，编译器在遭遇派生类模板定义式时，就不知道它继承自怎样的基类，既然如此，也就无法知道这个类里拥有怎样的成员，具体点说，无法知道这个类是否拥有函数 <code>foo()</code>。因此它往往拒绝在模板化基类内寻找继承来的名称。</p>
<p>幸运的是，我们有三种办法使得派生类模板能成功调用基类模板。</p>
<ol>
<li class="lvl-3">
<p>在基类函数前加 <code>this-&gt;</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 假设 foo() 被继承</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>使用 using 声明，将基类名称引入派生类中</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> Base<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>foo<span class="token punctuation">;</span>   <span class="token comment">// 告诉编译器假设 foo() 位于 Base 内</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 假设 foo() 被继承</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>显式指明被调用函数的作用域</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 假设 foo() 被继承</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种做法最糟糕，因为一旦 <code>foo()</code> 是个 virtual 函数，那么就完全无法实现多态了。</p>
</li>
</ol>
<p>上述做法仅仅是提供一个假设，而一旦实例化了一个 <code>Derived&lt;int&gt;</code> 对象，那么一切依然照旧——无法通过编译。</p>
<h2 id="44-将与参数无关的代码抽离-template">44. 将与参数无关的代码抽离 template</h2>
<p>template 是节省时间和避免代码重复的奇技淫巧。但如果不小心，使用 template 也可能会导致代码膨胀，即实例化时，产生多个类和多个函数，造成重复的二进制代码。所以任何 template 代码都不该与某个造成膨胀的参数产生耦合关系。</p>
<p>因<strong>非类型模板参数</strong>而造成的代码膨胀，往往可以通过函数参数或类成员变量替换的方式来<strong>消除</strong>，但会因此将编译期行为迁移到运行期。</p>
<p>因<strong>类型参数</strong>造成的代码膨胀，可以让带有完全相同二进制表述的实例类型共享实现码来<strong>降低</strong>。</p>
<p>比如希望实现某个矩阵，并支持求逆运算：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t n<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  T data<span class="token punctuation">[</span>n<span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

SquareMatrix<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;</span> m1<span class="token punctuation">;</span>
SquareMatrix<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> m2<span class="token punctuation">;</span>

m1<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m2<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两份实例化了的对象，产生了两份除了常量 5 和 10 不同，其它完全相同的函数。这就是一个典型的代码膨胀例子。为了消除这一膨胀行为，进行如下修改：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token function">SquareMatrixBase</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">,</span> T<span class="token operator">*</span> pMem<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pData</span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">setDataPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> pData <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size matrixSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">;</span>
  T<span class="token operator">*</span> pData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t n<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">SquareMatrixBase</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>invert<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token generic-function"><span class="token function">SquareMatrixBase</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  T data<span class="token punctuation">[</span>n<span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基类 <code>SquareMatrixBase</code> 中放置了一个带参数的 <code>invert()</code>，不同的是它只对矩阵元素对象的<strong>类型</strong>进行参数化，而不对矩阵的尺寸参数化，因此对于某给定类型，所有矩阵共享唯一一个 <code>SquareMatrixBase</code> 类，也因此共享唯一一个 <code>invert()</code>。</p>
<h2 id="45-运用成员函数模板接受所有兼容类型">45. 运用成员函数模板接受所有兼容类型</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
  <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>      <span class="token comment">// 未声明为 explicit 是刻意的，因为原始指针间的转换是隐式转换</span>
    <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>  <span class="token comment">// 无需写出转型动作，即支持 Smart&lt;Base&gt; pBase = &amp;d; 这样的写法</span>
                                          <span class="token comment">// 仅当存在隐式转换 U-&gt;T 时编译才通过</span>
  T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> heldPtr<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  T<span class="token operator">*</span> heldPtr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>SmartPtr&lt;Base&gt;</code> 与 <code>SmartPtr&lt;Derived&gt;</code> 是两种完全不同的类型，无法通过后者对前者进行拷贝构造/赋值，尽管相应的裸指针是拥有这种转换能力的。通过定义<strong>构造函数模板</strong>，上述转型得以实现。这种构造函数又称<strong>泛化拷贝构造函数</strong>。而这种函数的出现并不会替代正常拷贝构造函数的地位，如果没有声明，编译器依然会默认生成一个 <code>SmartPtr(const SmartPtr&amp;)</code> 来，所以为了面面俱到，必须同时声明泛化版本的和"正常"版本的拷贝构造函数。相同规则也适用于<strong>赋值</strong>。</p>
<h2 id="46-需要类型转换时请为模板定义非成员函数">46. 需要类型转换时请为模板定义非成员函数</h2>
<p><a href="#24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8-non-member-%E5%87%BD%E6%95%B0"><strong>条款 24</strong></a> 讨论过为什么惟有 non-member 函数才有能力"在所有实参身上实施院式类型转换"，该条款并以 <code>Rational</code> 类的 <code>operator*()</code> 函数为例。本条款将对该例子进行扩充——模板化。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
  <span class="token keyword">const</span> T <span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> T <span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>

Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! 无法通过 2 来生成一个 Rational&lt;int&gt; 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>推导 <code>oneHalf</code> 并不困难，然而，编译器并没有如此强大的能力，仅根据 <code>2</code> 来进行模板实参推导，因为规则是<strong>绝不</strong>将通过构造函数而发生的隐式类型转换纳入考虑。这样的转换在函数调用过程中确实被使用了，但在能够调用一个函数之前，首先必须知道那个函数存在，而为此又必须先为相关的函数模板推导出参数类型，然后才能将适当的函数实例化。</p>
<p>而只需要在类模板中用 <code>friend</code> 指涉某个特定函数（即 <code>operator*</code>）即可应对挑战。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
  <span class="token keyword">const</span> T <span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> T <span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                                   <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>

Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在对 <code>operator*</code> 的混合式调用可以通过编译了，因为当对象 <code>oneHalf</code> 被声明为一个 <code>Rational&lt;int&gt;</code> 时，相应的类被实例化，同时友元函数 <code>operator*(const Rational&lt;int&gt;, const Rational&lt;int&gt;)</code> 也就被自动声明出来。后者身为一个函数而非函数模板，因此编译器可在调用它时使用隐式转换函数，而这便是混合式调用之所以成功的原因。但这个函数虽然声明于类内，却并没有被定义——既然我们声明了一个函数，那就有责任定义这个函数！最简单可行的办法就是将函数定义式直接写到类内，并令其调用一个辅助函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token function">doMultiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                  lhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                                   <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">doMutiply</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="47-请使用-traits-classes-表现类型信息">47. 请使用 traits classes 表现类型信息</h2>
<p>STL 里使用 <a href="https://blog.csdn.net/qq_15730877/article/details/117482541"><strong>iterator_traits</strong></a> 来表达迭代器的信息，包含迭代器类型所属(iterator_category)，所指对象类型(value_type)，迭代器间距离(difference_type)，所指内容指针(pointer)，所指内容引用(reference)。根据这些信息，就能为算法提供深度优化。这些信息在编译期可用，通过 template 和特化完成实现，并有可能在编译期对类型执行 if-else 测试。</p>
<h2 id="48-认识模板元编程">48. 认识模板元编程</h2>
<p><a href="https://zhuanlan.zhihu.com/p/137853957"><strong>模板元编程</strong></a>的优点在于，其执行于编译期，故可以在编译期侦测出一些原本运行时才能找出的错误，并且降低了运行时长、可执行文件大小与内存需求，但劣势很明显，编译时期变长了许多。</p>
<h2 id="49-了解-new-handler-的行为">49. 了解 new-handler 的行为</h2>
<p>当 <code>operator new</code> 抛出异常以反映一个未获满足的内存需求之前，它会先调用一个错误处理函数，即 <code>new-handler</code>，定义为一个 <code>void(*)()</code> 类型的函数指针。我们可以通过 <code>set_new_handler()</code> 函数来自定义这个处理函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 已声明于 &lt;new&gt; 中的代码</span>
<span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
  <span class="token keyword">using</span> new_handler <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.cpp</span>
<span class="token comment">/* ... */</span>
<span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"无法分配足够内存\n"</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>pBigDataArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100000000L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>operator new</code> 无法分配足够内存空间时，它会反复调用 <code>new-handler</code> 函数（尽管在上面代码中调用第一次就会先输出一段信息，然后 <code>abort()</code> 终止），直到找到足够内存。因此，一个设计良好的 new-handler 函数必须做以下事情：</p>
<ol>
<li class="lvl-3">
<p><strong>让更多内存可被使用</strong>。一个做法是，程序一开始就分配一大块内存，当 <code>new-handler</code> 第一次被调用时，将那块内存还给程序；</p>
</li>
<li class="lvl-3">
<p><strong>安装另一个 <code>new-handler</code></strong>。使用其它能取得更多可用内存的 <code>new-handler</code> 通过 <code>set_new_handler()</code> 代替现有的，或者修改自身行为，比如通过修改一些 <code>static</code> / <code>global</code> 数据来影响行为；</p>
</li>
<li class="lvl-3">
<p><strong>卸载 <code>new-handler</code></strong>。一旦上面的策略不可行，则需要将 <code>nullptr</code> 传给 <code>set_new_handler()</code>，此时 <code>operator new</code> 会在内存分配失败时抛出异常；</p>
</li>
<li class="lvl-3">
<p><strong>抛出 <code>bad_alloc</code> 或其派生类的异常</strong>；</p>
</li>
<li class="lvl-3">
<p><strong>不返回</strong>。通常调用 <code>std::abort()</code> 或 <code>std::exit()</code>；</p>
</li>
</ol>
<p>有时候我们希望根据分配对象的类型不同而调用不同的 <code>new_handler</code>，只需要令每个类提供一个 <code>set_new_handler()</code> 和 <code>operator new</code> 即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler curHandler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>new_handler Widget<span class="token double-colon punctuation">::</span>curHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">// 存储后返回原来的 new-handler，与  std::set_new_handler 做法无异。仅改变局部 new-handler</span>
std<span class="token double-colon punctuation">::</span>new_handler <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>new_handler oldHandler <span class="token operator">=</span> curHandler<span class="token punctuation">;</span>
  curHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>
  <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>Widget::operator new</code> 做了以下事情：</p>
<ol>
<li class="lvl-3">
<p>调用 <code>std::set_new_handler()</code>，告知 <code>Widget</code> 的错误处理函数，从而将 <code>Widget</code> 的 <code>new-handler</code> 安装为全局 <code>new-handler</code>；</p>
</li>
<li class="lvl-3">
<p>调用全局 <code>operator new</code></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>如果分配失败，调用 <code>Widget</code> 的 <code>new-handler</code>。如果全局 <code>operator new</code> 最终无法分配足够内存，会抛出 <code>std::bad_alloc</code> 异常。此时 <code>Widget</code> 的 <code>operator new</code> 必须恢复原本的全局 <code>new-handler</code>，再传播该异常；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NewHandlerHolder</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler nh<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">handler</span><span class="token punctuation">(</span>nh<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 取得原先 new-handler</span>
  <span class="token operator">~</span><span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>         <span class="token comment">// 释放当前</span>

  <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewHandlerHolder<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  NewHandlerHolder<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewHandlerHolder<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>new_handler handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就使得 <code>Widget::operator new</code> 的实现非常简单：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  NewHandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-5">
<p>反之，<code>Widger::operator new</code> 返回一个指向分配所得的指针。<code>Widget::~Widget()</code> 会自动将全局 <code>new-handler</code> 恢复。</p>
</li>
</ul>
</li>
</ol>
<h2 id="50-了解-new-和-delete-的合理替换时机">50. 了解 new 和 delete 的合理替换时机</h2>
<p>为何要替换呢？总的来说有以下理由：</p>
<ol>
<li class="lvl-3">
<p>检测运行时错误；</p>
</li>
<li class="lvl-3">
<p>强化效能；</p>
</li>
<li class="lvl-3">
<p>收集使用上的统计数据；</p>
</li>
<li class="lvl-3">
<p>增加分配和释放的速度；</p>
</li>
<li class="lvl-3">
<p>降低缺省内存管理器带来的额外空间开销；</p>
</li>
<li class="lvl-3">
<p>弥补缺省分配器中的非最佳齐位；</p>
</li>
<li class="lvl-3">
<p>将相关对象成簇集中；</p>
</li>
<li class="lvl-3">
<p>获得非传统的行为；</p>
</li>
</ol>
<h2 id="51-编写-new-和-delete-时需固守常规">51. 编写 new 和 delete 时需固守常规</h2>
<p><code>operator new</code> 应该内含一个无限循环，在其中尝试分配内存，若无法满足，则调用 <code>new-handler</code>。它需要有能力处理 0 bytes 的分配申请。类中的重载版本还应该处理比正确大小更大的错误申请。</p>
<p><code>operator delete</code> 应该不处理任何 <code>nullptr</code> 的释放申请。同样的，类中的重载版本还应该处理比正确大小更大的错误申请。</p>
<h2 id="52-写了-placement-new-也要写-placement-delete">52. 写了 placement new 也要写 placement delete</h2>
<p>如果一个 placement new 没有 placement delete，那么当 new 的内存分配动作需要取消并恢复原状时就没有任何 delete 会被调用。因此，为了消除这种内存泄漏，有必要在写了 placement new 的同时声明一个 placement delete。</p>
<p>btw，如<a href="#33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><strong>条款 33</strong></a> 讨论的那样，我们必须小心让 <code>operator new</code> 掩盖外层作用域的其它版本。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> logstram<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 掩盖 global operator new</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 掩盖 Base::operator new</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Base<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>                   <span class="token comment">// ERROR! normal operator new 被掩盖</span>
Base<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Base</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// OK!</span>
Derived<span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>clog<span class="token punctuation">)</span> Derived<span class="token punctuation">;</span> <span class="token comment">// ERROR! Base::operator new 被掩盖</span>
Derived<span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>             <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方案为：对于撰写内存分配函数，需要在缺省情况下，在全局作用域内提供以下所有形式的 <code>operator new</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// normal new</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                  <span class="token comment">// placement new</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment">// nothrow new</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果在类内声明任何 <code>operator new</code>，它会遮掩上述这些标准形式。除非你就是要阻止用户使用这些形式，否则请确保它们在你所生成的任何自定义 <code>operator new</code> 可用。对于每一个可用的 <code>operator new</code>，也请确定提供对应的 <code>operator delete</code>。如果希望这些函数有着平常的行为，只要令自定义重载版本调用全局版本即可。</p>
<p>一个简单做法是，建立一个基类，内含所有调用全局版本的 new 和 delete。凡是想以自定义形式扩充的用户，可利用继承机制与 <code>using</code> 声明取得标准形式。</p>
<h2 id="53-不要轻忽编译器的警告">53. 不要轻忽编译器的警告</h2>
<p>一旦从某个特定编译器的警告信息中获得经验，你将学会了解，不同的信息意味什么——那往往和它们"看起来"的意义十分不同！尽管一般认为，写出一个在最高警告级别下也无任何警告信息的程序最是理想，然而一旦有了上述的经验和对警告信息的深刻理解，你倒是可以选择忽略某些警告信息。不管怎样说，在你打发某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要。</p>
<p>记住，警告信息天生和编译器相依，不同的编译器有不同的警告标准。所以，草率编程然后倚赖编译器为你指出错误，并不可取。</p>
<h2 id="54-让自己熟悉包括-TR1-在内的标准程序库">54. 让自己熟悉包括 TR1 在内的标准程序库</h2>
<p>所有功能都被 <a href="https://zh.cppreference.com/w/cpp/11"><strong>C++11</strong></a> 囊括。</p>
<h2 id="55-让自己熟悉-Boost">55. 让自己熟悉 Boost</h2>
<p>大部分都被 <a href="https://zh.cppreference.com/w/cpp/11"><strong>C++11</strong></a> 囊括。</p>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>现代图形学入门（GAMES101）の 作业记录</title>
    <url>/lab/games101lab/</url>
    <content><![CDATA[<p><a href="https://github.com/Leager-zju/GAMES101">&gt;&gt;&gt; Github 传送门&lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="环境搭建">环境搭建</h2>
<p>使用平台：<strong>Windows</strong> + Vscode + MSYS2 + MinGW</p>
<h3 id="Eigen-库安装-编译">Eigen 库安装 &amp; 编译</h3>
<p>进入<a href="https://gitlab.com/libeigen/eigen/-/releases/">下载地址</a>进行下载并解压。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /your/path/to/Eigen
<span class="token function">mkdir</span> build <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> build
cmake <span class="token parameter variable">-G</span> <span class="token string">"Unix Makefiles"</span> <span class="token punctuation">..</span> <span class="token comment">## windows 下默认生成 ninja，需要改为生成 makefile</span>
<span class="token function">make</span> <span class="token function">install</span> <span class="token parameter variable">-j8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后会自动在 <code>C:/Program Files(x86)</code> 下生成一个名为 <code>eigen3</code> 的文件夹。也可以移到自己喜欢的地方，记为 <code>/your/path/to/eigen3</code>。</p>
<h3 id="opencv-库安装-编译">opencv 库安装 &amp; 编译</h3>
<p>进入<a href="https://sourceforge.net/projects/opencvlibrary/files/opencv-win/">下载地址</a>进行下载并双击 .exe 文件解压。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /your/path/to/opencv
<span class="token builtin class-name">cd</span> sources
<span class="token function">mkdir</span> build <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">cd</span> build
cmake <span class="token parameter variable">-G</span> <span class="token string">"Unix Makefiles"</span> <span class="token parameter variable">-D</span> <span class="token assign-left variable">WITH_OPENGL</span><span class="token operator">=</span>ON <span class="token parameter variable">-D</span> <span class="token assign-left variable">ENABLE_CXX11</span><span class="token operator">=</span>ON <span class="token parameter variable">-D</span> <span class="token assign-left variable">WITH_IPP</span><span class="token operator">=</span>OFF <span class="token parameter variable">-D</span> <span class="token assign-left variable">ENABLE_PRECOMPILED_HEADERS</span><span class="token operator">=</span>OFF <span class="token punctuation">..</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>接下来用管理员权限运行 <code>make -j8 &amp;&amp; make install -j8</code>。</p>
<p>会在 <code>sources/build/</code> 目录下生成一个名为 <code>install</code> 的目录，这就是我们所需要的目录，其他都可以忽略，记为 <code>your/path/to/opencv</code></p>
<h3 id="编译">编译</h3>
<p>CMakelists 参见相应分支。</p>
<p>❗ 注意：需要将 <code>your/path/to/opencv/x64/mingw/bin</code> 加入系统变量 PATH，否则链接阶段会找不到对应的动态库。</p>
<h2 id="Assignment1-透视投影">Assignment1 透视投影</h2>
<p>第一个作业要求实现透视投影的 MVP 三个矩阵。</p>
<h3 id="旋转矩阵-Model">旋转矩阵(Model)</h3>
<p>这里要求实现按 $\mathbf{z}$ 轴旋转的矩阵。注意 <code>get_model_matrix(float rotation_angle)</code> 的参数是角度制，而使用 C++ 函数 <code>sin()</code>/<code>cos()</code> 时要转为弧度制。</p>
<p>实现如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 角度转弧度</span>
<span class="token keyword">float</span> <span class="token function">angleToRadians</span><span class="token punctuation">(</span><span class="token keyword">float</span> angle<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> MY_PI<span class="token operator">*</span>angle<span class="token operator">/</span><span class="token number">180</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token comment">// Create the model matrix for rotating the triangle around the Z axis.</span>
<span class="token comment">// Then return it.</span>
Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_model_matrix</span><span class="token punctuation">(</span><span class="token keyword">float</span> rotation_angle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// transform angle to radians</span>
    <span class="token keyword">float</span> cosValue <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token function">angleToRadians</span><span class="token punctuation">(</span>rotation_angle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> sinValue <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token function">angleToRadians</span><span class="token punctuation">(</span>rotation_angle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Matrix4f rotate<span class="token punctuation">;</span>
    rotate <span class="token operator">&lt;&lt;</span> cosValue<span class="token punctuation">,</span> <span class="token operator">-</span>sinValue<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
              sinValue<span class="token punctuation">,</span> cosValue<span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
              <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token number">0</span><span class="token punctuation">,</span>         <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
              <span class="token number">0</span><span class="token punctuation">,</span>        <span class="token number">0</span><span class="token punctuation">,</span>         <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> rotate<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="平移矩阵-View">平移矩阵(View)</h3>
<p>这里其实就是将世界中所有物体同时平移，使得相机位于世界坐标的原点。<code>get_view_matrix(Eigen::Vector3f eye_pos)</code> 的参数是相机的初始位置。</p>
<p>实现如下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_view_matrix</span><span class="token punctuation">(</span>Eigen<span class="token double-colon punctuation">::</span>Vector3f eye_pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Eigen<span class="token double-colon punctuation">::</span>Matrix4f translate<span class="token punctuation">;</span>
    translate <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>eye_pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span>eye_pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span>eye_pos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
                 <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> translate<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="投影矩阵-Projection">投影矩阵(Projection)</h3>
<p>这里需要我们实现透视投影矩阵，也是本次任务的难点所在。虽然课程中已经用数学方法推导出了矩阵，但这里还有一些不一样的地方：课程中的推导采用右手系，即相机在原点往 $\mathbf{z}$ 轴负方向看，此时矩阵中的 $n$ 和 $f$ 都应为负值。</p>
<p>而通过观察 <code>main()</code> 我们发现，这里 <code>get_projection_matrix(float eye_fov, float aspect_ratio, float zNear, float zFar)</code> 的两个参数 <code>zNear</code>/<code>zFar</code> 传入的都是正数。如果直接用这两个作为 $n$ 和 $f$，会发现结果出现三角形上下颠倒的问题（准确来说是与预期值在 $\mathbf{z}$ 轴上偏移了 180°）。</p>
<p>导致这一结果的原因在于，我们在推导过程中认为可视空间内某一点 $(x, y, z)$ 与近平面上的点 $(x’, y’, n)$ 应当存在这样一个关系</p>
<p>$$
x’ = \frac{n}{z}x
$$</p>
<p>一旦 $n$ 和 $z$ 符号相反，就会出现 $x’$ 的值也相反，同理 $y’$ 的值也反了，那不就使得观测结果不符合预期了么。</p>
<p>我的做法是：依然采用<strong>右手系</strong>，不同的是需要将这两个参数理解为近/远平面离原点的距离，$n$ 和 $f$ 各取相应的负值，这样就能解决这一问题了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_projection_matrix</span><span class="token punctuation">(</span><span class="token keyword">float</span> eye_fov<span class="token punctuation">,</span> <span class="token keyword">float</span> aspect_ratio<span class="token punctuation">,</span>
                                      <span class="token keyword">float</span> zNear<span class="token punctuation">,</span> <span class="token keyword">float</span> zFar<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// eye_fov: viewing angle in the range of [-eye_fov, eye_fov]</span>
    <span class="token comment">// aspect_ratio: the height:width of viewing plane</span>
    Eigen<span class="token double-colon punctuation">::</span>Matrix4f squish<span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Matrix4f translation<span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Matrix4f scale<span class="token punctuation">;</span>

    <span class="token keyword">float</span> n <span class="token operator">=</span> <span class="token operator">-</span>zNear<span class="token punctuation">;</span>
    <span class="token keyword">float</span> f <span class="token operator">=</span> <span class="token operator">-</span>zFar<span class="token punctuation">;</span>

    squish <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span>
              <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">,</span>
              <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token operator">+</span>f<span class="token punctuation">,</span> <span class="token operator">-</span>n<span class="token operator">*</span>f<span class="token punctuation">,</span>
              <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>   <span class="token number">0</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> top <span class="token operator">=</span> <span class="token function">abs</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token operator">*</span><span class="token function">tan</span><span class="token punctuation">(</span><span class="token function">angleToRadians</span><span class="token punctuation">(</span>eye_fov<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> bottom <span class="token operator">=</span> <span class="token operator">-</span>top<span class="token punctuation">;</span>

    <span class="token keyword">float</span> right <span class="token operator">=</span> top<span class="token operator">*</span>aspect_ratio<span class="token punctuation">;</span>
    <span class="token keyword">float</span> left <span class="token operator">=</span> <span class="token operator">-</span>right<span class="token punctuation">;</span>

    translation <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>left<span class="token operator">+</span>right<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>
                   <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>top<span class="token operator">+</span>bottom<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>
                   <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token punctuation">(</span>n<span class="token operator">+</span>f<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">,</span>
                   <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">;</span>

    scale <span class="token operator">&lt;&lt;</span> <span class="token number">2</span><span class="token operator">/</span><span class="token punctuation">(</span>right<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>              <span class="token number">0</span><span class="token punctuation">,</span>       <span class="token number">0</span><span class="token punctuation">,</span>
             <span class="token number">0</span><span class="token punctuation">,</span>              <span class="token number">2</span><span class="token operator">/</span><span class="token punctuation">(</span>top<span class="token operator">-</span>bottom<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>       <span class="token number">0</span><span class="token punctuation">,</span>
             <span class="token number">0</span><span class="token punctuation">,</span>              <span class="token number">0</span><span class="token punctuation">,</span>              <span class="token number">2</span><span class="token operator">/</span><span class="token punctuation">(</span>n<span class="token operator">-</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>
             <span class="token number">0</span><span class="token punctuation">,</span>              <span class="token number">0</span><span class="token punctuation">,</span>              <span class="token number">0</span><span class="token punctuation">,</span>       <span class="token number">1</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> scale<span class="token operator">*</span>translation<span class="token operator">*</span>squish<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="BONUS-按任意轴-axis-旋转">BONUS: 按任意轴 axis 旋转</h3>
<p>按照课程推导结果代入即可</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Matrix4f <span class="token function">get_rotation</span><span class="token punctuation">(</span>Vector3f axis<span class="token punctuation">,</span> <span class="token keyword">float</span> angle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Eigen<span class="token double-colon punctuation">::</span>Matrix4f K <span class="token operator">=</span> Eigen<span class="token double-colon punctuation">::</span><span class="token class-name">Matrix4f</span><span class="token double-colon punctuation">::</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> sinValue <span class="token operator">=</span> <span class="token function">sin</span><span class="token punctuation">(</span><span class="token function">angleToRadians</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> cosValue <span class="token operator">=</span> <span class="token function">cos</span><span class="token punctuation">(</span><span class="token function">angleToRadians</span><span class="token punctuation">(</span>angle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> kx <span class="token operator">=</span> axis<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> ky <span class="token operator">=</span> axis<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> kz <span class="token operator">=</span> axis<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    K <span class="token operator">&lt;&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token operator">-</span>kz<span class="token punctuation">,</span> ky<span class="token punctuation">,</span>
         kz<span class="token punctuation">,</span>  <span class="token number">0</span><span class="token punctuation">,</span>   <span class="token operator">-</span>kx<span class="token punctuation">,</span>
         <span class="token operator">-</span>ky<span class="token punctuation">,</span> kx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Eigen<span class="token double-colon punctuation">::</span><span class="token class-name">Matrix4f</span><span class="token double-colon punctuation">::</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> sinValue<span class="token operator">*</span>K <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>cosValue<span class="token punctuation">)</span><span class="token operator">*</span>K<span class="token operator">*</span>K<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结">总结</h3>
<p>第一个作业难度甚至可以说低。唯一的难点在于对 <code>zNear</code> 和 <code>zFar</code> 的理解是否有误，这一点当时卡了我一定时间，解决该问题的同时对整个透视投影的理解也加深了许多。</p>
<h2 id="Assignment2-光栅化">Assignment2 光栅化</h2>
<p>第二个作业要求利用 Z-Buffer 算法实现光栅化。</p>
<h3 id="判断是否在三角形内">判断是否在三角形内</h3>
<p>经过透视投影后，我们知道了三角形三个顶点在屏幕空间中的坐标。那么对于屏幕空间内的 pixel，可以利用重心坐标来判断是否在三角形内，如果重心坐标的三个值均在 $[0, 1]$ 之间，那么就认为这个 pixel 在三角形内。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">static</span> <span class="token keyword">bool</span> <span class="token function">insideTriangle</span><span class="token punctuation">(</span><span class="token keyword">float</span> x<span class="token punctuation">,</span> <span class="token keyword">float</span> y<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">*</span> _v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">auto</span> <span class="token punctuation">[</span>alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> gamma<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computeBarycentric2D</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> _v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> alpha <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> beta <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> gamma <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>computeBarycentric2D()</code> 是课程框架为我们实现好的求重心坐标的函数，直接用即可。</p>
<h3 id="对三角形进行光栅化">对三角形进行光栅化</h3>
<p>要实现的函数为 <code>rasterize_triangle()</code>。为了减少开销，我们只需要在三角形的 bounding box 内遍历 pixel 即可。</p>
<blockquote>
<p>可能存在的 corner case 是三角形顶点坐标不在可视空间内，所以需要对 bounding box 的边界进行特殊处理。</p>
</blockquote>
<p>如果一个 pixel 在三角形内，那么我们需要利用重心坐标求出对应的深度值，并判断是否需要用当前 RGB 覆盖原有的。因为这里是右手系，所以求出的点的 $\mathbf{z}$ 值都是负数，这个值越大，说明离原点（相机）越近，就是要覆盖的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> rst<span class="token double-colon punctuation">::</span>rasterizer<span class="token double-colon punctuation">::</span><span class="token function">rasterize_triangle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Triangle<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 求解 bounding box（略）</span>

    <span class="token comment">// 遍历 pixel</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> min_x<span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> max_x<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> min_y<span class="token punctuation">;</span> y <span class="token operator">&lt;=</span> max_y<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> pixel_index <span class="token operator">=</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// pixel center 坐标值</span>
            <span class="token keyword">float</span> sampleX <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> sampleY <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">insideTriangle</span><span class="token punctuation">(</span>sampleX<span class="token punctuation">,</span> sampleY<span class="token punctuation">,</span> t<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token keyword">auto</span><span class="token punctuation">[</span>alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> gamma<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computeBarycentric2D</span><span class="token punctuation">(</span>sampleY<span class="token punctuation">,</span> sampleY<span class="token punctuation">,</span> t<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>

            <span class="token comment">// 下面这段代码是什么意思呢？</span>
            <span class="token keyword">float</span> w_reciprocal <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> z_interpolated <span class="token operator">=</span> alpha <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> gamma <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            z_interpolated <span class="token operator">*=</span> w_reciprocal<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isinf</span><span class="token punctuation">(</span>depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">||</span> z_interpolated <span class="token operator">&gt;</span> depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span> <span class="token operator">=</span> z_interpolated<span class="token punctuation">;</span>
                <span class="token function">set_pixel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意到框架让我们用注释的方法求深度值，但提供的代码有些莫名其妙。查阅资料发现，可视空间中的三角形经过透视投影变换到了屏幕空间后，同一点 $P$ 的重心坐标会发生变化，所以不能直接用屏幕空间中的重心坐标来插值三角形的在可视空间中的真实属性，而需要用一定手段进行<strong>校正</strong>。</p>
<p>🙋‍♂️ 看到这里需要特别说明一下，下面所有在<strong>屏幕空间</strong>中（求出）的值都会加上 $\prime$，如果没有，则表明这个值是属于<strong>可视空间/真实空间</strong>的。</p>
<p>网上关于这个的资料已经非常详细了，我直接贴结论：</p>
<p>$$
\frac{1}{z_P} = \frac{\alpha’}{z_A}+\frac{\beta’}{z_B}+\frac{\gamma’}{z_C}
$$</p>
<blockquote>
<p>解释一下，其中 $\alpha’, \beta’, \gamma’$ 是点 $P$ 在 $\triangle{ABC}$ 中<strong>屏幕空间</strong>下的重心坐标，而 $z_P, z_A, z_B, z_C$ 都是这些点在<strong>可视空间</strong>中的 $\mathbf{z}$ 值。</p>
</blockquote>
<p>如果想通过插值求点 $P$ 的属性 $I$，那就用以下公式：</p>
<p>$$
I_P = z_P[\frac{\alpha’}{z_A}I_A + \frac{\beta’}{z_B}I_B + \frac{\gamma’}{z_C}I_C] = \frac{\frac{\alpha’}{z_A}I_A + \frac{\beta’}{z_B}I_B + \frac{\gamma’}{z_C}I_C}{\frac{\alpha’}{z_A}+\frac{\beta’}{z_B}+\frac{\gamma’}{z_C}}
$$</p>
<p>而透视投影矩阵的第四行为 $[0,0,1,0]$，也就是说最后得到的 $\mathbf{w}$ 值自然就存储了顶点的真实深度。这就是为什么框架给的代码用的是齐次坐标 $\mathbf{w}$ 值而不是 $\mathbf{z}$ 值了——屏幕空间中的 $\mathbf{z}$ 值是经过投影变换后的，不是真实深度。</p>
<blockquote>
<p>至于之前的旋转平移变换，都只是改变绝对位置，相对位置还是不变的，所以不会影响深度，只要看透视投影就行。</p>
</blockquote>
<p>那么框架的代码就很容易理解了，<code>z_interpolated</code> 并不是真实深度，而是可视空间深度。只不过框架这里存在问题，前面 <code>v = t.toVector4()</code> 的时候，函数 <code>toVector4()</code> 里对 $\mathbf{w}$ 的赋值竟然直接赋了 <code>1</code>，这就导致所谓的校正仍然 fall back 到线性插值。虽然结果看起来没啥问题，但这也是一个值得注意的点。</p>
<h3 id="BONUS-MSAA">BONUS: MSAA</h3>
<p>为了实现 MSAA，就不能对于一个 pixel 设置一个 Z Buffer 值了。假设我们用 $n\times n$ 个采样点对同一个 pixel 进行采样，那么就需要对同一个 pixel 设置 $n\times n$ 个 Z Buffer，与等量的 RGB Buffer，这样之后就可以求一个 pixel 内所有采样点的 RGB 平均值来上色。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> rst<span class="token double-colon punctuation">::</span>rasterizer<span class="token double-colon punctuation">::</span><span class="token function">rasterize_triangle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Triangle<span class="token operator">&amp;</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 求解 bounding box（略）</span>

    <span class="token keyword">const</span> <span class="token keyword">int</span> sample_count <span class="token operator">=</span> msaa<span class="token operator">*</span>msaa<span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> min_x<span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> max_x<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> min_y<span class="token punctuation">;</span> y <span class="token operator">&lt;=</span> max_y<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> pixel_index <span class="token operator">=</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sample_count<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">float</span> samplePointWidth <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span>msaa<span class="token punctuation">;</span>
                <span class="token keyword">int</span> col <span class="token operator">=</span> i<span class="token operator">%</span>msaa<span class="token punctuation">;</span>
                <span class="token keyword">int</span> row <span class="token operator">=</span> i<span class="token operator">/</span>msaa<span class="token punctuation">;</span>
                <span class="token comment">// 计算采样点中心坐标</span>
                <span class="token keyword">float</span> sampleX <span class="token operator">=</span> x <span class="token operator">+</span> col<span class="token operator">*</span>samplePointWidth <span class="token operator">+</span> samplePointWidth<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
                <span class="token keyword">float</span> sampleY <span class="token operator">=</span> y <span class="token operator">+</span> row<span class="token operator">*</span>samplePointWidth <span class="token operator">+</span> samplePointWidth<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">insideTriangle</span><span class="token punctuation">(</span>sampleX<span class="token punctuation">,</span> sampleY<span class="token punctuation">,</span> t<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

                <span class="token keyword">auto</span><span class="token punctuation">[</span>alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> gamma<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computeBarycentric2D</span><span class="token punctuation">(</span>sampleX<span class="token punctuation">,</span> sampleY<span class="token punctuation">,</span> t<span class="token punctuation">.</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">float</span> w_reciprocal <span class="token operator">=</span> <span class="token number">1.0</span><span class="token operator">/</span><span class="token punctuation">(</span>alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token keyword">float</span> z_interpolated <span class="token operator">=</span> alpha <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> gamma <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                z_interpolated <span class="token operator">*=</span> w_reciprocal<span class="token punctuation">;</span>

                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isinf</span><span class="token punctuation">(</span>sample_depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token operator">||</span> z_interpolated <span class="token operator">&gt;</span> sample_depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    sample_depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> z_interpolated<span class="token punctuation">;</span>
                    sample_color_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    count<span class="token operator">++</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// 即上色结果有更新</span>
                Vector3f res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> color <span class="token operator">:</span> sample_color_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                    res <span class="token operator">+=</span> color<span class="token punctuation">;</span>
                <span class="token punctuation">}</span>
                <span class="token function">set_pixel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> res<span class="token operator">/</span><span class="token punctuation">(</span>sample_count<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结-2">总结</h3>
<p>校正插值是本次作业的难点，需要好好理解推导过程。</p>
<p>输出结果如下：</p>
<img src="./MSAA.png" style="zoom:70%">
<p>左侧是不用 MSAA 的结果，右侧是使用 4×MSAA 的结果，可以看到锯齿得到了明显改善。</p>
<h2 id="Assignment3-纹理与插值">Assignment3 纹理与插值</h2>
<p>第三个作业要求我们实现更多属性的插值，并且将纹理应用到模型上。</p>
<h3 id="更多的插值与法线着色">更多的插值与法线着色</h3>
<p>有了作业 2 的前置知识，其实求真实属性已经不是什么难点了，只不过这次 <code>rasterize_triangle()</code> 函数中多了一个名为 <code>view_pos</code> 的参数，通过阅读 <code>draw()</code> 函数我们发现，这正是三角形顶点在可视空间中的坐标，这样一来真实深度就有了，只要在屏幕空间求一遍重心坐标即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> rst<span class="token double-colon punctuation">::</span>rasterizer<span class="token double-colon punctuation">::</span><span class="token function">rasterize_triangle</span><span class="token punctuation">(</span><span class="token keyword">const</span> Triangle<span class="token operator">&amp;</span> t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span>Eigen<span class="token double-colon punctuation">::</span>Vector3f<span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> view_pos<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 求解 bounding box（略）</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> x <span class="token operator">=</span> min_x<span class="token punctuation">;</span> x <span class="token operator">&lt;=</span> max_x<span class="token punctuation">;</span> x<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">=</span> min_y<span class="token punctuation">;</span> y <span class="token operator">&lt;=</span> max_y<span class="token punctuation">;</span> y<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">int</span> pixel_index <span class="token operator">=</span> <span class="token function">get_index</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> sampleX <span class="token operator">=</span> x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> sampleY <span class="token operator">=</span> y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">insideTriangle</span><span class="token punctuation">(</span>sampleX<span class="token punctuation">,</span> sampleY<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>

            <span class="token keyword">auto</span><span class="token punctuation">[</span>alpha<span class="token punctuation">,</span> beta<span class="token punctuation">,</span> gamma<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">computeBarycentric2D</span><span class="token punctuation">(</span>sampleX<span class="token punctuation">,</span> sampleY<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Barycentric Coordinates</span>

            <span class="token keyword">float</span> Z <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                             gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// depth in view space</span>
            <span class="token keyword">float</span> zp <span class="token operator">=</span>
                alpha <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> beta <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span>
                gamma <span class="token operator">*</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">z</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// depth in projection space</span>
            zp <span class="token operator">*=</span> Z<span class="token punctuation">;</span>

            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isinf</span><span class="token punctuation">(</span>depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">||</span> zp <span class="token operator">&gt;</span> depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                depth_buf<span class="token punctuation">[</span>pixel_index<span class="token punctuation">]</span> <span class="token operator">=</span> zp<span class="token punctuation">;</span>

                <span class="token comment">// 各个属性的插值结果</span>
                Vector3f interpolated_color <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>
                    alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    t<span class="token punctuation">.</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> Z<span class="token punctuation">)</span><span class="token punctuation">;</span>

                Vector3f interpolated_normal <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>
                    alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    t<span class="token punctuation">.</span>normal<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>normal<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>normal<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> Z<span class="token punctuation">)</span><span class="token punctuation">;</span>

                Vector2f interpolated_texcoords <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>
                    alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    t<span class="token punctuation">.</span>tex_coords<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tex_coords<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">.</span>tex_coords<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> Z<span class="token punctuation">)</span><span class="token punctuation">;</span>

                Vector3f interpolated_shadingcoords <span class="token operator">=</span> <span class="token function">interpolate</span><span class="token punctuation">(</span>
                    alpha <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> beta <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> gamma <span class="token operator">/</span> v<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    view_pos<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> view_pos<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> view_pos<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">/</span> Z<span class="token punctuation">)</span><span class="token punctuation">;</span>

                <span class="token comment">// 一个数据结构，传递给 fragment_shader 以求出上色结果</span>
                fragment_shader_payload <span class="token function">payload</span><span class="token punctuation">(</span>
                    interpolated_color<span class="token punctuation">,</span> interpolated_normal<span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                    interpolated_texcoords<span class="token punctuation">,</span> texture <span class="token operator">?</span> <span class="token operator">&amp;</span><span class="token operator">*</span>texture <span class="token operator">:</span> <span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                payload<span class="token punctuation">.</span>view_pos <span class="token operator">=</span> interpolated_shadingcoords<span class="token punctuation">;</span>

                Vector3f pixel_color <span class="token operator">=</span> <span class="token function">fragment_shader</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token function">set_pixel</span><span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y<span class="token punctuation">}</span><span class="token punctuation">,</span> pixel_color<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果如下：</p>
<img src="./normal.png" style="zoom:40%">
<h3 id="Blinn-Phong-着色">Blinn Phong 着色</h3>
<p>Blinn Phong 模型里面有三个项：漫反射项、高光项、环境光项。这些项的所需参数大部分都在框架中给出，需要我们求的有</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>光线方向 $\mathbf{l}$；</p>
</li>
<li class="lvl-2">
<p>观测方向 $\mathbf{v}$；</p>
</li>
<li class="lvl-2">
<p>半程向量 $\mathbf{h}$；</p>
</li>
</ul>
<p>注意，结构体 <code>fragment_shader_payload</code> 中包含了非常多有用信息，比如</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>着色点真实坐标 <code>view_pos</code>；</p>
</li>
<li class="lvl-2">
<p>着色点 RGB <code>color</code>；</p>
</li>
<li class="lvl-2">
<p>着色点法线方向 <code>normal</code>；</p>
</li>
<li class="lvl-2">
<p>着色点纹理坐标 <code>tex_coords</code>；</p>
</li>
<li class="lvl-2">
<p>着色点所在模型对应的纹理 <code>texture</code>；</p>
</li>
</ul>
<p>那么 $\mathbf{l},\mathbf{v},\mathbf{h}$ 就很好求了，要注意的是公式里的这些变量都是单位向量，要调用 <code>normalized()</code> 进行单位化。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Vector3f <span class="token function">phong_fragment_shader</span><span class="token punctuation">(</span><span class="token keyword">const</span> fragment_shader_payload<span class="token operator">&amp;</span> payload<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f ka <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">,</span> <span class="token number">0.005</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f kd <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f ks <span class="token operator">=</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span><span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">,</span> <span class="token number">0.7937</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> l1 <span class="token operator">=</span> light<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> l2 <span class="token operator">=</span> light<span class="token punctuation">{</span><span class="token punctuation">{</span><span class="token operator">-</span><span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>light<span class="token operator">&gt;</span> lights <span class="token operator">=</span> <span class="token punctuation">{</span>l1<span class="token punctuation">,</span> l2<span class="token punctuation">}</span><span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f amb_light_intensity<span class="token punctuation">{</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f eye_pos<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> p <span class="token operator">=</span> <span class="token number">150</span><span class="token punctuation">;</span>

    Eigen<span class="token double-colon punctuation">::</span>Vector3f color <span class="token operator">=</span> payload<span class="token punctuation">.</span>color<span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f point <span class="token operator">=</span> payload<span class="token punctuation">.</span>view_pos<span class="token punctuation">;</span>
    Eigen<span class="token double-colon punctuation">::</span>Vector3f normal <span class="token operator">=</span> payload<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>

    Eigen<span class="token double-colon punctuation">::</span>Vector3f result_color <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> light <span class="token operator">:</span> lights<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        Vector3f l <span class="token operator">=</span> <span class="token punctuation">(</span>light<span class="token punctuation">.</span>position <span class="token operator">-</span> point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 光线方向</span>
        Vector3f v <span class="token operator">=</span> <span class="token punctuation">(</span>eye_pos <span class="token operator">-</span> point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment">// 观测方向</span>
        Vector3f h <span class="token operator">=</span> <span class="token punctuation">(</span>l <span class="token operator">+</span> v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                   <span class="token comment">// 半程向量</span>
        <span class="token keyword">float</span> r_square <span class="token operator">=</span> <span class="token punctuation">(</span>light<span class="token punctuation">.</span>position <span class="token operator">-</span> point<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>light<span class="token punctuation">.</span>position <span class="token operator">-</span> point<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Vector3f light_intensity <span class="token operator">=</span> light<span class="token punctuation">.</span>intensity <span class="token operator">/</span> r_square<span class="token punctuation">;</span>

        Vector3f ambient_item <span class="token operator">=</span> <span class="token function">product</span><span class="token punctuation">(</span>ka<span class="token punctuation">,</span> amb_light_intensity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 环境光项</span>
        Vector3f diffuse_item <span class="token operator">=</span>
            <span class="token function">product</span><span class="token punctuation">(</span>kd<span class="token punctuation">,</span> light_intensity<span class="token punctuation">)</span> <span class="token operator">*</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 漫反射项</span>
        Vector3f specular_item <span class="token operator">=</span>
            <span class="token function">product</span><span class="token punctuation">(</span>ks<span class="token punctuation">,</span> light_intensity<span class="token punctuation">)</span> <span class="token operator">*</span>
            std<span class="token double-colon punctuation">::</span><span class="token function">pow</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">max</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">float</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token number">0.0</span><span class="token punctuation">,</span> normal<span class="token punctuation">.</span><span class="token function">dot</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 高光项</span>
        result_color <span class="token operator">+=</span> ambient_item <span class="token operator">+</span> diffuse_item <span class="token operator">+</span> specular_item<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">return</span> result_color <span class="token operator">*</span> <span class="token number">255.f</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>这里 <code>ka</code>/<code>kd</code>/<code>ks</code>/<code>light_intensity</code> 都是三元向量，分别在 RGB 三个通道上进行乘算，最后的结果也是一个三元向量，那就需要定义一个新的向量乘法，使得 $\text{product}([a_1, a_2, \dots, a_n], [b_1, b_2, \dots, b_n]) = [a1<em>b_1, a2</em>b_2,\dots,a_n*b_n]$。</p>
</blockquote>
<p>输出结果如下：</p>
<img src="./phong.png" style="zoom:40%">
<h3 id="纹理着色">纹理着色</h3>
<p>这一步是在 Blinn Phong 的基础上用纹理中的 RGB 值代替模型本身 RGB 值，在前面加上以下代码即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>payload<span class="token punctuation">.</span>texture<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">float</span> u <span class="token operator">=</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">x</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> v <span class="token operator">=</span> payload<span class="token punctuation">.</span>tex_coords<span class="token punctuation">.</span><span class="token function">y</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    return_color <span class="token operator">=</span> payload<span class="token punctuation">.</span>texture<span class="token operator">-&gt;</span><span class="token function">getColorBilinear</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果如下：</p>
<img src="./texture.png" style="zoom:40%">
<h3 id="凹凸贴图">凹凸贴图</h3>
<p>按照注释实现即可，其中 TBN 矩阵会在后续进行推导。输出结果如下：</p>
<img src="./bump.png" style="zoom:40%">
<h3 id="位移贴图">位移贴图</h3>
<p>依然是按照注释实现。输出结果如下：</p>
<img src="./displacement.png" style="zoom:40%">
<h3 id="BONUS-双线性插值">BONUS: 双线性插值</h3>
<p>我们需要在 <code>Texture.hpp</code> 里实现函数 <code>getColorBilinear()</code>。结合下面这张图，我们可以得出一些思路。</p>
<img src="./bilinear.png" style="zoom:40%">
<p>第一步要做的是找出离纹理坐标系上的一点 $(u, v)$ 最近的 4 个 texel，那么就需要根据这个点在当前 texel 的位置进行判断。我们可以计算当前点到左侧 texel 中心在横坐标上的距离（对应公式中的 $s$），如果值大于 1，说明在横向上最近的是右侧 texel，反之是左侧的 texel。我们只需要将当前 $(u, v)$ 定位到 4 个 texel 中左下的那个，就可以很方便地进行计算了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Eigen<span class="token double-colon punctuation">::</span>Vector3f <span class="token function">getColorBilinear</span><span class="token punctuation">(</span><span class="token keyword">float</span> u<span class="token punctuation">,</span> <span class="token keyword">float</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// 纹理图是一个矩阵，要用行/列的形式访问</span>
    <span class="token keyword">auto</span> u_img <span class="token operator">=</span> u <span class="token operator">*</span> width<span class="token punctuation">;</span>        <span class="token comment">// 矩阵列</span>
    <span class="token keyword">auto</span> v_img <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> v<span class="token punctuation">)</span> <span class="token operator">*</span> height<span class="token punctuation">;</span> <span class="token comment">// 矩阵行</span>

    <span class="token keyword">float</span> s <span class="token operator">=</span> u_img<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>u_img <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> t <span class="token operator">=</span> v_img<span class="token operator">-</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>v_img <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        s <span class="token operator">=</span> s<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        u_img <span class="token operator">=</span> u_img<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        t <span class="token operator">=</span> t<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        v_img <span class="token operator">=</span> v_img<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">auto</span> u00 <span class="token operator">=</span> image_data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v_img<span class="token punctuation">,</span> u_img<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> u10 <span class="token operator">=</span> image_data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v_img<span class="token punctuation">,</span> u_img <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> u01 <span class="token operator">=</span> image_data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v_img <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> u_img<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> u11 <span class="token operator">=</span> image_data<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>v_img <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> u_img <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> u0 <span class="token operator">=</span> u00 <span class="token operator">+</span> s <span class="token operator">*</span> <span class="token punctuation">(</span>u10 <span class="token operator">-</span> u00<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">auto</span> u1 <span class="token operator">=</span> u01 <span class="token operator">+</span> t <span class="token operator">*</span> <span class="token punctuation">(</span>u11 <span class="token operator">-</span> u01<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">auto</span> color <span class="token operator">=</span> u0 <span class="token operator">+</span> t <span class="token operator">*</span> <span class="token punctuation">(</span>u1 <span class="token operator">-</span> u0<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token class-name">Eigen</span><span class="token double-colon punctuation">::</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>color<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> color<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果对比（奶牛鼻子处），右侧是采用双线性插值的结果，可以看到过渡更加平滑。</p>
<img src="./bi.png" style="zoom:70%">
<h3 id="总结-3">总结</h3>
<p>框架帮我们实现了 <code>insideTriangle()</code> 函数，但可能会出现纹理坐标 $&gt;1$ 的情况，修改为用重心坐标判断就 ok 了。</p>
<h2 id="Assignment4-贝塞尔曲线">Assignment4 贝塞尔曲线</h2>
<p>第四个作业要求我们绘制贝塞尔曲线。</p>
<h3 id="贝塞尔曲线">贝塞尔曲线</h3>
<p>课程给的框架中为我们实现了一个静态的贝塞尔曲线绘制函数 <code>naive_bezier()</code>，根据 4 个控制点进行绘制。我们需要实现另一个递归的版本。</p>
<p>递归版本的思路是：对于给定控制点集 $C={c_1, c_2, \dots, c_n}$，取所有的相邻的两个控制点 $c_i, c_{i+1}$，找到所有的 $n-1$ 个 $t$ 分点 $c_{i, t} = t*c_i + (1-t)*c_{i+1}$ 加入新的控制点集合 $C’ = {c_{1,t}, c_{2,t}, \dots, c_{n-1, t}}$ ，并作为递归函数的参数传入。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cv<span class="token double-colon punctuation">::</span>Point2f <span class="token function">recursive_bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> <span class="token keyword">float</span> t<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> control_points<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> new_control_points<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> control_points<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        new_control_points<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>t <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>t<span class="token punctuation">)</span> <span class="token operator">*</span> control_points<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>new_control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">bezier</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>Mat <span class="token operator">&amp;</span>window<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> t <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> <span class="token number">0.001</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cv<span class="token double-colon punctuation">::</span>Point2f point <span class="token operator">=</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 找到 bezier(t) 的点</span>
        <span class="token comment">// 通道 [1] 是 G 值，[2] 是 R 值</span>
        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>point<span class="token punctuation">.</span>y<span class="token punctuation">,</span> point<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">255</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>虽然课程框架只说实现 4 个控制点的版本，但是递归的实现应该能够支持任意数量的控制点。</p>
</blockquote>
<p>输出结果如下：</p>
<img src="./my_bezier_curve.png" style="zoom:70%">
<h3 id="反走样">反走样</h3>
<p>曲线反走样的基本思路就是<strong>加粗</strong>。虽然这里不能用双线性插值，因为最近的 4 个像素点不一定都有颜色，但是也值得参考。我们可以找最近的四个 pixel，根据 <code>bezier(t)</code> 与这些 pixels 中心点的距离来为其赋予相应的 G 值。</p>
<p>对于一个点来说，其与最近 4 个 pixel-center 的距离应该在区间 $[0, \sqrt{2}]$ 内，并且离一个 pixel 越近，这个 pixel 的 G 值就应该越高，可以简单的用公式 $\displaystyle G = 255*(1-\frac{d}{\sqrt{2}})$ 来线性计算，从而得到下面的代码</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">bezier_antialiasing</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Point2f<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>control_points<span class="token punctuation">,</span> cv<span class="token double-colon punctuation">::</span>Mat <span class="token operator">&amp;</span>window<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">double</span> t <span class="token operator">=</span> <span class="token number">0.0</span><span class="token punctuation">;</span> t <span class="token operator">&lt;=</span> <span class="token number">1.0</span><span class="token punctuation">;</span> t <span class="token operator">+=</span> <span class="token number">0.001</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cv<span class="token double-colon punctuation">::</span>Point2f point <span class="token operator">=</span> <span class="token function">recursive_bezier</span><span class="token punctuation">(</span>control_points<span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token keyword">float</span> x <span class="token operator">=</span> point<span class="token punctuation">.</span>x<span class="token punctuation">;</span>
        <span class="token keyword">float</span> y <span class="token operator">=</span> point<span class="token punctuation">.</span>y<span class="token punctuation">;</span>
        <span class="token keyword">float</span> u <span class="token operator">=</span> x <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>x <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> v <span class="token operator">=</span> y <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>y <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>u <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            u <span class="token operator">=</span> u<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>v <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            v <span class="token operator">=</span> v<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        <span class="token keyword">float</span> d00 <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> d01 <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>u<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> d10 <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span>u<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> d11 <span class="token operator">=</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>u<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">-</span>v<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>
            <span class="token function">fmin</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">255</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>d00 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>
            <span class="token function">fmin</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">255.0</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>d01 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>
            <span class="token function">fmin</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">255.0</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>d10 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span>
            <span class="token function">fmin</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">,</span> window<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">at</span><span class="token generic class-name"><span class="token operator">&lt;</span>cv<span class="token double-colon punctuation">::</span>Vec3b<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>y <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">255.0</span> <span class="token operator">*</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token function">sqrt</span><span class="token punctuation">(</span>d11 <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>输出结果如下：</p>
<img src="./my_bezier_curve_anti_aliasing.png" style="zoom:70%">
<p>可以看到锯齿现象得到了明显改善。</p>
<h3 id="总结-4">总结</h3>
<p>没有难度。</p>
<h2 id="Assignment5-光线追踪">Assignment5 光线追踪</h2>
<p>说是光追，实际上要实现的部分并不多，整体以阅读框架为主。</p>
<p>按照作业要求所述，在 <code>main()</code> 中首先定义了场景 <code>scene</code>，并且调用 <code>add()</code> 方法加入各个物体，之后用 <code>Render.render()</code> 进行渲染。</p>
<p>这里的渲染方式很简单，对于屏幕空间中的每个像素，以相机为起点向可视空间中打出一条光线，找到光线的与第一个物体表面的交点，根据材质判断是否要进行反射/折射，并令光线进一步传播。如果光线最终能不遮挡地到达光源，那么这条光路就会被<strong>有效渲染</strong>，即将后续所有弹射点的着色值加到第一个交点上。</p>
<p>我们要实现两个函数，分别是确定打出光线的方向，以及判断光线和三角形的交点。</p>
<h3 id="确定光线方向">确定光线方向</h3>
<p>因为有 MVP 变换，所以相机视为在 $xOy$ 平面上永远处于屏幕空间的中心，也就是 $(scene.width/2, scene.height/2)$。我们只要确定相机到屏幕的距离 $z$，就可以用像素中心坐标减去像素坐标，构造一个方向向量，<code>normalized()</code> 之后就是要求的光线方向了。</p>
<p><code>scene</code> 中有一个参数 <code>fov</code>，表示相机在 $\mathbf{y}$ 方向的视角，有 $\displaystyle \tan(\text{fov}/2) = \frac{scene.height}{2z}$，这样就能算出 $z$ 了。</p>
<p>关于像素中心的坐标，这里有一个坑点在于，代码中的 $i, j$ 实际上是从左上角的像素开始，往右下角进行遍历的，而不是我们平常认知中的平面直角坐标系的遍历方式。在 $\mathbf{x}$ 方向上的分量很好求，就是 $i-scene.width/2+0.5$，但是 $\mathbf{y}$ 方向上的分量就不是 $j-scene.height/2+0.5$ 了，而是其相反数。</p>
<p>所以得到以下代码（稍作修改，更加可读）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Renderer</span><span class="token double-colon punctuation">::</span><span class="token function">Render</span><span class="token punctuation">(</span><span class="token keyword">const</span> Scene<span class="token operator">&amp;</span> scene<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> w <span class="token operator">=</span> scene<span class="token punctuation">.</span>width<span class="token punctuation">;</span>
    <span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> h <span class="token operator">=</span> scene<span class="token punctuation">.</span>height<span class="token punctuation">;</span>

    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Vector3f<span class="token operator">&gt;</span> <span class="token function">framebuffer</span><span class="token punctuation">(</span>w <span class="token operator">*</span> h<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> z <span class="token operator">=</span> h <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">/</span> std<span class="token double-colon punctuation">::</span><span class="token function">tan</span><span class="token punctuation">(</span><span class="token function">deg2rad</span><span class="token punctuation">(</span>scene<span class="token punctuation">.</span>fov <span class="token operator">*</span> <span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Use this variable as the eye position to start your rays.</span>
    Vector3f <span class="token function">eye_pos</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> h<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        <span class="token keyword">float</span> y <span class="token operator">=</span> h <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">-</span> j <span class="token operator">-</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> w<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            <span class="token comment">// generate primary ray direction</span>
            <span class="token keyword">float</span> x <span class="token operator">=</span> i <span class="token operator">-</span> w <span class="token operator">*</span> <span class="token number">0.5</span> <span class="token operator">+</span> <span class="token number">0.5</span><span class="token punctuation">;</span>
            Vector3f dir <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span><span class="token function">Vector3f</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> <span class="token operator">-</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            framebuffer<span class="token punctuation">[</span>m<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span>eye_pos<span class="token punctuation">,</span> dir<span class="token punctuation">,</span> scene<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">UpdateProgress</span><span class="token punctuation">(</span>j <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>h<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意 $z$ 要取负值，因为是往 $-\mathbf{z}$ 侧发出的光线。</p>
</blockquote>
<h3 id="与三角形的交点">与三角形的交点</h3>
<p>用上课讲的 Möller–Trumbore 算法即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">rayTriangleIntersect</span><span class="token punctuation">(</span><span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v0<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v1<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> v2<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> orig<span class="token punctuation">,</span>
                          <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> dir<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> tnear<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> u<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> v<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token comment">// o + t * d = (1-alpha-beta) * v0 + alpha * v1 + beta * v2</span>
    <span class="token comment">// t * (-d) + alpha * (v1 - v0) + beta * (v2 - v0) = o - v0</span>
    <span class="token comment">// [-d, v1-v0, v2-v0] * [t, alpha, beta]^T = o-v0</span>
    Vector3f X <span class="token operator">=</span> <span class="token operator">-</span>dir<span class="token punctuation">;</span>
    Vector3f Y <span class="token operator">=</span> v1<span class="token operator">-</span>v0<span class="token punctuation">;</span>
    Vector3f Z <span class="token operator">=</span> v2<span class="token operator">-</span>v0<span class="token punctuation">;</span>
    Vector3f W <span class="token operator">=</span> orig<span class="token operator">-</span>v0<span class="token punctuation">;</span>

    <span class="token comment">// Cramer's rule</span>
    <span class="token keyword">float</span> detA <span class="token operator">=</span> <span class="token function">Determinant</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Z<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> t <span class="token operator">=</span> <span class="token function">Determinant</span><span class="token punctuation">(</span>W<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Z<span class="token punctuation">)</span><span class="token operator">/</span>detA<span class="token punctuation">;</span>
    <span class="token keyword">float</span> alpha <span class="token operator">=</span> <span class="token function">Determinant</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> W<span class="token punctuation">,</span> Z<span class="token punctuation">)</span><span class="token operator">/</span>detA<span class="token punctuation">;</span>
    <span class="token keyword">float</span> beta <span class="token operator">=</span> <span class="token function">Determinant</span><span class="token punctuation">(</span>X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> W<span class="token punctuation">)</span><span class="token operator">/</span>detA<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">&lt;=</span> <span class="token number">0.f</span> <span class="token operator">||</span> alpha <span class="token operator">&lt;</span> <span class="token number">0.f</span> <span class="token operator">||</span> beta <span class="token operator">&lt;</span> <span class="token number">0.f</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token operator">-</span>alpha<span class="token operator">-</span>beta <span class="token operator">&lt;</span> <span class="token number">0.f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    tnear <span class="token operator">=</span> t<span class="token punctuation">;</span>
    <span class="token comment">// 这里参数意义不明，tnear 并不是全局最近，而仅仅是与三角形的交点的 t 值，用于在 trace() 里更新全局最近 t</span>
    u <span class="token operator">=</span> alpha<span class="token punctuation">;</span>
    v <span class="token operator">=</span> beta<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>注意判断交点是否在三角形内时不能用 $\leq0$，因为顶点也算在三角形内。</p>
</blockquote>
<h3 id="总结-5">总结</h3>
<p>CMakeLists 里的编译选项中有一个 <code>-fsanitize=undefined</code>，这会导致出现 <code>runtime error: xxx is outside the range of representable values of type 'char'</code> 的报错，将这个选项去掉就能 work 了。</p>
<p>输出结果如下：</p>
<img src="./raytrace.png" style="zoom:70%">
<h2 id="Assignment6-BVH-加速结构">Assignment6 BVH 加速结构</h2>
<p>本次作业要求用 BVH 对光追进行加速。具体原理见课程笔记，简单来说其核心思想就是对物体进行划分，构建一棵 BVH-Tree，以二分的方式找到光线在场景中与物体的第一个交点，而不用遍历所有的物体，从而达到加速的效果。</p>
<h3 id="判断-AABB-是否与光线相交">判断 AABB 是否与光线相交</h3>
<p>求出光线与三对平面的 $tmin, tmax$，然后判断这三个区间是否在 $\geq0$ 处有交集即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">bool</span> <span class="token class-name">Bounds3</span><span class="token double-colon punctuation">::</span><span class="token function">IntersectP</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ray<span class="token operator">&amp;</span> ray<span class="token punctuation">,</span> <span class="token keyword">const</span> Vector3f<span class="token operator">&amp;</span> invDir<span class="token punctuation">,</span>
                                <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> dirIsNeg<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    Vector3f tmin <span class="token operator">=</span> <span class="token punctuation">(</span>pMin <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">*</span> invDir<span class="token punctuation">;</span>
    Vector3f tmax <span class="token operator">=</span> <span class="token punctuation">(</span>pMax <span class="token operator">-</span> ray<span class="token punctuation">.</span>origin<span class="token punctuation">)</span> <span class="token operator">*</span> invDir<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirIsNeg<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>tmin<span class="token punctuation">.</span>x<span class="token punctuation">,</span> tmax<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirIsNeg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>tmin<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tmax<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>dirIsNeg<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> std<span class="token double-colon punctuation">::</span><span class="token function">swap</span><span class="token punctuation">(</span>tmin<span class="token punctuation">.</span>z<span class="token punctuation">,</span> tmax<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span>tmin<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token function">fmax</span><span class="token punctuation">(</span>tmin<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tmin<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token function">fmin</span><span class="token punctuation">(</span>tmax<span class="token punctuation">.</span>x<span class="token punctuation">,</span> <span class="token function">fmin</span><span class="token punctuation">(</span>tmax<span class="token punctuation">.</span>y<span class="token punctuation">,</span> tmax<span class="token punctuation">.</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> b <span class="token operator">&gt;=</span> a <span class="token operator">&amp;&amp;</span> b <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="利用-BVH-加速求交">利用 BVH 加速求交</h3>
<p>对于一个给定的 BVH 节点，我们首先判断光线是否与当前的 AABB 相交。如果不相交，那么这道光和所有的子节点必然不相交；反之，这个节点要么是叶子节点，要么光线和左右子节点都相交或者只和其中一个相交，需要分情况讨论：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果是叶子节点，直接返回与物体的交点；</p>
</li>
<li class="lvl-2">
<p>如果和左右子节点都相交，那么需要求出两个交点中最近的那个；</p>
</li>
<li class="lvl-2">
<p>如果只和一个节点相交，那直接返回交点即可；</p>
</li>
</ul>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Intersection <span class="token class-name">BVHAccel</span><span class="token double-colon punctuation">::</span><span class="token function">getIntersection</span><span class="token punctuation">(</span>BVHBuildNode<span class="token operator">*</span> node<span class="token punctuation">,</span> <span class="token keyword">const</span> Ray<span class="token operator">&amp;</span> ray<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>array<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">&gt;</span> dirIsNeg<span class="token punctuation">{</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">.</span>x <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">.</span>y <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction<span class="token punctuation">.</span>z <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>bounds<span class="token punctuation">.</span><span class="token function">IntersectP</span><span class="token punctuation">(</span>ray<span class="token punctuation">,</span> ray<span class="token punctuation">.</span>direction_inv<span class="token punctuation">,</span> dirIsNeg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// 是叶子节点，直接判断是否与物体相交</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token operator">-&gt;</span>left <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> node<span class="token operator">-&gt;</span>object<span class="token operator">-&gt;</span><span class="token function">getIntersection</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>

        Intersection left  <span class="token operator">=</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>
        Intersection right  <span class="token operator">=</span> <span class="token function">getIntersection</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>right<span class="token punctuation">,</span> ray<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 都相交</span>
            <span class="token keyword">return</span> left<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> right<span class="token punctuation">.</span>distance <span class="token operator">?</span> left <span class="token operator">:</span> right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> left<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> right<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="如何构建-BVH">如何构建 BVH</h3>
<p>首先将所有物体根据分布关系进行排序——在哪个轴上分布的最多就按哪个轴排。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Bounds3 centroidBounds<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>size_t i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>
    centroidBounds <span class="token operator">=</span>
        <span class="token function">Union</span><span class="token punctuation">(</span>centroidBounds<span class="token punctuation">,</span> objects<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> dim <span class="token operator">=</span> centroidBounds<span class="token punctuation">.</span><span class="token function">maxExtent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>dim<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token number">0</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> objects<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> f1<span class="token punctuation">,</span> <span class="token keyword">auto</span> f2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> f1<span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x <span class="token operator">&lt;</span>
                f2<span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>x<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> objects<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> f1<span class="token punctuation">,</span> <span class="token keyword">auto</span> f2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> f1<span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>y <span class="token operator">&lt;</span>
                f2<span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>
    std<span class="token double-colon punctuation">::</span><span class="token function">sort</span><span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> objects<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">auto</span> f1<span class="token punctuation">,</span> <span class="token keyword">auto</span> f2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> f1<span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>z <span class="token operator">&lt;</span>
                f2<span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Centroid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>z<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后找到所有 <code>object</code> 中最中间的那个，划分成两个部分</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">auto</span> beginning <span class="token operator">=</span> objects<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> middling <span class="token operator">=</span> objects<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> ending <span class="token operator">=</span> objects<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">auto</span> leftshapes <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>Object<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>beginning<span class="token punctuation">,</span> middling<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">auto</span> rightshapes <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">vector</span><span class="token generic class-name"><span class="token operator">&lt;</span>Object<span class="token operator">*</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>middling<span class="token punctuation">,</span> ending<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对这两部分分别进行构建</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">recursiveBuild</span><span class="token punctuation">(</span>leftshapes<span class="token punctuation">)</span><span class="token punctuation">;</span>
node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">recursiveBuild</span><span class="token punctuation">(</span>rightshapes<span class="token punctuation">)</span><span class="token punctuation">;</span>

node<span class="token operator">-&gt;</span>bounds <span class="token operator">=</span> <span class="token function">Union</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>bounds<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>bounds<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于特殊情况（只有一个或两个 <code>object</code>），则无需排序。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// Create leaf _BVHBuildNode_</span>
    node<span class="token operator">-&gt;</span>bounds <span class="token operator">=</span> objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">-&gt;</span><span class="token function">getBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>object <span class="token operator">=</span> objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>objects<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node<span class="token operator">-&gt;</span>left <span class="token operator">=</span> <span class="token function">recursiveBuild</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">{</span>objects<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token operator">-&gt;</span>right <span class="token operator">=</span> <span class="token function">recursiveBuild</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token punctuation">{</span>objects<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    node<span class="token operator">-&gt;</span>bounds <span class="token operator">=</span> <span class="token function">Union</span><span class="token punctuation">(</span>node<span class="token operator">-&gt;</span>left<span class="token operator">-&gt;</span>bounds<span class="token punctuation">,</span> node<span class="token operator">-&gt;</span>right<span class="token operator">-&gt;</span>bounds<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结-6">总结</h3>
<p>SAH 的优化效果并没有特别明显，就不掰扯了。</p>
<p>输出结果如下：</p>
<img src="./bvh.png" style="zoom:70%">
<h2 id="Assignment7-Path-Tracing">Assignment7 Path Tracing</h2>
<p>最难的一次，要求实现路径追踪。这次作业坑非常多，我将一一记录。</p>
<h3 id="多线程">多线程</h3>
<p>为了提高运行效率，我先做了多线程。</p>
<p>原本的代码是，按行优先顺序遍历像素点，调用 <code>castRay()</code> 等待返回的着色结果。</p>
<p>如果要做多线程版本，比如说设置 <code>n_thread</code> 个线程，那第 <code>i</code> 个线程负责 <code>rowId % n_thread = i</code> 的行即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">Renderer</span><span class="token double-colon punctuation">::</span><span class="token function">Render</span><span class="token punctuation">(</span><span class="token keyword">const</span> Scene<span class="token operator">&amp;</span> scene<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token keyword">const</span> <span class="token keyword">int</span> n_worker <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>thread<span class="token operator">&gt;</span> worker<span class="token punctuation">;</span>
    <span class="token keyword">auto</span> task <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">&amp;</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token keyword">int</span> threadIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> threadIndex<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> scene<span class="token punctuation">.</span>height<span class="token punctuation">;</span> j <span class="token operator">+=</span> n_worker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> scene<span class="token punctuation">.</span>width<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token comment">// cast ray</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n_worker<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        worker<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;&amp;</span> w <span class="token operator">:</span> worker<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        w<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// save framebuffer to file</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>以及 <code>get_random_float()</code> 中的前三个变量都可以设为 <code>static</code>，经测试在 spp=256 的 case 下性能提高了 3 倍。</p>
<h3 id="拷贝之前的代码">拷贝之前的代码</h3>
<p>这里我们需要拷贝 <code>Bounds3::IntersectP()</code>、<code>BVHAccel::getIntersection()</code>、<code>Triangle::getIntersection</code>。</p>
<p>值得注意的是，在 <code>Bounds3::IntersectP()</code> 也就是判断光线和 AABB 是否相交的地方，需要用 <code>texit &gt;= tenter</code>，而不是 <code>&gt;</code>。这是因为作业 7 中几个物体的 AABB 可能就是一个二维平面而不是一个立方体，从而某一对平面的 <code>tenter = texit</code>。</p>
<p>如果用 <code>&gt;</code>，最后结果就是一大片漆黑。</p>
<h3 id="实现-castRay">实现 castRay</h3>
<p>当一束光线从相机出发打到可视空间中时，有三种情况：</p>
<ol>
<li class="lvl-3">
<p>光线没有打到任何物体，此时观测结果为纯黑；</p>
</li>
<li class="lvl-3">
<p>光线打到自发光物体，此时直接返回其 color（在这里是 <code>material.emit</code>）；</p>
</li>
<li class="lvl-3">
<p>光线打到不发光物体，此时需要进行直接光照与间接光照的采样；</p>
</li>
</ol>
<p>第一种情况很好实现，直接 <code>return</code> 即可，关键是第二种情况。</p>
<h4 id="直接光照">直接光照</h4>
<p>设光线打到物体的 $p$ 点。</p>
<p>对于直接光照的采样，框架为我们实现了 <code>sampleLight()</code> 方法，其原理是随机选择一个 <code>hasEmit() = true</code> 的物体（自发光物体，或者称其为光源），并在其表面上随机选择一点，返回该点的 <code>Intersection</code> 信息与 <code>pdf</code>。</p>
<p>有了这一信息后，还需要判断该光源与物体之间是否存在物体遮挡，判断方式就是以 $p$ 为起点，向光源打出一道光，判断击中的物体距离和物体与光源的距离是否相等。如果相等，则认为没有物体遮挡。</p>
<blockquote>
<p>这里距离是浮点数类型，而判断浮点类型是否相等是无法做到的，课程里是通过两数之差的绝对值小于 <code>EPLSILON</code> 来判断相等。</p>
<p>这里 <code>EPSILON</code> 比数据精度小，导致即便没有物体遮挡也会在计算中判断错误，使得结果中出现黑色条纹。这里只需要将 <code>EPSILON</code> 从 <code>0.0001</code> 改为 <code>0.001</code> 即可。</p>
<p>当然，判断光线与 AABB 是否相交也可以用 <code>texit + EPSILON &gt; tenter</code></p>
</blockquote>
<p>如果光源能直接照射到物体，那么我们就可以用公式计算直接光照项 <code>L_dir</code> 了。</p>
<p>这里如果改用光源向物体打出的光线进行遮挡判断会出现 <code>Intersection.distance = 0</code> 的错误，认为应该是光线与光源的 AABB 产生了交点，需要将起点进行偏移处理。为了方便还是采用从 $p$ 点出发的方法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Intersection light<span class="token punctuation">;</span>
<span class="token keyword">float</span> pdf<span class="token punctuation">;</span>
<span class="token function">sampleLight</span><span class="token punctuation">(</span>light<span class="token punctuation">,</span> pdf<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">float</span> dis <span class="token operator">=</span> <span class="token punctuation">(</span>hitPoint <span class="token operator">-</span> light<span class="token punctuation">.</span>coords<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Vector3f wi <span class="token operator">=</span> <span class="token punctuation">(</span>hitPoint <span class="token operator">-</span> light<span class="token punctuation">.</span>coords<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自发光物体打来的直接光照</span>
Intersection block <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token function">Ray</span><span class="token punctuation">(</span>hitPoint<span class="token punctuation">,</span> <span class="token operator">-</span>wi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 判断该光照是否被其它物体遮挡</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> dis <span class="token operator">-</span> block<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> EPSILON<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">float</span> dis2 <span class="token operator">=</span> dis<span class="token operator">*</span>dis<span class="token punctuation">;</span>
    Vector3f emit <span class="token operator">=</span> light<span class="token punctuation">.</span>emit<span class="token punctuation">;</span>
    Vector3f eval <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> cosThetaPrime <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> light<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    L_dir <span class="token operator">=</span> emit <span class="token operator">*</span> eval <span class="token operator">*</span> cosTheta <span class="token operator">*</span> cosThetaPrime <span class="token operator">/</span> dis2 <span class="token operator">/</span> pdf<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="间接光照">间接光照</h4>
<p>对于间接光照的计算，首先要用俄罗斯轮盘赌策略来判断是否需要继续递归。框架提供的随机数函数是 <code>get_random_float()</code>。如果进行了之前提到的优化，这一步的时间开销将会大大降低。</p>
<p>如果需要继续递归，那么就根据黎曼积分，在物体表面半球区域随机采样一个方向，框架提供的方法是 <code>Material::sample()</code>，根据入射方向与法线随机生成出射方向，然后根据公式计算间接光照项 <code>L_indir</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_random_float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> RussianRoulette<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Vector3f sampleDir <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">sample</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vector3f wi <span class="token operator">=</span> <span class="token operator">-</span>sampleDir<span class="token punctuation">;</span> <span class="token comment">// 其它物体打来的间接光照</span>
    Vector3f eval <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Vector3f Li <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span><span class="token function">Ray</span><span class="token punctuation">(</span>hitPoint<span class="token punctuation">,</span> sampleDir<span class="token punctuation">)</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>sampleDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">float</span> pdf <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">pdf</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>

    L_indir <span class="token operator">=</span> Li <span class="token operator">*</span> eval <span class="token operator">*</span> cosTheta <span class="token operator">/</span> pdf <span class="token operator">/</span> RussianRoulette<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里要注意，间接光照不能由直接光源提供，否则能量就会不守恒——同一个光源提供了两次贡献。这里可以利用 <code>castRay()</code> 的 <code>depth</code> 参数，为 0 时表示由相机发出，可以接收光源的贡献；反之表示由场景中的物体进行间接光照采样时调用的。在 <code>Render::Render()</code> 中的调用设为 1，其它时候设为 0。</p>
<p>完整的函数如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Vector3f <span class="token class-name">Scene</span><span class="token double-colon punctuation">::</span><span class="token function">castRay</span><span class="token punctuation">(</span><span class="token keyword">const</span> Ray <span class="token operator">&amp;</span>ray<span class="token punctuation">,</span> <span class="token keyword">int</span> depth<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
    Intersection intersection <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span>ray<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>intersection<span class="token punctuation">.</span>happened<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Material <span class="token operator">*</span>m <span class="token operator">=</span> intersection<span class="token punctuation">.</span>m<span class="token punctuation">;</span>
    Vector3f hitPoint <span class="token operator">=</span> intersection<span class="token punctuation">.</span>coords<span class="token punctuation">;</span>
    Vector3f N <span class="token operator">=</span> intersection<span class="token punctuation">.</span>normal<span class="token punctuation">;</span>

    <span class="token comment">// 打到自发光物体</span>
    <span class="token comment">// 如果是首次打到，说明是相机调用的 castRay()，直接返回其颜色；</span>
    <span class="token comment">// 反之，说明是为了计算间接光照项，此时不能对自发光物体采样，返回空值；</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>m<span class="token operator">-&gt;</span><span class="token function">hasEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> depth <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> m<span class="token operator">-&gt;</span><span class="token function">getEmission</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> Vector3f<span class="token punctuation">{</span><span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">,</span> <span class="token number">0.0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    Vector3f L_dir<span class="token punctuation">;</span>
    Vector3f L_indir<span class="token punctuation">;</span>
    Vector3f wo <span class="token operator">=</span> <span class="token operator">-</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">;</span>

    <span class="token punctuation">{</span>   <span class="token comment">// 直接光照</span>
        Intersection light<span class="token punctuation">;</span>
        <span class="token keyword">float</span> pdf<span class="token punctuation">;</span>
        <span class="token function">sampleLight</span><span class="token punctuation">(</span>light<span class="token punctuation">,</span> pdf<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">float</span> dis <span class="token operator">=</span> <span class="token punctuation">(</span>hitPoint <span class="token operator">-</span> light<span class="token punctuation">.</span>coords<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">norm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

        Vector3f wi <span class="token operator">=</span> <span class="token punctuation">(</span>hitPoint <span class="token operator">-</span> light<span class="token punctuation">.</span>coords<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 自发光物体打来的直接光照</span>
        Intersection block <span class="token operator">=</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token function">Ray</span><span class="token punctuation">(</span>hitPoint<span class="token punctuation">,</span> <span class="token operator">-</span>wi<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// 判断该光照是否被其它物体遮挡</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>block<span class="token punctuation">.</span>happened <span class="token operator">&amp;&amp;</span> dis <span class="token operator">-</span> block<span class="token punctuation">.</span>distance <span class="token operator">&lt;</span> EPSILON<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">float</span> dis2 <span class="token operator">=</span> dis<span class="token operator">*</span>dis<span class="token punctuation">;</span>
            Vector3f emit <span class="token operator">=</span> light<span class="token punctuation">.</span>emit<span class="token punctuation">;</span>
            Vector3f eval <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> cosThetaPrime <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> light<span class="token punctuation">.</span>normal<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

            L_dir <span class="token operator">=</span> emit <span class="token operator">*</span> eval <span class="token operator">*</span> cosTheta <span class="token operator">*</span> cosThetaPrime <span class="token operator">/</span> dis2 <span class="token operator">/</span> pdf<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token punctuation">{</span>   <span class="token comment">// 间接光照</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">get_random_float</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> RussianRoulette<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            Vector3f sampleDir <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">sample</span><span class="token punctuation">(</span>ray<span class="token punctuation">.</span>direction<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">normalized</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            Vector3f wi <span class="token operator">=</span> <span class="token operator">-</span>sampleDir<span class="token punctuation">;</span>
            Vector3f eval <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">eval</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Vector3f Li <span class="token operator">=</span> <span class="token function">castRay</span><span class="token punctuation">(</span><span class="token function">Ray</span><span class="token punctuation">(</span>hitPoint<span class="token punctuation">,</span> sampleDir<span class="token punctuation">)</span><span class="token punctuation">,</span> depth <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> cosTheta <span class="token operator">=</span> <span class="token function">fmax</span><span class="token punctuation">(</span><span class="token number">0.f</span><span class="token punctuation">,</span> <span class="token function">dotProduct</span><span class="token punctuation">(</span>sampleDir<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">float</span> pdf <span class="token operator">=</span> m<span class="token operator">-&gt;</span><span class="token function">pdf</span><span class="token punctuation">(</span>wi<span class="token punctuation">,</span> wo<span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">;</span>

            L_indir <span class="token operator">=</span> Li <span class="token operator">*</span> eval <span class="token operator">*</span> cosTheta <span class="token operator">/</span> pdf <span class="token operator">/</span> RussianRoulette<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> L_dir <span class="token operator">+</span> L_indir<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="总结-7">总结</h3>
<p>微表面(Microfacet)部分我没做，因为看了半天公式依然不能理解，以后学有所成再来补上。</p>
<p>输出结果如下：</p>
<p>分辨率 960*1280，spp=256</p>
<img src="./pathtracing.png" style="zoom:70%">]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>计算机角色动画基础（GAMES105）の 笔记</title>
    <url>/note/games105note/</url>
    <content><![CDATA[<p><a href="https://games-105.github.io/">&gt;&gt;&gt;课程主页传送门&lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="线性代数基础">线性代数基础</h2>
<p>线性代数的基础是二维的<strong>向量</strong>和三维的<strong>矩阵</strong>。向量可以用来获取方向和长度，也可以认为是点在坐标系中的位置；而矩阵则一般被视为某种变换手段，左乘一个列向量可以将其转变成新的向量。</p>
<h3 id="向量相关">向量相关</h3>
<p>已知三维向量 $\mathbf{a}=[a_x, a_y, a_z]^T$ 和三维向量 $\mathbf{b} = [b_x, b_y, b_z]^T$。</p>
<h4 id="向量运算">向量运算</h4>
<p>已知向量之间的夹角为 $\theta$。</p>
<p><strong>点乘</strong>：$\mathbf{a}·\mathbf{b} = a_x b_x + a_y b_y + a_z b_z = \lVert\mathbf{a}\rVert \lVert\mathbf{b}\rVert\cos\theta$</p>
<blockquote>
<p>可以视为向量在另一个向量上的投影长度。同时也可以求出向量<strong>夹角</strong>。</p>
</blockquote>
<p><strong>叉乘</strong>：$\mathbf{c} = \mathbf{a}\times\mathbf{b} = \lVert\mathbf{a}\rVert \lVert\mathbf{b}\rVert\sin\theta ·\mathbf{u} = \left[\begin{matrix} a_y b_z - a_z b_y \ a_z b_x - a_x b_z \ a_x b_y - a_y b_x \end{matrix}\right] = \det\left[\begin{matrix} \mathbf{i} &amp; \mathbf{j} &amp; \mathbf{k} \ a_x &amp; a_y &amp; a_z \ b_x &amp; b_y &amp; b_z\end{matrix}\right]$</p>
<blockquote>
<p>可以视为两个向量基于<strong>右手定则</strong>计算出的两个向量所在平面的法向量，其中 $\mathbf{u}$ 是单位法向量。</p>
<p>同时也可以求得两个向量的<strong>最小旋转角</strong>，对应<strong>旋转轴</strong>即叉乘结果。</p>
<img src="crossproduct.png" style="zoom:33%">
</blockquote>
<p>叉乘运算也可以等价为一个<strong>反对称矩阵</strong>乘运算符右侧的向量，即</p>
<h1>$$
\mathbf{a}\times\mathbf{b}=
\left[\begin{matrix}
0 &amp; -a_z &amp; a_y \
a_z &amp; 0 &amp; -a_x \
-a_y &amp; a_x &amp; 0
\end{matrix}\right]
\left[\begin{matrix}
b_x \
b_y \
b_z
\end{matrix}\right]</h1>
<p>[\mathbf{a}]_{\times}\mathbf{b}
$$</p>
<blockquote>
<p>这里的 $[\mathbf{a}]_{\times}$ 一般称为向量 $\mathbf{a}$ 的<strong>叉乘矩阵</strong>。</p>
</blockquote>
<h3 id="矩阵相关">矩阵相关</h3>
<h4 id="坐标系">坐标系</h4>
<p>在三维空间中，坐标系本质上由三个线性无关的<strong>基向量</strong>组成，这三个向量的所有线性组合能够描述整个坐标空间。通常，我们用<strong>标准正交基</strong>来描述，即三个相互正交的单位向量（下面写作 $\mathbf{e}_x, \mathbf{e}_y, \mathbf{e}_z$）。</p>
<p>在游戏中，坐标系又分为<strong>父坐标系</strong>和<strong>局部坐标系</strong>。如果一个物体不随世界中其他物体改变而改变，那么它的父坐标系就是<strong>世界坐标系</strong>。</p>
<p>假设物体在父坐标系中进行了某个旋转变换，对应的旋转矩阵为 $\mathbf{R}$，那么其局部坐标系的基向量也会进行相应的旋转，得到的新的基向量矩阵应该在原基向量矩阵上乘以旋转矩阵，即</p>
<p>$$
\left[
\begin{matrix}
\mathbf{e}‘_x &amp; \mathbf{e}’_y &amp; \mathbf{e}'_z
\end{matrix}
\right] =
\mathbf{R}
\left[
\begin{matrix}
\mathbf{e}_x &amp; \mathbf{e}_y &amp; \mathbf{e}_z
\end{matrix}
\right]
$$</p>
<h4 id="局部坐标系-父坐标系">局部坐标系 -&gt; 父坐标系</h4>
<blockquote>
<p><strong>考虑这样一个问题</strong>：已知某局部坐标系在父坐标系的旋转为 $\mathbf{R}$，且该局部坐标系的原点在父坐标系中的坐标为 $\mathbf{p}_0 = (x_0, y_0, z_0)$，求局部坐标系中坐标为 $\mathbf{l} = (x, y, z)$ 的点在父坐标系中的坐标 $\mathbf{p}$。</p>
</blockquote>
<p>不难想到，在父坐标系下，该点的坐标应当为「局部坐标系的原点偏移量」➕「局部坐标系的基向量」✖️「局部坐标」。</p>
<p>而局部坐标系相对于父坐标系的基向量就是旋转矩阵 $\mathbf{R}$ 的列向量，那么能得到所求结果为 $\mathbf{p} = \mathbf{p}_0 + \mathbf{R}\mathbf{l}$。</p>
<h4 id="父坐标系-局部坐标系">父坐标系 -&gt; 局部坐标系</h4>
<p>把上述结论进行稍微修改，得到 $\mathbf{p} = \mathbf{R}^T(\mathbf{p}'-\mathbf{p}_0)$</p>
<h2 id="旋转变换">旋转变换</h2>
<h3 id="旋转矩阵">旋转矩阵</h3>
<p>旋转本质上是「计算新向量」。在线性代数中，我们可以通过对列向量左乘一个矩阵 $\mathbf{R}$（或行向量右乘）来计算，这样的矩阵称为旋转矩阵。</p>
<p>考虑到对物体的旋转是可逆的，且旋转及其逆操作并不会改变物体，因此有 $\mathbf{R}^{-1}\mathbf{R} = \mathbf{I}$，即旋转矩阵必定是一个<strong>正交矩阵</strong>。</p>
<blockquote>
<p>正交矩阵的所有行（列）向量相互正交，且均为单位向量。</p>
</blockquote>
<h4 id="罗德里格斯旋转公式-Rodrigues’-Rotation-Formula">罗德里格斯旋转公式(Rodrigues’ Rotation Formula)</h4>
<p>该公式旨在解决这一问题：求向量 $\mathbf{a}$ 绕旋转轴 $\mathbf{u}$ 旋转角度 $\theta$ 得到的新向量 $\mathbf{b}$</p>
<details>
<summary>👈推导过程自行点击查看</summary>
<blockquote>
<img src="rodrigues.png" style="zoom:33%">
<p>我们可以将旋转看成是向量端点在某个平面上产生的位移，此时不妨令向量 $\mathbf{b} = \mathbf{a} + \mathbf{v} + \mathbf{t}$，其中 $\mathbf{v}, \mathbf{t}$ 分别与向量 $\mathbf{u}\times\mathbf{a}$ 与 $\mathbf{u}\times(\mathbf{u}\times\mathbf{a})$ 共向，且在该旋转平面上。</p>
<p>因为端点运动轨迹在平面上是一个圆，所以向量 $\mathbf{a}, \mathbf{b}$ 在该平面上的投影长度实际上是圆的半径，二者相等，为 $\lVert\mathbf{a}\rVert\sin(\mathbf{u}, \mathbf{a}) = \lVert\mathbf{u}\times\mathbf{a}\rVert$</p>
<p>此时可以得出向量 $\mathbf{v}, \mathbf{t}$ 的长度，分别如图所示。</p>
<p>将长度乘上对应的方向单位向量，能得到</p>
<p>$$
\begin{align}
\mathbf{v} &amp;= \sin\theta\ \mathbf{u}\times\mathbf{a}\
\mathbf{t} &amp;= (1-\cos\theta)\ \mathbf{u}\times(\mathbf{u}\times\mathbf{a})
\end{align}
$$</p>
</blockquote>
</details>
<p>结论为</p>
<p>$$
\mathbf{b} = \mathbf{a} + \sin\theta\ \mathbf{u}\times\mathbf{a} + (1-\cos\theta)\ \mathbf{u}\times(\mathbf{u}\times\mathbf{a})
$$</p>
<p>转成对应的叉乘矩阵形式就是</p>
<p>$$
\mathbf{b} = [\mathbf{I} + \sin\theta[\mathbf{u}]<em>{\times} + (1-\cos\theta)[\mathbf{u}]</em>{\times}^2]·\mathbf{a}
$$</p>
<p>最终得到绕单位向量 $\mathbf{u}$ 旋转角度 $\theta$ 对应的旋转矩阵为</p>
<p>$$
\mathbf{R}(\mathbf{u}, \theta) = \mathbf{I} + \sin\theta[\mathbf{u}]<em>{\times} + (1-\cos\theta)[\mathbf{u}]</em>{\times}^2
$$</p>
<p>这样一来，已知旋转轴和旋转角度，我们可以很轻松地利用 Rodrigues 公式进行计算新向量。但由于一个旋转矩阵有 9 个参数，每个参数意义不明朗的同时，矩阵乘法的计算量并不小。如果要计算多次旋转（多个旋转矩阵相乘），那开销就更大了。</p>
<p>另一方面，如果希望对物体变换进行插值，<strong>平移</strong>操作很简单，直接线性插值即可；而如果是用旋转矩阵来表示的<strong>旋转</strong>操作，则线性插值会存在问题，比如下图就是个例子。</p>
<img src="Interpolation1.png" style="zoom:25%">
<h3 id="欧拉角">欧拉角</h3>
<p><strong>欧拉角</strong>实际上是把物体的旋转用一组「绕坐标轴的旋转」表示。绕 $\mathbf{x}, \mathbf{y}, \mathbf{z}$ 三个坐标轴旋转的旋转矩阵如下：</p>
<img src="RotationAroundAxes.png" style="zoom:30%">
<p>欧拉角的优点在于参数少，几何上较为直观。而缺点在于：</p>
<ol>
<li class="lvl-3">
<p>表示不唯一，即同一个旋转可以用不同欧拉角表示；</p>
</li>
<li class="lvl-3">
<p>还是要转成旋转矩阵的乘法，且要进行三次，计算复杂度甚至提高；</p>
</li>
<li class="lvl-3">
<p>会出现<a href="https://zh.wikipedia.org/wiki/%E7%92%B0%E6%9E%B6%E9%8E%96%E5%AE%9A"><strong>万向锁</strong></a>问题。</p>
<blockquote>
<p>一旦选择<strong>±90°</strong>作为第二次旋转的角度，就会导致第一次旋转和第三次旋转等价，整个旋转表示系统被限制在只能绕竖直轴旋转，丢失了一个表示维度。这种角度为±90°的第二次旋转使得第一次和第三次旋转的旋转轴相同的现象，称作万向锁。</p>
</blockquote>
</li>
</ol>
<h3 id="旋转向量">旋转向量</h3>
<p><strong>旋转向量</strong>可以用旋转角 $\theta$ 和旋转轴 $\mathbf{u}$ 的乘积表示。这两个信息分别可以通过「求模」和「单位化」来获取。对物体旋转状态的插值可以转为对旋转向量进行线性插值。</p>
<p>旋转向量的优点在于很直观地表示旋转，但要注意 $\theta=0$ 的 corner case。</p>
<img src="rotationVectors.png" style="zoom:25%">
<h3 id="四元数">四元数</h3>
<p><strong>四元数</strong>参考了二维空间中的复数表示，将其拓展，如下所示。</p>
<img src="quaternions1.png" style="zoom:30%">
<h4 id="基本性质">基本性质</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>复数表示法</strong>
<img src="quaternions2.png" style="zoom:30%"></p>
</li>
<li class="lvl-2">
<p><strong>向量表示法</strong>
<img src="quaternions3.png" style="zoom:30%"></p>
</li>
</ul>
<p>对于四元数的乘法，则可直接应用乘法分配律。</p>
<img src="quaternions4.png" style="zoom:30%">
<p>转成向量表示法如下，更加简单。</p>
<img src="quaternions5.png" style="zoom:30%">
<p>可以简单证明，四元数乘法不满足交换律（因为叉乘不满足，除非共线，但此时乘积为 0），但满足结合律。此外，还有以下三条性质，这和复数非常相似。</p>
<img src="quaternions6.png" style="zoom:30%">
<h4 id="旋转变换应用">旋转变换应用</h4>
<p>我们首先定义单位四元数，其模长为 1，，因此<strong>其逆等于其共轭</strong>。这和旋转矩阵的性质（$\mathbf{R}<sup>T=\mathbf{R}</sup>{-1}$）非常相似！事实上现在主流的方法就是用单位四元数来表示一个旋转，即</p>
<img src="quaternions7.png" style="zoom:30%">
<blockquote>
<p>不难发现 $\mathbf{q}$ 和 $-\mathbf{q}$ 表示同一旋转。</p>
</blockquote>
<p>那么用四元数来旋转向量则可以表示为</p>
<img src="quaternions8.png" style="zoom:30%">
<p>如果要对两个旋转进行叠加，只需要进行一次四元数乘法即可。</p>
<img src="quaternions9.png" style="zoom:30%">
<p>四元数除了参数不直观、表示不唯一以外无懈可击！它完美解决了欧拉角万向锁的问题，同时又吸取了旋转向量的优势，计算效率高的同时，在插值上也非常平滑。可以直接对两个旋转状态进行线性插值，但不能保证匀速。</p>
<blockquote>
<p>可以将四元数视为单位球上的某一点，在两点之间进行线性插值，角速度并不均。</p>
</blockquote>
<img src="quaternions10.png" style="zoom:30%">
<p>为了使插值更平滑，可以采用**球面线性插值(SLerp)**的方式。</p>
<img src="quaternions11.png" style="zoom:30%">
<h2 id="运动学">运动学</h2>
<h3 id="前向运动学-Forward-Kinematics">前向运动学(Forward Kinematics)</h3>
<p>FK 的核心思想是：<strong>从骨骼层级结构的根部开始，沿着层级结构逐关节向下计算，最终确定末端在全局空间中的位置和方向</strong>。</p>
<p>已知每个关节的旋转状态 $\mathbf{R}_i$，则关节局部坐标系的基向量 $\mathbf{Q}_i$ 可以如下求得：</p>
<img src="FK1.png" style="zoom:30%">
<blockquote>
<p>关节 $i$ 相对于关节 $j$ 的旋转可以表示为 $\displaystyle \prod\limits_{k=j+1}^i \mathbf{R}_k$</p>
</blockquote>
<p>末端局部坐标系中的任意一点 $\mathbf{x}_0$ 相对于关节 $k$ 的位置可以通过以下方法求解。</p>
<img src="FK2.png" style="zoom:30%">
<img src="FK4.png" style="zoom:40%">
<blockquote>
<p>其中 $\mathbf{l}_i$ 是关节 $i+1$ 在父关节局部坐标系中的坐标，$\mathbf{x}_0$ 是目标点在末端坐标系中的局部坐标。</p>
</blockquote>
<p>不妨把角色建模为这样一个树状结构，每个关节有不同性质。一般来说把根节点放在腰部。不同根节点的设置会导致最终旋转效果不同。</p>
<img src="FK5.png" style="zoom:30%">
<h3 id="逆向运动学-Inverse-Kinematics">逆向运动学(Inverse Kinematics)</h3>
<p>IK 是 FK 的逆过程，其本质是为了求解这样一个问题：<strong>已知末端目标在全局空间中的位置与方向，求解父关节的旋转状态</strong>。</p>
<h4 id="两关节-IK-问题">两关节 IK 问题</h4>
<details open="">
<summary><span class="pre-summary">&nbsp;</span>123345</summary><p>123</p>
</details>
<p>::: p 123
123
:::</p>
<p>两关节 IK 问题是最简单且常见的问题。比如胳膊和腿。一般有两种求解方式：</p>
<ol>
<li class="lvl-3">
<p><strong>方法一</strong>：</p>
</li>
</ol>
<img src="IK1.png" style="zoom:30%">]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>Gameplay Study(1)：Startup</title>
    <url>/unreal/gameplay1/</url>
    <content><![CDATA[<p>通过实现一个 RPG demo，学习 UE Gameplay 基本设计，以及 GAS 用法。</p>
<span id="more"></span>
<p>参考资料：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><a href="https://www.bilibili.com/video/BV1JD421E7yC?p=1&amp;vd_source=6c9ee957ce4e9589cb06ddc343edf771">Bilibili 视频</a></p>
</li>
<li class="lvl-2">
<p><a href="https://github.com/DruidMech/GameplayAbilitySystem_Aura">完整项目地址</a></p>
</li>
<li class="lvl-2">
<p><a href="https://www.unrealengine.com/zh-CN">官方文档</a></p>
</li>
</ul>
<h2 id="准备工作">准备工作</h2>
<h3 id="下载-Unreal-Engine-与-Visual-Studio">下载 Unreal Engine 与 Visual Studio</h3>
<p><a href="https://www.unrealengine.com/zh-CN/download">这是 Unreal Engine 的下载链接</a>。</p>
<blockquote>
<p>最终得到的是 Epic Games，可以用 steam 登录，之后下载最新版虚幻引擎。此时是 <strong>5.4.3</strong> 版本。</p>
</blockquote>
<p><a href="https://visualstudio.microsoft.com/zh-hans/vs/">这是 Visual Studio 的下载链接</a>。</p>
<blockquote>
<p>下载 Community 2022 版。</p>
</blockquote>
<p>根据<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/setting-up-visual-studio-development-environment-for-cplusplus-projects-in-unreal-engine">这个教程</a>进行 VS 相关组件的安装。</p>
<p>同时去虚幻商城搜索并安装「Visual Studio Tools」。</p>
<blockquote>
<p>🍕可选：安装 <a href="https://zhuanlan.zhihu.com/p/661815368">Visual Assist 破解版</a>。</p>
</blockquote>
<h3 id="创建新项目">创建新项目</h3>
<p>选择「空白项目」，在项目默认设置中选择「C++」，并取消勾选「初学者内容包」，选择项目位置和项目名称 <code>ActionRPG</code>，点击创建，经过亿点时间后，我们就能在编辑器中看到我们新建的项目了。</p>
<h3 id="引入美术资产">引入美术资产</h3>
<p>把原项目 git clone 下来，然后把 <code>Content/Assets</code> 这个文件夹全部拷贝到自己的项目中。</p>
<h3 id="🍕可选设置">🍕可选设置</h3>
<p>在「编辑」「编辑器偏好设置」中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>关闭「启用实时代码编写」与「自动编译新添C++类」；</p>
</li>
<li class="lvl-2">
<p>设置「资产编辑器打开路径」为<strong>主窗口</strong>；</p>
</li>
</ul>
<p>在「编辑」「项目设置」中：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>任意修改「版权声明」，这会出现在新建的 <code>.cpp</code>/<code>.h</code> 文件的第一行。</p>
</li>
</ul>
<h2 id="创建角色">创建角色</h2>
<h3 id="新建-C-类">新建 C++ 类</h3>
<blockquote>
<p>「工具」「新建C++类」「角色」</p>
</blockquote>
<p>需要一个基类 <code>RCharacterBase</code> 来抽象表示所有角色（玩家和敌怪）共有的属性与方法，这样在需要新增角色时只需从其派生即可。</p>
<img src="createcharacter.png">
<blockquote>
<p>这里可以在 UCLASS 宏中加入 <code>Abstract</code> 属性说明符，表示这是一个抽象类。</p>
<p>同时考虑到敌怪不需要接受玩家输入，可以删除 <code>SetupPlayerInputComponent()</code> 函数，留到派生的玩家类中实现。</p>
<p>出于性能考虑，<code>Tick()</code> 函数也没有留下的必要，因为后续 coding 过程中并不需要在「每帧」执行某些行为。</p>
<p>构造函数中的变量 <code>PrimaryActorTick.bCanEverTick</code> 也可以设置为 false。</p>
</blockquote>
<p>同样的，我们可以创建玩家基类 <code>RPlayerBase</code> 和敌怪基类 <code>REnermyBase</code>，只需派生自 <code>RCharacterBase</code> 即可。</p>
<h3 id="角色类设计">角色类设计</h3>
<p>本项目中，所有角色都会持有武器，所以需要在头文件中添加一个表示武器的成员变量</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/RCharacterBase.h</span></div><code class="language-cpp"><span class="token function">UCLASS</span><span class="token punctuation">(</span>Abstract<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> ARCharacterBase <span class="token operator">:</span> <span class="token keyword">public</span> ACharacter
<span class="token punctuation">{</span>
  <span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">ARCharacterBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditDefaultsOnly<span class="token punctuation">,</span> Category <span class="token operator">=</span> <span class="token string">"Apperance"</span><span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>USkeletalMeshComponent<span class="token operator">&gt;</span> Weapon<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在角色类的构造函数中实现相应逻辑</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/RCharacterBase.cpp</span></div><code class="language-cpp"><span class="token class-name">ARCharacterBase</span><span class="token double-colon punctuation">::</span><span class="token function">ARCharacterBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  PrimaryActorTick<span class="token punctuation">.</span>bCanEverTick <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

  <span class="token comment">// 生成名为 Weapon 的 SkeletalMeshComponent，并添加至 Mesh 的 WeaponHandSocket 插槽上</span>
  <span class="token comment">// 同时设置碰撞类型为 忽略所有碰撞</span>
  Weapon <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CreateDefaultSubobject</span><span class="token generic class-name"><span class="token operator">&lt;</span>USkeletalMeshComponent<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Weapon"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ensure</span><span class="token punctuation">(</span>Weapon<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Weapon<span class="token operator">-&gt;</span><span class="token function">SetupAttachment</span><span class="token punctuation">(</span><span class="token function">GetMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">FName</span><span class="token punctuation">(</span><span class="token string">"WeaponHandSocket"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Weapon<span class="token operator">-&gt;</span><span class="token function">SetCollisionEnabled</span><span class="token punctuation">(</span>ECollisionEnabled<span class="token double-colon punctuation">::</span>NoCollision<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最终得到下面这样一个角色类树状结构</p>
<pre class="line-numbers language-text" data-language="text"><code class="language-text">Character
   │     RCharacterBase
   │
   ├─Enermy
   │  │    REnermyBase
   │  │
   │  ├─Goblin
   │  |       RGoblin
   |  |       ...
   |  └─...
   │
   └─Player
           RPlayerBase
           ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="遇到的一些知识点">遇到的一些知识点</h3>
<p>这里就涉及到很多知识点了。</p>
<h4 id="虚幻命名规则">虚幻命名规则</h4>
<p>UE 会根据一定<strong>命名规则</strong>为类型添加相应的字母前缀，以更好地辨认一个类名。常见的有以下几种：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>A</code>：<code>Actor</code> 的派生类。</p>
</li>
<li class="lvl-2">
<p><code>U</code>：<code>Object</code> 的派生类。</p>
</li>
<li class="lvl-2">
<p><code>F</code>：非虚幻对象的类，通常是一些辅助类或数据结构。</p>
</li>
<li class="lvl-2">
<p><code>I</code>：Interface，接口类。</p>
</li>
<li class="lvl-2">
<p><code>T</code>：Template，模板类。</p>
</li>
<li class="lvl-2">
<p><code>S</code>：Slate UI，<code>SWidget</code> 的派生类，</p>
</li>
<li class="lvl-2">
<p><code>E</code>：Enum，枚举类。</p>
</li>
</ul>
<p>这里就在 RCharacterBase 类前加入了前缀 <code>A</code>。</p>
<h4 id="虚幻的宏">虚幻的宏</h4>
<p><code>UCLASS()</code> 宏用于定义一个类，告诉引擎如何处理这个类，以便它能够在编辑器中使用并在蓝图中被继承和实例化，同时能够与反射系统进行交互，使其能够在运行时被识别和操作。</p>
<p><code>UPROPERTY()</code> 同理，用于类的成员变量，以定义它们的属性和行为。常用的有以下属性说明符：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>VisibleDefaultsOnly</strong>：指示此属性仅在<strong>原型</strong>的属性窗口中可见，不能编辑。</p>
</li>
<li class="lvl-2">
<p><strong>VisibleInstanceOnly</strong>：指示此属性仅在<strong>实例</strong>的属性窗口中可见，不能编辑。</p>
</li>
<li class="lvl-2">
<p><strong>VisibleAnywhere</strong>：指示此属性在<strong>所有</strong>属性窗口中都可见，但无法编辑。</p>
</li>
<li class="lvl-2">
<p><strong>EditDefaultsOnly</strong>：指示此属性可由属性窗口编辑，但只能在<strong>原型</strong>上编辑。</p>
</li>
<li class="lvl-2">
<p><strong>EditInstanceOnly</strong>：指示此属性可由属性窗口编辑，但只能在<strong>实例</strong>上编辑。</p>
</li>
<li class="lvl-2">
<p><strong>EditAnywhere</strong>：指示此属性可由属性窗口编辑，且能对<strong>原型和实例</strong>编辑。</p>
</li>
<li class="lvl-2">
<p><strong>BlueprintReadOnly</strong>：在蓝图中可见但只读。</p>
</li>
<li class="lvl-2">
<p><strong>BlueprintReadWrite</strong>：在蓝图中可见且可编辑。</p>
</li>
</ul>
<p><code>GENERATED_BODY()</code> 宏就比较简单，会生成一些额外的代码，包括 <code>new</code>/<code>delete</code> 操作符重载、拷贝构造、移动构造、析构函数等基础函数，以及一些额外的 UE 功能。</p>
<p><code>ensure</code> 是一个用于调试的宏，用于在运行时检查条件是否为真。如果条件为假，程序将停止执行，并在调试环境下显示错误信息，以便开发者可以及时发现和修复问题。</p>
<h3 id="玩家蓝图类与武器生成">玩家蓝图类与武器生成</h3>
<p>首先参考以上步骤，创建一个派生自 <code>RPlayerBase</code> 的类 <code>RPlayer_Aura</code>，这就是我们实际要控制的玩家了，可以在 C++ 中加上 <code>final</code> 修饰。</p>
<p>在 <code>Content/BluePrint/Character/Player</code> 目录下创建派生自 <code>RPlayer_Aura</code> 的蓝图类，并命名为 <code>BP_Aura</code>，前缀 BP 表明这是一个 BluePrint。</p>
<p>进入编辑器后，点击「网格体」，设置「骨骼网格体资产」为 SKM_Aura，同时调整一下网格体的位置，我这里是位置 (0, 0, -88)，旋转 (0, 0, -90°)。</p>
<p>点击「Weapon」，设置「骨骼网格体资产」为 SKM_Staff，发现武器出现在了正确的位置，这是因为开发者已经贴心地为我们在 SKM_Aura 中添加了相应插槽，并设置了正确的位置，所以直接使用即可。最后结果如下：</p>
<img src="aura.png">
<p>Enermy 是同理的，也只需应用相应的两个骨骼网格体资产即可。</p>
<h2 id="让-Aura-动起来">让 Aura 动起来</h2>
<h3 id="动画蓝图初识">动画蓝图初识</h3>
<p><strong>动画蓝图</strong>是一种用于创建角色动画逻辑的视觉化编程工具，可以和角色骨骼体绑定，使角色具备根据不同状态，播放不同骨骼动画的能力。可以在动画蓝图中定义状态机，里面有很多自定义的状态，不同状态与不同的骨骼动画绑定，不同的状态之间具有转换规则，满足规则就切换状态，从而可以根据状态播放不同的动画。</p>
<h3 id="创建动画蓝图">创建动画蓝图</h3>
<blockquote>
<p>「内容浏览器」「添加」「动画」「动画蓝图」</p>
</blockquote>
<p>选择合适的骨骼网格体后，就可以创建与之对应的动画蓝图类了，这里将其命名为 <code>ABP_Aura</code>。首先在蓝图中创建一个 State Machine，并命名为 <strong>Main State</strong>。</p>
<p>双击进入其中，可以看到有个「Entry」，这就是 State Machine 的入口，通过拖拽可以「添加状态」，这就形成一个有向图，意味着一旦从 Entry 进入任一状态，都将在本 State Machine 中逗留。</p>
<p>新建一个状态命名为 <code>IdleWalkRun</code> 用于输出 Aura 站立、行走、奔跑的动画。</p>
<p>双击进入其中，发现只有一个「Output Animation Pose」节点，我们要做的就是在内部通过一定手段将处理后的姿势输出。幸好开发者为我们提供了相应资产，在「资产浏览器」中，可以看到有个「IdleWalkRun」的文件，拖拽到窗口中，发现是一个<strong>混合空间播放器</strong>，其实是利用了插值，将静止、行走、奔跑三者根据人物速度混合到同一个动画中。</p>
<img src="idlewalkrun.png">
<p>它需要一个浮点数 Speed 来控制输出结果，那么我们就需要在动画的每一帧都获取 Aura 的移速，从而进行正确插值，获取结果。在事件图表中设置如下节点即可。</p>
<img src="getspeed.png">
<p>最后将变量 Speed 连接到 Blendspace Player 的输入上。</p>
<h3 id="应用动画蓝图">应用动画蓝图</h3>
<p>进入 <code>BP_Aura</code>，左键「网格体」在「细节」栏中设置「动画类」为 <code>ABP_Aura_C</code>。编译蓝图，看到正确结果。</p>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>现代图形学入门（GAMES101）の 笔记</title>
    <url>/note/games101note/</url>
    <content><![CDATA[<p><a href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">&gt;&gt;&gt;课程主页传送门&lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="变换-Transformation">变换(Transformation)</h2>
<p>变换分为两种：Modeling（平移、旋转、缩放等）和 Viewing（3D 投影到 2D）</p>
<h3 id="模型变换-Modeling">模型变换(Modeling)</h3>
<p>先讨论二维的情况。</p>
<blockquote>
<p>在二维平面图上，所有的 modeling 都是基于原点 $(0, 0)$ 的。</p>
</blockquote>
<h4 id="缩放-Scale">缩放(Scale)</h4>
<p>对于原图像上任意一个点 $(x, y)$，其缩放后的坐标为 $(x’, y’) = (s_x·x, s_y·y)$。其中 $s_x, s_y$ 分别表示 $\mathbf{x}, \mathbf{y}$ 方向上的缩放倍率。</p>
<p>用线性代数的方式表示就是：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
s_x &amp; 0\
0 &amp; s_y
\end{matrix}\right)
\left(\begin{matrix}
x\ y
\end{matrix}\right)
$$</p>
<h4 id="镜像-Reflection">镜像(Reflection)</h4>
<p>考虑下面这张图</p>
<img src="reflection.png" style="zoom:50%">
<p>我们也可以得到下面这样一个线性表达式：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
-1 &amp; 0\
0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\ y
\end{matrix}\right)
$$</p>
<h4 id="旋转-Rotate">旋转(Rotate)</h4>
<p>考虑下面这张图：</p>
<img src="rotate.png" style="zoom:70%">
<p>我们可以采用特值法，$(1, 0)\rightarrow(\cos{\alpha}, \sin{\alpha})\quad(0, 1)\rightarrow(-\sin{\alpha}, \cos{\alpha})$，代入 $\mathbf{a’}=\mathbf{M}\mathbf{a}$ 求解，从而得到：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
\cos{\alpha} &amp; -\sin{\alpha}\
\sin{\alpha} &amp; \cos{\alpha}
\end{matrix}\right)
\left(\begin{matrix}
x\ y
\end{matrix}\right)
$$</p>
<blockquote>
<p>这里如果改变旋转方向，从逆时针改为顺时针，那么矩阵 $\mathbf{M}$ 应该代入 $-\alpha$，得到</p>
<p>$$
\mathbf{M(-\alpha)} =
\left(\begin{matrix}
\cos{\alpha} &amp; \sin{\alpha}\
-\sin{\alpha} &amp; \cos{\alpha}
\end{matrix}\right) = \mathbf{M}(\alpha)^T
$$</p>
<p>事实上改变方向，角度不变的两个旋转应该互为逆操作，所以也有 $\mathbf{M(-\alpha)} = \mathbf{M(\alpha)}^{-1}$</p>
<p>易得，<strong>旋转矩阵是一个正交矩阵</strong>。</p>
</blockquote>
<h4 id="切变-Shear">切变(Shear)</h4>
<p>考虑下面这张图：</p>
<img src="shear.png" style="zoom:70%">
<p>坐标在 $\mathbf{x}$ 方向上的偏移量与其纵坐标的大小有关，并且呈线性关系，同时纵坐标又不会发生偏移，那么很容易能够得到下面这个关系：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
1 &amp; a\
0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\ y
\end{matrix}\right)
$$</p>
<h4 id="齐次坐标与平移-Translation">齐次坐标与平移(Translation)</h4>
<p>上面这些都属于线性变换，都可以通过 $\mathbf{a} = \mathbf{M}\mathbf{a}$ 的方式来表示，但这并不适用于「平移」操作，比如下面这张图：</p>
<img src="translation.png" style="zoom:50%">
<p>我们之前讨论的变换，不难发现图像在变换前后，$(0, 0)$ 处的点是不动的，但平移不然。我们似乎不能通过 $\mathbf{a} = \mathbf{M}\mathbf{a}$ 使得 $(x’, y’) = (x+t_x, y+t_y)$。换句话说，平移并非线性变换，其需要的「变换」应当为</p>
<h1>$$
\left(\begin{matrix}
x’\ y’
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
a &amp; b\
c &amp; d
\end{matrix}\right)
\left(\begin{matrix}
x\ y
\end{matrix}\right)
+
\left(\begin{matrix}
t_x\ t_y
\end{matrix}\right)
\tag{1}
$$</p>
<p>于是科学家引入了「齐次坐标」，对于二维的点/向量，为其增加第三个坐标 $w$。当 $w=1$ 时，表示点；$w=0$ 时，表示向量。</p>
<p>那么对于图像上任意一个点，对其进行平移操作，相当于做了下面这样的变换：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’\ w’
\end{matrix}\right)</h1>
<h1>\left(\begin{matrix}
1 &amp; 0 &amp; t_x\
0 &amp; 1 &amp; t_y\
0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\ y\ 1
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
x+t_x\ y+t_y\ 1
\end{matrix}\right)
$$</p>
<p>得到的结果依然是一个「点」的形式。而对于向量而言，因为 $w=0$，那么有</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>vector ± vector = vector</p>
</li>
<li class="lvl-2">
<p>point - point = vector</p>
</li>
<li class="lvl-2">
<p>point + vector = point</p>
</li>
</ul>
<p>从而能够满足向量的平移不变性。</p>
<blockquote>
<p>那么 point + point 呢？我们定义当 $w\neq0$ 时，$\left(\begin{matrix}x\ y\ w\end{matrix}\right)$ 等同于点 $\left(\begin{matrix}x/w\ y/w\ 1\end{matrix}\right)$。易得<strong>两点相加得到该两点所成线段的中点</strong>。</p>
</blockquote>
<h4 id="仿射变换-Affine">仿射变换(Affine)</h4>
<p>根据齐次坐标，我们能够把式(1)改写为：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’\ 1
\end{matrix}\right)</h1>
<h1>\left(\begin{matrix}
a &amp; b &amp; t_x\
c &amp; d &amp; t_y\
0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\ y\ 1
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
ax+by+t_x\ cx+dy+t_y\ 1
\end{matrix}\right)
$$</p>
<p>即线性变换+平移。这样就用一个形式统一了所有的变换。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>缩放</strong>: $\mathbf{S}(s_x, s_y) = \left(\begin{matrix}s_x &amp; 0 &amp; 0\ 0 &amp; s_y &amp; 0\0 &amp; 0 &amp; 1\end{matrix}\right)$</p>
</li>
<li class="lvl-2">
<p><strong>旋转</strong>: $\mathbf{R}(\alpha) = \left(\begin{matrix}\cos{\alpha} &amp; -\sin{\alpha} &amp; 0\ \sin{\alpha} &amp; \cos{\alpha} &amp; 0\0 &amp; 0 &amp; 1\end{matrix}\right)$</p>
</li>
<li class="lvl-2">
<p><strong>平移</strong>: $\mathbf{T}(t_x, t_y) = \left(\begin{matrix}1 &amp; 0 &amp; t_x\ 0 &amp; 1 &amp; t_y\0 &amp; 0 &amp; 1\end{matrix}\right)$</p>
</li>
</ul>
<h4 id="逆变换-Inverse">逆变换(Inverse)</h4>
<p>相当于左乘一个逆矩阵。</p>
<img src="inverse.png" style="zoom:80%">
<h4 id="对变换进行压缩-Composing-Transforms">对变换进行压缩(Composing Transforms)</h4>
<p>根据上面的结论，<strong>左乘</strong>一个仿射矩阵相当于进行相应的变换。我们知道矩阵是有结合律的，一系列变换相当于不断左乘对应的矩阵，那么左侧所有矩阵的乘积就是这一系列变换的总和。</p>
<img src="compose.png" style="zoom:60%">
<p>再考虑下面两种情况：</p>
<ol>
<li class="lvl-3">
<p>先平移后旋转；</p>
</li>
<li class="lvl-3">
<p>先旋转后平移；</p>
</li>
</ol>
<p>两者得到的结果并不一样。这是<strong>矩阵不满足交换律</strong>导致的，即 $\mathbf{R}(\alpha)·\mathbf{T}(t_x, t_y) \neq \mathbf{T}(t_x, t_y)·\mathbf{R}(\alpha)$</p>
<p>如果希望图像围绕一个特定的点 $(x_0, y_0)$ 进行旋转，那么可以先平移至与原点对齐，旋转后再回到原来的位置，即</p>
<img src="trt.png" style="zoom:60%">
<h4 id="推广到三维空间">推广到三维空间</h4>
<p>也是一样的，都需要进行一个坐标的拓展。对于三维坐标系而言，其仿射变换长下面这样：</p>
<h1>$$
\left(\begin{matrix}
x’\ y’\ w’\ 1
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
a &amp; b &amp; c &amp; t_x\
d &amp; e &amp; f &amp; t_y\
g &amp; h &amp; i &amp; t_z\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\ y\ z\ 1
\end{matrix}\right)
$$</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>缩放</strong>: $\mathbf{S}(s_x, s_y, s_z) = \left(\begin{matrix}s_x &amp; 0 &amp; 0 &amp; 0\ 0 &amp; s_y &amp; 0 &amp; 0\ 0 &amp; 0 &amp; s_z &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)$</p>
</li>
<li class="lvl-2">
<p><strong>旋转</strong>（往轴负方向看逆时针）:</p>
<ul class="lvl-2">
<li class="lvl-4">绕 $x$ 轴：$\mathbf{R_x}(\alpha) = \left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; 0\ 0 &amp; \cos{\alpha} &amp; -\sin{\alpha} &amp; 0\ 0 &amp; \sin{\alpha} &amp; \cos{\alpha} &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)$</li>
<li class="lvl-4">绕 $y$ 轴：$\mathbf{R_y}(\alpha) = \left(\begin{matrix}\cos{\alpha} &amp; 0 &amp; \sin{\alpha} &amp; 0\ 0 &amp; 1 &amp; 0 &amp; 0\ -\sin{\alpha} &amp; 0 &amp; \cos{\alpha} &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)$</li>
<li class="lvl-4">绕 $z$ 轴：$\mathbf{R_z}(\alpha) = \left(\begin{matrix}\cos{\alpha} &amp; -\sin{\alpha} &amp; 0 &amp; 0\ \sin{\alpha} &amp; \cos{\alpha} &amp; 0 &amp; 0\ 0 &amp; 0 &amp; 1 &amp; 0\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)$</li>
</ul>
</li>
<li class="lvl-2">
<p><strong>平移</strong>: $\mathbf{T}(t_x, t_y, t_z) = \left(\begin{matrix}1 &amp; 0 &amp; 0 &amp; t_x\ 0 &amp; 1 &amp; 0 &amp; t_y\ 0 &amp; 0 &amp; 1 &amp; t_z\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)$</p>
</li>
</ul>
<p>三维空间的旋转比较特殊，因为需要考虑绕某个轴旋转（二维旋转可以视为有一条虚拟的 $z$ 轴，方向垂直纸面向外，所有的旋转都是绕该轴进行的）。</p>
<blockquote>
<p>有的科学家用飞机来模拟三维空间的旋转，并为其进行命名：<strong>roll</strong>，<strong>pitch</strong>，<strong>yaw</strong>。</p>
<img src="eularangles.png" style="zoom:60%">
</blockquote>
<h4 id="罗德里格斯旋转公式-Rodrigues’-Rotation-Formula">罗德里格斯旋转公式(Rodrigues’ Rotation Formula)</h4>
<p>参考<a href="../basicmathingame/#%E7%BD%97%E5%BE%B7%E9%87%8C%E6%A0%BC%E6%96%AF%E6%97%8B%E8%BD%AC%E5%85%AC%E5%BC%8Frodrigues-rotation-formula">罗德里格斯旋转公式</a>。</p>
<h3 id="观测变换-View">观测变换(View)</h3>
<h4 id="相机的放置">相机的放置</h4>
<p>要做观测变换，首先要解决「<strong>如何放置相机</strong>」这一问题。一般由以下三个属性在空间中唯一确定一个相机：</p>
<ol>
<li class="lvl-3">
<p><strong>位置</strong>(position)：$\mathbf{e}$；</p>
</li>
<li class="lvl-3">
<p><strong>朝向</strong>(gaze direction)：$\hat{g}$；</p>
</li>
<li class="lvl-3">
<p><strong>上方</strong>(up direction)：$\hat{t}$；</p>
</li>
</ol>
<p>另外还有一个关键属性：<strong>相对不变</strong>。即如果相机和所有的物体保持同样的移动，那么得到的观测（照片）永远一致。常用的做法是将相机变换到下面这样的初始状态，其它物体也做同样的变换。</p>
<p>$$
\begin{aligned}
\mathbf{e} &amp;= (0, 0, 0)\
\hat{g} &amp;= -\mathbf{z}\
\hat{t} &amp;= \mathbf{y}
\end{aligned}
$$</p>
<blockquote>
<p>把人头当作相机，观测结果就是我们日常画的<strong>二维坐标系</strong>。上面这个是约定俗成的，能够使观测变容易。</p>
</blockquote>
<h4 id="相机变换">相机变换</h4>
<p>为了让任意位置的相机都能达到初始状态，需要进行一定的变换（称之为 $\mathbf{M}_{view}$）</p>
<ol>
<li class="lvl-3">
<p>将 $\mathbf{e}$ 移至原点；</p>
</li>
<li class="lvl-3">
<p>将 $\hat{g}$ 旋转至 $-\mathbf{z} = (0, 0, -1, 0)$；</p>
</li>
<li class="lvl-3">
<p>将 $\hat{t}$ 旋转至 $\mathbf{y} = (0, 1, 0, 0)$；</p>
</li>
<li class="lvl-3">
<p>将 $\hat{g}\times\hat{t}$ 旋转至 $\mathbf{x} = (1, 0, 0, 0)$；</p>
</li>
</ol>
<p>不难得到 $\mathbf{M}<em>{view} = \mathbf{R}</em>{view}\mathbf{T}_{view}$（先平移后旋转）。</p>
<p>其中</p>
<p>$$
\mathbf{T}_{view} =
\left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -x_e\
0 &amp; 1 &amp; 0 &amp; -y_e\
0 &amp; 0 &amp; 1 &amp; -z_e\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
$$</p>
<p>那么旋转矩阵要如何表示呢？发现正着来不太好写，那不如倒着来，先考虑逆操作，即 $\mathbf{x}\rightarrow\hat{g}\times\hat{t},\quad \mathbf{y}\rightarrow\hat{t},\quad \mathbf{z}\rightarrow-\hat{g}$，分别代入特殊值可以得到</p>
<p>$$
\mathbf{R}<em>{view}^{-1} =
\left(\begin{matrix}
x</em>{\hat{g}\times\hat{t}} &amp; x_{\hat{t}} &amp; x_{-\hat{g}} &amp; 0\
y_{\hat{g}\times\hat{t}} &amp; y_{\hat{t}} &amp; y_{-\hat{g}} &amp; 0\
z_{\hat{g}\times\hat{t}} &amp; z_{\hat{t}} &amp; z_{-\hat{g}} &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
$$</p>
<blockquote>
<p>矩阵分别乘 $\mathbf{x}, \mathbf{y}, \mathbf{z}$ 能得到 $\hat{g}\times\hat{t},\hat{t},-\hat{g}$</p>
</blockquote>
<p>之前我们讨论过，二维旋转矩阵是<strong>正交矩阵</strong>，其实这一性质对三维同样成立，所以有</p>
<p>$$
\mathbf{R}<em>{view} =
(\mathbf{R}</em>{view}<sup>{-1})</sup>T =
\left(\begin{matrix}
x_{\hat{g}\times\hat{t}} &amp; y_{\hat{g}\times\hat{t}} &amp; z_{\hat{g}\times\hat{t}} &amp; 0\
x_{\hat{t}} &amp; y_{\hat{t}} &amp; z_{\hat{t}} &amp; 0\
x_{-\hat{g}} &amp; y_{-\hat{g}} &amp; z_{-\hat{g}} &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
$$</p>
<h3 id="投影变换-Projection">投影变换(Projection)</h3>
<img src="projections.png" style="zoom:80%">
<blockquote>
<p>透视投影会形成视角锥，正交投影假设相机置于无穷远处。</p>
</blockquote>
<h4 id="正交投影-Orthographic-projection">正交投影(Orthographic projection)</h4>
<p>在计算机图形学中，为了节省计算资源，会定义一个<strong>可视空间</strong>，只有可视空间内的物体才需要进行绘制。正交投影定义的可视空间是一个<strong>盒状可视空间</strong>，本质上是三维物体的外切立方体，其长宽高分别由区间 $[f, n], [l, r], [b, t]$ 确定。</p>
<p>所谓正交投影，其实就是已知该可视空间内的任意点，将其垂直投影到 $xOy$ 平面并求解对应点的坐标。一种朴素的思路是直接舍弃 $z$ 坐标，但这样做在有前后遮挡的情况下会出现错误的绘制结果。</p>
<img src="orth.png" style="zoom:50%">
<p>现代化做法是像上图这样。首先将可视空间平移至以原点为空间中心，再对长宽高进行归一化。</p>
<p>不难得到两步操作之和的变换矩阵为</p>
<h1>$$
\mathbf{M}_{ortho} =
\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2}\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2}\
0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2}\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)</h1>
<p>\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l}\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b}\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; -\frac{n+f}{n-f}\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
$$</p>
<blockquote>
<p>归一化是因为，现实情况几乎所有的图形系统都把坐标系的空间范围限定在 $(-1,1)$ 范围内，这么做是为了方便移植，使坐标系独立于各种尺寸的图形设备。</p>
</blockquote>
<blockquote>
<p>我们这里是<strong>右手系</strong>，所以有反直觉的 $n&gt;f$，有的引擎采用左手系（相机看向 $\mathbf{z}$ 正向），从而 $f&gt;n$，更加符合直觉。</p>
</blockquote>
<h4 id="透视投影-Perspective-projection">透视投影(Perspective projection)</h4>
<p>透视投影符合我们日常视角，即<strong>近大远小</strong>，且平行线不再平行，视觉效果看会收束到一个点。</p>
<p>闫神提供的解法是，将相机视锥形成的四棱台**压缩(squish)**成盒状，再应用正交投影即可。</p>
<img src="squish.png" style="zoom:80%">
<details><summary>👈推导过程自行点击查看</summary>
<blockquote>
<p>对于视锥范围内的任意一点 $A(x, y, z)$，从原点作一条直线经过该点的直线（即视线），与近裁切面相交于点 $A’(x’, y’, z’=n)$。基于正交投影的性质，我们希望点 $A$ 在经过 squish 后的点 $B$ 满足 $x_B=x’, y_B=y’$。</p>
<img src="similarTriangle.png" style="zoom:60%">
<p>根据相似三角形，不难得到</p>
<p>$$
\begin{aligned}
x’&amp;=\frac{n}{z}x\[2em]
y’&amp;=\frac{n}{z}y
\end{aligned}
$$</p>
<p>在齐次坐标下，我们得到这样一个变换关系：</p>
<h1>$$
\mathbf{M}_{squish}
\left(
\begin{matrix}
x \ y \ z \ 1
\end{matrix}
\right)</h1>
<p>\left(
\begin{matrix}
nx/z \ ny/z \ ? \ 1
\end{matrix}
\right)
\overset{\times z}{\Longleftrightarrow}
\left(
\begin{matrix}
nx \ ny \ ? \ z
\end{matrix}
\right)
$$</p>
<p>从而有</p>
<h1>$$
\mathbf{M}_{squish}</h1>
<p>\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\
0 &amp; n &amp; 0 &amp; 0\
? &amp; ? &amp; ? &amp; ?\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
\overset{不妨设为}{==}
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\
0 &amp; n &amp; 0 &amp; 0\
A &amp; B &amp; C &amp; D\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
$$</p>
<p>接下来就是求 squish 矩阵的第三行元素。由于在 squish 前后，近裁切面和远裁切面上的所有点保持不变，所以我们可以代入两个特殊点进行求解，一个是近裁切面上的点 $(x, y, n)$，一个是远裁切面上的点 $(x, y, f)$，从而得到</p>
<h1>$$
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\
0 &amp; n &amp; 0 &amp; 0\
A &amp; B &amp; C &amp; D\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
\left(
\begin{matrix}
x \ y \ n \ 1
\end{matrix}
\right)</h1>
<h1>\left(
\begin{matrix}
nx \ ny \ Ax+By+Cn+D \ n
\end{matrix}
\right)</h1>
<p>\left(
\begin{matrix}
nx \ ny \ n^2 \ n
\end{matrix}
\right)
\Leftrightarrow
\left(
\begin{matrix}
x \ y \ n \ 1
\end{matrix}
\right)
$$</p>
<p>得到 $Cn+D = n^2$，同理 $Cf+D = f^2$，最终解得</p>
<p>$$
A=B=0,\ C=n+f,\ D=-nf
$$</p>
<p>即</p>
<h1>$$
\mathbf{M}_{squish}</h1>
<p>\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\
0 &amp; n &amp; 0 &amp; 0\
0 &amp; 0 &amp; n+f &amp; -nf\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
$$</p>
</blockquote>
</details>
<p>最终得到透视投影变换矩阵为</p>
<h1>$$
\mathbf{M}<em>{persp} = \mathbf{M}</em>{ortho}\mathbf{M}_{squish}</h1>
<p>\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l}\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b}\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; -\frac{n+f}{n-f}\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\
0 &amp; n &amp; 0 &amp; 0\
0 &amp; 0 &amp; n+f &amp; -nf\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right) \
$$</p>
<blockquote>
<p>❗提问：视锥内任意一点 $x, y, z$ 在 squish 后是靠近 $xOy$ 平面还是远离？</p>
<p>不妨代入式子求解，计算得到新的点为 $(nx/z, ny/z, n+f-nf/z)$，我们只需要判断 $n+f-nf/z$ 和 $z$ 的大小关系即可。</p>
<p>令 $f(z) = n+f-nf/z-z = -[z^2-(n+f)z+nf]/z = -[(z-n)(z-f)]/z$</p>
<p>当 $f \leq z \leq n &lt; 0$ 时，$f(z) &lt;= 0$ 恒成立，即 $n+f-nf/z \leq z$，表示<strong>远离</strong>。结论呼之欲出。</p>
</blockquote>
<p>在上面我们定义了远近裁切面，并对其作了相应映射操作。但还有一个问题我们没有解决，那就是<strong>如何定义近裁切面的大小</strong>。</p>
<p>近裁切面其实就是相机的<strong>视口(View Port)</strong>，可以用两个参数：**视角(fovY, Field of View)<strong>和</strong>宽高比(Aspect Ratio)**来定义。</p>
<img src="viewport.png" style="zoom:80%">
<img src="lrbt.png" style="zoom:80%">
<p>当近裁切面在 $\mathbf{z}$ 轴上的坐标 $n$ 确定后，我们就能得到 squish 后的盒状可视空间的上下左右裁切面坐标值，从而正确应用正交投影的平移/缩放。</p>
<p>$$
\begin{aligned}
t &amp;= |n|\tan{\frac{(fovY)}{2}} \
b &amp;= -t \[1.5em]
r &amp;= t·(aspect) \
l &amp;= -r
\end{aligned}
$$</p>
<h2 id="光栅化-Rasterization">光栅化(Rasterization)</h2>
<h3 id="屏幕映射">屏幕映射</h3>
<p><strong>屏幕</strong>其实就是一个二维数组，数组的每一个元素是一个<strong>像素(Pixel, Picture Element)</strong>，可以用坐标 $(x, y)$ 表示，其像素中心坐标实际上是 $(x+0.5, y+0.5)$。</p>
<p>对于一个分辨率为 width*height 的屏幕而言，其屏幕空间大小就是 width*height，对应了 width*height 大小的二维像素数组。</p>
<img src="pixels.png" style="zoom:80%">
<p>我们经过正交/透视投影变换后得到了一个归一化的立方体盒状可视空间（$[-1,1]^3$），需要将其 $xOy$ 平面上的点映射到屏幕空间（$[0, width]*[0, height]$）中。这一步很简单，缩放+平移即可，对应的变换矩阵为。</p>
<p>$$
\mathbf{M}_{viewport}
\left(
\begin{matrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2}\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2}\
0 &amp; 0 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right) \
$$</p>
<p>万事俱备，我们只差将其变成真正的<strong>图</strong>，也就是说，要将视口中的多边形打散成像素，得到每个像素的值，真正将其画在屏幕上，这就是光栅化。</p>
<h3 id="光栅化">光栅化</h3>
<p>大部分物体都会采用三角形来组合成对应的多边形，这是因为三角形：</p>
<ol>
<li class="lvl-3">
<p>是最基础的多边形，任意多边形都可以拆分为若干三角形；</p>
</li>
<li class="lvl-3">
<p>能够唯一确定一个平面；</p>
</li>
<li class="lvl-3">
<p>有明确的内外之分，不存在凹三角形和凸三角形，所以<strong>给定一个点可以唯一确定在三角形内部还是外部</strong>；</p>
</li>
<li class="lvl-3">
<p><strong>缺点</strong>在于无法完美还原曲线；</p>
</li>
</ol>
<img src="dolphinTriangle.png" style="zoom:70%">
<p>下面就以三角形为例，讲述光栅化的过程。</p>
<p>🙋‍♂️ 先进行一个提问：<strong>已知屏幕空间内三个点的坐标值，如何根据这三个点构成的三角形，为像素数组赋合理的值呢？</strong></p>
<h4 id="采样-Sampling">采样(Sampling)</h4>
<p>采样其实就是一个<strong>离散化</strong>的过程。比如下图，采样的思路是：如果一个像素的像素中心落在三角形的内部，那么就为这个像素赋予相应的值（三角形 RGB）。</p>
<img src="sample.png" style="zoom:70%">
<blockquote>
<p>判断一个点 $O$ 是否落在三角形 $P_0P_1P_2$ 内很简单，只需要<strong>三次叉乘</strong>，如果 $\mathbf{OP_0}\times\mathbf{P_0P_1}, \mathbf{OP_1}\times\mathbf{P_1P_2}, \mathbf{OP_2}\times\mathbf{P_2P_0}$ 同号，则认为在内部，反之在外部。</p>
</blockquote>
<blockquote>
<p>实际上去遍历屏幕上的所有像素是没必要的，像上图左边的白色区域是肯定不会碰到三角形的，三角形肯定不会填充到这些像素上，只要考虑蓝色区域即可。蓝色区域就叫三角形的<strong>轴对齐包围盒</strong>，简称 <strong>AABB(Axis-aligned bounding box)</strong>。</p>
</blockquote>
<h4 id="反走样-Antialiasing">反走样(Antialiasing)</h4>
<p>由于一个像素实际上会被填充为一个正方形，大部分情况下，采样的结果并不能完美地还原一个图形，反而容易产生<strong>锯齿(Jaggies)</strong>，比如下图。</p>
<img src="jaggies.png" style="zoom:70%">
<p>锯齿是<strong>走样(Aliasing)问题</strong>的其中一种表现形式，此外还有摩尔纹（空间采样）、车轮错觉（时间采样）等。本质原因都是：<u>信号（函数）变化太快，以至于采样速度跟不上</u>。</p>
<p><strong>反走样(Antialiasing)<strong>就是为了解决这一问题所提出的。以三角形锯齿问题为例，我们可以先将其</strong>模糊处理(Blurring)</strong>，或者说<strong>滤波(Pre-Filtering)</strong>，再对模糊结果进行采样，这样就会有一些边界被采样成粉红色，而不是说只要像素中心不落在三角形内部就被采样成白色。</p>
<img src="blur.png" style="zoom:70%">
<p>❗ 注意<strong>顺序不能颠倒</strong>，这涉及到一些**频域(frequency domain)**相关的知识。可以明确的一点是：<u>采用同样的间隔进行采样，频率越高采样越不准确，所以更高频率的函数需要更密集的采样点</u>。比如下面，用相同的手段分别对黑色和蓝色的曲线进行采样，得到的结果是一样的，也就无法对其进行区分，从而导致走样。</p>
<img src="diff.png" style="zoom:50%">
<p>而模糊处理其实就是<strong>低通滤波</strong>，将高频信息滤掉，只通过低频分量，这样再做采样操作，就不容易在频域上发生混叠。</p>
<img src="filter.png" style="zoom:50%">
<p>最简单的操作就是，根据三角形在一个像素区域中的覆盖面积来决定采样结果。</p>
<img src="sample2.png" style="zoom:50%">
<p>那如何计算三角形覆盖的区域呢？有一种近似方法叫 <strong>MSAA(MultiSampling Anti-Aliasing)</strong>：对于任何一个像素 $P$，考虑其被划分成 $n$ 个小的像素 $p_i$，求 $P$ 被三角形覆盖的面积，实际上就是求有多少 $p_i$ 落在三角形内部，最后对结果除以 $n$，这就得到了一个近似的结果。比如下图，将像素划分为 4 个小像素。</p>
<img src="22supersample.png" style="zoom:50%">
<img src="afterss.png" style="zoom:50%">
<img src="result.png" style="zoom:50%">
<blockquote>
<p>虽然效果不错，但实际上增加了 $n$ 倍的开销。实际上从工业的角度，人们并不是把一个像素规则的划分为 $n$ 个点，而是会用更加有效的图案去分布这些点，邻近的点还会被相邻的像素所复用，以减少开销。</p>
<p>还有一些重要的反走样方法，如 <strong>FXAA(Fast Approximate AA)</strong>、<strong>TAA(Temporal AA)</strong>。</p>
</blockquote>
<p>这部分内容并没有「变换」那样涉及到大量公式，都是一些理论上的知识点，所以相对来说篇幅不是那么大。</p>
<h2 id="着色-Shading">着色(Shading)</h2>
<p>在本课程中，着色的定义为：「对不同物体应用不同材质的过程」。</p>
<h3 id="可见性-Visibility">可见性(Visibility)</h3>
<p>在屏幕映射这一部分中，我们说到将直接将多边形 $xOy$ 平面上的点映射到屏幕空间，但并没有考虑 $\mathbf{z}$ 轴方向上会出现的**遮挡(Occlusion)**问题。</p>
<h4 id="画家算法-👎">画家算法(👎)</h4>
<p>这是人们最开始想到的一种朴素的做法：维护一个<strong>帧缓存(Frame Buffer)</strong> 存放屏幕空间的临时像素值，不断用更近的点覆盖原有的像素值，就像油画家的做法一样，最后将得到的 Frame Buffer 写入屏幕空间对应的像素数组，得到结果图像。</p>
<p>这种做法需要将所有的三角形进行排序（多边形拆成若干三角形），需要 $O(n\log{n})$ 的时间复杂度。<strong>缺点</strong>在于，一旦出现<strong>循环覆盖</strong>的情况，画家算法就失效了，比如下图，无法判断哪个三角形更近。</p>
<img src="painter.png" style="zoom:50%">
<h4 id="Z-Buffer-👍">Z-Buffer(👍)</h4>
<p>Z-Buffer 是经过实践检验的优秀算法。它的基本思路是这样的：在维护<strong>帧缓存(Frame Buffer)<strong>的同时，额外维护一个</strong>深度缓存(Depth Buffer, Z-Buffer)</strong>。我们需要遍历可视空间内的所有三角形，对其进行采样，并保留被采样点的完整坐标信息。对于一个三角形的所有采样点，如果发现某个点 $(x, y, z)$ 对应的深度 $|z|$ 超过 $\text{Z-Buffer}(x, y)$，那么就将其舍弃，反之用该点信息更新两个 Buffer。虽然牺牲了一部分空间，却换来了<strong>速度</strong>（线性时间复杂度，无需关心顺序）与<strong>鲁棒性</strong>（解决了循环覆盖问题）。</p>
<blockquote>
<p>同时，还可以根据像素深度进行额外的处理，如着色深浅。</p>
</blockquote>
<details> <summary>🤳伪代码</summary>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">for each triangle T
    for each sample(x, y, z) in T
        if (z &lt; ZBuffer[x, y])
            FrameBuffer[x, y] = RGB
            ZBuffer = z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</details>
<h3 id="Blinn-Phong-模型——Shading-is-Local">Blinn-Phong 模型——Shading is Local</h3>
<p>Blinn-Phong Model 是一个简单的着色模型，它计算<u>从点光源射出，在物体表面的一个点（即<strong>着色点(Shading Point)</strong>）上反射向相机的光</u>。</p>
<blockquote>
<p>它将着色完全理想化，而不考虑物理真实性，因而没有太大的现实借鉴意义。</p>
</blockquote>
<p>这里认为在一个局部比较小的范围内，着色点永远是一个平面。那么关于光的反射，需要定义以下内容：</p>
<ol>
<li class="lvl-3">
<p>平面法线 $\mathbf{n}$；</p>
</li>
<li class="lvl-3">
<p>观测方向 $\mathbf{v}$；</p>
</li>
<li class="lvl-3">
<p>光照方向 $\mathbf{l}$；</p>
</li>
<li class="lvl-3">
<p>物体表面属性（如下面要提到的漫反射系数）；</p>
</li>
</ol>
<img src="shadingpoint.png" style="zoom:50%">
<blockquote>
<p><strong>Shading is Local</strong>，这句话的意思是，着色只会考虑这个着色点，以及光照和观测方向，不考虑其他物体的存在，所以没有阴影。</p>
</blockquote>
<h4 id="漫反射-Diffuse-Reflection">漫反射(Diffuse Reflection)</h4>
<p>对于<strong>漫反射(Diffuse Reflection)<strong>而言，光在着色点</strong>均匀</strong>地向四面八方反射，故此时观测结果与观测方向无关。</p>
<p>另外我们发现，当着色点平面法线方向和光线的夹角变化时，得到的观测结果明暗程度也会发生变化。根据光的波粒二象性，<u>光是具有能量的</u>，所以当 $\theta(\mathbf{n}, \mathbf{l})$ 变化时，着色点在单位面积收到的<strong>能量值</strong>（光强度）也会有所变化。具体而言，光强度与 $\cos{\theta}=\mathbf{n}·\mathbf{l}$ 呈正相关。<u>我们判断物体的明暗程度，本质上就是判断该物体表面能接收到多少能量</u>。</p>
<img src="nl.png" style="zoom:50%">
<p>除了角度以外，点光源与着色点的<strong>距离</strong>也是决定光强度的一个重要因素。根据能量守恒定律，假设光的传播不会发生能量损耗，则以点光源为中心，半径 1 个单位长度的球体表面和半径 r 个单位长度的球体表面，两者所具有的能量应该是相等的。假设前者的光强度为 $I$，那么后者的光强度应该为</p>
<p>$$
I’ = \frac{4\pi}{4\pi r^2} I = \frac{I}{r^2}
$$</p>
<p>基于以上讨论，Blinn-Phong 模型给出如下的漫反射公式：</p>
<p>$$
L_d = k_d·\frac{I}{r^2}·\max{(0, \mathbf{n}·\mathbf{l})}
$$</p>
<p>其中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$L_d$ 为漫反射光强；</p>
</li>
<li class="lvl-2">
<p>$k_d$ 为<strong>漫反射系数</strong>，表示这个点对光的吸收率；</p>
<blockquote>
<p>对于一个点，它之所以会有颜色，是因为这个点会吸收一部分的颜色（能量），将那部分不吸收的能量进行反射。那不同的物体表面材质不同，因而有不同的<strong>吸收率</strong>，就会产生不同的反射光。当这个系数为 1 时，表示这个点完全不吸收能量；为 0 就表示所有能量都被吸收了。如果把这个系数表示为一个三通道的 RGB 颜色向量，那就可以在着色点上定义一个颜色了。</p>
<p>控制变量法得到的结果大概是下面这样</p>
<img src="diffuseresult.png" style="zoom:50%">
</blockquote>
</li>
</ul>
<h4 id="高光-Specular">高光(Specular)</h4>
<p>当观测方向和光反射方向一致（或者说接近）时，能观测到高光。</p>
<blockquote>
<p>这里不考虑漫反射，只谈<strong>镜面反射</strong>。</p>
</blockquote>
<p>那么如何定义「接近」呢？假设反射光方向为 $\mathbf{R}$，则 $\theta{\mathbf{R},\mathbf{v}}$ 越小，表示越接近。但是 $\mathbf{R}$ 比较难求，Blinn-Phong 模型改为求解<strong>半程向量</strong> $\mathbf{h}$ 与法线 $\mathbf{n}$ 之间的夹角 $\alpha$。所谓半程向量，其实就是 $\mathbf{v}$ 与 $\mathbf{l}$ 的角平分线，有 $\displaystyle \mathbf{h}=\frac{\mathbf{v}+\mathbf{l}}{||\mathbf{v}+\mathbf{l}||}$ 。</p>
<img src="specular.png" style="zoom:50%">
<p>基于以上讨论，Blinn-Phong 模型给出如下的高光项公式：</p>
<p>$$
L_s = k_s\frac{I}{r^2}\max{(0, \mathbf{n}·\mathbf{h})}^p
$$</p>
<p>其中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$L_s$ 为高光项光强；</p>
</li>
<li class="lvl-2">
<p>$k_d$ 为<strong>高光项系数</strong>，决定观测到的高光明暗程度；</p>
</li>
</ul>
<blockquote>
<p>🙋‍♂️ 之所以有一个指数 $p$，是因为需要对「接近程度」设置一个阈值，当 $p=1$ 时，即便 $\mathbf{h}$ 与 $\mathbf{n}$ 夹角达到了 45°，此时我们认为已经是相当偏离了，但余弦值为 $\sqrt{2}/2\approx 0.7$，还是能观测到比较明显的高光，这完全不符合我们的预期吧！</p>
<p>所以需要加入指数 $p$ 进行控制，使得夹角增大时，$(\cos{\alpha})^p$ 能够快速衰减，比如下图</p>
<img src="cosinePower.png" style="zoom:50%">
<p>控制变量法得到的结果大概是下面这样（加入漫反射项）：</p>
<img src="specularresult.png" style="zoom:50%">
</blockquote>
<h4 id="环境光照-Ambient">环境光照(Ambient)</h4>
<p>虽然有些点因为遮挡等因素，不会接收点光源的直射光，但是存在来自四面八方的、反射自其它物体表面的光，这就是<strong>环境光(Ambient)</strong>。</p>
<img src="ambient.png" style="zoom:50%">
<p>Blinn-Phong 模型给出的环境光项公式很简单：</p>
<p>$$
L_a = k_aI_a
$$</p>
<p>其中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$L_a$ 为环境光强；</p>
</li>
<li class="lvl-2">
<p>$k_a$ 为<strong>环境光系数</strong>；</p>
</li>
<li class="lvl-2">
<p>$I_a$ 为光强，且假设任何一个点接收到来自环境的光强永远都是相同的；</p>
</li>
</ul>
<p>不难发现，该模型的环境光强和 $\mathbf{l}, \mathbf{n}, \mathbf{v}$ 无关，是一个<strong>常数</strong>，保证了没有一个地方完全是黑的。事实上不是这么一回事，正如我之前说的，Blinn-Phong 只是一个简单的模型，如果要对环境光做精确求值，需要运用到<strong>全局光照</strong>的知识。</p>
<h4 id="总结">总结</h4>
<p>Blinn-Phong 模型下，我们最终能观测到的光强是以上三大项之和，即</p>
<p>$$
L = L_a+L_d+L_s = k_aI_a + k_d\frac{I}{r^2}\max{(0, \mathbf{n},\mathbf{l})}+k_s\frac{I}{r^2}\max{(0, \mathbf{n}·\mathbf{h})}^p
$$</p>
<p>下面是一个简单的示例</p>
<img src="blinnphongresult.png" style="zoom:50%">
<p>❗ 再次强调，<strong>Blinn-Phong 只是一个简单的模型，不具备物理真实性，没有太大的现实借鉴意义</strong>。</p>
<h3 id="着色频率-Shading-Frequency">着色频率(Shading Frequency)</h3>
<p>选择着色频率，本质上是「如何选择着色点」的问题。下面的讨论中，我们认为物体表面由若干三角形的平面组成。</p>
<img src="shadingFreq.png" style="zoom:50%">
<h4 id="Flat-Shading">Flat Shading</h4>
<p>将着色应用到整个三角形上。对于一个三角形，我们只需对任意两条边作叉乘，即可求得法线，最后对三角形内部所有点作同样的着色处理。缺点是不够平滑。</p>
<h4 id="Gouraud-Shading">Gouraud Shading</h4>
<p>将着色应用到顶点上。对于物体表面任意一个顶点，其相邻的所有三角形为 $T_1, T_2, \dots$，这些三角形面积为 $S_1, S_2, \dots$，法线为 $\mathbf{n}_1, \mathbf{n}_2, \dots$，那么此顶点为着色点对应的法线为</p>
<p>$$
\mathbf{n} = \frac{S_1\mathbf{n}_1 + S_2\mathbf{n}_2 + \dots}{S_1 + S_2 + \dots}
$$</p>
<blockquote>
<p>本质上是对所有法线作一个<strong>加权平均</strong>，权值为其面积，故面积越大的三角形，影响/贡献越大。</p>
</blockquote>
<p>对于一个三角形，其三个顶点的着色已知，那么三角形内部应用<strong>插值</strong>即可。缺点是一旦某个三角形过大，着色效果就会不明显。</p>
<h4 id="Phong-Shading">Phong Shading</h4>
<p>将着色应用到像素上。首先对于三角形的每个顶点求出各自的法线，在三角形内部每一个像素上都<strong>插值</strong>出一个法线方向，对每一个像素进行一次着色，就会得到一个相对比较好的效果。</p>
<blockquote>
<p>🤔 注意和 Blinn-Phong 区分。虽然都是同一个人发明的。</p>
</blockquote>
<h4 id="总结-2">总结</h4>
<p>根据一开始放的图，在顶点数较少，即模型比较简单时，Phong 的效果无疑是最好的，但也要一定的开销。而当顶点数增大，模型逐渐复杂时，即便用相对简单的 Flat Shading 也能得到一个比较好的效果，因为此时一个平面的大小可能已经接近像素大小了。</p>
<h3 id="实时渲染管线-Real-time-Rendering-PipeLine">实时渲染管线(Real-time Rendering PipeLine)</h3>
<img src="gpipe.png" style="zoom:50%">
<ol>
<li class="lvl-3">
<p>输入空间中的若干点；</p>
</li>
<li class="lvl-3">
<p>将这些点投影到屏幕上，定义连接关系，生成相应三角形；</p>
</li>
<li class="lvl-3">
<p>光栅化，形成不同的离散的<strong>片元(fragment)</strong>；</p>
</li>
<li class="lvl-3">
<p>考虑可见性与着色频率，将不同的片元进行着色；</p>
</li>
<li class="lvl-3">
<p>输出到显示器；</p>
</li>
</ol>
<p>以上就是从三维场景到最后渲染出二维图片的基本操作，这些都是已经在 GPU 里写好了的。</p>
<blockquote>
<p>🙋‍♂️ 提问：<strong>为什么在管线中是先把三维空间中的点投影到屏幕上去，然后再把它连成三角形呢？</strong></p>
<p>定义空间物体时，首先定义顶点，再进行若干次定义由哪三个顶点构成小平面，这两步是将<strong>直接定义所有的三角形</strong>进行拆分，本质上是一样的，且三维空间投影到二维屏幕时，点与点之间的连接关系是不变的，所以我们只要对顶点进行操作就行。</p>
</blockquote>
<h3 id="纹理映射-Texture-Mapping">纹理映射(Texture Mapping)</h3>
<p>纹理映射解决了这样一个问题：<strong>给定三角形，我们希望观察到的结果为，三角形内部填充了某一张图片</strong>。</p>
<p>前面提到，对于一个表面，我们能够观察到不同颜色以及不同明暗程度，实际上是这个物体表面的属性发挥了作用——吸收一部分光，反射剩下的部分。我们能够看到物体表面仿佛填充了一张图片，本质上是<strong>这个物体表面的不同点具有不同的属性</strong>，这才是决定了不同观测结果的重要因素。</p>
<p>所以纹理映射的根本作用，就是<strong>定义物体表面属性</strong>。</p>
<p>那么如何定义呢？对于任意一个三维物体，其表面都可以通过某种方式转变成大小为 $1\times 1$ 的二维图像，那么只要我们得到任意一张图，就可以通过逆操作将其「贴」到三维物体上，这就是赋予纹理的过程。只要将三维物体表面的所有三角形平面，都在这个二维图像找到一一对应关系，那么我们就可以把「定义三维物体表面属性」简化为「定义二维图像表面属性」了。</p>
<img src="texturemap.png" style="zoom:50%">
<p>假设这种映射关系已经找到了。不难发现，任意一个三角形的顶点，在二维纹理图像 $\mathbf{uv}$ 上都有对应的坐标，所以顶点处的纹理很好计算。那如何计算三角形内部任何一个点的纹理坐标呢？这就又涉及到<strong>插值</strong>了，即让纹理在三角形内部作平滑过渡。</p>
<blockquote>
<p>同时我们希望对于多个相邻物体赋予同一纹理时（比如草坪，以一个平方为单位赋予纹理），我们希望两块纹理之间能够<strong>无缝衔接</strong>（这种纹理称为 <strong>tilable texture</strong>）。这就需要一个好的纹理设计，通常使用 <strong>wang tiled</strong> 算法。</p>
</blockquote>
<h3 id="插值-Interpolation">插值(Interpolation)</h3>
<p>之前我们提到过很多次「插值」的概念，在这里对其进行比较详细的阐述。插值的意义在于，如果已知三角形的三个顶点的值，那么通过插值的方法可以得到三角形内任何一点的值，并且任意两点之间的值是平滑过渡的。下面主要了解一种名为「重心坐标」的插值方法。</p>
<h4 id="重心坐标-Barycentric-Coordinates">重心坐标(Barycentric Coordinates)</h4>
<p>根据高中知识，对于二维平面上的三角形而言，其<strong>重心</strong>定义为三条中线的交点。重心有一些重要的性质，比如与三角形顶点的连线将三角形面积三等分，平面直角坐标系中重心的坐标等于顶点坐标的算术平均等。第二条性质用数学的方法可以表示为</p>
<p>$$
P_{x,y} = \frac{1}{3}A_{x,y}+\frac{1}{3}B_{x,y}+\frac{1}{3}C_{x,y}
$$</p>
<p>其中 $P$ 为 $\triangle{ABC}$ 的重心。</p>
<p>再次根据高中知识，线段 $AB$ 上的一点 $Q$ 的坐标可以表示为 $Q_{x,y}=\alpha A_{x,y}+(1-\alpha)B_{x,y}$。</p>
<p>那么对于 $\triangle{ABC}$ 而言，我们完全可以认为其内部一点是 $AB$ 上某一点和 $C$ 所成线段上的点，是否也可以利用上面这个性质呢？答案是：<strong>可以</strong>！</p>
<p>事实上三角形内部任何一点 $Q$ 的坐标都可以表示成 $Q_{x,y} = \alpha A_{x,y}+\beta B_{x,y}+\gamma C_{x,y}$ 的形式，其中 $\alpha+\beta+\gamma=1$。只不过重心是 $\alpha=\beta=\gamma=1/3$ 时的特殊情况。</p>
<details><summary>简单的推导</summary>
<p>取 $\triangle{ABC}$ 内部任意一点 $P$，连接 $CP$ 并延长交 $AB$ 于点 $Q$。易得 $Q_{x,y} = \lambda A_{x,y} + (1-\lambda) B_{x,y}$，那么有</p>
<p>$$
\begin{aligned}
P_{x,y}
&amp;= \gamma C_{x,y} + (1-\gamma) P_{x,y} \
&amp;= \gamma C_{x,y} + (1-\gamma)\lambda A_{x,y} + (1-\gamma)(1-\lambda) B_{x,y}
\end{aligned}
$$</p>
<p>此时令 $\alpha=(1-\gamma)\lambda, \beta=(1-\gamma)(1-\lambda)$ 即得结果，并且不难发现 $\alpha+\beta = 1-\gamma$</p>
</details>
<p>我们称 $(\alpha,\beta,\gamma)$ 为<strong>重心坐标</strong>（注意区别于<em>重心的坐标</em>）。</p>
<p>现在问题来了，对于三角形内一个点，怎么求对应的重心坐标呢？答案如下图所示，证明就不证了。</p>
<img src="bc.png" style="zoom:50%">
<p>现在我们可以利用这三个系数进行插值了。已知三个顶点的「值」 $V_A, V_B, V_C$，利用重心坐标，内部任意一点的「值」为</p>
<p>$$
V = \alpha V_A + \beta V_B + \gamma V_C
$$</p>
<blockquote>
<p>这里的「值」既可以是 Phong Shading 的法线，也可以是纹理值。</p>
<p>要注意的是，三维空间的点 $P$ 投影到二维屏幕上成为 $P’$ 后，$(\alpha,\beta,\gamma)<em>P\neq (\alpha,\beta,\gamma)</em>{P’}$。所以想要对三维空间的属性进行插值，就必须先在三维空间内做，再对应到二维结果上去。</p>
</blockquote>
<h4 id="纹理映射中的应用">纹理映射中的应用</h4>
<p>现在我们可以计算三角形内部任一点的纹理坐标 $\mathbf{u}\mathbf{v}$ 了，具体做法是：在三维空间中，先求出重心坐标 $(\alpha,\beta,\gamma)$，再利用三个顶点的纹理坐标进行插值计算 $\mathbf{u}\mathbf{v} = \alpha(\mathbf{u}\mathbf{v}_A)+\beta(\mathbf{u}\mathbf{v}_B)+\gamma(\mathbf{u}\mathbf{v}_C)$。得到结果后，就可以直接去二维纹理图上找到对应的纹理值，应用即可。</p>
<h4 id="双线性插值-Bilinear-Interpolation">双线性插值(Bilinear Interpolation)</h4>
<p>对于一个给定的纹理，其上的<strong>纹理元素(Texel, Texture Element)<strong>数量是固定的。在纹理比较</strong>小</strong>的情况下，比如我们要将一张 512*512 的纹理应用到整个 4k 屏幕上，就必然导致屏幕的多个像素，对同一个 Texel 进行采样。有的像素点可能对应的纹理坐标没有落到纹理中心，比如下面这样</p>
<img src="texelsample.png" style="zoom:50%">
<p>一种简单的方法是<strong>就近法(Nearest)</strong>，就是找最近的那个 Texel，那么会使得多个像素赋予同一个纹理值，最后得到的结果就会呈现颗粒状，两个像素之间有明显的界限，如下面最左边那张图。</p>
<img src="nearest.png" style="zoom:50%">
<p>我们发现中间的 Bilinear 方法效果更好，那么它为什么会这么好呢？是因为 Bilinear 不是找最近的一个，而是根据最近的四个 Texel 的纹理值作两次线性插值，就会得到一个比较好的效果，同时开销也不会非常大。</p>
<img src="bilinear.png" style="zoom:50%">
<p>而最右侧的 Bicubic 是找最近的十六个点，效果当然会更好，但同样开销也更大了。</p>
<h4 id="mipmap-与三线性插值-Trilinear-Interpolation">mipmap 与三线性插值(Trilinear Interpolation)</h4>
<p>上面讨论了纹理过小的情况，还算比较简单。那么纹理如果过大呢？比如在一个屏幕内有一个视角很大、场景层次很丰富的世界场景，远山所占的屏幕内容很小，但是纹理贴图却很大，此时会转变为同一个像素点对多个 Texel 进行采样。根据之前的讨论，这时数据频率远大于采样频率，就会导致图像失真，出现摩尔纹等现象。</p>
<img src="texelbig.png" style="zoom:60%">
<p>我们可以用 MSAA 的方法，在一个像素点内用更多的采样点，取平均值就好了，效果当然会不错，但是开销也会非常大。有没有一种更好的方法，即我们能不能在采样前预先计算好平均值，这样就不需要在采样的时候作重复计算呢？<strong>Mipmap(Multum in parvo map)</strong> 来了。</p>
<p>Mipmap 的原理很简单，对于一个纹理图，不断将其分辨率缩放一半，每缩放一次，将结果作为更高的 level。$i$ 层对应大小为 $2^i$ 的纹理区域。之后只需要求出采样的纹理面积/边长，在相应 level 的纹理图中根据 $\mathbf{u}\mathbf{v}$ 取值就行。</p>
<img src="mipmap.png" style="zoom:60%">
<p>对于屏幕上的一个像素点 $P$，我们可以找其相邻的四个像素点，将这五个点分别在纹理空间中找到对应的纹理坐标，然后求中心点 $P_{tex}$ 到另外四个点距离的最大值 $L$，就可以近似认为该像素点所采样的纹理区域是一个边长为 $L$ 的正方形。说明该像素点对应的纹理值要去 $\log_2{L}$ 层取。</p>
<img src="computemipmap.png" style="zoom:60%">
<p>这里的 $\log_2{L}$ 如果是一个浮点数，就不能直接使用了，我们总不能去 1.7 层找吧！如果进行四舍五入那就又陷入就近法的误区了。参考之前的做法，我们可以找到 $D=\lfloor\log_2{L}\rfloor$ 层和 $D+1=\lceil\log_2{L}\rceil$ 层的 bilinear 结果，然后再次进行线性插值。实际上就是 <strong>trilinear</strong> 了。</p>
<img src="trilinear.png" style="zoom:60%">
<p>三线性 + mipmap 虽然能处理一些小像素采样大纹理的问题，但仅能对正方形进行近似，如果一个像素点采样的纹理区域是不规则图形，比如比较斜的平行四边形，此时用正方形对其进行近似就会出现 <strong>OverBlur</strong> 的问题。</p>
<img src="irregular.png" style="zoom:60%">
<blockquote>
<p>有一些替代方案，比如**各向异性过滤(Anisotropic Filtering)**可以用矩形进行近似，但并没有解决上面提到的问题。</p>
<p><strong>EWA filtering</strong> 可以将不规则形状拆分为若干圆形，每次查询其中一个圆，分多次查询来近似。虽然能够比较好的进行近似，但「多次查询」已经暴露了其开销过大的缺陷。</p>
</blockquote>
<h3 id="纹理的其他应用">纹理的其他应用</h3>
<p>对于现代 GPU 而言，所谓纹理，其实就是一块内存(memory)，并且可以对其进行范围查询/过滤(range query/filtering)，所以纹理其实是一个比较广义的概念，并不局限于「图片」，可以表示非常多的东西。</p>
<h4 id="环境贴图-Environment-Mapping">环境贴图(Environment Mapping)</h4>
<p>我们可以用纹理来描述环境光，再去渲染物体，这样就代替了点光源。此时我们可以假设环境光都是来自<strong>无穷远处</strong>，光强和距离无关，只记录方向信息，也就是说只要方向相同，环境光强就是一致的。比如下图，左图描述了在房间里从四面八方看到的光，用左图去渲染一个茶壶（右图），我们就能观察到茶壶被环境光所照亮，并反射来自四面八方的光。</p>
<img src="cup.png" style="zoom:60%">
<blockquote>
<p>这是一个经典模型，名为<strong>犹他茶壶(Ultra teapot)</strong></p>
</blockquote>
<p>那么如何描述呢？</p>
<p>第一种做法是存储在<strong>球面</strong>上，但因为不是一个均匀的描述，会在靠近极点的地方出现扭曲。</p>
<img src="sphericalmap.png" style="zoom:60%">
<p>第二种做法是，假设上面的球有一个立方体状的包围盒，那原来记录在球面上的环境光信息，会沿着与球心的延长线打在盒面上，而不会有差异。也就是可以将环境光信息存储在<strong>立方体表面</strong>上，这样展开就会得到下图：</p>
<img src="cubemap.png" style="zoom:60%">
<h4 id="凹凸贴图-Bump-Mapping">凹凸贴图(Bump Mapping)</h4>
<p>纹理甚至可以定义物体表面某个点的「相对高度」，也就是在原来物体基础上定义凸起和凹陷的程度。这样就可以在<strong>不修改几何模型</strong>的前提下影响物体表面的着色。如下图，定义了相对高度后，求得的法线就会随之发生变化，那 Shading 的结果就会发生变化，就会看到不同的明暗对比。</p>
<img src="orange.png" style="zoom:60%">
<blockquote>
<p>如果想表示球上凹凸不平的复杂几何，那就要用更多的三角形了。</p>
</blockquote>
<p>法线的求法也很简单，只需要在纹理空间中求出该点在 $\mathbf{u}, \mathbf{v}$ 两个方向上的梯度，那就得到了切线，通过切线就能简单地得到法线了。</p>
<h4 id="位移贴图-Displacement-mapping">位移贴图(Displacement mapping)</h4>
<p>凹凸贴图本质上没有改变物体几何，而是用了视错觉原理，欺骗人的眼球，给人一种凹凸不平的错觉。</p>
<img src="displacementmap.png" style="zoom:60%">
<p>而<strong>位移贴图</strong>实际上会修改物体几何，即改变了三角形顶点的位置。但如果一个三角形比较大，就无法改变三角形内部还有一些需要改变的位置。也就是说三角形要足够细，细到三角形顶点之间的间隔要比纹理定义的频率还要高，使得模型能够跟得上所定义的纹理的变化速度。</p>
<p>有一种解决方案是，开始先用比较粗糙（三角形少）的模型，在应用位移贴图的过程中检测一下是否应该把三角形变得更细，如果需要，就将三角形拆开成很多小三角形，再继续做位移贴图。</p>
<h4 id="三维纹理">三维纹理</h4>
<p>事实上纹理没必要限制在二维，也可以是三维的。像下图，如果将这个球砍一半，我们希望可以看到它内部的情况，也就是说需要定义空间中任意一个点的纹理值。而实际上没有真的生成纹理的图，而是定义了一个定义在三维空间中的噪声的函数，所以在空间中任何一个点，它都有一个解析式可以算出来噪声的值。像这里是<strong>柏林噪声(Perlin noise)</strong></p>
<img src="3dtexture.png" style="zoom:60%">
<h2 id="几何-Geometry">几何(Geometry)</h2>
<h3 id="隐式表示-Implicit">隐式表示(Implicit)</h3>
<p>隐式表示方法不会指明具体的点在哪，而是给出这些点满足的关系。</p>
<h4 id="代数曲面-Algebraic-Surfaces">代数曲面(Algebraic Surfaces)</h4>
<p>根据单位球面满足关系 $x<sup>2+y</sup>2+z^2=1$，不妨进行推广，任意物体表面都可以由这样一个数学公式进行表达：</p>
<p>$$
f(x,y,z)=0
$$</p>
<p>已知任意一个 $x,y,z$，我们可以计算 $f(x,y,z)$，进而判断 $(x,y,z)$ 在物体内部（&lt;0）、表面上（=0）还是在物体外部（&gt;0）。</p>
<h4 id="构造实体几何-CSG-Constructive-Solid-Geometry">构造实体几何(CSG, Constructive Solid Geometry)</h4>
<p>通过对基本几何的基本布尔运算（并集、交集、差集），来定义新的几何。</p>
<img src="csg.png" style="zoom:60%">
<h4 id="符号距离函数-Signed-Distance-Functions">符号距离函数(Signed Distance Functions)</h4>
<p>对于任何一个几何，都不直接描述它的表面，而是描述任何一个点到这个表面的最近距离，这就是<strong>符号距离函数</strong>（结果为正则认为在物体表面的外面，负的则在物体内部）。</p>
<p>计算出两个物体的符号距离函数 $SDF_1, SDF_2$ 后，就可以将两者做一个 blending，得到一个新的符号距离函数 $SDF$，然后再恢复成原来的物体（所有满足 $SDF(x,y,z) = 0$ 的点构成的集合就是物体的表面），就可以得到如下的变换。</p>
<img src="disfunc.png" style="zoom:60%">
<h4 id="水平集-Level-Set-Methods">水平集(Level Set Methods)</h4>
<p>这个方法的思路和距离函数其实完全一样，仅仅是函数的表述是写在格子上的，函数在不同的格子上有不同的值，只需要找出格子中值为 0 的点（可以通过双线性插值计算），就可以将函数试图描述的物体表面提取出来。</p>
<blockquote>
<p>这和地理上的等高线的概念是一致的。</p>
</blockquote>
<h4 id="分形-Fractals">分形(Fractals)</h4>
<p>分形是自相似的意思，也就是说自己的一个部分和它的整体长得非常像，和计算机科学中说的<strong>递归</strong>是一个道理。下图是一种叫 Romanesco 的西兰花。</p>
<img src="fractals.png" style="zoom:60%">
<blockquote>
<p>这种类型的几何对于渲染和描述来说都是巨大的挑战，渲染时会引起强烈的走样</p>
</blockquote>
<h4 id="总结-3">总结</h4>
<p>隐式表示表述起来相对容易，同时支持点与物体表面位置关系的查询，且有利于求解光线与表面的交集。</p>
<p>缺点在于，很难描述复杂的几何结构。</p>
<h3 id="显示表示-Explicit">显示表示(Explicit)</h3>
<p>显示表示则是直接给出点的位置。</p>
<h4 id="参数映射-Parameter-Mapping">参数映射(Parameter Mapping)</h4>
<p>比如定义了一个坐标系 $\mathbf{u}, \mathbf{v}$，对于给定的任意点 $(u,v)$，都会映射到空间中的点 $(x,y,z)$ 中，这样只需要遍历一遍 $(u,v)$，就可以得到所有的 $(x,y,z)$。</p>
<img src="explicit.png" style="zoom:60%">
<h4 id="点云-Point-Cloud">点云(Point Cloud)</h4>
<p>我们不考虑物体是一个表面，而是由海量点组成。只要点足够密集，那么点与点之间的缝隙就可以忽略不计，理论上可以表示任何类型的几何体。</p>
<p>而如果点云密度很低，就很难绘制成物理实体，所以除了最原始扫描出来的数据，人们很少用点云。</p>
<h4 id="多边形面-Polygon-Mesh">多边形面(Polygon Mesh)</h4>
<p>这是用的最广泛的，也是之前一直在聊的，就是将物体表面视为由若干三角形组成。这就会涉及到一个问题，就是三角形之间的<strong>连接关系</strong>，这是点云不会遇到的。</p>
<p>有一种特殊文件格式，<strong>The Wavefront Object File(.obj) Format</strong>，对于该格式的文件，一个文件存储一个物体或场景，把空间中的一堆顶点、法线和纹理坐标分开来表示，然后在一块把他们组织起来形成模型。如下图，描述的是一个立方体。</p>
<img src="obj.png" style="zoom:60%">
<ul class="lvl-0">
<li class="lvl-2">
<p><code>v</code>：描述顶点信息；</p>
</li>
<li class="lvl-2">
<p><code>vt</code>：描述纹理坐标；</p>
</li>
<li class="lvl-2">
<p><code>vn</code>：描述每个面的法线方向；</p>
</li>
<li class="lvl-2">
<p><code>f</code>：描述哪三个点构成三角形，格式为 <code>三角形顶点/纹理坐标/法线坐标</code>；</p>
</li>
</ul>
<h4 id="贝塞尔曲线-Bezier-Curve">贝塞尔曲线(Bézier Curve)</h4>
<p>贝塞尔曲线由一系列控制点 $\mathbf{b}_0, \mathbf{b}_1, \dots, \mathbf{b}<em>n$ 定义。具体而言，我们需要将控制点顺序连接（这样会有 $n-1$ 条边），在每条边上我们找到 $t$ 分点，得到一组新的点 $\mathbf{b}^1_0, \mathbf{b}^1_1, \dots, \mathbf{b}^1</em>{n-1}$。重复上述过程，直至生成唯一一个点 $\mathbf{b}^n_0$。当 $t\in[0,1]$ 时，这个点就表示了贝塞尔曲线的运动轨迹。</p>
<img src="bezier.png" style="zoom:60%">
<p>我们可以利用 $\mathbf{b}^n_i = (1-t)\mathbf{b}^{n-1}<em>i + t\mathbf{b}^{n-1}</em>{i+1}$ 这一性质作金字塔式计算，不难得到这样一个结论</p>
<p>$$
\mathbf{b}^n(t) = \mathbf{b}^n_0(t) = \sum\limits_{i=0}<sup>n\mathbf{b}_iB</sup>n_i(t)
$$</p>
<p>其中 $B^n_i(t)=\left(\begin{matrix}n\ i\end{matrix}\right)t<sup>i(1-t)</sup>{n-i}$，即二项分布多项式（<strong>伯恩斯坦多项式</strong>）。</p>
<p>贝塞尔曲线具备以下<strong>性质</strong>：</p>
<ol>
<li class="lvl-3">
<p>过起点 $\mathbf{b}_0$（t=0）和终点 $\mathbf{b}_n$（t=1）；</p>
</li>
<li class="lvl-3">
<p>在 $n=4$ 时，曲线在起点和终点的切线满足：$\mathbf{b}‘(0)=3(\mathbf{b}_1-\mathbf{b}_0),\mathbf{b}’(1)=3(\mathbf{b}_3-\mathbf{b}_2)$；</p>
</li>
<li class="lvl-3">
<p><strong>仿射相似性</strong>：对原始控制点作仿射变换后得到新控制点，再构造贝塞尔曲线 $bc’$，和直接对原始贝塞尔曲线 $bc$ 作仿射变换所得到的结果是一样的。<u>投影变换不行</u>；</p>
</li>
<li class="lvl-3">
<p><strong>凸包性质</strong>：贝塞尔曲线一定在所有控制点形成的凸包（能够包围一系列给定的几何形体的<strong>最小的凸多边形</strong>）内。如果所有控制点共线，那么对应的贝塞尔曲线是起点与终点形成的线段；</p>
</li>
</ol>
<p>🤷‍♂️ 当控制点数量过多时，得到的贝塞尔曲线并不一定是我们想要的，甚至很难控制。</p>
<img src="highorderbc.png" style="zoom:60%">
<p>此时可以若干个控制点为一组分别绘制贝塞尔曲线，再首尾相连即可。一般取 4 个为一组，也就是 <strong>Piecewise cubic Bézier</strong>。这形成一种最简单的连续，是几何上的连续，一般称为 $C^0$ 连续。</p>
<img src="c0pbc.png" style="zoom:60%">
<p>但为了使结果平滑过渡，我们需要利用<strong>性质 2</strong>，令分段点的左右切线相等。此时有三点共线，且分段点（中间的点）为线段中点，如下图所示。此时就称为 $C^1$ 连续。</p>
<img src="c1pbc.png" style="zoom:60%">
<blockquote>
<p>$C^2$ 连续则要保证二阶导连续，更高阶的连续性同理。</p>
</blockquote>
<h4 id="贝塞尔曲面-Bezier-Surfaces">贝塞尔曲面(Bézier Surfaces)</h4>
<p>贝塞尔曲面其实就是通过贝塞尔曲线得到的。对于一个用 4*4 个点控制的贝塞尔曲面而言，可以将其 4 个控制点为一组分为 4 组。</p>
<img src="bs1.png">
<p>每一组控制点得到一条横向的贝塞尔曲线 $bc_i$，当 $t$ 相同时，四条曲线上的点 $bc_i(t)$ 四点共面，我们认为这四个点可以作为新的控制点，并绘制出一条纵向的贝塞尔曲线。</p>
<img src="bs2.png">
<p>当 $t\in[0,1]$ 时，横向贝塞尔曲线的这四个点会逐渐扫过空间，那么这四个点控制的贝塞尔曲线在扫的过程中也就形成了最终我们想要的贝塞尔曲面。</p>
<img src="bs3.png" style="zoom:60%">
<p>要找到贝塞尔曲面上任何一个点，根据上面的过程，需要两个不同的参数，在水平方向上找一个参数 $t$，找到 4 个点后，这 4 个点要连成一条曲线，还需要一个参数 $t$。所以需要用二维参数来控制，那不如管它叫 $\mathbf{u}\mathbf{v}$ 好了🤣。</p>
<h3 id="网格细分-Mesh-Subdivision">网格细分(Mesh Subdivision)</h3>
<p>我们可以通过增加三角形的数量，使要表示的曲面更加光滑，看上去就像增大了图像的分辨率，可以看到更多细节的东西。</p>
<img src="meshsub.png" style="zoom:60%">
<h4 id="loop-细分">loop 细分</h4>
<blockquote>
<p>loop 是人名，不是「循环」的意思。</p>
</blockquote>
<p>取三角形三条边的中点，依次相连，可以将三角形一分为四。接下来就可以通过调整顶点位置来修改三角形的位置。这里特殊的一点是，新顶点和旧顶点需要采用不同的规则。</p>
<p>对于<strong>新</strong>的顶点 $P$，只要其所在边 $AB$ 不是物体边界，那么必定被两个三角形 $\triangle{ABC}, \triangle{ABD}$ 共享。此时需要将 $P$ 更新至 $\displaystyle \frac{3}{8}(A+B)+\frac{1}{8}(C+D)$，从而使得表面更加平滑。</p>
<img src="newvtx.png" style="zoom:60%">
<p>对于<strong>旧</strong>的顶点 $Q$，取其度 $n$ 以及一个相关的数 $u$，对其自身与邻接点（旧）做一个加权平均，这样既能在度较低时尽可能保留本身的位置信息，也允许在度较大时完全由其它点来决定。</p>
<img src="oldvtx.png" style="zoom:60%">
<h4 id="Catmull-Clark-Subdivision">Catmull-Clark Subdivision</h4>
<p>loop 细分仅在三角形网格中适用，而如果存在一些网格面是四边形（对应一般的情况），就需要用到 Catmull-Clark 细分了。</p>
<blockquote>
<p>图灵奖得主提的算法。</p>
</blockquote>
<p>首先定义度不为 4 的点为<strong>奇异点</strong>，四边形平面为 <strong>quad face</strong>，其它为 <strong>non-quad face</strong>。</p>
<p>第一步进行细分，具体操作为：取 <strong>non-quad face</strong> 上的<strong>重心</strong>，与其每条边的中点进行连接。在此操作后，就不存在 <strong>non-quad face</strong> 点了，只是会引入等量的奇异点。</p>
<img src="ccs.png" style="zoom:60%">
<p>第二步进行调整，依然是有不同规则，如下图。</p>
<img src="fyi.png" style="zoom:60%">
<h3 id="网格简化-Mesh-Simplification">网格简化(Mesh Simplification)</h3>
<p>游戏为提高性能，不希望顶点太多，顶点多了，顶点的变换、着色等要花更多的时间；并且如果某个物体距离很远，就不需要用很多三角形去把一些细节的东西建模出来。</p>
<p>总而言之，当我们不需要这么复杂的网格的时候，就可以减少网格数量，去掉一些边和三角形。</p>
<blockquote>
<p>但仍然要维持它们之间的相互关系，这就需要一定的方法。</p>
</blockquote>
<img src="meshsimp.png" style="zoom:60%">
<h4 id="边坍缩-Edge-Collapsing">边坍缩(Edge Collapsing)</h4>
<p>找一条边，将这条边两端的点缩到一起，这条边就不存在了。</p>
<img src="ec.png" style="zoom:60%">
<p>怎么找边也是有讲究的。我们希望找到的这条边尽可能「<strong>不重要</strong>」，也就是将其坍缩后对物体的影响尽可能小。那么如何衡量所谓的「影响」呢，就要使用到**二次度量误差(Quadric Error Metrics)**了。</p>
<p>令某条边坍缩后形成的新点 $P$，那么 $P$ 到原本受影响面的距离平方和就是要求的二次度量误差。</p>
<img src="eq.png" style="zoom:60%">
<p>我们不妨假设每条边坍缩后，将新点进行移动，总能移动到一个最优的位置，使得二次度量误差最小，那么可以将最小的二次度量误差值作为该边的<strong>坍缩分数</strong>（该值越大，就表示这条边坍缩后对物体的影响越大）。</p>
<p>在统计所有边的坍缩分数后，我们可以不断取坍缩分数最低的边进行坍缩，之后更新所有相关的边（或者说发生变化的边），重复上述步骤直至不再需要进行简化。</p>
<blockquote>
<p>这种方式是一个典型的贪心算法，通过不断对局部做最优解的方式试图找到一个全局的最优解。虽然不能保证有全局最优性质，但是结果不错。可以利用<strong>优先队列/堆</strong>来实现，能保证既快速取到最小值，又能动态的以最小的代价去更新其他的受影响的元素。</p>
</blockquote>
<h3 id="网格正则化-Mesh-Regularization">网格正则化(Mesh Regularization)</h3>
<p>如果三角形有大有小有细长，会对渲染造成不便，通常对于这种情况，会对模型做正则化，即让这些面变得更像正三角形。</p>
<img src="meshsreg.png" style="zoom:60%">
<h2 id="光线追踪-Ray-Tracing">光线追踪(Ray Tracing)</h2>
<p>光栅化本质上是一种快速，近似的渲染方法，质量相对较低，仅能处理局部着色点，并不能很好地处理全局效果，如<strong>软阴影(Soft Shadow)</strong>、<strong>光泽反射(Glosyy Reflection)</strong>、<strong>间接光照(Indirect Illumination)<strong>等。通常用于</strong>实时</strong>的应用，如每秒生成超过 30 帧的图。</p>
<p>而<strong>光线追踪</strong>渲染准确，质量高，完全符合物理规律，能给大家带来最真实的渲染结果，缺点是非常慢。更多被用于做<strong>离线</strong>的应用，如电影生成。</p>
<h3 id="Shadow-Mapping">Shadow Mapping</h3>
<blockquote>
<p>在「着色」部分，我们谈到「Shading is Local」，也就是没有考虑阴影，接下去就把这缺失但重要的部分给补上。</p>
</blockquote>
<p>我们先考虑点光源下如何生成阴影。如果将一个点和点光源相连，与其它物体产生交点，那说明该点被遮挡，在我们的视角里这个点会被打上阴影；如果这个点我们压根看不到，也就不用谈阴影的事了。</p>
<p>所以这里有一个很简单的思路：<strong>对于原始相机处所有可见的点，我们可以在点光源 $L$ 处对其进行观测，如果其在 $L$ 处不可见，说明光线没法到达这个点，那也就是在阴影里；反之正常着色</strong>。</p>
<p>判断一个点是否「能被光源相机看到」，可以直接在位置 $L$ 做一遍光栅化，就生成了所有光源会看到的点的深度信息。接着在原始位置再做一次光栅化，匹配可视点在 $L$ 处的深度，如果不一致，说明在阴影中，如下图红线；反之，可以被正常着色，如下图蓝线。</p>
<img src="shadowmapping.png" style="zoom:60%">
<p>这种做法在判断「深度一致」方面存在<strong>浮点精度</strong>问题，毕竟判断两个浮点数相等是做不到的，虽然人们也引入了 $a&gt;b+\text{bias}$ 的方式，但不能从根本上解决问题。</p>
<p>同时，在点光源处做光栅化也会涉及到<strong>分辨率</strong>的问题。如果分辨率很低，但渲染整个场景的分辨率又很高，那就容易产生走样（场景多个点对应到同一个像素）；但分辨率太大的话开销就会大。</p>
<p>我们在对某个点进行判断时，仅仅是「非此即彼」的形式，要么在阴影中，要么不在阴影中，所以 Shadow Mapping 只能做<strong>硬阴影(Hard Mapping)</strong>：阴影的边缘非常锐利。比如下面这样。</p>
<img src="hardshadow.png" style="zoom:60%">
<p>与此相对的还有一个<strong>软阴影(Soft Mapping)</strong>，它俩本质区别在于光源大小不同。如果光源非常大，那就会在物体背后形成「半影区」，此时就产生了软阴影：可以观察到阴影在逐渐过渡，越靠近物体根部越「硬」（本影区），反之越「虚」（半影区）。比如下面这样。</p>
<img src="softshadow.png" style="zoom:60%">
<h3 id="基础光追算法">基础光追算法</h3>
<p>光线具有以下基本物理性质：</p>
<ol>
<li class="lvl-3">
<p>直线传播；</p>
</li>
<li class="lvl-3">
<p>两条光线不会发生碰撞；</p>
</li>
<li class="lvl-3">
<p>光路可逆；</p>
</li>
</ol>
<blockquote>
<p>早期有人认为人眼观察到物体这一现象，是因为眼睛会发出感知光线打到世界中，当光线被物体挡住时就看到了东西。</p>
</blockquote>
<p>上面这一说法，在现在看来显然是错误的认知，但可以为光追原理带来一点感性上的参考。实际上，光线追踪是<u>从相机/人眼出发，往世界中投射光线，然后不断弹射直到光源上的过程</u>。</p>
<h4 id="光线投射-Ray-Casting-与针孔相机模型-Pinhole-Camera-Model">光线投射(Ray Casting)与针孔相机模型(Pinhole Camera Model)</h4>
<p>假设我们在往虚拟的世界中看，面前放了一个成像平面，成像平面上有很多像素的小格子。对于每个像素，可以从摄像机连一条线穿过这个像素，相当于打出去一根光线，这个光线会打到场景中的某个位置。</p>
<blockquote>
<p>事实上，这根光线会和很多物体相交，而物体之间会有遮挡关系，人眼看到的肯定是最近的，所以永远考虑这根光线和场景中的物体最近的交点。</p>
</blockquote>
<p>判断这个点是否在阴影里（与光源的连线(Shadow Rays)是否会被阻挡），如果它不在阴影里，根据光路可逆性质，这就形成了一条有效的光路。最后通过计算这条光路的能量，进行相应的着色操作。</p>
<img src="pcm1.png" style="zoom:60%">
<img src="pcm2.png" style="zoom:60%">
<h4 id="递归算法-Whitted-Style">递归算法(Whitted-Style)</h4>
<p>通过上面的方法可以得到和光栅化近似的结果，可这种方法狭隘地认为光线只反射一次——光线其实可以反射/折射很多次。对于更复杂的情况，可以用下面的算法实现。</p>
<p>Whitted-Style 的核心思想在于：<u>光线可以在空间中无限传播，只要你正确的算出来反射方向和折射方向</u>。</p>
<blockquote>
<p>如果一个点满足折射条件，那么光线投射到这点上就会发生折射，比如下面的球体（可以认为是一个玻璃球）。</p>
</blockquote>
<img src="ws.png" style="zoom:60%">
<p>由于光线发生多次弹射，上图中的 4 个弹射点都需要计算一次着色值，并且该光线对应的像素值为空间中所有弹射点的着色值之和（需要考虑能量损失）。</p>
<h3 id="光线和物体表面交点-Ray-Surface-Intersection-求解">光线和物体表面交点(Ray-Surface Intersection)求解</h3>
<blockquote>
<p><strong>奇-偶规则(Odd-Even Rule)</strong>：从任意位置 $p$ 作一条射线，若与该射线相交的多边形边的数目为奇数，则 $p$ 是多边形内部点，否则是外部点。</p>
</blockquote>
<p>数学意义上讲，光线其实就是一条<strong>射线</strong>，有起点和单位方向向量，表示为 $\mathbf{r}(t)=\mathbf{o}+t\mathbf{d}$。</p>
<p>其中</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>$\mathbf{o}$：起点位置；</p>
</li>
<li class="lvl-2">
<p>$t$：<strong>非负数</strong>，决定光线终点位置；</p>
</li>
<li class="lvl-2">
<p>$\mathbf{d}$：方向向量；</p>
</li>
</ul>
<h4 id="隐式物体表面">隐式物体表面</h4>
<p>对于隐式物体表面 $f(x, y, z)=0$，欲求光线与其交点，其实就是求解方程</p>
<p>$$
f(\mathbf{o}+t\mathbf{d})=0
$$</p>
<p>解出 $t$ 后代入 $\mathbf{r}(t)$ 即可求出交点位置，并根据解的数量判断与物体的位置关系。</p>
<h4 id="显式物体表面">显式物体表面</h4>
<p>对于显式物体表面，要分情况讨论。</p>
<p>对于单个三角形而言，交点只有 0 个或 1 个。对于一个三角形而言，我们可以快速求出其<strong>法线</strong> $\mathbf{N}$，假设交点为 $\mathbf{p}=\mathbf{o}+t\mathbf{d}$，可以找到三角形所在平面上另一个确定的点 $\mathbf{p’}$，必然满足 $(\mathbf{p}-\mathbf{p’})\mathbf{N}=0$。解得 $\mathbf{p}$ 后，可以用<strong>重心坐标</strong>判断是否在三角形内部。</p>
<blockquote>
<p>我们发现，光线与平面的交点 $\mathbf{p}$ 必然满足 $\mathbf{p} = b_1\mathbf{A}+b_2\mathbf{B}+(1-b_1-b_2)\mathbf{C}$，那么求解下面这个方程，就能把 $t$ 和重心坐标一起求出来，这就是 <strong>Möller–Trumbore 算法</strong>。</p>
<p>$$
\mathbf{o}+t\mathbf{d} = b_1\mathbf{A}+b_2\mathbf{B}+(1-b_1-b_2)\mathbf{C}
$$</p>
<p>我们将上式进行一定改动，得到</p>
<p>$$
-t\mathbf{d} + b_1(\mathbf{A}-\mathbf{C}) + b_2(\mathbf{B}-\mathbf{C}) = \mathbf{o} - \mathbf{C}
$$</p>
<p>不难发现这是一个关于 $t, b_1, b_2$ 的三元一次方程组，如果令</p>
<p>$$
\begin{aligned}
\mathbf{X} &amp;= -\mathbf{d}\ \mathbf{Y} &amp;= \mathbf{A}-\mathbf{C}\ \mathbf{Z} &amp;= \mathbf{B}-\mathbf{C}\ \mathbf{W} &amp;= \mathbf{o}-\mathbf{C}
\end{aligned}
$$</p>
<p>那么上式可以写作 $[\mathbf{X}, \mathbf{Y}, \mathbf{Z}]·[t, b_1, b_2]^T = \mathbf{W}$。</p>
<p>根据克莱姆法则，我们能够得到</p>
<p>$$
t = \det([\mathbf{W}, \mathbf{Y}, \mathbf{Z}])/\det([\mathbf{X}, \mathbf{Y}, \mathbf{Z}])
$$</p>
<p>又因为 $\det(\mathbf{a}, \mathbf{b}, \mathbf{c}) = \mathbf{a}·(\mathbf{b}\times\mathbf{c})$，则 $t$ 易求，同理 $b_1, b_2$ 易求。</p>
</blockquote>
<p>对于若干个三角形构成的物体而言，如果一个个三角形去遍历判断，那就太慢了。现代化做法是用**轴对齐包围盒(AABB)**包裹该物体，如果一道光线连 AABB 都不会产生交点，那必然不会和物体产生交点。</p>
<p>考虑<strong>二维空间</strong>，所谓 AABB，实际上就是 2 对分别与 $\mathbf{x},\mathbf{y}$ 轴垂直的平面形成的交集。所以判断光线能否与 AABB 产生交点，可以先令其所在直线与每一对平面作交点，此时每一对平面会生成两个交点，这样就形成了一条线段。如果 2 条线段之间在 $t\geq0$ 时存在交集，则说明光线与 AABB 相交。</p>
<img src="riaabb.png" style="zoom:60%">
<blockquote>
<p>使用 AABB 而不是任意平面是因为方便计算。</p>
</blockquote>
<p>那光线与 AABB 相交后，我们该如何判断光线与其内部的物体是否有交集呢？</p>
<h4 id="空间均匀切割-Uniform-Spatial-Partitions">空间均匀切割(Uniform Spatial Partitions)</h4>
<p>该方法指的是将给定 AABB 划分为若干小的 AABB，并且将那些与物体表面相交的小 AABB 打上标记。在光线传播过程中，如果与某个打上标记的小 AABB 有交点，则认为可能与物体表面相交，需要进一步判断。</p>
<img src="usp.png" style="zoom:60%">
<p>缺点是对于那些特别稀疏的场景而言，仍然需要较多的划分，并且需要找到一个划分疏密程度的平衡点。</p>
<h4 id="空间划分-Spatial-Partitions">空间划分(Spatial Partitions)</h4>
<p>对于一个物体比较稀少的空间，我们希望减少划分；而如果物体比较密集，我们希望能尽可能细致地划分。</p>
<p>之前常用的划分方式有八叉树(Oct-Tree)、KD-Tree、BSP-Tree。如果一条光线与某个 AABB 有交点，那么认为它可能与该 AABB 的所有划分结果有交点，需要在一个树状结构中进行递归判断。</p>
<blockquote>
<p>我们知道，光线与包围盒空间求交点是非常迅速的，但是与物体表面求交点相对而言更加困难，所以我们应当尽可能减少「与物体表面求交」这一操作。</p>
<p>前两者都有两个共同的问题，第一个是<strong>物体可能存在于多个子空间中</strong>，比如一条光线可能经过多个子空间，而这些子空间都与同一个物体相交，那就需要对该物体进行多次交点求解。第二个是<strong>很难判定 AABB 是否和物体存在交集</strong>。</p>
<p>而后者则没有划分为轴平行包围盒，不便于计算。</p>
</blockquote>
<img src="sp.png" style="zoom:60%">
<h4 id="物体划分-Object-Partitions-与-Bounding-Volume-Hierarchy-BVH">物体划分(Object Partitions)与 Bounding Volume Hierarchy(BVH)</h4>
<p>BVH 这种加速结构目前得到了非常广泛的应用，其本质思想在于：<u>对物体进行划分</u>。我们可以以一个大的 AABB 为起点，将其中的物体划分为两部分，分别计算这两部分的 AABB。如果某个 AABB 中的物体数量低于一定数量，那就停止；反之，继续以该 AABB 为起点进行递归的划分。</p>
<img src="bvh.png" style="zoom:60%">
<p>这就解决了上面空间划分的两个问题。因为一旦确定了划分方式，其实就相当于确定了 BVH 的树状结构。在 BVH 中，一个叶子节点对应了一个 AABB，并且一个物体只会存在于一个叶子节点中，相当于确定了这个 AABB 与哪些物体存在交集。</p>
<blockquote>
<p>尽管这种方式会使得 AABB 之间存在交集，但这点开销 who cares？</p>
</blockquote>
<p>唯一需要考量的是<strong>如何划分物体</strong>。一个可取的思路是：<u>取中间的物体进行划分</u>，即找若干个数的中位数，可以用<strong>快速选择算法</strong>在 $O(n)$ 内完成。</p>
<blockquote>
<p>❗ 需要注意的是，无论是 BVH 还是空间划分，都是在做光线追踪之前的预处理操作，有了这个树状结构就可以在真正做光追时进行加速。如果场景是动态的、物体移动了、或者加了新物体，要重新去计算一个新的加速结构。</p>
</blockquote>
<p>BVH 的求解伪代码如下：</p>
<img src="bvhcode.png" style="zoom:60%">
<h3 id="辐射度量学-Radiometry">辐射度量学(Radiometry)</h3>
<p>辐射度量学是一种方法，能定义一系列的属性和单位去描述光照。之前在 Blinn-Phong 模型中，我们有定义「光强」这么一个概念，但并没有明确给出其物理意义，这就是辐射度量学要说明的。接下来聊聊光照相关的两个基本属性。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>辐射能量(Radiant Energy)</strong>：符号 $Q$。单位<strong>焦耳</strong>($\text{J}$)；</p>
</li>
<li class="lvl-2">
<p><strong>辐射通量(Radiant Flux)</strong>：定义为单位时间产生的能量 $\displaystyle\Phi=\frac{dQ}{dt}$，常称<strong>功率</strong>。单位<strong>瓦特</strong>($\text{W}$)/<strong>流明</strong>($\text{lm}$)。也可定义为单位时间内通过某一平面的光子数量/光源的亮度；</p>
</li>
</ul>
<p>有了以上两个基本属性以后，就能对其进行拓展了。</p>
<h4 id="辐射强度-Intensity">辐射强度(Intensity)</h4>
<p>定义为<strong>点光源在单位立体角的辐射通量(Power Per Unit Solid Angle)</strong>。</p>
<p>即 $\displaystyle I(\omega)=\frac{\text{d}\Phi}{\text{d}\omega}$，单位 $\displaystyle \frac{\text{W}}{\text{sr}}=\frac{\text{lm}}{\text{sr}}=\text{cd}/\text{candela}$。</p>
<p>那么什么是立体角呢？数学中的**角(Angle)**通常用弧度表示，对应一段圆的弧长，此时弧度为 $\displaystyle\theta=\frac{l}{r}$。</p>
<img src="angle.png" style="zoom:60%">
<p>而立体角则是会形成一个锥体，对应球体的表面，此时立体角度为 $\displaystyle\Omega=\frac{A}{r^2}$。</p>
<img src="solidangle.png" style="zoom:60%">
<blockquote>
<p>整个球的立体角为 $4\pi r<sup>2/r</sup>2 = 4\pi$</p>
</blockquote>
<p>有了这一概念，那么单位立体角的计算，就可以通过计算球表面单位面积来求解。如果我们引入了球体的 $\theta,\phi$ 表示，那么这就很简单了，如下图。</p>
<img src="da.png" style="zoom:60%">
<blockquote>
<p>可以认为单位面积是一块矩形区域，其长为 $d\theta$ 对应的弧长，宽为 $d\phi$ 在半径为 $r\sin\theta$ 的圆中对应的弧长。</p>
<p>此时整个球的立体角也可以用下式进行计算</p>
<p>$$
\Omega=\displaystyle\int_{S<sup>2}d\omega=\int_0</sup>{2\pi}\int_0^\pi\sin\theta d\theta d\phi = 4\pi
$$</p>
</blockquote>
<p>我们只需要确定某个光照方向 $\omega$ ，就可以用 $\theta,\phi$ 定义其位置，进而计算出对应的单位立体角。所以 intensity 也可以理解为<strong>光源在任意方向上的亮度</strong>。</p>
<p>假设光线从点光源处均匀辐射，那么任一方向上的 intensity 都是相同的，如果我们又预先知道了这个点光源的 flux（对应整个球面），就可以用以下式子计算出 intensity：</p>
<p>$$
\Phi = \int_{S^2}Id\omega = 4\pi I \longrightarrow I = \frac{\Phi}{4\pi}
$$</p>
<h4 id="辐射照度-Irradiance">辐射照度(Irradiance)</h4>
<p>定义为<strong>单位面积上的辐射通量(Power Per Unit Area)</strong>。</p>
<p>即 $\displaystyle E(\mathbf{x})=\frac{\text{d}\Phi(\mathbf{x})}{\text{d}A}$，单位 $\displaystyle\frac{\text{W}}{\text{m}<sup>2}=\frac{\text{lm}}{\text{m}</sup>2}=\text{lux}$。</p>
<blockquote>
<p>注意计算时必须用 Power 垂直于 Unit Area 的分量，就是前面「漫反射」提到的，需要与平面法线作夹角并乘上 $\cos{\theta}$。也可以用太阳直射角与季节的关系来理解——夏季太阳几乎垂直入射到北半球，所以接收到能量就多，就会更热。</p>
</blockquote>
<p>之前我们聊 Blinn-Phong 模型的漫反射项时，提到「能量损耗」这么一个概念。基于上面提到的两个光照属性，我们发现对于一个点光源而言，随着半径的增大，intensity 其实是不会发生变化的，因为立体角是不变的。但是对于任意半径的球面而言，它们的 power 也是不变的，其实是 irradiance 发生了衰减。</p>
<img src="irradiancefalloff.png" style="zoom:60%">
<h4 id="辐射亮度-Radiance">辐射亮度(Radiance)</h4>
<p>定义为<strong>投射到单位面积上的单位立体角上的辐射通量(Power Per Unit Solid Angle, Per Projected Unit Area)</strong>。</p>
<p>即 $\displaystyle\text{L}(\mathbf{p}, \omega)=\frac{\text{d}^2\Phi(\mathbf{p}, \omega)}{\text{d}\omega\text{d}A\cos\theta}$，单位 $\displaystyle\frac{\text{W}}{\text{sr}\ \text{m}<sup>2}=\frac{\text{lm}}{\text{sr} \text{m}</sup>2}=\frac{\text{cd}}{\text{m}^2}=\text{nit}$。</p>
<p>这个概念可以和 intensity 和 irradiance 联系起来，既可以认为是投射到单位面积上的 intensity，也可以认为是某个点从单位立体角上接收到的 irradiance。</p>
<p>通常我们采用后者，也就是像下图这样，既然 irradiance 考虑的是点 $\mathbf{p}$ 从四面八方接收到的 power，那 radiance 就是只考虑其中的某个方向。</p>
<img src="radiance.png" style="zoom:60%">
<h4 id="双向反射分布函数-BRDF-Bidirectional-Reflectance-Distribution-Function">双向反射分布函数(BRDF, Bidirectional Reflectance Distribution Function)</h4>
<p>当光线打到某个点上时，会根据该点的属性，可能会吸收一部分能量，再形成特定的反射结果：如果这个点具有漫反射特性，那么会向四面八方均匀反射；如果这个点是镜面，那就会往法线的对称方向集中反射……如果能确定入射方向，那就需要某种数学方法来准确描述反射结果，这就是 BRDF 干的事情。</p>
<p>BRDF 定义了 irradiance 从某个单位立体角方向入射到单位面积上后，以怎样的结果向反射的立体角方向进行反射。</p>
<img src="brdf.png" style="zoom:60%">
<p>也就是说 BRDF 将一个入射方向与一个反射方向建立了映射。如果我们对所有的入射方向都应用一遍反射方向 $\omega_r$ 的 BRDF，那是不是就能得出一个正确的反射结果了呢？是的没错，正是下式：</p>
<p>$$
L_r(\mathbf{p}, \omega_r) = \int_{\Omega^+}f_r(\mathbf{p}, \omega_i\rightarrow\omega_r)L_i(\mathbf{p},\omega_i)\cos\theta_i \text{d}\omega_i
$$</p>
<p>上面这个方程称为<strong>反射方程(Reflection Equation)</strong>。</p>
<blockquote>
<p>从概念上来讲，反射方程考虑了任意入射方向的光照对反射方向的贡献，并将其累加。</p>
</blockquote>
<p>如果在此基础上考虑到物体本身会发光的情况，那就得到了<strong>渲染方程(Rendering Equation)</strong>，如下式：</p>
<p>$$
L_r(\mathbf{p}, \omega_r) = L_e(\mathbf{p}, \omega_r)
+
\int_{\Omega^+}f_r(\mathbf{p}, \omega_i\rightarrow\omega_r)L_i(\mathbf{p},\omega_i)\cos\theta_i \text{d}\omega_i
$$</p>
<blockquote>
<p>当然还要考虑「入射光不仅仅来自光源，也会来自其它物体表面的反射光」这么一种情况，那就是一个<strong>递归</strong>的解法了，即在点 $\mathbf{p}$ 处放置一个虚拟相机，观察其它物体表面的 $L_r$。这是光线弹射一次的做法，那么弹射两次、三次、……做法也是类似的。</p>
</blockquote>
<h3 id="路径追踪-Path-Tracing">路径追踪(Path Tracing)</h3>
<h4 id="蒙特卡洛积分-Monte-Carlo-Integration">蒙特卡洛积分(Monte Carlo Integration)</h4>
<p>回顾一下微积分中的<strong>黎曼积分</strong>，它的基本思路是将函数图像分解为若干个矩形，求解该函数的定积分实际上就是求这些矩形的面积之和。</p>
<p>蒙特卡洛积分也参考了这一思路，但它的核心思路是<strong>随机采样</strong>。也就是说，对于积分域 $[a,b]$，我们认为变量 $x$ 在区间内满足一定概率分布 $X_i\sim p(x)$，我们只要不断地进行随机采样，求得采样值对应的函数值（可以认为是一个矩形面积值），那么定积分的结果可以认为是这些函数值的<strong>平均</strong>。用式子 $\displaystyle F_N=\frac{1}{N}\sum\limits_{i=1}^N\frac{f(X_i)}{p(X_i)}$ 表示。其中 $N$ 为采样次数。</p>
<img src="mtkl.png" style="zoom:60%">
<blockquote>
<p>对于一个在积分域服从均匀分布的变量来说，$\displaystyle p(X_i)=\frac{1}{b-a}$，那么定积分的结果就是 $\displaystyle\frac{b-a}{N}\sum\limits_{i=1}^Nf(X_i)$</p>
</blockquote>
<h4 id="用蒙特卡洛积分求解路径追踪">用蒙特卡洛积分求解路径追踪</h4>
<p>利用所学知识，我们就可以对渲染方程作特殊处理了。取点 $\mathbf{p}$ 所有单位入射方向（半球）构成向量集合，表示采样域。对该集合进行 $N$ 次随机采样，得到一个概率分布，代入蒙特卡洛积分求解即可。</p>
<p>此时可以认为光线在所有方向上都是等概率的，即入射方向/立体角满足均匀分布，则有 $p(\omega_i) = 1/2\pi$（半球的立体角为 $2\pi$）。如果我们额外考虑某一束入射光是来自光源还是其它物体表面 $\mathbf{q}$ 的反射光，就可以得到下面这个式子</p>
<p>$$
L_r(\mathbf{p},\omega_r)\approx
\begin{cases}
\displaystyle\frac{1}{N}\sum\limits_{i=1}^N \frac{f_r(\mathbf{p},\omega_i\rightarrow\omega_r)L_i(\mathbf{p}, \omega_i)\cos\theta_i}{p(\omega_i)} \qquad 点光源直射
\[2em]
\displaystyle\frac{1}{N}\sum\limits_{i=1}^N \frac{f_r(\mathbf{p},\omega_i\rightarrow\omega_r)L_r(\mathbf{q}, -\omega_i)\cos\theta_i}{p(\omega_i)} \quad\ 来自其它物体的反射
\end{cases}
$$</p>
<p>进而可以用以下伪代码来描述</p>
<img src="globalillumination.png" style="zoom:60%">
<h4 id="优化1：解决指数爆炸">优化1：解决指数爆炸</h4>
<p>这种做法存在一个问题，那就是当 $N$ 比较大的时候，如果只考虑光源直射，那就只需要作 N 次采样即可，为线性时间复杂度；但是如果考虑其它物体的反射，进行递归计算时，对应的时间复杂度就高达 $O(N^{光线总反射次数})$。这显然是不可取的。</p>
<img src="ptp1.png" style="zoom:60%">
<p>如果设置 $N=1$，就叫<strong>路径追踪</strong>，可以解决上面的问题，只不过噪声大了点。但事实上我们要得到的是一整个像素的 radiance，而这个像素会对应多条 path，只要对这些 path 求平均就可以了。</p>
<img src="paths.png" style="zoom:60%">
<p>我们可以在像素内均匀地取 $N$ 个不同的点，对于每个点，发射一条光线到场景中（区别于上面那个 $N$），如果与物体产生交点，那就计算相应的着色。</p>
<img src="rg.png" style="zoom:60%">
<p>这样就把路径追踪和着色联系在了一起。</p>
<blockquote>
<p>如果 $N&gt;1$，就是<strong>分布式光线追踪</strong>，会出现指数爆炸。</p>
</blockquote>
<h4 id="优化2：确定递归终点">优化2：确定递归终点</h4>
<p>完了吗？没有，还有一个问题，那就是如何确定递归终点。</p>
<p>这里可以使用**俄罗斯轮盘赌(Russian Roulette)**的方式，即我们可以设置某个概率 $P$，在采样反射光时，以概率 $P$ 进行采样，概率 $1-P$ 什么也不干，此时我们收集到的 <code>shade()</code> 结果需要除以 $P$，使得期望不变。这样一来，上面 <code>shade()</code> 函数的伪代码就需要修正为下面这样。</p>
<img src="shaderr.png" style="zoom:60%">
<h4 id="优化3：在光源上采样">优化3：在光源上采样</h4>
<p>遗憾的是，上面的解法仍然存在问题，因为我们是在半球上随机取一个入射方向进行采样，运气成分就很大，可能没法取到一个恰好从光源入射的方向。此时就需要转换思路，可以在光源上采样。</p>
<p>但毕竟我们是把着色点为球心的单位球面作为积分域，如果要在光源上采样，那就需要把 $\text{d}\omega$ 转换成光源上的 $\text{d}A$，再进行积分。</p>
<p>这很简单，因为采样光的方向相同，那么对应的单位立体角也是相同的，所以 $\mathbf{x}‘$ 处的 intensity 和单位半球面上的 intensity 是相等的。考虑 $\text{d}A$ 的法线方向 $\mathbf{n}’$，我们可以得到</p>
<p>$$
\text{d}\omega·{||\mathbf{x}‘-\mathbf{x}||^2}=\text{d}A\cos\theta’ \Longrightarrow \text{d}\omega=\frac{\text{d}A\cos\theta’}{||\mathbf{x}'-\mathbf{x}||^2}
$$</p>
<img src="samplethelight.png" style="zoom:60%">
<p>这就把之前的所有知识都给串起来了。有了这一结论，渲染方程又可以进一步改为</p>
<p>$$
L_r(\mathbf{p}, \omega_r) = L_e(\mathbf{p}, \omega_r)
+
\int_{A}f_r(\mathbf{p}, \omega_i\rightarrow\omega_r)L_i(\mathbf{p},\omega_i)\frac{\cos\theta\cos\theta’}{||\mathbf{x}'-\mathbf{x}||^2} \text{d}A
$$</p>
<p>此时点光源直射的情况就不需要用 RR 来处理递归终点了，因为我们只需要一次采样就够了。考虑到着色点与点光源直接可能存在其它物体遮挡，伪代码可以进一步优化为下面这样：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">shade<span class="token punctuation">(</span>p<span class="token punctuation">,</span> wo<span class="token punctuation">)</span>
  <span class="token comment">## Contribution from the light source.</span>
  Uniformly sample the light at x’ <span class="token punctuation">(</span>pdf_light <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> A<span class="token punctuation">)</span>
  Shoot a ray <span class="token keyword">from</span> p to x’
  If the ray <span class="token keyword">is</span> <span class="token keyword">not</span> blocked <span class="token keyword">in</span> the middle
    L_dir <span class="token operator">=</span> L_i <span class="token operator">*</span> f_r <span class="token operator">*</span> cos θ <span class="token operator">*</span> cos θ’ <span class="token operator">/</span> <span class="token operator">|</span>x’ <span class="token operator">-</span> p<span class="token operator">|</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">/</span> pdf_light

  <span class="token comment">## Contribution from other reflectors.</span>
  L_indir <span class="token operator">=</span> <span class="token number">0.0</span>
  Test Russian Roulette <span class="token keyword">with</span> probability P_RR
  Uniformly sample the hemisphere toward wi <span class="token punctuation">(</span>pdf_hemi <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> 2pi<span class="token punctuation">)</span>
  Trace a ray r<span class="token punctuation">(</span>p<span class="token punctuation">,</span> wi<span class="token punctuation">)</span>
  If ray r hit a non<span class="token operator">-</span>emitting <span class="token builtin">object</span> at q
    L_indir <span class="token operator">=</span> shade<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">-</span>wi<span class="token punctuation">)</span> <span class="token operator">*</span> f_r <span class="token operator">*</span> cos θ <span class="token operator">/</span> pdf_hemi <span class="token operator">/</span> P_RR
  Return L_dir <span class="token operator">+</span> L_indir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>GAMES101 的难度在此已经到达峰值了，接下去就简单很多。</p>
</blockquote>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>Gameplay Study(2)：Inhanced Input</title>
    <url>/unreal/gameplay2/</url>
    <content><![CDATA[<p>现在我们已经有了动画蓝图，并且根据玩家速度输出不同的动画效果，那么接下来就要实现<strong>通过输入控制玩家移动</strong>。</p>
<span id="more"></span>
<h2 id="增强输入">增强输入</h2>
<p>这里用<strong>增强输入</strong>来实现按键控制。**增强输入系统(Enhanced Input System)**是 UE5 用于处理输入的功能框架，旨在提供比传统输入系统更强大、更灵活的功能。它引入了一些新特性和改进，使得输入管理变得更加高效和可扩展。</p>
<h3 id="如何使用">如何使用</h3>
<p>我用的是 UE5.4，直接内置了增强输入。之前使用输入绑定需要在「项目设置」「输入」进行设置，但是也仅仅是绑定，一些额外的设置如长按、连续按下还是需要用户自己实现，而且不同行为模式下的输入可能绑定到不同事件，总而言之就是很不方便。</p>
<p>但是现在点开显示<em>轴和操作映射现已废弃，请改用增强输入操作和输入映射上下文</em>。这里提到两个概念，分别是「输入操作」和「输入映射上下文」。前者其实就是一个事件，用于绑定到 C++ 中的 callback，后者则是将一组按键与输入操作绑定，并且能够在运行时动态装卸，从而达到在不同场景中同一按键对应不同行为的效果。</p>
<p>在「内容浏览器」中，可以通过「输入」「输入操作」创建一个 Input Action，并命名为 <code>IA_Move</code>，同时通过「输入」「输入映射情景」创建一个 Input Mapping Context，并命名为 <code>IMC_PlayerCtx</code>。</p>
<h3 id="Input-Action">Input Action</h3>
<p>打开 <code>IA_Move</code>，这里值得关注的是「值类型」和「修改器」。</p>
<p>值类型有 4 个选项，分别是</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>数字（布尔）</strong>：相当于之前的 Action Mapping；</p>
</li>
<li class="lvl-2">
<p><strong>Axis1D（浮点）</strong>：相当于之前的 Axis Mapping；</p>
</li>
<li class="lvl-2">
<p><strong>Axis2D（Vector2D）</strong>：扩展 Axis Mapping，能够获取 Y 轴上的值（输入默认在 X 轴上）；</p>
</li>
<li class="lvl-2">
<p><strong>Axis3D（向量）</strong>：继续扩展，能够获取 Z 轴上的值；</p>
</li>
</ul>
<img src="ia.png">
<p>修改器则是对输入的值执行一定的 Filter，它是一个数组类型，前一个 Modifier 的输出会作为后一个 Modifier 的输入，可以类比 Shell 中的管道操作符 <code>|</code>。比如有个 Modifier 的类型是「否定」（中文翻译问题，其实就是取反），那么只用这一个 Modifier 就是将输入值取反，如果在后面再加一个「否定」，那结果就是原来的数不变。</p>
<p>因为本项目中角色移动是在二维平面上，所以值类型选择 Axis2D，角色的左右移动和前后移动分别从输出值(Vector2D)的 X 和 Y 轴上取值。</p>
<h3 id="Input-Mapping-Context">Input Mapping Context</h3>
<p>打开 <code>IMC_PlayerCtx</code>，在这里可以创建映射。我们将 <code>WASD</code> 四个键绑定到 <code>IA_Move</code> 中。因为 IA_Move 的输出值类型是 Axis2D，并且所有值默认输入到 X 轴上，为了能使 A/D 输入值应用到 Y 轴上，需要用到名为「拌合输入轴值」的 Modifier，它其实就是交换两个轴，这里选「YXZ」，即交换 X 轴和 Y 轴，这样原本应用到 X 轴上的变化，经过 Modifier 以后就会转而应用到 Y 轴上。</p>
<p>那么同一轴上的两个想反的方向就可以用「否定」解决，也就是取反。</p>
<p>最后结果如下所示。</p>
<img src="imc.png">
<h3 id="总结">总结</h3>
<p>当按下按键 <code>Input</code> 时，首先会检测当前 IMC，假设该按键存在绑定且绑定到操作 <code>Action</code>，那么首先应用 IMC 中的 {Input, Action} 的 Modifier，将输出值送给 Action 自身的修改器，再做一次 Action_Modifier，两轮 Modifier 后的值才送到 callback 的入参。可以简单地用下图表示：</p>
<img src="datastream.png">
<h2 id="行为绑定">行为绑定</h2>
<p>这里我们需要新建一个派生自 <code>PlayerController</code> 的类 <code>RPlayerController</code>，用于实现控制玩家的逻辑。</p>
<blockquote>
<p>关于 <strong>Controller</strong>、<strong>Pawn</strong> 和 <strong>Character</strong> 的关系：</p>
<p>Character 由 Pawn 和 Controller 两部分组成。</p>
<p>Controller 只负责告诉 Pawn 做什么及如何表现，可以认为是 Pawn 的大脑。它将拥有(possess) Pawn，同理 Pawn 会被拥有(possessed by)。</p>
<p>Pawn 是世界中可控的 Actor 的物理表示。它不关心 Character 是由用户控制还是由 AI 控制，只接受 Controller 的命令，并使角色和世界进行物理交互。Pawn 具有网格物体、碰撞，也能产生声音、播放动画。</p>
<p>任何时刻每个 Pawn 都有一个单独的 Controller，比如 Player Controller 和 AI Controller。运行时允许修改一个 Pawn 的 Controller（同样也是修改了 Controller 控制的 Pawn），从而将发起命令与执行命令解耦。很常见的是一些游戏中的「托管」功能，相当于把自己的 Pawn 交给了 AIController。</p>
<p>而 Character 派生自 Pawn，在 Pawn 的基础上完善了更多功能，比如自带 SkeletalMeshComponent，可启用使用骨架的高级动画。本质上来讲，用 Controller 控制一个 Character，就是在控制其 Pawn。</p>
<img src="pcc.png">
</blockquote>
<p>为了实现移动，可以在头文件中添加如下成员</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/RPlayerController.h</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UInputMappingContext</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">UInputAction</span><span class="token punctuation">;</span>

<span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> ARPlayerController <span class="token operator">:</span> <span class="token keyword">public</span> APlayerController
<span class="token punctuation">{</span>
  <span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">ARPlayerController</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">SetupInputComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditDefaultsOnly<span class="token punctuation">,</span> Category <span class="token operator">=</span> <span class="token string">"Input"</span><span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>UInputMappingContext<span class="token operator">&gt;</span> PlayerInputCtx<span class="token punctuation">;</span>

  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditDefaultsOnly<span class="token punctuation">,</span> Category <span class="token operator">=</span> <span class="token string">"Input"</span><span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>UInputAction<span class="token operator">&gt;</span> MoveAction<span class="token punctuation">;</span>

  <span class="token keyword">void</span> <span class="token function">Move</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">FInputActionValue</span><span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>SetupInputComponent()</code> 函数会在关卡开始时自动被调用，用于初始化输入组件。<code>Move()</code> 函数则是按下按键时触发的移动行为逻辑，为了能被正确绑定，它的参数列表只需要有一个 <code>const FInputActionValue&amp;</code> 类型的入参。</p>
<p>函数实现如下所示，已给出注释。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/RPlayerController.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Components/RPlayerController.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"EnhancedInputSubsystems.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"EnhancedInputComponent.h"</span></span>

<span class="token class-name">ARPlayerController</span><span class="token double-colon punctuation">::</span><span class="token function">ARPlayerController</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  bReplicates <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// 该控制器的实例将在网络游戏中进行复制，以便在不同客户端之间同步控制器的状态和行为</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARPlayerController</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// check 宏保证后面的指针非空</span>
  <span class="token function">check</span><span class="token punctuation">(</span>PlayerInputCtx<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 设置 IMC 与优先级(0)</span>
  UEnhancedInputLocalPlayerSubsystem<span class="token operator">*</span> SubSystem <span class="token operator">=</span> ULocalPlayer<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">GetSubsystem</span><span class="token generic class-name"><span class="token operator">&lt;</span>UEnhancedInputLocalPlayerSubsystem<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">GetLocalPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>SubSystem<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    SubSystem<span class="token operator">-&gt;</span><span class="token function">AddMappingContext</span><span class="token punctuation">(</span>PlayerInputCtx<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 显示鼠标</span>
  bShowMouseCursor <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置鼠标样式</span>
  DefaultMouseCursor <span class="token operator">=</span> EMouseCursor<span class="token double-colon punctuation">::</span>Default<span class="token punctuation">;</span>

  FInputModeGameAndUI InputMode<span class="token punctuation">;</span>
  <span class="token comment">// 当玩家将鼠标移动到屏幕边缘时，游戏不会阻止鼠标光标离开游戏窗口</span>
  InputMode<span class="token punctuation">.</span><span class="token function">SetLockMouseToViewportBehavior</span><span class="token punctuation">(</span>EMouseLockMode<span class="token double-colon punctuation">::</span>DoNotLock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置在捕获鼠标时不隐藏鼠标光标</span>
  <span class="token comment">// 具有更高的优先级，可以在捕获鼠标输入时覆盖 bShowMouseCursor 的设定</span>
  InputMode<span class="token punctuation">.</span><span class="token function">SetHideCursorDuringCapture</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">SetInputMode</span><span class="token punctuation">(</span>InputMode<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARPlayerController</span><span class="token double-colon punctuation">::</span><span class="token function">SetupInputComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">SetupInputComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 将 Move() 绑定到 Action 上，CastChecked 保证结果非空</span>
  UEnhancedInputComponent<span class="token operator">*</span> EnhancedInputComp <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CastChecked</span><span class="token generic class-name"><span class="token operator">&lt;</span>UEnhancedInputComponent<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>InputComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  EnhancedInputComp<span class="token operator">-&gt;</span><span class="token function">BindAction</span><span class="token punctuation">(</span>MoveAction<span class="token punctuation">,</span> ETriggerEvent<span class="token double-colon punctuation">::</span>Triggered<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ARPlayerController<span class="token double-colon punctuation">::</span>Move<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARPlayerController</span><span class="token double-colon punctuation">::</span><span class="token function">Move</span><span class="token punctuation">(</span><span class="token keyword">const</span> FInputActionValue<span class="token operator">&amp;</span> Value<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// 根据控制器偏角，获取 xOy 平面上的方向向量</span>
  <span class="token keyword">const</span> FRotator<span class="token operator">&amp;</span> GroundRotation <span class="token operator">=</span> <span class="token function">FRotator</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token function">GetControlRotation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>Yaw<span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> FRotationMatrix<span class="token operator">&amp;</span> <span class="token function">GroundRotationMatrix</span><span class="token punctuation">(</span>GroundRotation<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> FVector<span class="token operator">&amp;</span> ForwardVector <span class="token operator">=</span> GroundRotationMatrix<span class="token punctuation">.</span><span class="token function">GetUnitAxis</span><span class="token punctuation">(</span>EAxis<span class="token double-colon punctuation">::</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> FVector<span class="token operator">&amp;</span> RightVector <span class="token operator">=</span> GroundRotationMatrix<span class="token punctuation">.</span><span class="token function">GetUnitAxis</span><span class="token punctuation">(</span>EAxis<span class="token double-colon punctuation">::</span>Y<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 输入值中的 X 应用到前后方向，Y 应用到左右方向</span>
  <span class="token keyword">const</span> FVector2D<span class="token operator">&amp;</span> InputAxis <span class="token operator">=</span> Value<span class="token punctuation">.</span><span class="token generic-function"><span class="token function">Get</span><span class="token generic class-name"><span class="token operator">&lt;</span>FVector2D<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>APawn<span class="token operator">*</span> Pawn <span class="token operator">=</span> <span class="token function">GetPawn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Pawn<span class="token operator">-&gt;</span><span class="token function">AddMovementInput</span><span class="token punctuation">(</span>ForwardVector<span class="token punctuation">,</span> InputAxis<span class="token punctuation">.</span>X<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Pawn<span class="token operator">-&gt;</span><span class="token function">AddMovementInput</span><span class="token punctuation">(</span>RightVector<span class="token punctuation">,</span> InputAxis<span class="token punctuation">.</span>Y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为什么上面 40 行，怎么保证 <code>InputComponent</code> 的类型转换成功呢？需要将「项目设置」「输入」「默认类」中的「默认玩家输入类」设置为 <code>EnhancedPlayerInput</code>，同理「默认输入组件类」设置为 <code>EnhancedInputComponent</code>。这样在生成时就会用这两个类型。</p>
<h2 id="应用到游戏中">应用到游戏中</h2>
<p>我们已经实现了一个自定义的 Player Controller，接下来要做的事就是在游戏中使用它。在「项目设置」「地图和模式」中，我们可以看到在「选中的游戏模式」下面，有很多类，其中默认的「玩家控制器类」是 PlayerController。那么目的很明确了，我们还需要新建一个自定义的 Game Mode，覆盖「默认的游戏模式」，就能设置默认的「玩家控制器类」为 <code>RPlayerController</code> 了。</p>
<p>所谓 Game Mode，顾名思义就是游戏模式，也可以理解为游戏规则。一个游戏可以有任意数量的 Game Mode，但是在一个时间点，只能使用一个 Game Mode。毕竟规则只能有一个。</p>
<p>接下去就是新建一个派生自 <code>GameModeBase</code> 的类，命名为 <code>RGameModeBase</code>。然后创建对应的蓝图类，命名为 <code>BP_RGameModeBase</code>。在蓝图类中，先进行如下设置</p>
<img src="gamemode.png">
<p>这样游戏就会使用 <code>BP_RMyPlayerController</code> 处理输入，并将命令发送给 <code>BP_Aura</code> 上，达到控制的效果。最后将 <code>PlayerStart</code> 拖拽到世界中，运行游戏，发现已经能通过 WASD 控制玩家移动了。</p>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Gameplay Study(3)：View Control</title>
    <url>/unreal/gameplay3/</url>
    <content><![CDATA[<p>前面实现移动后，发现我们的视野是有问题的，同时角色虽然能够进行平移，但身体永远面朝同一个方向。所以接下来要实现视角控制。</p>
<span id="more"></span>
<p>视角控制最关键的两个组件是<strong>弹簧臂组件(Spring Arm Component)<strong>与</strong>相机组件(Camera Component)</strong>。前者用于固定相机和角色的相对位置关系，后者则是用于将可视范围显示到屏幕上。在角色类中加入以下变量</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/Player/RPlayerBase.h</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">USpringArmComponent</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">UCameraComponent</span><span class="token punctuation">;</span>

<span class="token function">UCLASS</span><span class="token punctuation">(</span>Abstract<span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> ARPlayerBase <span class="token operator">:</span> <span class="token keyword">public</span> ARCharacterBase
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditDefaultsOnly<span class="token punctuation">,</span> Category <span class="token operator">=</span> <span class="token string">"View"</span><span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>USpringArmComponent<span class="token operator">&gt;</span> CameraBoom<span class="token punctuation">;</span>

  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditDefaultsOnly<span class="token punctuation">,</span> Category <span class="token operator">=</span> <span class="token string">"View"</span><span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>UCameraComponent<span class="token operator">&gt;</span> FollowCamera<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并且在构造函数中创建组件。在这之前需要了解一下 Pawn 和 Character 的朝向问题。</p>
<p>因为在 Move 函数中我们只是令 Pawn 平移，并没有修改朝向（改变 Rotation），所以可以认为 Pawn 永远朝某一方向。这也就是为什么之前运行游戏时，Character 朝向不变了。</p>
<p>但是由于 Character 自带 Mesh，所以在我们肉眼看来 Character 的「朝向」其实就是 Mesh 的面对方向（即蓝图编辑器中的「箭头组件」指向）。</p>
<p>对于这个俯视角第三人称 RPG 游戏而言，我们希望玩家在移动时，人物能够面朝移动方向，同时视角又不会随人物转向而变化，这就要用到两个关键变量 <code>bOrientRotationToMovement</code> 和 <code>bUsePawnControlRotation</code> 了。</p>
<p><code>bOrientRotationToMovement</code> 这个变量在 Character Movement Component 中定义，意思是「旋转角色朝向加速变量」，如果速度（矢量）方向向右，则玩家会自动调整转向，使得 Character 朝向右方。使用这个变量时，需要将 <code>bUseControllerRotation*</code> 设为 false，从而使角色旋转脱离 Controller。</p>
<p><code>bUsePawnControlRotation</code> 则是对于组件而言的，如果设为 true，则会改为与 Pawn 的旋转一致，否则就是默认跟随 Character 一起旋转。因为这里 Pawn 的不转的，所以组件也不会转，从而实现我们需要的「视角固定」效果。</p>
<blockquote>
<p>如果设置 <code>bUsePawnControlRotation</code> 为 true，则对组件相对旋转的自定义设置会无效。所以如果要实现俯视角，可以使用「插槽偏移」，即结束位置的偏移量。</p>
<p>或者也可以和 <code>bInherit*</code> 一起都设为 false，这样就不会被根组件的旋转干扰了，也就可以直接设置相对旋转，不用使用插槽偏移。</p>
</blockquote>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/Player/RPlayerBase.cpp</span></div><code class="language-cpp"><span class="token class-name">ARPlayerBase</span><span class="token double-colon punctuation">::</span><span class="token function">ARPlayerBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  
  bUseControllerRotationRoll <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  bUseControllerRotationPitch <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  bUseControllerRotationYaw <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 旋转朝向运动</span>
  <span class="token function">GetCharacterMovement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>bOrientRotationToMovement <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置转身速率</span>
  <span class="token function">GetCharacterMovement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>RotationRate <span class="token operator">=</span> <span class="token function">FRotator</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">400.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 限制对象在特定平面上的运动</span>
  <span class="token function">GetCharacterMovement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>bConstrainToPlane <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token comment">// 在对象初始化时，它会被立即捕捉到指定平面上</span>
  <span class="token function">GetCharacterMovement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>bSnapToPlaneAtStart <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

  <span class="token comment">// 创建组件</span>
  CameraBoom <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CreateDefaultSubobject</span><span class="token generic class-name"><span class="token operator">&lt;</span>USpringArmComponent<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Spring Arm"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">check</span><span class="token punctuation">(</span>CameraBoom<span class="token punctuation">)</span><span class="token punctuation">;</span>
  FollowCamera <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CreateDefaultSubobject</span><span class="token generic class-name"><span class="token operator">&lt;</span>UCameraComponent<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"Camera"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">check</span><span class="token punctuation">(</span>FollowCamera<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 绑定到胶囊体</span>
  CameraBoom<span class="token operator">-&gt;</span><span class="token function">SetupAttachment</span><span class="token punctuation">(</span><span class="token function">GetCapsuleComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  CameraBoom<span class="token operator">-&gt;</span>bUsePawnControlRotation <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  CameraBoom<span class="token operator">-&gt;</span>bInheritRoll <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  CameraBoom<span class="token operator">-&gt;</span>bInheritPitch <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  CameraBoom<span class="token operator">-&gt;</span>bInheritYaw <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  CameraBoom<span class="token operator">-&gt;</span>TargetArmLength <span class="token operator">=</span> <span class="token number">750.0f</span><span class="token punctuation">;</span>
  CameraBoom<span class="token operator">-&gt;</span><span class="token function">SetRelativeRotation</span><span class="token punctuation">(</span><span class="token function">FRotator</span><span class="token punctuation">(</span><span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token number">0.0f</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">45.0f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 相机绑定到弹簧臂</span>
  FollowCamera<span class="token operator">-&gt;</span><span class="token function">SetupAttachment</span><span class="token punctuation">(</span>CameraBoom<span class="token punctuation">)</span><span class="token punctuation">;</span>
  FollowCamera<span class="token operator">-&gt;</span>bUsePawnControlRotation <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Gameplay Study(4)：Highlight &amp; Interface</title>
    <url>/unreal/gameplay4/</url>
    <content><![CDATA[<p>现在要实现一个新功能：鼠标悬停在某个 Actor 身上时，能够使其高亮显示，移走时取消高亮。</p>
<span id="more"></span>
<p>基于面向对象的 <strong>Is-a</strong> 设计思想，可以用一个抽象类 Highlightable，只提供 <code>Highlight()</code> 和 <code>Unhighlight()</code> 接口（纯虚函数），并将实现交给派生类完成。一旦某一个类继承自 Highlightable 并实现了那两个接口，那么这个类就是「可高亮的」，这意味着当鼠标悬停到这个类在世界中的实例时，它就会高亮显示。</p>
<p>所以第一步是创建一个虚幻接口类，命名为 <code>RHighlightable</code>。</p>
<p>打开 C++ 发现头文件中定义了两个类，其中 <code>U</code> 开头的那个是一个空白类，它的存在只是为了向 UE 反射系统确保可见性。将由 <code>I</code> 前缀的类进行实际接口的声明，同时被其他类继承。在 <code>IRHighLightable</code> 类中加入上述两个纯虚函数后，进行派生类的实现。</p>
<h2 id="添加鼠标悬停判定">添加鼠标悬停判定</h2>
<p>所有设备输入都会流到 Controller，鼠标也不例外。这里需要每一帧都检查一遍鼠标悬停的对象，如果是 Highlightable，就令其高亮，如果和之前的高亮对象不是同一个，那就取消前一个对象的高亮效果。所以这里就要用到两个变量来表示当前鼠标悬停的对象 <code>Cur</code> 和上一帧的对象 <code>Last</code>。</p>
<p>为了实现逐帧检查，就需要重载基类的 <code>PlayerTick()</code> 函数，这是一个每一帧都会调用的函数，我们需要做的就是在该函数中执行鼠标悬停对象的检查（不妨把检查行为剥离出来成为一个新函数 <code>CursorTrace()</code>）。</p>
<p>这里使用到的函数为 <code>GetHitResultUnderCursor()</code>，这是一个用于在屏幕上根据指定 Channel 获取鼠标光标下的碰撞结果的函数。在该功能下，选择用**可见性通道(ECC_Visibility)**进行碰撞检测，这很符合常理，毕竟如果发生了前后遮挡，我们只希望高亮最前面的那个。</p>
<p>实现如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/RPlayerController.h</span></div><code class="language-cpp"><span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> ARPlayerController <span class="token operator">:</span> <span class="token keyword">public</span> APlayerController
<span class="token punctuation">{</span>
<span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">PlayerTick</span><span class="token punctuation">(</span><span class="token keyword">float</span> DeltaTime<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">CursorTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  IRHighLightable<span class="token operator">*</span> Last<span class="token punctuation">;</span>
  IRHighLightable<span class="token operator">*</span> Cur<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/RPlayerController.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ARPlayerController</span><span class="token double-colon punctuation">::</span><span class="token function">PlayerTick</span><span class="token punctuation">(</span><span class="token keyword">float</span> DeltaTime<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">PlayerTick</span><span class="token punctuation">(</span>DeltaTime<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">CursorTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARPlayerController</span><span class="token double-colon punctuation">::</span><span class="token function">CursorTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// 描述碰撞检测结果的结构体</span>
  FHitResult CursorHit<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">GetHitResultUnderCursor</span><span class="token punctuation">(</span>ECC_Visibility<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> CursorHit<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>

  Last <span class="token operator">=</span> Cur<span class="token punctuation">;</span>
  Cur <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>IRHighLightable<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>CursorHit<span class="token punctuation">.</span><span class="token function">GetActor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>Last <span class="token operator">==</span> Cur<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Last<span class="token punctuation">)</span> Last<span class="token operator">-&gt;</span><span class="token function">UnHighlight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Cur<span class="token punctuation">)</span> Cur<span class="token operator">-&gt;</span><span class="token function">Highlight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="实现高亮">实现高亮</h2>
<p>因为现在只实现了敌怪类，没有其它可以高亮的，所以先拿它开刀。来到 <code>UREnermyBase</code> 中，令其继承自 <code>IRHighLightable</code>，同时创建接口 override 声明。</p>
<h3 id="高亮效果">高亮效果</h3>
<p>为了添加高亮效果，需要回到编辑器中，在世界场景添加一个「后期处理体积」的 Actor。</p>
<img src="postprocess.png">
<p>选中该 Actor 实例，在「后期处理材质」中添加 PP_Highlight（免费的素材），并勾选「无限范围」选项，这就使得高亮效果能够作用到所有<strong>满足条件</strong>的 Actor。</p>
<p>与此同时还要进入「项目设置」「后期处理」，将「自定义深度-模板通道」设置为「启用模板」。</p>
<p>点开 PP_Highlight 资产，遍历蓝图节点，发现当「Custom Stencil Value」达到 250 才会在 Mesh 表面浮现一层红色（purple？）的高亮效果。</p>
<img src="value.png">
<p>这个值是在 Mesh 中的「自定义深度模板值」这设置的，一旦一个 Mesh 设置了该值（并且满足渲染条件），同时启用了「深度通道中渲染」，就会浮现高亮效果。同理，关闭「深度通道中渲染」，就会取消高亮效果。</p>
<blockquote>
<p>这部分不是学习重点，仅仅是跟着过了一遍。</p>
</blockquote>
<p>回到 C++，修改 <code>UREnermyBase</code> 的构造函数与接口实现，以正确设置「自定义深度模板值」和「深度通道中渲染」选项。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">AREnermyBase</span><span class="token double-colon punctuation">::</span><span class="token function">AREnermyBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Block Visibility 通道，以被检测到</span>
  <span class="token function">GetMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">SetCollisionResponseToChannel</span><span class="token punctuation">(</span>ECC_Visibility<span class="token punctuation">,</span> ECR_Block<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">GetMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span>CustomDepthStencilValue <span class="token operator">=</span> <span class="token number">250.0f</span><span class="token punctuation">;</span>

  Weapon<span class="token operator">-&gt;</span><span class="token function">SetCollisionResponseToChannel</span><span class="token punctuation">(</span>ECC_Visibility<span class="token punctuation">,</span> ECR_Block<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Weapon<span class="token operator">-&gt;</span>CustomDepthStencilValue <span class="token operator">=</span> <span class="token number">250.0f</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">AREnermyBase</span><span class="token double-colon punctuation">::</span><span class="token function">Highlight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">GetMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">SetRenderCustomDepth</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Weapon<span class="token operator">-&gt;</span><span class="token function">SetRenderCustomDepth</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">AREnermyBase</span><span class="token double-colon punctuation">::</span><span class="token function">UnHighlight</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">GetMesh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">SetRenderCustomDepth</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  Weapon<span class="token operator">-&gt;</span><span class="token function">SetRenderCustomDepth</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>关于碰撞的处理方式，需要记住几点规则：</p>
<ul class="lvl-1">
<li class="lvl-2">如果对另一个 Actor 设置了 Ignore，那么无论其碰撞预设如何，双方都不会触发事件。</li>
<li class="lvl-2">Overlap 和 Ignore 唯一的区别在于，前者可以启用「生成重叠事件」，这样在重叠时（并且另一个对象没有 Ignore 自己）会触发「重叠事件」（如 <code>OnComponentBeginOverlap</code>、<code>OnComponentEndOverlap</code>）。</li>
<li class="lvl-2">仅当两个 Actor 之间都对对方 Block 时才有阻挡效果，但是需要启用「模拟生成命中事件」才能触发「命中事件」（如 <code>OnComponentHit</code>）。
<ul class="lvl-3">
<li class="lvl-4">如果希望两个 Actor 彼此阻挡，就都需要设置为阻挡相应的对象类型。</li>
<li class="lvl-4">即使一个 Actor 会阻挡另一个 Actor，也可以生成重叠事件。</li>
<li class="lvl-4">对于两个或更多模拟对象：如果一个设置为重叠对象，另一个设置为阻挡对象，则发生重叠，而不会发生阻挡。</li>
</ul>
</li>
<li class="lvl-2">不建议一个对象同时拥有碰撞和重叠事件。虽然可以，但需要手动处理的部分太多。</li>
</ul>
<p>——参考自<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/collision-in-unreal-engine---overview">虚幻引擎官方文档：碰撞概述</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Gameplay Study(5)：Gameplay Ability System(GAS)</title>
    <url>/unreal/gameplay5/</url>
    <content><![CDATA[<p>接下来是重头戏，要基于**虚幻技能系统(Gameplay Ability System, GAS)**设计角色技能玩法了。</p>
<span id="more"></span>
<h2 id="技能系统-GAS">技能系统 GAS</h2>
<blockquote>
<p>Gameplay 技能系统 是一个高度灵活的框架，可用于构建你可能会在 RPG 或 MOBA 游戏中看到的技能和属性类型。你可以构建可供游戏中的角色使用的动作或被动技能，使这些动作导致各种属性累积或损耗的状态效果，实现约束这些动作使用的"冷却"计时器或资源消耗，更改技能等级及每个技能等级的技能效果，激活粒子或音效，等等。简单来说，此系统可帮助你在任何现代 RPG 或 MOBA 游戏中设计、实现及高效关联各种游戏中的技能，既包括跳跃等简单技能，也包括你喜欢的角色的复杂技能集。—— 虚幻官方文档</p>
</blockquote>
<p>技能系统主要有以下几个主要核心部件</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>技能系统组件(Ability System Component, ASC)</strong>: 是 Actor 和**游戏玩法系统(Gameplay Ability System)**之间的桥梁，负责处理许多事务包括授予技能、激活技能等。</p>
</li>
<li class="lvl-2">
<p><strong>属性集(Attribute Set, AS)</strong>: 存储角色的游戏属性（生命值、攻击力等），管理游戏属性与系统其他部分之间的交互，并将自己注册到角色的技能系统组件中。</p>
</li>
<li class="lvl-2">
<p><strong>技能(Gameplay Ability)</strong>: 对「技能」的封装，定义技能效果、技能消耗，以及释放条件等。并异步运行角色动画、粒子和声效等。</p>
</li>
<li class="lvl-2">
<p><strong>技能任务(Ability Task)</strong>: 异步执行技能相关的工作（播放施法动画、激发投射物粒子效果等），可以通过调用 <code>EndTask()</code> 函数自行终止。</p>
</li>
<li class="lvl-2">
<p><strong>效果(Gameplay Effect)</strong>: 执行与属性相关的多种功能，这些效果可以是即时效果，比如施加伤害，也可以是持续效果，比如毒杀，在一定的时间内对角色造成伤害。</p>
</li>
<li class="lvl-2">
<p><strong>提示(Gameplay Cue)</strong>: 负责处理音效、粒子效果等。</p>
</li>
<li class="lvl-2">
<p><strong>标签(Gameplay Tag)</strong>: 使用层次结构，执行 Identify 的功能，同时比 bool、enum、string 更加灵活。</p>
</li>
</ul>
<blockquote>
<p>具体可以参考 <a href="https://github.com/tranek/GASDocumentation">GAS Documentation</a></p>
</blockquote>
<h2 id="Ability-System-Component">Ability System Component</h2>
<p>ASC 和 AS 需要附加到 Actor 上才能被访问并发挥出效果，并且该 Actor 称之为 <code>OwnerActor</code>。</p>
<p>通常有两种 attach 方案：</p>
<ol>
<li class="lvl-3">
<p>第一种是 attach 到一个叫「PlayerState」的类里。这个类是持久化的，Game Mode 会在玩家加入游戏时或游戏开始时，为每个玩家创建一个新的 Player State 对象，并在需要时将其分配给对应的玩家（事实上 Pawn 可以通过 <code>GetPlayerState()</code> 获取指向该类实例的指针）。即便 Pawn 死亡被销毁，该对象也依然存在，这也就意味着它和 Pawn 是<strong>独立</strong>的。所以如果需要用到这一特性，则可以考虑将 ASC/AS attach 到 Player State 上；</p>
</li>
<li class="lvl-3">
<p>当然，如果不需要用到相关特性，比如一旦 Pawn 死亡之后就不会再用到其技能/属性了，常见的有 Moba 游戏中的小兵，那就可以直接 attach 到 Character 上；</p>
</li>
</ol>
<blockquote>
<p>Most Actors will have the ASC on themselves. If your Actor will respawn and need persistence of Attributes or GameplayEffects between spawns (like a hero in a MOBA), then the ideal location for the ASC is on the PlayerState.</p>
</blockquote>
<p>除了 <code>OwnActor</code>，GAS 的实际使用者称之为 <code>AvatarActor</code>。这里我们选择第一种方案来 attach ASC 和 AS。</p>
<h3 id="Player-State-与-Replication-in-multi-player">Player State 与 Replication in multi-player</h3>
<p>现在我们已经有了 Controller 类和 Character 类，那么接下来就是实现 PlayerState 类。步骤依然是创建 C++ 类 <code>RPlayerState</code> 与对应的蓝图类 <code>BP_RPlayerState</code>，并且在 Game Mode 中设置默认「玩家状态类」。我们可以在构造函数中为 <code>NetUpdateFrequency</code> 赋值，从而自定义 Play State 的复制速率。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/RPlayerState.cpp</span></div><code class="language-cpp"><span class="token class-name">ARPlayerState</span><span class="token double-colon punctuation">::</span><span class="token function">ARPlayerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  NetUpdateFrequency <span class="token operator">=</span> <span class="token number">100.0f</span><span class="token punctuation">;</span> <span class="token comment">// 100 updates per second</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>什么是复制速率？事实上，在多人游戏中，在某一时刻，clients 可能会持有不同的数据版本，此时就需要有一个 Authority 来决定正确的数据版本。这个 Authority 可以是 server，也可以是 client 中的「房主」，它负责会持有所有 Pawn 的 Player State，并且单向复制到其它的 client 上，从而实现同步。那么如果复制速率太低，就容易出现不一致的情况；如果太高，则会影响性能。</p>
<blockquote>
<p>每个 client 上只会有<strong>一个</strong>属于自己 Pawn 的 Controller，只有 server 有所有 Controller。</p>
<p>但每个 client 会拥有所有的 Pawn 及其 Player State，毕竟我们需要知道其它玩家的生命值、等级这些信息。这些信息就是由 Authority 负责同步了。</p>
</blockquote>
<h3 id="ASC-设置与初始化">ASC 设置与初始化</h3>
<blockquote>
<p>首先要新建 ASC 和 AS 的 C++ 类。步骤略。</p>
</blockquote>
<p>如果 ASC 是 attach 到 Player State 上的，那么它也会跟着一起复制，并且根据 Replication Mode 实现不同的复制效果。其中 Tag 和 Cue 永远会复制到其它 client 上，唯一区别在于 Effect 是否被复制。</p>
<table>
<thead>
<tr>
<th style="text-align:left">Replication Mode</th>
<th style="text-align:left">描述</th>
<th style="text-align:left">使用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Full</td>
<td style="text-align:left">每个 Effect 都会复制到所有 client</td>
<td style="text-align:left">单机</td>
</tr>
<tr>
<td style="text-align:left">Mixed</td>
<td style="text-align:left">Effect 只会被复制到持有它的 Actor</td>
<td style="text-align:left">多人游戏中玩家控制的角色</td>
</tr>
<tr>
<td style="text-align:left">Minimal</td>
<td style="text-align:left">永不复制 Effect</td>
<td style="text-align:left">多人游戏中 AI 控制的角色</td>
</tr>
</tbody>
</table>
<blockquote>
<p>⚠️<strong>注意</strong>: Mixed 期望 OwnerActor 的 Owner 是 Controller。PlayerState 的 Owner 在默认情况下是 Controller，但 Character 不是。如果在 OwnerActor 不是 PlayerState 的时候使用 Mixed 模式，那么必须在 OwnerActor 上调用 <code>SetOwner()</code>（PlayerState 的 Owner 会自动设置为 Controller）。</p>
</blockquote>
<p>对于本项目而言，敌怪就是 <strong>AI-Controlled Pawn</strong>，它会直接持有 ASC 和 AS。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/Enermy/REnermyBase.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Components/GAS/RGASComponent.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Components/GAS/RGASAttributeSet.h"</span></span>

<span class="token class-name">AREnermyBase</span><span class="token double-colon punctuation">::</span><span class="token function">AREnermyBase</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  AbilitySystemComponent <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CreateDefaultSubobject</span><span class="token generic class-name"><span class="token operator">&lt;</span>URGASComponent<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"GAS Comp"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ensure</span><span class="token punctuation">(</span>AbilitySystemComponent<span class="token punctuation">)</span><span class="token punctuation">;</span>
  AttributeSet <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CreateDefaultSubobject</span><span class="token generic class-name"><span class="token operator">&lt;</span>URGASAttributeSet<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token string">"GAS Attribute Set"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">ensure</span><span class="token punctuation">(</span>AttributeSet<span class="token punctuation">)</span><span class="token punctuation">;</span>

  AbilitySystemComponent<span class="token operator">-&gt;</span><span class="token function">SetIsReplicated</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  AbilitySystemComponent<span class="token operator">-&gt;</span><span class="token function">SetReplicationMode</span><span class="token punctuation">(</span>EGameplayEffectReplicationMode<span class="token double-colon punctuation">::</span>Mixed<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并且在 <code>PossessedBy()</code> 函数中进行初始化就行。这个函数会在游戏为每个 Pawn 分配 Controller 时调用。</p>
<p>而对于 <strong>Player-Controlled Pawn</strong>，则是在 <code>RPlayerState</code> 中持有（创建组件的步骤略）。</p>
<p>但是初始化的时机略有不同。考虑到 Player State 会在运行时由上层分配给 Pawn，所以不仅需要在 <code>PossessedBy()</code> 函数中进行初始化，还需要在 Pawn 的 <code>OnRep_PlayerState()</code> 也进行初始化。这样一来就能得到实现思路了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/RCharacterBase.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Components/RPlayerState.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"AbilitySystemComponent.h"</span></span>

<span class="token keyword">void</span> <span class="token class-name">ARCharacterBase</span><span class="token double-colon punctuation">::</span><span class="token function">PossessedBy</span><span class="token punctuation">(</span>AController<span class="token operator">*</span> NewController<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">PossessedBy</span><span class="token punctuation">(</span>NewController<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>GASComponent<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    GASComponent<span class="token operator">-&gt;</span><span class="token function">InitAbilityActorInfo</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> 
  <span class="token keyword">else</span>
  <span class="token punctuation">{</span>
    <span class="token function">InitAbilityActorInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARCharacterBase</span><span class="token double-colon punctuation">::</span><span class="token function">OnRep_PlayerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">OnRep_PlayerState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">InitAbilityActorInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARCharacterBase</span><span class="token double-colon punctuation">::</span><span class="token function">InitAbilityActorInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ARPlayerState<span class="token operator">*</span> PS <span class="token operator">=</span> <span class="token generic-function"><span class="token function">GetPlayerState</span><span class="token generic class-name"><span class="token operator">&lt;</span>ARPlayerState<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>UAbilitySystemComponent<span class="token operator">*</span> ASC <span class="token operator">=</span> PS<span class="token operator">-&gt;</span><span class="token function">GetAbilitySystemComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      ASC<span class="token operator">-&gt;</span><span class="token function">InitAbilityActorInfo</span><span class="token punctuation">(</span>PS<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Attribute-Set">Attribute Set</h2>
<h3 id="Attribute">Attribute</h3>
<p>我们熟知的属性（生命值、等级）都是由一个叫 <code>FGameplayAttributeData</code> 的结构体表示的。这个结构体包含两个浮点数，<code>BaseValue</code> 和 <code>CurrentValue</code>，前者是属性的永久值，后者是在前者的基础上，由 Effect 修改得到的临时值，在 Effect 过期时变回 <code>BaseValue</code>。</p>
<blockquote>
<p>但是并不能这么用——Base Value 表示最大生命值，Current Value 表示当前生命值。</p>
<p>比如英雄联盟里蒙多的 R 技能是一段时间内获得最大生命值，持续时间过后复原，这就要用到两个浮点数来维护了「最大生命值」这个属性了。所以应该用两个 <code>FGameplayAttributeData</code> 分别对应当前生命值和最大生命值。</p>
</blockquote>
<h3 id="在-Attribute-Set-中设置-Attribute">在 Attribute Set 中设置 Attribute</h3>
<p>AS 负责所有 Attribute 的管理，一个 ASC 可以有多个 AS，但是<strong>同一类</strong>的 AS 只能有一个。因为 AS 的内存开销并不大（两倍于属性个数的浮点数），可以选择让游戏中的每个角色共享一个大的单一的 AS，如果用不到某些属性，直接忽略即可。</p>
<blockquote>
<p>在 OwnerActor 的构造函数中创建 AS 会自动将其注册到其 ASC 中。</p>
</blockquote>
<p>为了在 AS 中设置 Attribute，需要使用 <code>UPROPERTY(ReplicatedUsing = FunctionName**)</code> 修饰，这指定了一个 callback，该函数在属性通过网络更新时执行，同时要在当前类实现该 callback。比如当前生命值属性：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/GAS/RGASAttributeSet.h</span></div><code class="language-cpp"><span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> URGASAttributeSet <span class="token operator">:</span> <span class="token keyword">public</span> UAttributeSet
<span class="token punctuation">{</span>
  <span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>BlueprintReadOnly<span class="token punctuation">,</span> ReplicatedUsing <span class="token operator">=</span> OnRep_CurHealth<span class="token punctuation">)</span>
  FGameplayAttributeData CurHealth<span class="token punctuation">;</span>

  <span class="token function">UFUNCTION</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">void</span> <span class="token function">OnRep_CurHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> FGameplayAttributeData<span class="token operator">&amp;</span> OldCurHealth<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>同时为了将相关的 CRUD 接口暴露给外部，可以添加下面这个宏到头文件最前面</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/GAS/RGASAttributeSet.h</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"AbilitySystemComponent.h"</span> <span class="token comment">// 必须加上</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">ATTRIBUTE_ACCESSORS</span><span class="token expression"><span class="token punctuation">(</span>ClassName<span class="token punctuation">,</span> PropertyName<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">GAMEPLAYATTRIBUTE_PROPERTY_GETTER</span><span class="token punctuation">(</span>ClassName<span class="token punctuation">,</span> PropertyName<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">GAMEPLAYATTRIBUTE_VALUE_GETTER</span><span class="token punctuation">(</span>PropertyName<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">GAMEPLAYATTRIBUTE_VALUE_SETTER</span><span class="token punctuation">(</span>PropertyName<span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">GAMEPLAYATTRIBUTE_VALUE_INITTER</span><span class="token punctuation">(</span>PropertyName<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>并且加上类似于 <code>ATTRIBUTE_ACCESSORS(URGASAttributeSet, CurHealth)</code> 这样的语句。之后，需要用 <code>GAMEPLAYATTRIBUTE_REPNOTIFY</code> 宏填充 <code>On_Rep*</code> 函数，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/GAS/RGASAttributeSet.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">URGASAttributeSet</span><span class="token double-colon punctuation">::</span><span class="token function">OnRep_CurHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> FGameplayAttributeData<span class="token operator">&amp;</span> OldCurHealth<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
  <span class="token function">GAMEPLAYATTRIBUTE_REPNOTIFY</span><span class="token punctuation">(</span>URGASAttributeSet<span class="token punctuation">,</span> CurHealth<span class="token punctuation">,</span> OldCurHealth<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
也可以用宏

#define SETUP_ONREP_FUNCTION_DECLARATION(ClassName, Attr)\
      void ClassName::OnRep_##Attr(const FGameplayAttributeData&amp; Old##Attr) const\
      {\
      GAMEPLAYATTRIBUTE_REPNOTIFY(ClassName, Attr, Old##Attr);\
      }
*/</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>This is a helper macro that can be used in RepNotify functions to handle attributes that will be predictively modified by clients. 这句话是源码中对宏的 comment，意思是加上这个宏就可以处理将被客户端预测修改的属性。</p>
<blockquote>
<p>所谓「预测」，指的就是 client 在被一个 Effect 影响时，可以把对相关值的修改放在「将修改请求发到 server 等其<strong>认可</strong>并同步」之前。而如果 server 认为该修改<strong>不合理</strong>（不认可），则会将 client 的修改 rollback。</p>
<p>预测机制使得多人游戏更加流畅。因为很少会出现「不合理」的修改请求，所以这种<strong>乐观</strong>的策略能大大减少对属性值修改的时延——如果没有预测机制，则需要等到下次 server 进行同步时才会对属性值进行修改。</p>
</blockquote>
<p>当 Attribute 被复制时的行为已经做好了，接下来还要指定一个 Attribute 如何被复制，这是在函数 <code>GetLifetimeReplicatedProps()</code> 中实现的。该函数负责复制我们使用 Replicated 说明符指派的任何属性，并可用于配置属性的复制方式。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/GAS/RGASAttributeSet.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">URGASAttributeSet</span><span class="token double-colon punctuation">::</span><span class="token function">GetLifetimeReplicatedProps</span><span class="token punctuation">(</span>TArray<span class="token operator">&lt;</span>FLifetimeProperty<span class="token operator">&gt;</span><span class="token operator">&amp;</span> OutLifetimeProps<span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">GetLifetimeReplicatedProps</span><span class="token punctuation">(</span>OutLifetimeProps<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 这一行必不可少</span>

  <span class="token function">DOREPLIFETIME_CONDITION_NOTIFY</span><span class="token punctuation">(</span>URGASAttributeSet<span class="token punctuation">,</span> CurHealth<span class="token punctuation">,</span> COND_None<span class="token punctuation">,</span> REPNOTIFY_Always<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中 <code>DOREPLIFETIME_CONDITION_NOTIFY</code> 宏的前两个参数很容易理解，分别是类名和类中的属性名，关键在于后两个参数。</p>
<p>第三个参数指明了 server 进行复制的条件。<code>COND_NONE</code> 是默认值，即无条件复制。
cod
第四个参数指明了 client 触发 OnRep 的条件。<code>REPNOTIFY_Always</code> 是一个枚举值，表明无论什么情况都会触发 OnRep，而默认是仅当 server 下发的值和 client 不同时才触发 OnRep，如果相同（意味着进行了正确的预测）则不会触发。</p>
<blockquote>
<p><code>DOREPLIFETIME*</code> 宏实际上会调用 <code>DOREPLIFETIME_WITH_PARAMS</code> 宏，并传入一个 <code>FDoRepLifetimeParams</code> 类型的额外参数，最后调用的是 <code>RegisterReplicatedLifetimeProperty()</code> 函数，根据函数名也可以知道，是进行了<strong>需要复制</strong>的变量的<strong>注册</strong>行为。</p>
</blockquote>
<p>之后可以通过命令行 <code>showdebug abilitysystem</code> 来进行 GAS 的调试。</p>
<h3 id="订阅-Attribute-变化">订阅 Attribute 变化</h3>
<p>以玩家为例，ASC 和 AS 均放在 Player State 中，那么就由 Player State 管理 Attribute 发生变化时的行为，这在语义上也是说得通的。具体要怎么做呢？答案是用 ASC 的一个叫 <code>GetGameplayAttributeValueChangeDelegate()</code> 的函数。这个函数会获取一个**委托(Delegate)**变量。所谓委托就是允许其它类在其上订阅它们感兴趣的事件，一旦某事件 SomeEvent 发生，委托就会通过广播的行为，告知那些关注 SomeEvent 的类，这通常是以在委托类中绑定 callback 实现的。用法如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Character/RCharacterBase.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ARPlayerState</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>AbilitySystemComponent <span class="token operator">&amp;&amp;</span> AttributeSet<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 就是下面这一行，返回的 Handle 可以设为成员变量。</span>
    <span class="token comment">// AddUObject 就是在绑定 callback</span>
    <span class="token comment">// 一旦 CurHealth 发生变化，就会调用 OnCurHealthChanged()</span>
    OnCurHealthChangedDelegateHandle <span class="token operator">=</span> AbilitySystemComponent<span class="token operator">-&gt;</span><span class="token function">GetGameplayAttributeValueChangeDelegate</span><span class="token punctuation">(</span>AttributeSet<span class="token operator">-&gt;</span><span class="token function">GetCurHealthAttribute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">AddUObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ARPlayerState<span class="token double-colon punctuation">::</span>OnCurHealthChanged<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>课程中的实现太繁琐，我直接参考了 GAS Documentation 来做的。</p>
</blockquote>
<h2 id="Gameplay-Effect">Gameplay Effect</h2>
<p><strong>Gameplay Effect(GE)</strong> 是 Ability 修改其自身和其他 Attribute 和 GameplayTag 的容器，其可以立即修改 Attribute（比如伤害或治疗）或应用长期的状态 buff/debuff（如加速或眩晕）。<code>UGameplayEffect</code> 只是一个定义单一游戏效果的数据类，不应该在其中添加额外的逻辑。通常会创建 <code>UGameplayEffect</code> 的派生蓝图类而非 C++ 类。</p>
<h3 id="持续时间">持续时间</h3>
<p>Effect 可分为三种，<strong>即刻(Instant)</strong>、<strong>有持续时间(Has Duration)<strong>和</strong>无限(Infinite)</strong>。其中 Instant 修改的是 BaseValue，通常用于伤害或治疗效果；其余两个修改的是 CurrentValue，通常用于 buff/debuff 之类的效果。</p>
<p>一旦将 Effect 设置为 Has Duration 或 Infinite，就可以进而为其设置<strong>生效周期(Period)</strong>，并且可以指定「对应用执行周期影响」，表示是否在应用时立即生效。</p>
<h3 id="修饰符-Modifier">修饰符(Modifier)</h3>
<p>修饰符指明了<strong>目标属性</strong>、<strong>操作类型</strong>、<strong>修改幅度</strong>，以及 Gameplay Tags 的过滤。</p>
<h4 id="操作类型">操作类型</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>「加」「乘」「除」: 这仨都是字面意思，多个对同一属性的操作，会通过聚合公式对属性的 CurrentValue 进行修改，结果为  <code>CurrentValue = (BaseValue + Add) * Mutiply / Divide</code>，其中 <code>Add</code> 为所有设置为「加」的 Modifier 的幅度；</p>
</li>
<li class="lvl-2">
<p>「重载」: 用当前值覆盖最后一个应用的修饰符的结果；</p>
</li>
<li class="lvl-2">
<p>「无效」:</p>
</li>
</ul>
<h4 id="修改幅度">修改幅度</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>「可扩展浮点」: 硬编码一个固定值；</p>
</li>
<li class="lvl-2">
<p>「属性基础」: 最简单来说就是允许根据 Attribute 代入某个公式进行计算求出最终结果；</p>
<ul class="lvl-2">
<li class="lvl-4">
<p><strong>支持属性</strong>中可以指定基于 Source 还是 Target，也可以指定 Attribute，若设置为<strong>快照</strong>，则会捕获 Effect <strong>创建</strong>时刻的数据，否则捕获<strong>施加</strong>时刻的数据；</p>
</li>
<li class="lvl-4">
<p><strong>属性计算幅度</strong>可以指定 <code>Value</code> 取 <code>BaseValue</code> 还是 <code>CurrentValue</code>，还是 <code>CurrentValue - BaseValue</code>；</p>
<blockquote>
<p>可以分别用于对应<strong>最大生命值</strong>、<strong>当前生命值</strong>、<strong>已损失生命值</strong>。</p>
</blockquote>
</li>
<li class="lvl-4">
<p>最后按照 <code>(Value + PreMultiplyAdditiveValue) * Coeffcient + PostMultiplyAdditiveValue</code> 得出最终修改值；</p>
</li>
</ul>
</li>
</ul>
<h4 id="曲线表">曲线表</h4>
<p>曲线表就是用于实现不同等级的 Effect 能施加不同程度的 Modify，并且会在「修改幅度」的基础上再乘上曲线上当前 Level 的值。</p>
<h4 id="标签过滤">标签过滤</h4>
<p>根据 Source 和 Target 的标签情况，决定 Modifier 是否生效。比如可以实现类似「目标中毒时，降低 50% 防御力」的效果。</p>
<h3 id="堆叠-Stack">堆叠(Stack)</h3>
<p>在英雄联盟这个游戏里，有很多技能/物品在使用后会获得一个「状态」。</p>
<p>部分技能连续使用时或许还会叠加「状态」层数，有些可以无限叠加，如邪恶小法师的 Q 技能「黑暗祭祀」；有些有叠加上限，并且一旦持续时间消失会逐渐降低层数，如战争之影的 Q 技能「暴走」；有些一旦持续时间结束会失去所有层数，如诺克萨斯之手的被动技能「出血」；而有些并不能叠加层数，也就是最高只有一层……在 Gameplay Effect 里面，我们可以用「堆叠」功能实现同样的效果。这一功能通常搭配 <code>Has Duration</code> 的 Effect 使用。</p>
<h4 id="堆叠样式-Stacking-Type">堆叠样式(Stacking Type)</h4>
<p>默认是「无」，即可以无限叠加，施加的每个 GameplayEffectSpec 都视为相互<strong>独立</strong>；</p>
<p>还有两种是「按源聚合」与「按目标聚合」，将样式设置为这两种才能开启完整功能，并可以设置「堆栈限制次数」。前者是每个 Source 最多施加 n 个 Effect，后者是每个 Target 最多<strong>被</strong>施加 n 个 Effect。</p>
<h4 id="堆栈持续时间刷新策略-Stacking-Duration-Refresh-Policy">堆栈持续时间刷新策略(Stacking Duration Refresh Policy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>「成功应用时刷新」: 当有新的 Effect 成功入栈时，栈中其它 Effect 会刷新自身的持续时间；</p>
</li>
<li class="lvl-2">
<p>「永不刷新」: 不会刷新持续时间；</p>
</li>
</ul>
<h4 id="堆栈周期重设策略-Stacking-Period-Refresh-Policy">堆栈周期重设策略(Stacking Period Refresh Policy)</h4>
<ul class="lvl-0">
<li class="lvl-2">
<p>「成功应用后重设」: 当有新的 Effect 成功入栈时，栈中其它 Effect 会更新自身的周期时间，即如果设置了周期，则会将下次触发的时间修改为 <code>now + period</code>；</p>
</li>
<li class="lvl-2">
<p>「永不刷新」: 不会更新周期时间；</p>
</li>
</ul>
<h4 id="堆栈过期策略-Stack-Expiration-Policy">堆栈过期策略(Stack Expiration Policy)</h4>
<p>每当栈内的某个 Effect 持续时间到了，就会应用该策略。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>「清除整个堆栈」: 字面意思；</p>
</li>
<li class="lvl-2">
<p>「移除单一堆栈并刷新持续时长」: 将过期的移除，剩下的 Effect 刷新自身的持续时间；</p>
</li>
<li class="lvl-2">
<p>「刷新时长」: 用这个能实现 Infinite，并且可以通过 <code>OnStackCountChange()</code> 手动实现栈计数减少的行为；</p>
</li>
</ul>
<h3 id="施加-Effect">施加 Effect</h3>
<h4 id="生命恢复药水">生命恢复药水</h4>
<blockquote>
<p>「药水」本质上是一个放置在世界中的 Actor，自带碰撞范围，当角色 Overlap 时为其施加「立即恢复生命」的效果。</p>
</blockquote>
<p>首先可以创建一个 Actor 类 <code>REffectActor</code>，表示所有能够为具有 ASC 的角色施加 GameplayEffect 的物体的基类。这一基类实现了一个公有的方法 <code>ApplyEffectToTarget()</code>，语义为对目标施加 Effect。</p>
<p>很多时候一个 Actor 可以施加多种效果，比如造成伤害（Instant）后施加一个持续若干秒的 debuff（Duration），所以就需要在类中定义一个 <code>TArray&lt;&gt;</code>，用于存放该 Actor 能够施加的所有 Effect 的类型。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Actor/EffectActor.cpp</span></div><code class="language-cpp"><span class="token keyword">bool</span> <span class="token class-name">AREffectActor</span><span class="token double-colon punctuation">::</span><span class="token function">ApplyEffectToTarget</span><span class="token punctuation">(</span>AActor<span class="token operator">*</span> TargetActor<span class="token punctuation">,</span> FEffectInfo<span class="token operator">&amp;</span> EffectInfo<span class="token punctuation">,</span> <span class="token keyword">bool</span> bMayCancelLater<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  UAbilitySystemComponent<span class="token operator">*</span> ASCOfTarget <span class="token operator">=</span> <span class="token class-name">UAbilitySystemBlueprintLibrary</span><span class="token double-colon punctuation">::</span><span class="token function">GetAbilitySystemComponent</span><span class="token punctuation">(</span>TargetActor<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsValid</span><span class="token punctuation">(</span>ASCOfTarget<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>EffectInfo<span class="token punctuation">.</span>GameplayEffectClass<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">float</span> EffectLevel <span class="token operator">=</span> EffectInfo<span class="token punctuation">.</span>EffectLevel<span class="token punctuation">;</span>
  TSubclassOf<span class="token operator">&lt;</span>UGameplayEffect<span class="token operator">&gt;</span> GameplayEffectClass <span class="token operator">=</span> EffectInfo<span class="token punctuation">.</span>GameplayEffectClass<span class="token punctuation">;</span>

  <span class="token comment">// 创建一个 Effect Context，用于后续生成 Effect</span>
  FGameplayEffectContextHandle EffectContextHandle <span class="token operator">=</span> ASCOfTarget<span class="token operator">-&gt;</span><span class="token function">MakeEffectContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 设置 Effect 的施加者 Source，保存在 Effect Context 中</span>
  EffectContextHandle<span class="token punctuation">.</span><span class="token function">AddSourceObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  
  <span class="token comment">// 根据 Effect class 和 Effect Context 生成一个 EffectSpec</span>
  <span class="token keyword">const</span> FGameplayEffectSpecHandle EffectSpecHandle <span class="token operator">=</span> ASCOfTarget<span class="token operator">-&gt;</span><span class="token function">MakeOutgoingSpec</span><span class="token punctuation">(</span>GameplayEffectClass<span class="token punctuation">,</span> EffectLevel<span class="token punctuation">,</span> EffectContextHandle<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 施加到 Target 的 ASC 上，并返回一个 Active Gameplay Effect Handle</span>
  <span class="token keyword">const</span> FActiveGameplayEffectHandle ActiveEffectHandle <span class="token operator">=</span> ASCOfTarget<span class="token operator">-&gt;</span><span class="token function">ApplyGameplayEffectSpecToSelf</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">(</span>EffectSpecHandle<span class="token punctuation">.</span>Data<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后在编辑器中创建一个派生蓝图类 <code>BP_HealthPotion</code>，设置 Static Mesh 和 Sphere Collision 以后，在蓝图中实现碰撞球体的 <code>BeginOverlap</code> 和 <code>EndOverlap</code> 方法。</p>
<p>此时还需要填充 <code>EffectInfo</code> 成员。需要做的就是创建一个派生自 <code>UGameplayEffect</code> 的蓝图类，命名为 <code>GE_HealthPotion</code>，进行相关设置，如「Instant」「加」「RAttributeSet.CurHealth」「某个值」。创建完毕后即可进行类型的填充。这样就实现了一个简单的药水效果。</p>
<p>基于上面这种创建流程，还可以设计「持续恢复生命值的药水」「一旦进入其中就会持续扣血的燃烧区域」等等。</p>
<h4 id="Pre-Post-函数">Pre/Post 函数</h4>
<p>在施加 Effect 与实际修改 Attribute 前后，AS 分别会调用以下六个函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * PreGameplayEffectExecute -&gt; PreAttributeBaseChange -&gt; PreAttributeChange -&gt; (ATTRIBUTE BE CHANGED) -&gt;
 * PostAttributeChange -&gt; ON_ATTRIBUTE_CHANGED DELEGATE -&gt; PostAttributeBaseChange -&gt; PostGameplayEffectExecute
 */</span>

<span class="token comment">/**
 * Called just before any modification happens to an attribute's base value which is modified by Instant Gameplay Effects.
 */</span>
<span class="token keyword">void</span> <span class="token function">PreAttributeBaseChange</span><span class="token punctuation">(</span><span class="token keyword">const</span> FGameplayAttribute<span class="token operator">&amp;</span> Attribute<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> NewValue<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Called just after any modification happens to an attribute's base value which is modified by Instant Gameplay Effects.
 */</span>
<span class="token keyword">void</span> <span class="token function">PostAttributeBaseChange</span><span class="token punctuation">(</span><span class="token keyword">const</span> FGameplayAttribute<span class="token operator">&amp;</span> Attribute<span class="token punctuation">,</span> <span class="token keyword">float</span> OldValue<span class="token punctuation">,</span> <span class="token keyword">float</span> NewValue<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Called just before any modification happens to an attribute's current value which is modified by Duration based Gameplay Effects.
 * 
 * This function is meant to enforce things like "Health = Clamp(Health, 0, MaxHealth)" and NOT things like "trigger this extra thing if damage is applied, etc".
 */</span>
<span class="token keyword">void</span> <span class="token function">PreAttributeChange</span><span class="token punctuation">(</span><span class="token keyword">const</span> FGameplayAttribute<span class="token operator">&amp;</span> Attribute<span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token operator">&amp;</span> NewValue<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Called just after any modification happens to an attribute.'s current value which is modified by Duration based Gameplay Effects.
 */</span>
<span class="token keyword">void</span> <span class="token function">PostAttributeChange</span><span class="token punctuation">(</span><span class="token keyword">const</span> FGameplayAttribute<span class="token operator">&amp;</span> Attribute<span class="token punctuation">,</span> <span class="token keyword">float</span> OldValue<span class="token punctuation">,</span> <span class="token keyword">float</span> NewValue<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Called just before the Gameplay Effect is executed.
 * 
 * Return true to continue, or false to throw out the modification.
 */</span>
<span class="token keyword">bool</span> <span class="token function">PreGameplayEffectExecute</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">FGameplayEffectModCallbackData</span><span class="token operator">&amp;</span> Data<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Called just after the Gameplay Effect is executed.
 * 
 * When PostGameplayEffectExecute() is called, changes to the Attribute have already happened,
 * but they have not replicated back to clients yet so clamping values here will not cause two network updates to clients.
 * Clients will only receive the update after clamping.
 */</span>
<span class="token keyword">void</span> <span class="token function">PostGameplayEffectExecute</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">FGameplayEffectModCallbackData</span><span class="token operator">&amp;</span> Data<span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中主要关注 <code>PreAttributeChange()</code> 和 <code>PostGameplayEffectExecute()</code> 这两个。</p>
<p>前者用于对 <code>NewValue</code> 进行 Clamp 操作，后者主要获取 Effect 的 Source 实现相关逻辑（比如反伤等等）。</p>
<h3 id="移除-Effect">移除 Effect</h3>
<p>为了移除施加到 ASC Of Target 上的 Effect，需要调用的函数是 <code>RemoveActiveGameplayEffect()</code>。该函数需要两个参数：一个 <code>FActiveGameplayEffectHandle</code> 和一个浮点数。</p>
<p>前者是通过调用 <code>ApplyGameplayEffectSpecToSelf()</code> 返回的，后者则表明了当移除该 Effect 时，要移除栈内多少个 Effect。默认为 <code>-1</code>，即全部移除。</p>
<p>所以为了正确调用，需要由一定数据结构保存施加 Effect 时返回的那个 <code>FActiveGameplayEffectHandle</code>。常用的是 <code>TMap&lt;&gt;</code>，存储 Active Handle 到 ASC 的映射。</p>
<h3 id="监听-Effect-行为">监听 Effect 行为</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>AbilitySystemComponent.h</span></div><code class="language-cpp"><span class="token comment">/** Delegate for when an effect is applied */</span>
<span class="token function">DECLARE_MULTICAST_DELEGATE_ThreeParams</span><span class="token punctuation">(</span>
  FOnGameplayEffectAppliedDelegate<span class="token punctuation">,</span>
  UAbilitySystemComponent<span class="token operator">*</span><span class="token punctuation">,</span>
  <span class="token keyword">const</span> FGameplayEffectSpec<span class="token operator">&amp;</span><span class="token punctuation">,</span>
  FActiveGameplayEffectHandle
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">/**
 * Called on server whenever a GE is applied to self.
 * This includes instant and duration based GEs.
 */</span>
FOnGameplayEffectAppliedDelegate OnGameplayEffectAppliedDelegateToSelf<span class="token punctuation">;</span>

<span class="token comment">/**
 * Called on server whenever a GE is applied to someone else.
 * This includes instant and duration based GEs.
 */</span>
FOnGameplayEffectAppliedDelegate OnGameplayEffectAppliedDelegateToTarget<span class="token punctuation">;</span>

<span class="token comment">/**
 * Called on both client and server whenever a duration based GE is added
 * (E.g., instant GEs do not trigger this).
 */</span>
FOnGameplayEffectAppliedDelegate OnActiveGameplayEffectAddedDelegateToSelf<span class="token punctuation">;</span>

<span class="token comment">/**
 * Called on server whenever a periodic GE executes on self
 */</span>
FOnGameplayEffectAppliedDelegate OnPeriodicGameplayEffectExecuteDelegateOnSelf<span class="token punctuation">;</span>

<span class="token comment">/**
 * Called on server whenever a periodic GE executes on target
 */</span>
FOnGameplayEffectAppliedDelegate OnPeriodicGameplayEffectExecuteDelegateOnTarget<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这些就是当 Effect 施加时可能进行广播的委托对象，在类 <code>UAbilitySystemComponent</code> 中定义。当我们要实现一些诸如「受到某些技能效果时触发某些事件」的功能，就需要用到这些了。</p>
<p>可以在 <code>RGASComponent</code> 类的 <code>BeginPlay()</code> 函数中执行 callback 的注册。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/GAS/RGASComponent.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">URGASComponent</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  OnGameplayEffectAppliedDelegateToSelf<span class="token punctuation">.</span><span class="token function">AddUObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span>
                                                   <span class="token operator">&amp;</span>URGASComponent<span class="token double-colon punctuation">::</span>OnEffectApplied<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">URGASComponent</span><span class="token double-colon punctuation">::</span><span class="token function">OnEffectApplied</span><span class="token punctuation">(</span>UAbilitySystemComponent<span class="token operator">*</span> AbilitySystemComponent<span class="token punctuation">,</span>
                                     <span class="token keyword">const</span> FGameplayEffectSpec<span class="token operator">&amp;</span> EffectSpec<span class="token punctuation">,</span>
                                     FActiveGameplayEffectHandle EffectHandle<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="Gameplay-Tags">Gameplay Tags</h2>
<p><code>FGameplayTag</code> 是由 <code>GameplayTagManager</code> 注册的形似 Parent.Child.Grandchild… 的层级 <code>FName</code>，这些标签对于分类和描述对象的状态非常有用（例如如果某个 Character 处于眩晕状态，我们可以授予其一个 State.Debuff.Stun 的 Tag）。用 GameplayTag 可以替换布尔值或枚举值，多个 GameplayTag 应被保存于一个 <code>FGameplayTagContainer</code> 中，相比 <code>TArray&lt;FGameplayTag&gt;</code> 做了一些很有效率的优化。可以更快地判断一个 Character 是否具有某 Tag，从而决定是否施加 Effect。</p>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Gameplay Study(6)：UI</title>
    <url>/unreal/gameplay6/</url>
    <content><![CDATA[<p>既然有了属性，我们就要一些 UI 控件来对关心的属性进行可视化。</p>
<span id="more"></span>
<p>在 Game Mode 的默认类中会发现一个叫 HUD 的类。所谓 <strong>HUD(Heads-Up Display)</strong>，指的就是在游戏或应用程序中以某种方式显示信息给玩家或用户的技术和概念。而在 UE 中，HUD 可以包括诸如玩家的健康状态、武器信息、地图、任务目标等重要信息。这些信息通常以图形、文本或图标的形式显示在屏幕上，使玩家能够实时了解游戏中的关键信息，并且会在游戏开始时被创建，可被 Player Controller 访问。</p>
<h2 id="创建类">创建类</h2>
<p>这样一来，就可以令 HUD 管理所有 UI 控件了。首先需要创建一个 HUD 类 <code>RHUD</code>，接着是一个派生自 <code>UserWidget</code> 的用于显示生命值和魔法值的 UI 控件 <code>RStatusBarWidget</code>。</p>
<h3 id="HUD">HUD</h3>
<p><code>RHUD</code> 类做的事很简单，定义控件成员，在构造时将控件输出到屏幕上，并且提供一个访问控件的接口（用于其它类在 Attribute 变化时更新）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UI/RHUD.h</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">URStatusBarWidget</span><span class="token punctuation">;</span>

<span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> ARHUD <span class="token operator">:</span> <span class="token keyword">public</span> AHUD
<span class="token punctuation">{</span>
  <span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">public</span><span class="token operator">:</span>
  URStatusBarWidget<span class="token operator">*</span> <span class="token function">GetStatusBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> StatusBar<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  
<span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">override</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>VisibleAnywhere<span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>URStatusBarWidget<span class="token operator">&gt;</span> StatusBar<span class="token punctuation">;</span>

  <span class="token comment">// 因为需要在蓝图中绘制控件，所以会生成一个控件蓝图类。就必须用一个蓝图中可编辑的变量来表示这个蓝图类。</span>
  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>EditDefaultsOnly<span class="token punctuation">)</span>
  TSubclassOf<span class="token operator">&lt;</span>URStatusBarWidget<span class="token operator">&gt;</span> StatusBarClass<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UI/RHUD.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"UI/RHUD.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"UI/Widget/RStatusBarWidget.h"</span></span>

<span class="token keyword">void</span> <span class="token class-name">ARHUD</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token class-name">Super</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  StatusBar <span class="token operator">=</span> <span class="token generic-function"><span class="token function">CreateWidget</span><span class="token generic class-name"><span class="token operator">&lt;</span>URStatusBarWidget<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">GetWorld</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> StatusBarClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
  StatusBar<span class="token operator">-&gt;</span><span class="token function">AddToViewport</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Status-Bar-Widget">Status Bar Widget</h3>
<p>一个控件中可能有许多子控件，比如图像、按钮、进度条等等。最开始我们可以简单地只关注「进度条」这一个控件，而无需在意它用的是什么贴图和什么颜色。当人物 Attribute 发生变化时，可以通过设置进度条的百分比来达到效果。而真正显示的是派生出的蓝图类。为了让蓝图类知道在自己这里绘制的某个控件是继承自基类的，需要在基类中用 <code>UPROPERTY(meta=(BindWidget))</code> 修饰，并且蓝图类中创建的控件名必须和基类一致，这就实现了<strong>绑定</strong>。当执行 C++ 中设置进度条百分比的逻辑时，用于显示的蓝图类也会应用一样的修改。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UI/Widget/RStatusBarWidget.h</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">UProgressBar</span><span class="token punctuation">;</span>

<span class="token function">UCLASS</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">class</span> <span class="token class-name">ACTIONRPG_API</span> URStatusBarWidget <span class="token operator">:</span> <span class="token keyword">public</span> UUserWidget
<span class="token punctuation">{</span>
  <span class="token function">GENERATED_BODY</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  
<span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">// 暴露给 HUD 的接口</span>
  <span class="token keyword">void</span> <span class="token function">SetHealthBarPercentage</span><span class="token punctuation">(</span><span class="token keyword">float</span> Percentage<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token function">UPROPERTY</span><span class="token punctuation">(</span>meta <span class="token operator">=</span> <span class="token punctuation">(</span>BindWidget<span class="token punctuation">)</span><span class="token punctuation">)</span>
  TObjectPtr<span class="token operator">&lt;</span>UProgressBar<span class="token operator">&gt;</span> HealthBar<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UI/Widget/RStatusBarWidget.cpp</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"UI/Widget/RStatusBarWidget.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"Components/ProgressBar.h"</span></span>

<span class="token keyword">void</span> <span class="token class-name">URStatusBarWidget</span><span class="token double-colon punctuation">::</span><span class="token function">SetHealthBarPercentage</span><span class="token punctuation">(</span><span class="token keyword">float</span> Percentage<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  HealthBar<span class="token operator">-&gt;</span><span class="token function">SetPercent</span><span class="token punctuation">(</span>Percentage<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="何时设置进度条百分比？">何时设置进度条百分比？</h3>
<p>之前我们已经进行了 Attribute 变化事件的 callback 绑定，对应的函数是 <code>RPlayerState::OnCurHealthChanged</code>。所以也就是在这个函数中，Player State 获取当前角色使用的 HUD。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Components/RPlayerState.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">ARPlayerState</span><span class="token double-colon punctuation">::</span><span class="token function">BeginPlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>ARPlayerController<span class="token operator">*</span> PC <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ARPlayerController<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token function">GetOwner</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    HUD <span class="token operator">=</span> <span class="token generic-function"><span class="token function">Cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>ARHUD<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>PC<span class="token operator">-&gt;</span><span class="token function">GetHUD</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token class-name">ARPlayerState</span><span class="token double-colon punctuation">::</span><span class="token function">OnCurHealthChanged</span><span class="token punctuation">(</span><span class="token keyword">const</span> FOnAttributeChangeData<span class="token operator">&amp;</span> Data<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>URStatusBarWidget<span class="token operator">*</span> StatusBar <span class="token operator">=</span> HUD<span class="token operator">-&gt;</span><span class="token function">GetStatusBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    StatusBar<span class="token operator">-&gt;</span><span class="token function">SetHealthBarPercentage</span><span class="token punctuation">(</span>Data<span class="token punctuation">.</span>NewValue <span class="token operator">/</span> <span class="token function">GetMaxHealth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里简单地认为 Owner 保持不变。如果应用场景中会发生变化，则可以将 HUD 的获取推迟到 <code>On..Changed()</code> 中来。</p>
<h2 id="结果">结果</h2>
<p>绘制过程就略过了，总之用的是课程的素材。结果如下</p>
<img src="hudres.png">]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>面经</title>
    <url>/interview/interviewexperience/</url>
    <content><![CDATA[<p>个人的 面试经验整理。</p>
<span id="more"></span>
<h2 id="C">C++</h2>
<h3 id="C-和-C-的区别">C 和 C++ 的区别</h3>
<blockquote>
<p>说实话这是个比较宏大的问题。要考虑这个问题，首先得明白什么才算「区别」。就面向对象而言，C 中也可以实现封装（成员函数可以用函数指针代替，构造/析构函数可以用工厂函数代替）、继承（在结构体的最开始直接定义一个基类对象）、多态（可以自定义虚函数表），无非看着别扭了点就是了，所以这算不上「区别」。</p>
<p>我认为，只用 C 语言无法模拟出，或者人工模拟代价很大的 C++ 的特性，这才是能称之为「<strong>区别</strong>」。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>确定性析构</strong>: 虽然 C 可以模拟析构函数，但很难保证每次都能够在一个对象生命周期即将结束时调用模拟的析构函数，搞不好就容易出 Bug。而 C++ 的析构函数则完美解决了这个问题，并且实现更加优雅，将「释放对象」这一行为交给编译器，同时基于此还将 RAII 哲学应用到了语言上，进一步产生了各种容器、智能指针、锁管理者这些标准库对象，不得不说析构函数是 C++ 的几大根基之一了；</p>
</li>
<li class="lvl-3">
<p><strong>右值和移动语义</strong>: 虽然 C 中可以通过「指针常量」模拟左值引用，但却无法实现对右值/匿名对象的「引用」（因为右值没有地址，无法被指针指向），函数调用中传入一个匿名的 struct 会涉及到数据拷贝，影响性能。而 C++11 之后引入了「右值」这一概念，同时加入了右值引用、万能引用、<code>std::forward</code>、<code>std::move</code> 等内容；</p>
</li>
<li class="lvl-3">
<p><strong>模板</strong>: C++ 编译器会自动对模板类/函数生成相应的代码，C 想实现诸如 <code>max()</code>/<code>swap()</code> 这种函数代价就太大了。同时 C++ 还在模板的基础上引入了「<strong>模板元编程</strong>」之类的技巧，将一些计算提到编译期，提高了运行时性能；</p>
</li>
<li class="lvl-3">
<p>…</p>
</li>
</ol>
<h3 id="说下-C-内存布局？以及堆和栈的区别？为什么不能只用其中一个？">说下 C++ 内存布局？以及堆和栈的区别？为什么不能只用其中一个？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-memory">C++ の 内存分配</a></p>
</blockquote>
<p>C++ 的内存布局中，从低到高依次为代码区、常量存储区、全局存储区、堆区、栈区。</p>
<p>堆的地址从低到高增长，是程序员通过 new/delete <strong>手动</strong>分配和释放的，其生命周期与整个程序相同。</p>
<p>栈的地址从高到低增长，由编译器<strong>自动</strong>管理分配，以**栈帧(Frame)**为单位，存放函数局部变量、函数参数值等。一旦函数结束，对应的栈帧也就被 pop，里面的变量生命周期也就结束了。</p>
<p>栈的优势在于将变量的管理交付给编译器，不需要麻烦程序员了；并且在栈上分配变量开销低——直接移动栈顶指针就好了。相比而言，在堆上分配内存还要涉及到不同的内存分配策略，开销就会很高。</p>
<p>而堆的优势在于延长变量的生命周期。试想一下如果只用栈，该如何实现树、链表这样的需要动态维护的数据结构？</p>
<h3 id="整数除以-0-会发生什么？浮点数呢？">整数除以 0 会发生什么？浮点数呢？</h3>
<p>如果是直接以比如 <code>1/0;</code> 进行编码会报编译错误。</p>
<p>如果是将 <code>0</code> 存到变量中除以一个变量，那么通常会触发运行时错误。</p>
<p>如果是浮点数之间除以 <code>0</code>，则会生成一个 <code>NAN</code>。</p>
<h3 id="struct-和-class-的区别">struct 和 class 的区别</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-oop/#%E4%B8%8E-struct-%E7%9A%84%E5%BC%82%E5%90%8C">C++ の OOP</a></p>
</blockquote>
<p>主要区别在于默认访问权限、继承方式，以及 struct 不能用模板。</p>
<h3 id="在类的不同函数中执行-delete-this-语句会发生什么？">在类的不同函数中执行 delete this; 语句会发生什么？</h3>
<p><code>delete this</code> 除了释放<strong>堆</strong>上的内存，还会调用析构函数。</p>
<p>如果是在栈上分配的对象，调用相关函数会 crash。</p>
<p>如果是在析构函数中执行，则会导致<strong>栈溢出</strong>。</p>
<p>而如果在成员函数中执行，则需要保证后续不会访问类的成员变量以及虚函数表，否则会导致<strong>段错误</strong>。</p>
<p>如果是在构造函数中执行，则会导致<strong>未定义行为</strong>。因为此时对象未完全构造，可能导致资源泄漏或数据损坏，同时构造函数后续的任何访问将导致访问违规。</p>
<h3 id="左值和右值的区别？">左值和右值的区别？</h3>
<p>左值可以取地址并具有变量名。</p>
<p>剩下的都是右值，又称<strong>匿名对象</strong>，只存在于寄存器中，无法在内存中寻址，不具有持久性。</p>
<h3 id="什么是右值引用-T-？">什么是右值引用(T&amp;&amp;)？</h3>
<p>左值引用 <code>T&amp;</code> 可以修改形参但无法用右值传值。</p>
<p>常量左值引用 <code>const T&amp;</code> 可以用右值传值但无法在函数内部对形参进行修改。</p>
<p>可以选择在栈上开一个左值的内存然后赋予右值，再用前者，也就是 <code>T&amp;</code> 传值，但存在拷贝开销。右值引用 <code>T&amp;&amp;</code> 能够解决这一问题——既可以传入右值，又可以修改形参。并在此基础上支持类的移动构造函数，以实现移动语义（转移所有权）。</p>
<blockquote>
<p>右值引用绑定的对象为右值，其具有变量名，所以是左值。</p>
</blockquote>
<h3 id="拷贝构造和移动构造的区别？">拷贝构造和移动构造的区别？</h3>
<p>前者相当于在内存中创建一个副本</p>
<blockquote>
<p>如果成员对象中有指针，则存在潜在的<strong>浅拷贝</strong>的问题。</p>
</blockquote>
<p>后者是在内存中转移数据所有权（被移动的对象失去底层数据，如指针置空），基于 <code>std::move</code> 和右值引用。</p>
<h3 id="std-move-和-std-forward-的区别？">std::move 和 std::forward 的区别？</h3>
<blockquote>
<p>具体可参考 <a href="https://cntransgroup.github.io/EffectiveModernCppChinese/5.RRefMovSemPerfForw/item23.html#%E6%9D%A1%E6%AC%BE%E4%BA%8C%E5%8D%81%E4%B8%89%E7%90%86%E8%A7%A3stdmove%E5%92%8Cstdforward">Effective Modern C++ Item23</a></p>
</blockquote>
<p><code>std::move</code> 仅仅做了个 become 右值引用的类型转换，并没有真正的「移动」。即</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">typename</span> <span class="token class-name">remove_reference</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span> <span class="token function">move</span><span class="token punctuation">(</span>T<span class="token operator">&amp;&amp;</span> param<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span>remove_reference<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>type<span class="token operator">&amp;&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::forward</code> 仅仅是将实参转为对应的引用版本，适用于万能引用下类型不明确的情况。</p>
<h3 id="std-move-中为什么要使用-remove-reference">std::move 中为什么要使用 remove_reference</h3>
<p>为了防止「引用折叠」，导致传入左值时返回值被折叠为左值引用。</p>
<h3 id="std-shared-ptr-和-std-unique-ptr-的异同？">std::shared_ptr 和 std::unique_ptr 的异同？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-smartptr">C++11 の 智能指针</a></p>
</blockquote>
<p>这两个都是智能指针，均满足 RAII 准则，在析构时自动释放堆上分配的内存。</p>
<p>shared ptr 为<strong>共享</strong>指针，允许拷贝构造，允许多个 shared ptr 指向同一块内存，经拷贝方式生成的 shared ptr 共享一个引用计数器，每引用一个对象计数器加 1；每释放一个对象计数器减 1。当计数器为 0 时该内存才会被释放。</p>
<blockquote>
<p>可以通过 <code>use_count()</code> 函数获取引用计数值。</p>
</blockquote>
<p>unique ptr 为<strong>独占</strong>指针，不允许拷贝构造，同时只能有一个 unique ptr 指向某块内存，只能通过移动语义来进行更改所有权。</p>
<h3 id="std-shared-ptr-有什么缺陷？如何解决？">std::shared_ptr 有什么缺陷？如何解决？</h3>
<p>shared ptr 存在「<strong>循环引用</strong>」的问题，可以用 <code>std::weak_ptr</code> 解决。比如下面这段代码，分别有两个 shared ptr 指向 a 和 b 所在的内存空间，outPa/inPa 与 outPb/inPb 的计数器均为 <strong>2</strong>。</p>
<p>当 <code>func()</code> 退出时，栈变量 outPa 和 outPb 结束生命周期，调用析构函数，分别使得 outPa/inPa 和 outPb/inPb 的计数值 <strong>-1</strong>。然而，类成员变量 inPa/inPb （的所有数据）还位于 a/b 所在的堆空间中，它们的计数器并没有归零，而是 <strong>1</strong>。那么永远得不到释放，这就造成了<strong>内存泄漏</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>循环引用</span></div><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>B<span class="token operator">&gt;</span> inPb<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>A<span class="token operator">&gt;</span> inPa<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">auto</span> outPa <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>A<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 视为指向堆空间 a</span>
  <span class="token keyword">auto</span> outPb <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">make_shared</span><span class="token generic class-name"><span class="token operator">&lt;</span>B<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 视为指向堆空间 b</span>
  outPa<span class="token operator">-&gt;</span>inPb <span class="token operator">=</span> outPb<span class="token punctuation">;</span>
  outPa<span class="token operator">-&gt;</span>inPa <span class="token operator">=</span> outPa<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果使用 <code>std::weak_ptr&lt;B&gt; inPb</code> 来代替 <code>std::shared_ptr&lt;B&gt; inPb</code>，则可以解决该问题。这是因为 weak ptr 并不影响 <strong>指向该内存的 shared ptr</strong> 的计数器，它只作为一个<strong>观测者</strong>，用于监测对应的空间是否被释放（通过 <code>expired()</code> 函数），同时提供了一个 <code>lock()</code> 函数来访问地址。根据这一特性，尽管 outPa/inPa 的计数器为 2，但是 outPb 的计数器为 1，那么其在函数退出后可以对 b 的内存进行释放，从而使 inPa 的计数器 counterA-=1，而 outPa 又因为函数退出而再次使计数器 counterA-=1，进而释放 a 的内存。</p>
<p>此时，a/b 的内存均被释放。</p>
<p>上面是第一个缺陷，第二个缺陷在于，如果用非拷贝非移动的方式，创建两个 shared ptr 指向同一块内存，则可能会出现 「<strong>悬垂指针</strong>」与「<strong>Double free</strong>」 的问题。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>悬垂指针 &amp; Double free</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DOUBLE_FREE</span></span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span><span class="token operator">*</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p1</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifdef</span> <span class="token expression">DOUBLE_FREE</span></span>
    std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">p2</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token punctuation">}</span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">ifndef</span> <span class="token expression">DOUBLE_FREE</span></span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token operator">*</span>a<span class="token punctuation">;</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果同时使用 p1 和 p2，则 p2 先析构，计数器归零，释放 a 指向的内存，然后 p1 析构，计数器归零，又释放 a 指向的内存，造成 double free 的错误。</p>
<p>如果仅使用 p1，则 p1 析构后释放 a 的内存，后续解引用 a 时出现 Undefined Behavior，输出可能是任意数。</p>
<h3 id="int-和-void-的区别？">int* 和 void* 的区别？</h3>
<p><code>int*</code> 类型的变量会有类型信息，告诉编译器「我指向的这块内存是个 <code>int</code> 变量，如果你要读取就只能一次性读 4 字节」。其他的 <code>double*</code>、<code>long long*</code> 同理。</p>
<p><code>void*</code> 意为无类型指针，可以指向任意类型的数据，但赋值给 <code>int*</code> 这种的就要配合类型转换了。直接读取是读 1 字节，毕竟也是指向了一个内存地址。</p>
<h3 id="若干-STL-容器的区别与特点、使用场景、迭代器失效问题等">若干 STL 容器的区别与特点、使用场景、迭代器失效问题等</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-stl">C++ の STL</a></p>
</blockquote>
<h3 id="map-中使用-at-和用-operator-有什么异同？">map 中使用 at() 和用 operator[] 有什么异同？</h3>
<p>两者都是基于 key 去索引 value。区别在于，如果 key 不存在，前者会抛异常，后者不会，并且还会插入一个 item，以及调用 value 的默认构造函数。</p>
<h3 id="static-关键字的用法？">static 关键字的用法？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-static">C++ の static</a></p>
</blockquote>
<h3 id="extern-关键字的用法？">extern 关键字的用法？</h3>
<p>第一种用法是为一个全局变量、函数或模板赋予**外部链接(external linkage)**属性，即编译器在某个 <code>.cpp</code> 文件中遇到一个声明为 <code>extern</code> 的变量或函数，就会试图去其他文件中寻找该符号的定义。</p>
<p>第二种用法是以指定编译器(C or C++)来处理接下来这部分内容。因为 C++ 为了处理函数重载，会以与 C 函数不同的方式（函数名+参数名）进行符号命名，而 C 不会，因此会造成链接时无法找到对应函数的情况。所以如果要对编译器提示使用C的方式来处理函数的话，那么就要使用 <code>extern "C"</code> 来说明。</p>
<h3 id="volatile-关键字的用法？">volatile 关键字的用法？</h3>
<p>用 <code>volatile</code> 声明的类型变量表示可以被某些编译器未知的因素更改，此时编译器就不会对其进行优化，从而总是从它所在的内存读取数据。</p>
<blockquote>
<p>一些可能的优化策略有：如果发现两次读变量（比如 <code>i</code>）的代码之间，没有对 <code>i</code> 进行过操作，那就会自动把第一次读的 <code>i</code> 值交给第二次的读取。尽管，在这期间内存中变量的值发生了变化。</p>
<p>感觉有点像数据库的可重复读？而 volitale 反而是禁止了可重复读。</p>
</blockquote>
<h3 id="new-和-malloc-的区别？">new 和 malloc 的区别？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-memory">C++11 の 内存分配</a></p>
</blockquote>
<p><code>new</code>: 操作符；支持传入类型/构造函数参数；会调用构造函数；直接返回对应类型的指针；用 <code>delete</code> 释放；分配失败时抛异常；</p>
<p><code>malloc</code>: 函数；只能传入需要分配的字节数；不会调用构造函数；以 <code>void*</code> 形式返回已分配内存的首地址；用 <code>free</code> 释放；分配失败时返回空指针；</p>
<h3 id="信号量和锁的区别？">信号量和锁的区别？</h3>
<p>两者都用于多线程并发场景。</p>
<p>锁通常用于互斥场景，即多个线程同时访问某一共享变量。</p>
<p>信号量既可以用于互斥，也可以用于同步（生产者 &amp; 消费者问题）。可以认为锁是信号量计数值为 1 时候的特例。</p>
<h3 id="使用模板-template-的优缺点？">使用模板(template)的优缺点？</h3>
<p><strong>优点</strong>: 提升开发效率；减少编码时间。</p>
<p><strong>缺点</strong>: 难以调试；声明和实现必须都放在同一个文件里，否则报 <code>undefined reference</code> 编译错误；拖慢编译时间。</p>
<h3 id="内联函数和普通函数的区别？">内联函数和普通函数的区别？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-inline">C++11 の 内联函数</a></p>
</blockquote>
<p>内联函数在编译期会被直接展开，减少了函数调用开销（参数压栈、地址跳转等）。</p>
<h3 id="虚函数的机制？一个类中可以把所有函数设为虚函数吗？如果把除了构造函数以外的函数设为虚函数会有什么问题？">虚函数的机制？一个类中可以把所有函数设为虚函数吗？如果把除了构造函数以外的函数设为虚函数会有什么问题？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-oop">C++11 の 面向对象</a></p>
</blockquote>
<p>如果本类或父类中有虚函数，内存最开始就会有一个虚表指针，指向一个存放<strong>所有声明为虚函数的函数指针</strong>的数组。如果用基类指向派生类，并调用虚函数，就会去虚表中查，取出相应的函数指针并调用，从而实现多态。</p>
<p>除了构造函数，其它的函数都能设为虚函数，并且析构函数必须设为虚函数。</p>
<p>有些函数不需要实现多态特性，那么就没必要声明为虚函数。即便没有在子类中重写，也需要去虚表中查询，多了一次访存开销。</p>
<h3 id="析构函数中能调用虚函数吗？">析构函数中能调用虚函数吗？</h3>
<blockquote>
<p>具体可参考 <a href="../../note/effectivec-Note/%E7%BB%9D%E4%B8%8D%E5%9C%A8%E6%9E%84%E9%80%A0%E5%92%8C%E6%9E%90%E6%9E%84%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8-virtual-%E5%87%BD%E6%95%B0">条款 9. 绝不在构造和析构过程中调用 virtual 函数</a></p>
</blockquote>
<blockquote>
<p>一般来说，存在虚函数的类派生链中，基类的析构函数都会设置成 virtual，以在出现基类指针指向派生类的情况时，对派生类进行正确的析构（否则只会调用基类的析构函数）。所以最后的执行顺序为：派生类析构函数 &gt; 基类析构函数。</p>
</blockquote>
<p>问题可以分成两种情况：在派生类析构函数中能否调用虚函数？在基类析构函数中能否调用虚函数？</p>
<p>两种情况在语法上都是可行的。</p>
<p>对于第一种情况，在运行上由于虚函数表仍存在，自身的成员变量并没有释放，所以是没有问题的，调用的虚函数将会是派生类的版本。</p>
<p>对于第二种情况，由于在调用基类的析构函数时，派生类已经析构，内存中只剩下基类部分，此时将<strong>不使用动态联编</strong>，也就是将当前对象视为基类对象，调用的虚函数将会是基类的版本而非派生类。不难发现，此时对虚函数的调用已经失去了多态性。</p>
<p>总结来说就是语法和运行上都不会报错，只不过在基类的析构函数中中调用虚函数不会起到我们想要的效果。</p>
<h3 id="RTTI-保存在哪里？">RTTI 保存在哪里？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-oop/#%E8%99%9A%E7%BB%A7%E6%89%BF-1">C++11 の 面向对象</a></p>
</blockquote>
<p>在虚函数表的负值索引处，除了 <code>runtime typeinfo</code>，其实还会存虚继承的虚基类 <code>offset</code>。</p>
<h3 id="简单介绍智能指针">简单介绍智能指针</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-smartptr/">C++ の 智能指针</a></p>
</blockquote>
<h3 id="如何实现一个支持引用计数的类？">如何实现一个支持引用计数的类？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-smartptr#%E5%A6%82%E4%BD%95%E6%89%8B%E6%92%95%E4%B8%80%E4%B8%AA-shared-ptr">如何手撕智能指针</a></p>
</blockquote>
<p>基本思想是类内有一个 <code>Counter*</code> 指针指向计数器，每次拷贝时 <code>Counter</code> 内部计数值增加，析构时减少，为 0 时才释放资源。计数值可以采用 <code>std::atomic</code> 来实现无锁版本。</p>
<h3 id="智能指针的优缺点是什么？或者说哪些情况下非得用裸指针？">智能指针的优缺点是什么？或者说哪些情况下非得用裸指针？</h3>
<p>优点自然是利用 RAII 思想自动进行内存分配与释放，降低内存泄漏的可能性。</p>
<p>（缺点我也是临时想的）在用 <code>dynamic_cast</code> 的时候不得不用裸指针了。</p>
<blockquote>
<p>但是也可以用 <code>dynamic_pointer_cast</code> 来解决，面试官没反驳我倒是。</p>
<p>或者可以说 <code>shared_ptr</code> 存在循环引用问题，但可以用 <code>weak_ptr</code> 解决。暂时没想到好的回答，感觉像是上压力看看应对能力。</p>
</blockquote>
<h3 id="对三种智能指针分别应用-sizeof，输出值是多少？">对三种智能指针分别应用 sizeof，输出值是多少？</h3>
<p>直接上代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>sizeof(三种智能指针)</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  unique_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> a<span class="token punctuation">;</span>
  shared_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> b<span class="token punctuation">;</span>
  weak_ptr<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> c<span class="token punctuation">;</span>

  cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token char">' '</span> <span class="token operator">&lt;&lt;</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> endl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>64 位机器下，上面的代码输出结果为 <code>8 16 16</code>，即 8B、16B、16B。</p>
<p>分析：<code>unique_ptr</code> 只保有一个对象指针；<code>shared_ptr</code> 和 <code>weak_ptr</code> 都是除了对象指针还保有一个计数器指针（两者的计数器类型不同）。</p>
<h3 id="重载、重写、覆盖三者的区别？">重载、重写、覆盖三者的区别？</h3>
<p><strong>重载</strong>：在同一个作用域内，函数名相同但参数列表不同的多个函数，包括函数的参数类型、参数个数或参数顺序的不同。即<strong>静态多态</strong>。</p>
<p><strong>重写</strong>：派生类重新定义基类中的虚函数，以便在运行时动态调用派生类的函数。即<strong>动态多态</strong>。</p>
<p><strong>覆盖</strong>：派生类中声明了与基类相同名称的成员变量或方法，使得基类中的同名成员在子类中不可见。如果此时需要调用基类的同名方法，则需要使用 <code>Base::func()</code> 的形式（假设基类为 <code>Base</code>）。</p>
<h3 id="如何实现一个线程池？">如何实现一个线程池？</h3>
<blockquote>
<p>具体可参考 <a href="../../c/c-concurrent/#%E7%BA%BF%E7%A8%8B%E6%B1%A0thread-pool">并发应用 —— 线程池</a></p>
</blockquote>
<h2 id="操作系统">操作系统</h2>
<h3 id="进程和线程的区别？">进程和线程的区别？</h3>
<p>进程: 资源分配的单位，拥有独立地址空间，切换时需修改页表基地址寄存器，清空 TLB 以及 CS、IP 等寄存器。新进程一开始访页时大概率会 cache miss，从而开销大。</p>
<p>线程: 调度的单位，同一进程下所有线程共享地址空间，但线程之间拥有独立的程序计数器与栈空间，切换时仅需修改相关寄存器，无需修改页表，故开销小。另外，不同进程之间的线程切换也会涉及到进程切换，开销变大。</p>
<p>本质区别在于<strong>是否和其它单位共享页表</strong>。</p>
<h3 id="哪些情况会导致进程-crash？">哪些情况会导致进程 crash？</h3>
<p>主要是<strong>段错误</strong>，比如</p>
<ol>
<li class="lvl-3">
<p>访问空指针；</p>
</li>
<li class="lvl-3">
<p>数组越界访问；</p>
</li>
<li class="lvl-3">
<p>除以零；</p>
</li>
<li class="lvl-3">
<p>内存耗尽，比如栈溢出、内存泄漏等；</p>
</li>
</ol>
<h3 id="用户级线程和内核级线程的区别？">用户级线程和内核级线程的区别？</h3>
<p>用户级线程，或者说协程，如 coroutine，由应用程序实现，调度在用户态完成，不需要内核介入，所以开销较小。缺点在于一旦一个用户及线程阻塞，那整个进程都将被阻塞。</p>
<p>内核级线程，如 thread，由操作系统实现，调度也由操作系统完成，意味着对内核级线程的调度要从用户态陷入内核，开销较大。优点在于即使自我阻塞，整个进程也能正常运转。</p>
<h3 id="切换地址空间是怎样实现的？">切换地址空间是怎样实现的？</h3>
<p>修改页表基地址寄存器，以访问正确的页表；以及清空 TLB，防止进行错误的地址转换。当然如果 TLB 支持 ASID 就不用清空了。</p>
<h3 id="虚拟地址和物理地址区别？为什么要用虚拟地址？">虚拟地址和物理地址区别？为什么要用虚拟地址？</h3>
<blockquote>
<p>具体可参考 <a href="https://www.xiaolincoding.com/os/3_memory/vmem.html#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98">这篇文章</a>。</p>
</blockquote>
<p>物理地址是指实际存储在内存中的地址，它可以直接被硬件访问。物理地址是固定的，并且受到物理内存大小的限制。</p>
<p>虚拟地址是指软件视图中的内存地址，它是逻辑地址，不受物理内存大小的限制。通常是连续的，因此程序员可以使用连续的虚拟地址，而不必考虑实际内存中的分布情况。</p>
<p>如果只有物理地址，那么程序员编程时必须足够小心，以防使用了其它程序的地址，更不能访问内核空间。在页面置换时，也必须将其放到固定的位置。而引入了虚拟地址，就可以将编程与访存分离，将内存访问交给操作系统去实现（页表），进而实现进程空间隔离，保证了安全性。</p>
<h3 id="进程访页过程？">进程访页过程？</h3>
<p>以<strong>在支持二级页表的 32 位机器中取指令</strong>为例。</p>
<p>首先进程根据当前 CS:IP 寄存器，进行指令地址的计算（CS&lt;&lt;4 + IP），从而获得相应代码段中的指令地址。注意这是一个虚拟地址，需要根据硬件转换为物理地址。</p>
<p><strong>注意</strong>: 假设该虚拟地址的前 10 位 <code>PD_Index</code> 是页目录条目的索引，中间 10 位 <code>PT_Index</code> 是页表条目的索引，后 12 位是页内偏移 <code>Offset</code>。</p>
<p>先访问 TLB，TLB 实际存储的是虚拟页号 <code>VPN</code> 到物理页帧号 <code>PFN</code> 的转换。如果 TLB 命中，就直接根据 <code>PFN&lt;&lt;10 | Offset</code> 得到物理地址了。如果没有命中，就要获取正确的 <code>PFN</code> 并更新 TLB 条目以便未来的访问同一物理页时降低开销。</p>
<p>那么首先去页目录基地址寄存器中获取页目录的地址 <code>PD_Addr</code>，这是个物理地址，可以直接访问，然后根据 <code>PD_Addr + 4*PD_Index</code> （一个条目为 4 字节）获得相应页目录项条目。这一条目中存放的是相应页表的地址 <code>PT_Addr</code>，还有一些状态位（如果该页表中没有任何一个页面分配，那么有效位就是 0，反之为 1）。</p>
<p>这里假设页目录项有效，那么我们得到了页表，用同样的方法，我们访问地址 <code>PT_Addr + 4*PT_Index</code> 可以得到 <code>PFN</code>，假设页表项仍然有效，那就赶紧更新 TLB 然后重新访问一遍。</p>
<p>由于上次的插入，这次必定能获得物理地址，那么就可以愉快地访存了。</p>
<p>如果页目录项/页表项无效，说明我们要访问的物理页帧并没有存放我们想要的数据（页表也占据了一整个物理页帧），那么此时此刻就要去磁盘上获取数据，然后根据一定的置换规则（如 LRU）进行换页。</p>
<h3 id="为什么要用多级页表？">为什么要用多级页表？</h3>
<p>32 位机器下，如果一个页面为 4KB 并且采用单级页表，那就要整整 4MB 的连续空间，而且不一定这 2^20 个页面都得到分配，会有很大一部分页表项是浪费的。</p>
<p>二级页表就不会有这种情况。假设前 10 位为页目录索引，中间 10 位为页表索引，如果某个页表所指向的 2^10 个页面都没得到分配，那么就不会为这个页表分配物理页帧，页目录中会将该页表的有效位设为 0。这样就大大节省了空间，还防止了无法分配过大连续内存的问题。</p>
<h3 id="用户态和内核态的区别？怎么切换？为什么要区分这两个级别？">用户态和内核态的区别？怎么切换？为什么要区分这两个级别？</h3>
<p>用户态和内核态是操作系统的两种运行级别，两者最大的区别就是特权级不同。用户态拥有最低的特权级，内核态拥有最高的特权级。运行在用户态的程序不能直接访问内核，例如不能使用系统调用。Due to the complexity of developing and maintaining the kernel, only the most essential and performance-critical code are placed in the kernel. Other things, such as GUI, management and control code, typically are programmed as user-space applications. This practice of splitting the implementation of certain features between kernel and user space is quite common in Linux.（引用自 <a href="https://www.linuxjournal.com/article/7356">Linux Journal</a>）</p>
<p>处于用户态的进程可以通过 1.请求系统调用 2.硬件中断 3.软件异常 等方式陷入内核态，然后再利用 ret 指令返回用户态。</p>
<p>如果只有用户态，那就完全没法利用操作系统的内核功能；如果只有内核态，那所有进程都可以访问内核数据，甚至修改内核，不安全。</p>
<h3 id="进程有几个栈？">进程有几个栈？</h3>
<p>两个。用户态一个，内核态一个。两个栈的数据不互通，也是为了安全性考虑。</p>
<h3 id="执行系统调用的过程？">执行系统调用的过程？</h3>
<ol>
<li class="lvl-3">
<p>将系统调用号放到寄存器 EAX 中，执行 <code>int 0x80</code> 指令发出中断；</p>
</li>
<li class="lvl-3">
<p>CPU 收到中断后，根据中断号 <code>0x80</code> 到中断向量表中查找对应中断描述符，其中包含中断服务程序 <code>system_call</code> 的代码段选择子；</p>
</li>
<li class="lvl-3">
<p>根据该段选择子去全局描述符表 GDT 里取得段描述符，段描述符 <code>SD</code> 里保存了中断服务程序的段基址和属性信息，此时 CPU 就得到了中断服务程序的起始地址。这里，CPU 会检查 CS.CPL 和 SD.DPL，以确保中断服务程序的特权级是高于当前用户程序的，或者说当前程序有权限使用中断服务程序，这可以避免用户应用程序访问特殊的中断门；</p>
</li>
<li class="lvl-3">
<p>在执行 <code>system_call</code> 前，CPU 会先从当前进程的 TSS 字段里取得内核栈地址，然后保存用户进程现场（CS、IP、SS、ESP 等信息），并将新的内核栈信息赋给 SS 和 ESP；</p>
</li>
<li class="lvl-3">
<p>开始执行 <code>system_call</code>，根据 EAX 寄存器存储的系统调用号，从系统调用表上找到相应的系统调用并调用；</p>
</li>
<li class="lvl-3">
<p>执行 <code>itret</code> 指令返回用户态，取出内核栈中保存的用户进程信息，重新赋值给相关寄存器，至此系统调用完成；</p>
</li>
</ol>
<h3 id="堆和栈的区别？">堆和栈的区别？</h3>
<p>堆和栈是内存模型中的两片不同区域。</p>
<p>堆存放程序员动态分配的数据，同时需要程序员手动释放，由低向高增长，空间较大。</p>
<p>栈存放一般函数局部变量，一个函数调用对应一个栈帧，由操作系统自动管理栈空间的分配与释放，由高向低增长，空间较小，需要预防栈溢出的异常。</p>
<h3 id="调用-malloc-分配一个-100B-大小的空间，内存会发生怎样的变化？">调用 malloc 分配一个 100B 大小的空间，内存会发生怎样的变化？</h3>
<p>事实上内存并不会发生变化。</p>
<p>如果只调用了 <code>malloc()</code>，那么只会在该进程的虚拟地址空间中划分出 100B，新增一个页表项，设置 flag=0，表明未分配物理地址。</p>
<p>等到实际访问这个虚拟地址时，会发现对应的物理地址并不存在，触发缺页中断，这个时候才会在堆上进行实际的内存分配(brk)，并再次修改那个页表项。后续的访问就能正常进行。</p>
<h3 id="mmap-的流程？和-read-的区别？是零拷贝吗？">mmap 的流程？和 read 的区别？是零拷贝吗？</h3>
<p>调用 <code>mmap()</code> 时，首先分配一片相应大小的虚拟地址，并在页表中添加相应页表项。</p>
<p>当第一次访问该虚拟地址时，产生缺页中断，陷入内核，根据 <code>inode</code> 号将相应文件中的某一段通过 I/O 读入内核的 <strong>Page Cache</strong> 中（虽然叫 cache 但其实是在内存里的），然后通过修改用户态进程中页表的方式赋予用户态进程读写这段内存的权利。</p>
<p>回到用户态后，此时进程就可以通过该页表项直接对文件内容进行读写了（如果是脏写还需要将 Page Cache 的内容刷回磁盘），而无需进行额外的内核态与用户态的数据拷贝操作，所以<strong>是</strong>零拷贝。</p>
<p><code>read()</code> 则在 I/O 到内核缓冲区后还要拷贝到用户空间，写回时亦然。相比而言 <code>mmap()</code> 省去了不必要的拷贝操作，效率更高。</p>
<h3 id="僵尸进程、孤儿进程分别指什么？如何处理？">僵尸进程、孤儿进程分别指什么？如何处理？</h3>
<p>进程终止执行时，进程表中还会保留一段时间其进程控制块(PCB)，直至父进程执行 <code>wait()</code> 或 <code>waitpid()</code> 系统调用，这会<strong>阻塞</strong>父进程直至子进程结束，其间操作系统会释放子进程的 PCB。这是正常的父子进程管理流程。</p>
<p>如果子进程比父进程先结束，父进程又没有执行 <code>wait()</code>/<code>waitpid()</code> 时，子进程的 PCB 将滞留在进程表中，无法得到释放，直至父进程结束。这就成了「<strong>僵尸进程</strong>」。</p>
<p>而当父进程比子进程先结束时（意味着并没有执行 <code>wait()</code>/<code>waitpid()</code>），此时子进程会成为「<strong>孤儿进程</strong>」，并由 init 进程(pid=1)收养，管理子进程的结束行为。</p>
<p>相比于僵尸进程，孤儿进程的 PCB 由于被 init 进程接管，能够及时释放 PCB，所以无伤大雅。</p>
<p>但僵尸进程则不同了，出现大量僵尸进程会占用系统资源，虽然 init 进程会定期检查并清理僵尸进程，释放它们占用的系统资源，但这是不可控的。系统所能使用的进程号是有限的，如果大量的产生僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。</p>
<blockquote>
<p>这是真实可能发生的，它有一定的概率，特别当存在一个编码糟糕的程序开始大量产生僵尸进程的时候。</p>
</blockquote>
<p>更严重的是，我们还<strong>不能</strong>通过 <code>kill</code> 来杀死僵尸进程——进程都结束了，还怎么处理信号呢？</p>
<p>对于父进程已结束的僵尸进程，可以直接执行 <code>kill -9</code> 杀死父进程，这样所有的僵尸进程就会变成孤儿进程了，被 init 收养、清理。</p>
<p>上面是亡羊补牢式的解决方案，正确的策略是尽可能在代码层面预防这种现象。事实上，当子进程终止时，内核就会向它的父进程发送一个 <code>SIGCHLD</code> 信号，而对于这种信号的系统默认动作是忽略它，但我们可以修改父进程的信号处理函数，让父进程中收 SIGCHLD 信号后调用 <code>wait()</code>/<code>waitpid()</code>，比如下面这样:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>预防僵尸进程</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;errno.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;signal.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;sys/wait.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">deal_child</span><span class="token punctuation">(</span><span class="token keyword">int</span> sig_no<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  pid_t id<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>id <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">waitpid</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> WNOHANG<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// WNOHANG 表示非阻塞</span>
    <span class="token comment">// 这里意思是以非阻塞形式等待任意一个子进程</span>
    <span class="token comment">// 而 SIGCHLD 是不可靠信号，即信号不会排队等待</span>
    <span class="token comment">// 也就是说，如果父进程收到了一个 SIGCHLD</span>
    <span class="token comment">// 信号，那么表明至少有一个子进程已终止或已停止</span>
    <span class="token comment">// 因此，在每次处理信号时都应该尽可能多地回收子进程，所以这里用了 while 循环</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">signal</span><span class="token punctuation">(</span>SIGCHLD<span class="token punctuation">,</span> deal_child<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 设置对 SIGCHLD 信号的处理函数为 deal_child</span>

  pid_t pid<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"fork error, %s\n"</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>errno<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token comment">/* child */</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* parent */</span>
  <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="计算机网络">计算机网络</h2>
<h3 id="如何判断一台机器是大端序还是小端序？">如何判断一台机器是大端序还是小端序？</h3>
<p>简单的代码示例</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>判断是否为小端序</span></div><code class="language-cpp"><span class="token keyword">bool</span> <span class="token function">isSmallEndian</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0x1234</span><span class="token punctuation">;</span>
  <span class="token keyword">char</span><span class="token operator">*</span> c <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>num<span class="token punctuation">;</span>
  <span class="token keyword">return</span> c<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0x34</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>如果内存中第一个字节是 0x12 则说明是大端序</p>
</blockquote>
<h3 id="说一下五层网络模型，并且指出-TCP-处于哪一层？">说一下五层网络模型，并且指出 TCP 处于哪一层？</h3>
<p>应用层，传输层，网络层，数据链路层，物理层。TCP 位于传输层。</p>
<h3 id="TCP-和-UDP-的区别？">TCP 和 UDP 的区别？</h3>
<p><strong>TCP</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>为了满足可靠传输，数据传输前要用三次握手建立连接，数据传输过程中提供拥塞控制，用滑动窗口控制有序性（序列号和确认号），牺牲了效率；</p>
</li>
<li class="lvl-2">
<p>首部存在各种控制字段；</p>
</li>
<li class="lvl-2">
<p>如果 payload 长度过大，TCP 会进行分片；</p>
</li>
<li class="lvl-2">
<p>面向字节流，不关心 payload 的内容，是直接从缓冲区中取出字节加上首部组成报文段后发送，接收方可能无法区分消息边界，导致<strong>粘包问题</strong>；</p>
</li>
</ul>
<p><strong>UDP</strong></p>
<ul class="lvl-0">
<li class="lvl-2">
<p>无需连接，不计后果地发送，即便丢包也无所谓，虽然不可靠，但效率很高，一般用于视频、DNS 查询等；</p>
</li>
<li class="lvl-2">
<p>首部仅仅包含四个字段——{源端口，目标端口，长度，校验和}；</p>
</li>
<li class="lvl-2">
<p>一个 UDP 对应一个用户消息，即便乱序到达，接收方也可以区分消息边界；</p>
</li>
</ul>
<h3 id="为什么视频可以用-UDP？">为什么视频可以用 UDP？</h3>
<p>因为即使丢包也可以用<strong>插值算法补帧</strong>，允许这种不可靠，同时更要追求视频的实时性。</p>
<h3 id="点击-url-到显示网页之间发生了什么？">点击 url 到显示网页之间发生了什么？</h3>
<blockquote>
<p>具体可参考 <a href="../../computer-network/whathappenedafterclickurl">点击 Url 到显示网页之间发生了什么？</a></p>
</blockquote>
<h3 id="TCP-和-UDP-都是怎么处理数据量较大的包的（如-5KB）？">TCP 和 UDP 都是怎么处理数据量较大的包的（如 5KB）？</h3>
<p>因为以太网 MTU=1500MB 的缘故，IP 层会将过大的包进行分片，处理方式为在头部设置<strong>标识位</strong>与<strong>片偏移</strong>。TCP 和 UDP 都不负责分片工作，而是将其交付给下一层去做。</p>
<p>特别的，IP 首部的长度字段为 16 位，意味着同一个分片组最大可以容纳 64KB 的 TCP/UDP 数据，那对 TCP/UDP 而言 5KB 简直是小意思，不会分片。而如果超过 64 KB，那就要分成多个 TCP/UDP 包发送了。</p>
<h3 id="如果应用层基于-TCP-发送了两个分别为-100B-和-200B-大小的数据包，接收方可能的情况有哪些？换成-UDP-呢？">如果应用层基于 TCP 发送了两个分别为 100B 和 200B 大小的数据包，接收方可能的情况有哪些？换成 UDP 呢？</h3>
<p>理想情况下，接收方会先收到 100B 的包（记为 <strong>「包1」</strong>），再收到 200B 的包（记为 <strong>「包2」</strong>）。</p>
<p>非理想情况下:</p>
<ol>
<li class="lvl-3">
<p>数据包可能是乱序到达的，硬件层面可能会先收到「包2」，一层层往上交付后，TCP 模块会发现这个包的序列号与期望值不匹配，将其数据缓存，等到后续收到后「包1」，解包后再和之前缓存的「包2」数据一并交给上层；</p>
</li>
<li class="lvl-3">
<p>由于 TCP 基于字节流，在传输层无法确认消息边界，总是在字节流冲满 buffer 后再被上层一次性取走，所以上层拿到的数据并不一定是完整的「包1」或者「包2」，这就是出现了粘包；</p>
</li>
</ol>
<p>如果使用 UDP:</p>
<ol>
<li class="lvl-3">
<p>对于乱序到达的情况，则先到的「包2」会直接被交付，而不用等「包1」有没有到，因为 UDP 本身是不提供可靠传输的，不用保证数据的有序性；</p>
</li>
<li class="lvl-3">
<p>对于粘包情况，UDP Header 指明了数据长度，一个 UDP 包就是一个用户消息，所以即便「包1」和「包2」同时到达，UDP 也能正确分清数据的边界，不会产生粘包现象；</p>
</li>
</ol>
<h3 id="select-poll-epoll-的区别">select/poll/epoll 的区别</h3>
<blockquote>
<p>具体可参考 <a href="https://www.xiaolincoding.com/os/8_network_system/selete_poll_epoll.html#_9-2-i-o-%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8-select-poll-epoll">这篇文章</a>。</p>
</blockquote>
<h3 id="网络层如何转发数据包？路由器是如何进行自学习的？">网络层如何转发数据包？路由器是如何进行自学习的？</h3>
<p>交换机根据源 MAC 地址建立转发表，根据目的 MAC 地址转发，如果目的 MAC 地址不在，就发一个 ARP 广播请求来获取。</p>
<p>路由器根据目的 IP 地址进行将数据包由特定端口发出。对于静态路由而言，转发表需管理员手动配置；而动态路由则会根据路由协议（如 RIP）定时与其他路由器交换路由信息，从而建立转发表。</p>
<h3 id="HTTP-和-HTTPS-的区别">HTTP 和 HTTPS 的区别</h3>
<ol>
<li class="lvl-3">
<p>HTTP 协议的数据传输是<strong>明文</strong>的，是不安全的；HTTPS 是 HTTP 协议的安全版本，使用了 SSL/TLS 协议进行了加密处理，相对更安全；</p>
</li>
<li class="lvl-3">
<p>HTTP 和 HTTPS 使用连接方式不同，默认端口也不一样，HTTP是 80，HTTPS是 443；</p>
</li>
<li class="lvl-3">
<p>HTTPS 由于需要设计加密以及多次握手，性能方面不如 HTTP；</p>
<blockquote>
<p>这里指的是在三次握手之后，使用 HTTPS 协议的双方需要用四次(TLS v1.2)/两次(TLS v1.3)握手进行密钥的交换，后续所有消息都通过密钥加密传输。</p>
</blockquote>
</li>
</ol>
<h3 id="为什么要使用三次握手？">为什么要使用三次握手？</h3>
<blockquote>
<p>具体可参考 <a href="../../computer-network/tcpthings/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%8F%A1%E6%89%8B%E6%98%AF%E4%B8%89%E6%AC%A1%E8%80%8C%E4%B8%8D%E6%98%AF%E4%B8%A4%E6%AC%A1%E5%9B%9B%E6%AC%A1">TCP Things</a>，其实还有一些其他的作用。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>确认双方初始序列号，以确保后续接收到的报文段位于同一个连接中；</p>
</li>
<li class="lvl-3">
<p>使发送方确认拥塞窗口，控制发送速率；</p>
</li>
</ol>
<h3 id="为什么-TIMEWAIT-要等-2MSL">为什么 TIMEWAIT 要等 2MSL</h3>
<blockquote>
<p>具体可参考 <a href="../../computer-network/tcpthings/#%E4%B8%BA%E4%BB%80%E4%B9%88-time-wait-%E8%A6%81%E7%AD%89-2msl">TCP Things</a>。</p>
</blockquote>
<h2 id="数据库系统">数据库系统</h2>
<h3 id="说下-ACID-分别代表什么意思？">说下 ACID 分别代表什么意思？</h3>
<p>A: Atomic 原子性</p>
<p>C: Consistency 一致性</p>
<p>I: Isolation 隔离性</p>
<p>D: Durability 持久性</p>
<h3 id="事务隔离级别分别有哪些？分别解决了什么问题？">事务隔离级别分别有哪些？分别解决了什么问题？</h3>
<p><strong>读未提交</strong>: 这种隔离级别不加任何锁，有可能读事务 reader 读取到了写事务 writer 写入数据库但未提交的数据。这就是<strong>脏读</strong>。</p>
<p><strong>读提交</strong>: 这种隔离级别上了写锁，但同一事务 reader 对同一个键的前后两次读取之间可能会因为穿插了另一事务 writer 的写入，从而读取到了不一样的数据。这就是<strong>不可重复读</strong>。</p>
<p><strong>可重复读</strong>: 这种隔离级别下，对某个键的读取开始后不再允许任何写入，因而不会出现不可重复读，前后两次读结果必定相同。但在某些场景比如 <code>select * from table; insert values {k1, v1} into table;</code> 中，两个语句之间由于另一事务也插入了 <code>{k1, v1}</code> 这一键值对，导致 <code>insert</code> 失败，原因是键冲突，但 <code>select</code> 时并没有看到这一条数据。这就是<strong>幻读</strong>。</p>
<p><strong>可序列化</strong>: 这种隔离级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</p>
<h3 id="B-树、B-树、红黑树的区别？为什么索引中使用-B-树？">B 树、B+ 树、红黑树的区别？为什么索引中使用 B+ 树？</h3>
<p><strong>B Tree</strong>: 内部节点存数据，从而可存储的用于索引子节点的指针数变少，整棵树趋于高瘦；查询效率不稳定（时快时慢），并且不支持范围查询。</p>
<p><strong>B+ Tree</strong>: 内部节点仅存索引指针，数据仅由叶子节点存放，整棵树趋于矮胖，能够减少 I/O 次数，有利于提高查找性能；查询效率稳定（都去叶子节点上查），并且支持范围查询（叶子节点之间之间相当于双向链表）。</p>
<p><strong>红黑树</strong>: 属于平衡二叉树，节点分红/黑两种，保证不存在任意两个红色节点相邻，并且根到叶的最长路径不超过最短路径的两倍，查找为 $O(\log N)$，增删都只需要常数次自旋。</p>
<p>索引用 B+ 树主要还是因为其能够大幅减少磁盘 I/O 次数，并且支持范围查询。</p>
<h3 id="除了-B-树，还有哪些用于索引的数据结构？">除了 B+ 树，还有哪些用于索引的数据结构？</h3>
<ol>
<li class="lvl-3">
<p><strong>Hash 索引</strong>：使用哈希函数将索引键映射到实际数据的存储位置。这种索引结构通常能够提供非常快速的数据查找，特别是对于等值查询（即精确匹配）而言。缺点是<strong>不</strong>支持范围查询，且存在潜在的<strong>哈希冲突</strong>；</p>
</li>
<li class="lvl-3">
<p><strong>LSM Tree</strong>：一种对磁盘写进行优化的结构。核心思想是「<strong>批量 &amp; 顺序</strong>」写而非单次随机写，具体可参考<a href="https://anyview.fun/2022/09/23/%E4%B8%80%E6%96%87%E4%BA%86%E8%A7%A3lsm-tree/">此文</a>。缺点是存在<strong>空间放大</strong>（不同 SSTable 存同一 Key 的副本）和<strong>读放大</strong>（需要在多层 SSTable 中查数据，可能产生更多开销）。</p>
</li>
<li class="lvl-3">
<p>…</p>
</li>
</ol>
<h3 id="时序数据库的特点是什么？和在关系型数据库中把-Timestamp-作为主键有什么区别？">时序数据库的特点是什么？和在关系型数据库中把 Timestamp 作为主键有什么区别？</h3>
<p>时序数据库(TSDB)的关键特点在于<strong>数据按时间顺序到达</strong>和<strong>时间戳为主键</strong>，专注于时间序列数据的存储和管理，支持按时间范围处理数据。由于数据更新频繁，TSDB 需要更高的性能，处理引擎必须是 Online 的，常用于实时监控与报警场景。可以认为时序数据库是为特定 Workload 做出的定向优化。</p>
<p>而普通的关系型数据库则更偏向对数据进行离线分析，无法满足 TSDB 的使用场景。</p>
<h2 id="分布式系统">分布式系统</h2>
<h3 id="简单介绍一下-Raft-算法的实现">简单介绍一下 Raft 算法的实现</h3>
<p>主要是基于「<strong>过半原则</strong>」的「<strong>选举</strong>」和「<strong>日志</strong>」两大模块。</p>
<p><strong>选举</strong>：每个节点有选举定时器，仅当收到 <code>Leader</code> 的 heartbeat/appendEntry 请求，或满足条件（当前 Term 没给其它成员投过票，且投票请求中包含的日志更新）的投票请求时重置。一旦超时，则增加 Term，成为 <code>Candidate</code> 并发起选举，向其他成员发送投票请求。如果超过半数成员（包括自己）同意投票，则当选 <code>Leader</code>，反之退为 <code>Follower</code>。</p>
<p><strong>日志</strong>：上层会给 <code>Leader</code> 推送请求，打包为日志后检查是否有其他成员需要发送日志（通过 next 变量），如果有就从 <code>Index=next[peer]</code> 处开始发送，其间会有冲突检查，一旦对方接收成功就更新 match 变量。当某一 Index 的日志被超过半数成员持有（通过 match 变量），则认为这条日志的状态是 <code>COMMITTED</code>，<code>Leader</code> 需要在与 <code>Follower</code> 的交互中告知有哪些日志是 <code>COMMITTED</code>。所有成员定期将所有 <code>COMMITTED</code> 的日志推给上层，然后将这些日志的状态改为 <code>APPLIED</code>。在这基础上还引入了 snapshot，用于内存优化。</p>
<h3 id="如何提高一个分布式系统的写性能">如何提高一个分布式系统的写性能</h3>
<blockquote>
<p>算是一个开放性问题，可以从多种角度去回答</p>
</blockquote>
<ol>
<li class="lvl-3">
<p><strong>分库分表</strong>。一个集群能够提供的写性能是有限的，一旦超过了某个阈值，那么后续的写请求必然被之前的写请求所阻塞。一个合理的做法是将整个 Key 集合划分为多个 Shard，一个 Shard 由一个集群负责，这样就将整个服务的负载分散到多个集群，有利于提高写性能；</p>
</li>
<li class="lvl-3">
<p><strong>非阻塞写</strong>。当集群收到写请求时，允许直接返回消息而非阻塞直至写操作 apply；</p>
</li>
<li class="lvl-3">
<p><strong>利用缓冲区</strong>。磁盘 I/O 也是一大性能瓶颈，可以在写入过程中使用 buffer，并且异步地将 buffer 中的数据落盘，减少对持久化存储的写入次数，可以减少对底层存储系统的压力，提高写入性能；</p>
</li>
<li class="lvl-3">
<p>…</p>
</li>
</ol>
<h2 id="游戏场景">游戏场景</h2>
<h3 id="玩家攻击，如何判断武器打到怪物？如果武器速度过快，前后两帧恰好在怪物两侧，如何处理这种异常？">玩家攻击，如何判断武器打到怪物？如果武器速度过快，前后两帧恰好在怪物两侧，如何处理这种异常？</h3>
<p>第一个问题是<a href="https://www.cnblogs.com/xiangshancuizhu/p/3679004.html"><strong>三维空间碰撞检测</strong></a>。</p>
<p>第二个问题涉及到<a href="https://zhuanlan.zhihu.com/p/380532960"><strong>连续碰撞检测</strong></a>。</p>
<h3 id="给定若干怪物的二维坐标-x-y-，如何确定离玩家最近的那个怪物？">给定若干怪物的二维坐标 (x, y)，如何确定离玩家最近的那个怪物？</h3>
<p>用到了<a href="https://songlinlife.github.io/2022/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%A0%91%E6%9F%A5%E8%AF%A2%E7%AE%97%E6%B3%95/"><strong>最近邻检索算法</strong></a>。</p>
<h3 id="给定若干怪物的二维坐标-x-y-，选择哪个坐标释放半径为-r-的圆形范围-aoe，使得攻击到的怪物最多？">给定若干怪物的二维坐标 (x, y)，选择哪个坐标释放半径为 r 的圆形范围 aoe，使得攻击到的怪物最多？</h3>
<p>是<a href="https://www.cnblogs.com/zExNocs/p/16995282.html"><strong>固定半径圆最大覆盖问题</strong></a>。</p>
<h3 id="如何实现一个高效的-Timer-Manager">如何实现一个高效的 Timer Manager</h3>
<p>参考<a href="https://cloud.tencent.com/developer/article/2356003"><strong>时间轮算法</strong></a></p>
<h3 id="现在要设计一个新手引导关，有若干新手引导点，如何对「某个玩家是否完成某个引导点」进行快速存取？要求尽可能精简内存，并可以认为「引导点」由一个整数-id-表示。">现在要设计一个新手引导关，有若干新手引导点，如何对「某个玩家是否完成某个引导点」进行快速存取？要求尽可能精简内存，并可以认为「引导点」由一个整数 id 表示。</h3>
<p>第一步是引导点 id 的设计。</p>
<p>一开始说认为新手引导是单线的，可以直接用一个从 0 开始递增的无符号数来表示，面试官提出可能有多条线，因为不同功能模块可能都需要设计引导。</p>
<p>然后说可以将 id 划分为高低位，高位表示模块类型，低位表示该模块的引导点序号，但是考虑到最后是用数组做的，可以在从 0 开始递增的基础上，为不同模块设置一个 BEGIN 和 END（比如战斗模块的 BEGIN 和 END 分别是 3 和 7，那么 id 3~7 就对应战斗模块的引导点 1~5）。</p>
<p>（这个方案被认可）接下去就可以用 <code>vector&lt;bool&gt;</code> 去支持判断是否完成了。</p>
<p>（进一步提出如果只有 30 个引导点，可以如何优化）用一个 uint32 变量 <code>FLAG</code> 即可，每个二进制位 <code>1/0</code> 来表示是否完成。那么存取就是位运算了，完成第 i 个引导点就是 <code>FLAG |= (1 &lt;&lt; i)</code>，查询是 <code>FLAG &amp;= (1 &lt;&lt; i)</code>。</p>
<p>（进一步提问如何统计完成了多少个引导点）这个问题其实就是统计二进制中 <code>1</code> 的个数，这个算法比较经典，可以看<a href="https://www.cnblogs.com/graphics/archive/2010/06/21/1752421.html">这篇</a>。</p>
<blockquote>
<p>但是后面要求不能用<strong>循环、迭代、递归、模板元编程、额外成员变量</strong>，就没回答上了。</p>
</blockquote>
<h2 id="UE">UE</h2>
<h3 id="AActor-APawn-ACharacter-三者的区别与联系？">AActor / APawn / ACharacter 三者的区别与联系？</h3>
<blockquote>
<p>类派生关系为 AActor -&gt; APawn -&gt; ACharacter</p>
</blockquote>
<p><strong>Actor</strong>：Actor 是可以放到关卡中的任何对象；</p>
<p><strong>Pawn</strong>：在 Actor 基础上集成了 Controller 类，允许玩家或 AI 进行控制；</p>
<p><strong>Character</strong>：Character 在 Pawn 的基础上引入了三大组件，<code>SkeletalMeshComponent</code>、<code>CharacterMovementComponent</code> 以及 <code>CapsuleComponent</code>，这些组件提供了角色实现<strong>基于骨骼的高级动画</strong>、<strong>移动基本逻辑功能</strong>以及<strong>移动碰撞检测</strong>的能力。</p>
<blockquote>
<p>那么，当对象逻辑简单、不需要过多的逻辑动作（比如方块、飞船）那么可以选择继承 Pawn 而不是继承 Character 类。</p>
</blockquote>
<h3 id="UCharacterMovementComponent-做了哪些事？">UCharacterMovementComponent 做了哪些事？</h3>
<p>先看官方注释：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * CharacterMovementComponent handles movement logic for the associated Character owner.
 * It supports various movement modes including: walking, falling, swimming, flying, custom.
 *
 * Movement is affected primarily by current Velocity and Acceleration. Acceleration is updated each frame
 * based on the input vector accumulated thus far (see UPawnMovementComponent::GetPendingInputVector()).
 *
 * Networking is fully implemented, with server-client correction and prediction included.
 */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="FName-FText-FString-的区别？">FName / FText / FString 的区别？</h3>
<p>见 <a href="../../unreal/uetext">UE 字符串处理</a></p>
<h3 id="USkeletalMesh-USkeletalMeshComponent-ASkeletalMeshActor-三者的区别与联系？">USkeletalMesh / USkeletalMeshComponent / ASkeletalMeshActor 三者的区别与联系？</h3>
<h3 id="UE-的垃圾回收机制？">UE 的垃圾回收机制？</h3>
<h2 id="Lua">Lua</h2>
<h3 id="Lua-如何实现面向对象？不用-metatable-呢？">Lua 如何实现面向对象？不用 metatable 呢？</h3>
<h3 id="Lua-的垃圾回收机制？为什么做后续优化？">Lua 的垃圾回收机制？为什么做后续优化？</h3>
<h3 id="Lua-虚拟栈是什么？">Lua 虚拟栈是什么？</h3>
<h3 id="Lua-和-C-之间如何互相调用？">Lua 和 C 之间如何互相调用？</h3>
]]></content>
      <categories>
        <category>Interview</category>
      </categories>
  </entry>
  <entry>
    <title>用 C++ 的方式学习 Lua</title>
    <url>/lua/learnluawithcpp/</url>
    <content><![CDATA[<p>花了一晚上浅学了一下 Lua 脚本语言。作为 C++ Coder，对我而言，学一门新语言的最容易接受的方式就是将它和 C++ 进行对比，看看能不能实现 C++ 相关特性，或者额外的 C++ 做不到的事，观摩了网上的资料以及骚扰 GPT 后，彻底顿悟，写下心得。</p>
<span id="more"></span>
<h2 id="基础概念">基础概念</h2>
<h3 id="Hello-World">Hello World</h3>
<p>作为一门「脚本语言」，它本身是<strong>解释性</strong>的，对应的解释器就是 <code>lua</code>。可以新建一个 <code>.lua</code> 文件，然后以 <code>lua &lt;filename&gt;.lua</code> 的方式运行。比如</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>HelloWorld.lua</span></div><code class="language-lua"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token comment">-- 控制台输出函数</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span> <span class="token comment">-- 这个也是</span>
<span class="token comment">--[[
  执行 lua HelloWorld.lua，能看到输出如下:
    Hello
    World

]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么就从上面这个例子开始，进入到对 Lua 的探索中。</p>
<h3 id="注释">注释</h3>
<p><code>--</code> 后跟单行注释，<code>--[[</code> 和 <code>]]</code> 之间允许跨行注释。</p>
<blockquote>
<p>对应 C++ 的 <code>//</code> 和 <code>/**/</code>。</p>
</blockquote>
<h3 id="变量作用域">变量作用域</h3>
<p>所有变量默认为「<strong>全局</strong>变量」，如果要声明一个仅在当前作用域下生效的局部变量，需要用 <code>local</code> 关键词进行修饰。并且在内部作用域声明的局部变量，访问优先级高于全局变量。</p>
<blockquote>
<p>不难发现 Lua 中「作用域」的概念和 C++ 是基本一致的。</p>
</blockquote>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>作用域</span></div><code class="language-lua">a <span class="token operator">=</span> <span class="token number">5</span>           <span class="token comment">-- 全局变量</span>
<span class="token keyword">local</span> b <span class="token operator">=</span> <span class="token number">5</span>     <span class="token comment">-- 局部变量</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">local</span> a <span class="token operator">=</span> <span class="token number">6</span> <span class="token comment">-- 该变量优先级高于 line 1 的 a</span>
    b <span class="token operator">=</span> <span class="token keyword">nil</span>     <span class="token comment">-- 上层作用域的局部变量亦能在本作用域中访问，将其设置为 nil 相当于删除该变量</span>
    c <span class="token operator">=</span> <span class="token number">5</span>       <span class="token comment">-- 全局变量</span>
    <span class="token keyword">local</span> d <span class="token operator">=</span> <span class="token number">6</span> <span class="token comment">-- 仅在 foo() 的作用域内生效</span>
    <span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token comment">--&gt; 6       nil</span>
<span class="token keyword">end</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>     <span class="token comment">--&gt; 5       nil</span>
<span class="token function">print</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> d<span class="token punctuation">)</span>     <span class="token comment">--&gt; 5       nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>根据最后一行执行结果，我们得出一个额外的结论：<strong>一个不在本作用域生效的变量的值为 nil</strong>。</p>
<p>同时还应该知道的是：应该尽可能使用局部变量，因为<strong>既能避免命名冲突，访问速度也比全局变量更快</strong>。</p>
<h3 id="基本数据类型">基本数据类型</h3>
<p>Lua 有 8 大基本类型：</p>
<table>
<thead>
<tr>
<th style="text-align:left">数据类型</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">nil</td>
<td style="text-align:left">本作用域内无效的变量均为该类型，打印结果也是 nil</td>
</tr>
<tr>
<td style="text-align:left">boolean</td>
<td style="text-align:left">只有 false 和 nil 算 <code>false</code>，其余都是 <code>true</code></td>
</tr>
<tr>
<td style="text-align:left">number</td>
<td style="text-align:left">双精度浮点数，允许隐式转为 string</td>
</tr>
<tr>
<td style="text-align:left">string</td>
<td style="text-align:left">字符串，用<strong>成对</strong>的单引号/双引号包裹，也可以用 <code>[[</code> 和 <code>]]</code> 包裹跨行字符串，允许隐式转为 number</td>
</tr>
<tr>
<td style="text-align:left">function</td>
<td style="text-align:left">Lua 或 C 的函数</td>
</tr>
<tr>
<td style="text-align:left">userdata</td>
<td style="text-align:left">C 中的数据结构</td>
</tr>
<tr>
<td style="text-align:left">thread</td>
<td style="text-align:left">线程</td>
</tr>
<tr>
<td style="text-align:left">table</td>
<td style="text-align:left">支持任意类型的 key-value 映射</td>
</tr>
</tbody>
</table>
<p>可以通过 <code>type()</code> 函数获取某个变量的类型，函数返回值为 <code>string</code> 类型。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>type</span></div><code class="language-lua">x <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>               <span class="token comment">-- 可以通过 {} 建表</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">nil</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token comment">--&gt; nil</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">--&gt; table</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; string</span>
x <span class="token operator">=</span> <span class="token number">1</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment">--&gt; number</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们又可以得出一个额外的结论：<strong>Lua 中的变量可以绑定到任意类型的值，并非像 C++ 那样一经声明就确定了变量名与类型的强绑定关系</strong>。</p>
<blockquote>
<p>Lua 最初是用 C 语言编写的，这使得 Lua 可以很容易地与 C 语言进行交互，所以一些数据类型也与 C 存在关系。</p>
</blockquote>
<h3 id="运算符">运算符</h3>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>算术运算符</span></div><code class="language-lua"><span class="token comment">--[[
  用 = 赋值，并支持多变量同时多赋值
  如果 #(变量) &lt; #(值)，则多出来的值被舍弃，比如下面第二行的 4
  如果 #(变量) &gt; #(值)，则多出来的变量被丢弃（不会被定义），比如下面第三行的 e
  支持第四行这样的 swap 行为
]]</span> 
a <span class="token operator">=</span> <span class="token number">1</span>
b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span>
d<span class="token punctuation">,</span> e <span class="token operator">=</span> <span class="token number">5</span>
b<span class="token punctuation">,</span> c <span class="token operator">=</span> c<span class="token punctuation">,</span> b
<span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token comment">--&gt; 1 3 2 5 nil</span>

<span class="token comment">--[[
  支持 + - * / 四则运算
  其中如果 + 的操作变量类型为 string，则会尝试将 string 转为 number
]]</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"123"</span> <span class="token operator">+</span> <span class="token number">456</span><span class="token punctuation">)</span>   <span class="token comment">--&gt; 579</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"123"</span> <span class="token operator">+</span> <span class="token string">'456'</span><span class="token punctuation">)</span> <span class="token comment">--&gt; 579</span>

<span class="token comment">--[[
  % 是取模，^ 是求幂（这个是和 C/C++ 不一样的）
]]</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">)</span>  <span class="token comment">--&gt; 3       4</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>比较运算符</span></div><code class="language-lua"><span class="token comment">--[[
  除了不等于(~=)和 C/C++ 不同之外，其余比较符都是一样的，就不多讲了
]]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>逻辑运算符 &amp; 其他</span></div><code class="language-lua"><span class="token comment">--[[
  Lua 中用 or（或）、and（与）、not（非）实现逻辑运算，对应 C/C++ 中的 ||、&amp;&amp;、!，就不多讲了
]]</span>

<span class="token comment">--[[
  支持 .. 进行 string 拼接操作，如果操作变量类型为 number，则会尝试将 number 转为 string
  支持 ## 取 string 的长度
]]</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token operator">#</span><span class="token punctuation">(</span><span class="token string">"Hello"</span> <span class="token operator">..</span> <span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; 10</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token number">114</span> <span class="token operator">..</span> <span class="token number">514</span><span class="token punctuation">)</span>            <span class="token comment">--&gt; 114514</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token number">19.19</span> <span class="token operator">..</span> <span class="token number">8.10</span><span class="token punctuation">)</span>         <span class="token comment">--&gt; 19.198.1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="循环控制语句">循环控制语句</h3>
<p>一共有 4 种循环控制语句</p>
<ol>
<li class="lvl-3">
<p><code>while</code>；</p>
</li>
<li class="lvl-3">
<p><code>for</code>；</p>
</li>
<li class="lvl-3">
<p><code>repeat until</code>；</p>
</li>
<li class="lvl-3">
<p>基于以上三种的嵌套循环；</p>
</li>
</ol>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>循环</span></div><code class="language-lua"><span class="token comment">-- while 循环。如果 condition 为 true，则一直运行 statement。</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token comment">-- statement</span>
<span class="token keyword">end</span>

<span class="token comment">-- for 循环分 数值循环 和 泛型循环 两种。</span>
<span class="token comment">--[[
  数值循环语法如下：

  for var = val1, val2 [, val3=1] do
      statement
  end

  其中 var 会在区间 [val1, val2] 内以步长 val3（默认为 1）迭代
  等价于 for (auto var = val1; var &lt;= val2; var += val3) {}
]]</span> 
<span class="token keyword">for</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">--&gt; 0 2 4 6 8 10（这里的空格应该是换行）</span>
<span class="token keyword">end</span>

<span class="token comment">--[[
  泛型循环语法如下：

  for var in iterator do
      statement
  end

  Lua 内置的迭代器方法有 pair() 和 ipair() 两种，都需要配合 table 进行使用
  前者是返回 table 中所有的 key-value 对，后者则限制 key 为从 1 开始递增的整型 number，直到不存在该 key
]]</span>
a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
a<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
a<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                      <span class="token comment">--&gt; 3       3</span>
<span class="token keyword">end</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
<span class="token keyword">end</span>

<span class="token comment">-- repeat until 循环。一直运行 statement 直到 condition 为 true。</span>
<span class="token keyword">repeat</span>
    <span class="token comment">-- statement</span>
<span class="token keyword">until</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的 for 迭代循环还会在后文提到，如何自定义迭代器。</p>
<h3 id="流程控制语句">流程控制语句</h3>
<p>其实就是 <code>if</code>、<code>elseif</code>、<code>else</code> 那一套，只不过语法上稍微有些区别，需要用 <code>then</code> 和 <code>end</code> 代替大括号。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>流程控制语句</span></div><code class="language-lua">a <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a &lt; 10"</span><span class="token punctuation">)</span>
<span class="token keyword">elseif</span> <span class="token punctuation">(</span>a <span class="token operator">&lt;</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token keyword">then</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"10 &lt;= a &lt; 50"</span><span class="token punctuation">)</span>
<span class="token keyword">else</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"a &gt;= 50"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="字符串-string-操作">字符串(string)操作</h3>
<p>之前说过可以用单双引号，或者中括号来包裹 string，也说到可以用 <code>..</code>、<code>#</code> 运算符操作 string，但这里的「string」指的都是类型。事实上 Lua 内置了一个名为 <code>string</code> 的对象（本质上是 table），并为其实现了许多成员函数，如下所示：</p>
<blockquote>
<p>⚠️<strong>注意字符串的位置默认从 1 开始</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">string.upper(str)</td>
<td style="text-align:left">将 str 转为大写。</td>
</tr>
<tr>
<td style="text-align:left">string.upper(str)</td>
<td style="text-align:left">将 str 转为小写。</td>
</tr>
<tr>
<td style="text-align:left">string.gsub(str, substr, replace, num)</td>
<td style="text-align:left">将 str 中前 num 个 substr 子串替换为 replace。</td>
</tr>
<tr>
<td style="text-align:left">string.find(str, pattern, init=1, plain=true)</td>
<td style="text-align:left">找到 str 从 init 开始第一次出现的 pattern，并返回其起始位置与结束位置。如果 plain 为 true 则禁用正则匹配。没找到就返回 nil。</td>
</tr>
<tr>
<td style="text-align:left">string.reserve(str)</td>
<td style="text-align:left">将 str 反转。</td>
</tr>
<tr>
<td style="text-align:left">string.char(…)</td>
<td style="text-align:left">可变参函数，输入若干 number，并将 number 转成对应的字符然后拼成字符串（如 97 98 -&gt; “ab”）。</td>
</tr>
<tr>
<td style="text-align:left">string.byte(str, i=1, j=i)</td>
<td style="text-align:left">返回 str[i:j] 的所有字符对应整数（如 ‘a’ -&gt; 97）。</td>
</tr>
<tr>
<td style="text-align:left">string.length(str)</td>
<td style="text-align:left">求长度，等价于 #str。</td>
</tr>
<tr>
<td style="text-align:left">string.rep(str, n)</td>
<td style="text-align:left">将 str 重复 n 次。</td>
</tr>
<tr>
<td style="text-align:left">string.match(str, pattern, init=1)</td>
<td style="text-align:left">找到 str 从 init 开始第一次出现的 pattern，并返回匹配到的结果串。支持正则匹配。匹配失败就返回 nil。</td>
</tr>
<tr>
<td style="text-align:left">string.gmatch(str, pattern)</td>
<td style="text-align:left"><strong>迭代器函数</strong>。不断对 str 进行 pattern 的匹配，并返回匹配到的结果串。支持正则匹配。直到返回 nil。</td>
</tr>
</tbody>
</table>
<h3 id="数组">数组</h3>
<p>Lua 的数组依托 table 实现，对下标 i 的访问实际上就是访问 table 中 <code>key=i</code> 的那一项。不再赘述。</p>
<h3 id="函数-function">函数(function)</h3>
<p>Lua 的函数定义本质上是定义一个类型为 function 的变量，与变量相关的大部分性质也都适用。我们可以通过以下方式定义一个 function：</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>函数定义</span></div><code class="language-lua"><span class="token keyword">local</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"local"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"global"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">--&gt; local</span>
<span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">--&gt; global</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">type</span><span class="token punctuation">(</span>foo<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; function</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="多返回值">多返回值</h4>
<p>和 C/C++ 不同，Lua 的函数支持<strong>多返回值</strong>，当然也可以利用赋值的性质，用个数不等的变量去接收值。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>多返回值函数</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span>
<span class="token keyword">end</span>
a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       2       nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="参数包">参数包</h4>
<p>甚至支持参数包。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>参数包</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>base<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span>         <span class="token comment">-- 可以有固定参数，但是必须在参数包之前</span>
    <span class="token keyword">local</span> s <span class="token operator">=</span> base
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"get "</span> <span class="token operator">..</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token string">"#"</span><span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span> <span class="token operator">..</span> <span class="token string">" elements"</span><span class="token punctuation">)</span>
    <span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token keyword">in</span> <span class="token function">ipairs</span> <span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token punctuation">}</span> <span class="token keyword">do</span> <span class="token comment">-- {...}表示一个用参数包构成的数组</span>
        s <span class="token operator">=</span> s <span class="token operator">+</span> v
    <span class="token keyword">end</span>
    <span class="token keyword">return</span> s
<span class="token keyword">end</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">select</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 相当于调用 add(0, 3, 4, 5)</span>
                                        <span class="token comment">--&gt; 12</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面我们用了一个叫 <code>select</code> 的函数，这个函数实际上也支持可变参数，它有以下两种用法：</p>
<ol>
<li class="lvl-3">
<p><code>select("#", ...)</code>: 获取参数包的参数个数；</p>
</li>
<li class="lvl-3">
<p><code>select(i, ...)</code>: 返回参数包从第 i 个元素开始到最后一个元素的切片；</p>
</li>
</ol>
<p>事实上，当我们以参数包的形式传参时，函数内部会为我们隐式添加一个局部 table 变量 <code>arg = {...}</code>，将参数包内的所有参数都加入该 table 中，这样我们就能以数组的形式访问参数包了。同时 <code>arg</code> 还有一个名为 <code>n</code> 的 key，表示参数包的参数个数，比如下面这样。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>arg.lua</span></div><code class="language-lua"><span class="token comment">--[[
    假设以 lua arg.lua 1 2 3 的方式去执行
]]</span>
<span class="token keyword">function</span> <span class="token function">aa</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>n<span class="token punctuation">,</span> arg<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">function</span> <span class="token function">bb</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>n<span class="token punctuation">,</span> arg<span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">function</span> <span class="token function">cc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>n<span class="token punctuation">,</span> arg<span class="token punctuation">,</span> arg<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token function">aa</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>                      <span class="token comment">--&gt; nil     table: 0x6c9e50</span>
<span class="token function">cc</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span>                      <span class="token comment">--&gt; 1       table: 0x6cae50        6</span>
<span class="token function">bb</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">)</span>                      <span class="token comment">--&gt; nil     table: 0x6c9e50</span>
<span class="token function">cc</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>                         <span class="token comment">--&gt; 0       table: 0x6ca420        nil</span>
<span class="token function">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">.</span>n<span class="token punctuation">,</span> arg<span class="token punctuation">)</span>                <span class="token comment">--&gt; nil     table: 0x6c9e50</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>            <span class="token comment">--&gt; 1       1</span>
                                 <span class="token comment">--&gt; 2       2</span>
                                 <span class="token comment">--&gt; 3       3</span>
                                 <span class="token comment">--&gt; -1      lua</span>
                                 <span class="token comment">--&gt; 0       arg.lua</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这就为我们提供了两种访问参数包的方法。</p>
<p>同时不难发现其实也有一个全局 table 变量 <code>arg</code>，当一个函数未使用参数包时，就不会生成 <code>local arg</code>，所以引用的是全局的 <code>arg</code>。全局 <code>arg</code> 不具有成员 <code>n</code>，但是具有执行该脚本时通过命令行传递给脚本的所有参数。</p>
<p>其中 <code>-1</code> 和 <code>0</code> 分别是 <code>lua</code> 和文件名，之后的就是用户自定义传入的参数了。</p>
<h4 id="实现具有默认值的函数参数">实现具有默认值的函数参数</h4>
<p>Lua 也可以利用一些基本性质实现 C++ 中的具有<strong>默认值</strong>的函数参数，当然这些参数必须在参数列表的最右侧。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>支持默认值的函数参数</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">)</span>
    b <span class="token operator">=</span> b <span class="token keyword">or</span> <span class="token number">2</span> <span class="token comment">-- 如果不传入第二个参数，则 b 就会被视为 nil，通过这个语句可以令其具有默认值 2</span>
    c <span class="token operator">=</span> c <span class="token keyword">or</span> <span class="token number">3</span> <span class="token comment">-- 同理</span>
    <span class="token keyword">return</span> a <span class="token operator">+</span> b <span class="token operator">+</span> c
<span class="token keyword">end</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>         <span class="token comment">-- 会报错，因为入参 a 相当于 nil，而 nil 不支持参与四则运算</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token comment">--&gt; 6</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">114</span><span class="token punctuation">,</span> <span class="token number">514</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; 631</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="表-table">表(table)</h3>
<p>Lua 中的 table 可以说是应用扩展性最高的类型了，因为其支持任意类型的 key 和 value，就可以玩出很多花样来。</p>
<p>先说说最基础的用法。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>table 构造 &amp; 访问 &amp; 新增</span></div><code class="language-lua">key0 <span class="token operator">=</span> <span class="token number">0</span>
tab <span class="token operator">=</span> <span class="token punctuation">{</span>key1 <span class="token operator">=</span> <span class="token string">"value1"</span><span class="token punctuation">,</span> key2 <span class="token operator">=</span> <span class="token string">"value2"</span><span class="token punctuation">,</span> key3 <span class="token operator">=</span> <span class="token string">"value3"</span><span class="token punctuation">,</span> <span class="token string">"value4"</span><span class="token punctuation">}</span>
tab<span class="token punctuation">[</span>key0<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"value0"</span>

<span class="token function">print</span><span class="token punctuation">(</span>tab<span class="token punctuation">.</span>key0<span class="token punctuation">,</span> tab<span class="token punctuation">.</span>key1<span class="token punctuation">,</span> tab<span class="token punctuation">[</span>key2<span class="token punctuation">]</span><span class="token punctuation">,</span> tab<span class="token punctuation">[</span><span class="token string">"key3"</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">--&gt; nil value1 nil value2</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token function">type</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token function">type</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; 1       number  value4  string</span>
                                              <span class="token comment">--&gt; key1    string  value1  string</span>
                                              <span class="token comment">--&gt; key3    string  value3  string</span>
                                              <span class="token comment">--&gt; 0       number  value0  string</span>
                                              <span class="token comment">--&gt; key2    string  value2  string</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>简要分析一下: 首先我们通过 <code>{k = v, ...}</code> 的方式构造了一个 table，并且通过 <code>table[]</code> 往里加入新元素，后续的访问既可以通过 <code>.</code> 的方式，也可以通过 <code>[]</code> 的方式。但是根据输出结果来看，我们能得出以下结论：</p>
<ol>
<li class="lvl-3">
<p>若以 <code>[k] = v</code> 方式添加元素，则会保留 k 的源类型；</p>
</li>
<li class="lvl-3">
<p>若以 <code>{k = v, ...}</code> 方式构造 table，则 k 会视为 string 类型，比如上面 key1 = “value1” 实际上是生成了一个 “key1” -&gt; “value1” 的映射关系；</p>
</li>
<li class="lvl-3">
<p>若上面这种方式不指定 k，则会默认 k 为从 1 开始自增的 number；</p>
<blockquote>
<p>通过这种方式可以进行<strong>数组</strong>的构造，即 <code>nums = {1, 2, 3, 4, 5}</code>。注意下标默认从 1 开始。但 Lua 中事实上是没有「数组」的，是通过 table 模拟的。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>若以 <code>[k]</code> 方式访问，则基于 k 的源类型，比如上面 <code>tab[key2]</code> 中，<code>key2</code> 变量不生效，为 nil，所以返回一个 nil</p>
</li>
<li class="lvl-3">
<p>若以 <code>.</code> 方式访问，则 k 会视为 string 类型，比如上面 <code>tab.key0</code> 实际上等价于 <code>tab["key0"]</code>，同理 <code>tab.key1</code> 等价于 <code>tab["key1"]</code>，这也就是为什么前者输出 nil 而后者输出 value1 的原因了；</p>
</li>
</ol>
<h3 id="元表-metatable">元表(metatable)</h3>
<p>所谓 metatable 本质上其实就是一个普通的 table，并不是什么特殊的数据类型，只不过表现为 table 中某个<strong>特殊</strong>的 key 对应的 value，为 table 提供若干功能。目前只能通过以下两种方式设置元表。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>设置元表</span></div><code class="language-lua">metatable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

tab1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token function">setmetatable</span><span class="token punctuation">(</span>tab1<span class="token punctuation">,</span> metatable<span class="token punctuation">)</span>      <span class="token comment">-- 第一种方式</span>

tab2 <span class="token operator">=</span> <span class="token function">setmetatable</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> metatable<span class="token punctuation">)</span> <span class="token comment">-- 第二种方式</span>

<span class="token function">getmetatable</span><span class="token punctuation">(</span>tab1<span class="token punctuation">)</span>                 <span class="token comment">-- 获取 metatable 的方式</span>

<span class="token comment">-- 其实就是为传入的第一个参数设置 metatable 为第二个参数，然后将其返回。</span>
<span class="token comment">-- 设置的元表并不会通过 key value 公开给用户，比如下面的脚本就啥也不输出。</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab1<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面说了 metatable 可以为 table 提供若干功能，具体有以下功能：</p>
<h4 id="index">__index</h4>
<blockquote>
<p><code>__index</code> 提供了访问表中不存在 key 的处理逻辑。</p>
</blockquote>
<p>当通过 <code>table[key]</code> 访问且 key 在 table 中不存在时，如果设置了 metatable，则会用 metatable 的 <code>__index</code> 进行查找。反之返回 nil。</p>
<p><code>__index</code> 可以是 function，也可以是 table。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当 <code>__index</code> 是 function 时，相当于调用 <code>metatable.__index(table, key)</code>；</p>
</li>
<li class="lvl-2">
<p>当 <code>__index</code> 是 table 时，相当于调用 <code>metatable.__index[key]</code>；</p>
</li>
</ul>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>__index</span></div><code class="language-lua">tab1 <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __index <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token keyword">end</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
tab2 <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __index <span class="token operator">=</span> tab1
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>tab1<span class="token punctuation">,</span> tab2<span class="token punctuation">)</span>         <span class="token comment">--&gt; table: 0x189d6d0        table: 0x189d080</span>
<span class="token function">print</span><span class="token punctuation">(</span>tab1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tab2<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">--&gt; table: 0x189d6d0        0</span>
                          <span class="token comment">--&gt; table: 0x189d6d0        1</span>
                          <span class="token comment">--&gt; 1       1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的示例中，因为 <code>tab1</code> 不存在 key <code>0</code>，所以访问 <code>tab1[0]</code> 相当于调用了 <code>metatable.__index(tab1, 0)</code>，将其打印后并返回 1。</p>
<p>同时，因为 <code>tab2</code> 不存在 key <code>1</code>，所以访问 <code>tab2[1]</code> 相当于调用了 <code>metatable.__index[1]</code> 即 <code>tab1[1]</code>，所以传入的第一个参数是 <code>tab1</code> 而非 <code>tab2</code>。</p>
<blockquote>
<p>因为 Lua 函数调用的特性，如果我们用不到 table 和 key 这两个参数，也可以不设置形参，这样传入的实参就会被舍弃。同理，也可以设置参数列表为 (table, key1, key2, …, keyn)，只不过从 key2 开始后面的都会是 nil 了。</p>
</blockquote>
<h4 id="newindex">__newindex</h4>
<blockquote>
<p><code>__newindex</code> 提供了添加表中不存在 key 的处理逻辑。</p>
</blockquote>
<p>当通过 <code>table[key] = value</code> 或 <code>table.key = value</code> 赋值且 key 在 table 中不存在时，如果设置了 metatable，则会用 metatable 的 <code>__newindex</code> 进行操作。反之进行正常的添加。</p>
<p>同样，<code>__newindex</code> 可以是 function，也可以是 table。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>当 <code>__newindex</code> 是 function 时，相当于调用 <code>metatable.__newindex(table, key, value)</code>；</p>
</li>
<li class="lvl-2">
<p>当 <code>__newindex</code> 是 table 时，相当于调用 <code>metatable.__newindex[key] = value</code>；</p>
</li>
</ul>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>__newindex</span></div><code class="language-lua">tab1 <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __newindex <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
            <span class="token function">print</span><span class="token punctuation">(</span>table<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
            <span class="token keyword">return</span> <span class="token number">1</span>
        <span class="token keyword">end</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
tab2 <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __newindex <span class="token operator">=</span> tab1
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>tab1<span class="token punctuation">,</span> tab2<span class="token punctuation">)</span>       <span class="token comment">--&gt; table: 0x20ec130        table: 0x20ec200</span>
tab1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>
tab2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token function">print</span><span class="token punctuation">(</span>tab1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> tab2<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">--&gt; table: 0x20ec130        0       1</span>
                        <span class="token comment">--&gt; table: 0x20ec130        0       2</span>
                        <span class="token comment">--&gt; nil     nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>道理和 <code>__index</code> 一样的，就不赘述了。</p>
<h4 id="call">__call</h4>
<blockquote>
<p><code>__call</code> 提供了 table 作为 function 进行函数调用的处理逻辑。</p>
</blockquote>
<p>当通过 <code>table(...)</code> 的形式执行类似于函数调用的操作时，如果设置了 metatable，则会用 metatable 的 <code>__call</code> 进行操作。反之报错。</p>
<blockquote>
<p>用 C++ 的话描述，其实就是重载了 <code>operator()</code>。</p>
</blockquote>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>__call</span></div><code class="language-lua">tab <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __call <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token punctuation">...</span><span class="token punctuation">)</span>
            <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
                self<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
            <span class="token keyword">end</span>
        <span class="token keyword">end</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token function">tab</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                      <span class="token comment">--&gt; 2       2</span>
                      <span class="token comment">--&gt; 3       3</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="tostring">__tostring</h4>
<blockquote>
<p><code>__tostring</code> 提供了被 print 调用时的处理逻辑。</p>
</blockquote>
<p>当通过 <code>print(table)</code> 的形式执行类似于函数调用的操作时，如果设置了 metatable，则会用 metatable 的 <code>__tostring</code> 尝试获取一个能被 <code>print()</code> 函数接受的类型的值。反之报错。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>__tostring</span></div><code class="language-lua">tab <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __tostring <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
            <span class="token keyword">local</span> sum <span class="token operator">=</span> <span class="token number">0</span>
            <span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span> <span class="token keyword">do</span>
                sum <span class="token operator">=</span> sum <span class="token operator">+</span> v
            <span class="token keyword">end</span>
            <span class="token keyword">return</span> <span class="token string">"表所有元素的和为 "</span> <span class="token operator">..</span> sum
        <span class="token keyword">end</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

<span class="token function">print</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token comment">--&gt; 表所有元素的和为 6</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="运算符-2">运算符</h4>
<p>我们可以通过 <code>__add</code>，<code>__sub</code> 这些字段重载 table 的运算符（就像 C++ 中那样！），比如下面这样：</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>__add</span></div><code class="language-lua">tab <span class="token operator">=</span>
    <span class="token function">setmetatable</span><span class="token punctuation">(</span>
    <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        __add <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span> <span class="token comment">-- 用 C++ 的话来说就是重载了 tab 的 operator+()</span>
            <span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token keyword">do</span>
                self<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
            <span class="token keyword">end</span>
            <span class="token keyword">return</span> self
        <span class="token keyword">end</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>

res <span class="token operator">=</span> tab <span class="token operator">+</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                      <span class="token comment">--&gt; 2       2</span>
                      <span class="token comment">--&gt; 3       3</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                      <span class="token comment">--&gt; 2       2</span>
                      <span class="token comment">--&gt; 3       3</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>上面 tab 的值也被更改了，说明 table 类型的传值是以<strong>指针/引用</strong>的形式。</p>
</blockquote>
<p>其余运算符也可以重载，如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">元方法</th>
<th style="text-align:center">对应运算符</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">__add</td>
<td style="text-align:center">+</td>
</tr>
<tr>
<td style="text-align:center">__sub</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">__mul</td>
<td style="text-align:center">*</td>
</tr>
<tr>
<td style="text-align:center">__div</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">__mod</td>
<td style="text-align:center">%</td>
</tr>
<tr>
<td style="text-align:center">__unm</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">__concat</td>
<td style="text-align:center">…</td>
</tr>
<tr>
<td style="text-align:center">__eq</td>
<td style="text-align:center">==</td>
</tr>
<tr>
<td style="text-align:center">__lt</td>
<td style="text-align:center">&lt;</td>
</tr>
<tr>
<td style="text-align:center">__le</td>
<td style="text-align:center">&lt;=</td>
</tr>
</tbody>
</table>
<h2 id="进阶玩法">进阶玩法</h2>
<h3 id="迭代器">迭代器</h3>
<p>之前我们提到可以用 <code>pairs</code> 和 <code>ipairs</code> 去遍历一个 table，但实际上迭代器(iter)并不限于此。以 <code>ipairs()</code> 为例，我们先尝试获取这个函数的返回值是什么。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>pairs</span></div><code class="language-lua">tab <span class="token operator">=</span> <span class="token punctuation">{</span>key1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">ipairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; function: 0x1a8d080     table: 0x1a94020        0</span>
<span class="token function">print</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>         <span class="token comment">--&gt; table: 0x1a94020</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>第一个返回值是一个 function，应该是一个闭包；第二个返回值是 tab 对象本身；第三个返回值是 0，可能会用于索引。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>接上面的代码</span></div><code class="language-lua">a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c <span class="token operator">=</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span>
<span class="token comment">-- print(a())       --&gt; bad argument #1 to 'a' (table expected, got no value)</span>
<span class="token comment">-- print(a(b))      --&gt; bad argument #2 to 'a' (number expected, got no value)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">--&gt; 1       2</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">--&gt; 2       3</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt;</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">a</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment">--&gt;</span>
<span class="token comment">-- 是的，最后两个就是打印了空行，但实际上应该返回 nil</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从上面可以得到，<code>ipairs()</code> 的第一个返回值 function 对象接受两个参数，且第一个参数要求是 table，第二个参数要求是 number（但是传入 0 却实现了返回 <code>1 tab[1]</code>，比较莫名其妙）。那么下面是一个可能的 <code>ipairs</code> 的实现：</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>myIpairs</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">iter</span><span class="token punctuation">(</span>tbl<span class="token punctuation">,</span> i<span class="token punctuation">)</span>
    i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">local</span> v <span class="token operator">=</span> tbl<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">if</span> v <span class="token keyword">then</span>
        <span class="token keyword">return</span> i<span class="token punctuation">,</span> v
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">function</span> <span class="token function">myIpairs</span><span class="token punctuation">(</span>table<span class="token punctuation">)</span>
    <span class="token keyword">return</span> iter<span class="token punctuation">,</span> table<span class="token punctuation">,</span> <span class="token number">0</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">ipairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                      <span class="token comment">--&gt; 2       2</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">myIpairs</span><span class="token punctuation">(</span>tab<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                      <span class="token comment">--&gt; 2       2</span>
                      <span class="token comment">-- 根据这一输出结果，猜想得到证实</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>进一步分析「泛型循环」的行为：</p>
<ol>
<li class="lvl-3">
<p>首先执行 <code>in</code> 左侧的表达式，期望得到<strong>三</strong>个返回值，记为 <code>func</code>，<code>param1</code>，<code>param2</code>；</p>
</li>
<li class="lvl-3">
<p>调用 <code>func(param1, param2)</code>，可以得到若干返回值 <code>value1</code>，<code>value2</code>，…；</p>
</li>
<li class="lvl-3">
<p>这些返回值会被 <code>in</code> 左侧的变量接收，多余的丢弃，不足的用 nil 补充；</p>
</li>
<li class="lvl-3">
<p>如果 <code>value1</code> 为 nil，终止循环，否则执行循环体；</p>
</li>
<li class="lvl-3">
<p><code>param1</code> 不变，<code>param2 = value1</code>，重复步骤 2；</p>
</li>
</ol>
<p>其中只有 <code>func</code> 是必要的。另外，由于 <code>param1</code> 不变，所以又被称为「<strong>状态常量</strong>」，<code>param2</code> 仅用于第一次的 <code>func()</code> 调用，在循环过程中会发生变化，故又被称为「<strong>初始变量</strong>」。</p>
<p>也可以实现一个只返回 <code>func</code> 的迭代器函数：</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>无状态迭代器</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">square</span><span class="token punctuation">(</span>iteratorMaxCount<span class="token punctuation">,</span> currentNumber<span class="token punctuation">)</span>
    <span class="token keyword">if</span> currentNumber <span class="token operator">&lt;</span> iteratorMaxCount <span class="token keyword">then</span>
        currentNumber <span class="token operator">=</span> currentNumber <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">return</span> currentNumber<span class="token punctuation">,</span> currentNumber <span class="token operator">^</span> <span class="token number">2</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> i<span class="token punctuation">,</span> n <span class="token keyword">in</span> square<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> n<span class="token punctuation">)</span> <span class="token comment">--&gt; 1       1</span>
                <span class="token comment">--&gt; 2       4</span>
                <span class="token comment">--&gt; 3       9</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种只利用<strong>状态常量</strong>和<strong>初始变量</strong>两个值就可以获取下一个元素的迭代器函数称为「<strong>无状态的迭代器</strong>」。那么当然也有「<strong>有状态的迭代器</strong>」了。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>有状态迭代器</span></div><code class="language-lua">array <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"Jack"</span><span class="token punctuation">,</span> <span class="token string">"Mike"</span><span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">elementIterator</span><span class="token punctuation">(</span>collection<span class="token punctuation">)</span>
    <span class="token keyword">local</span> index <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">local</span> count <span class="token operator">=</span> <span class="token operator">#</span>collection
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        index <span class="token operator">=</span> index <span class="token operator">+</span> <span class="token number">1</span>
        <span class="token keyword">if</span> index <span class="token operator">&lt;=</span> count <span class="token keyword">then</span>
            <span class="token keyword">return</span> collection<span class="token punctuation">[</span>index<span class="token punctuation">]</span>
        <span class="token keyword">end</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token function">elementIterator</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token comment">--&gt; Jack</span>
                   <span class="token comment">--&gt; Mike</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里通过定义局部变量，并将其赋给闭包函数，使得在整个循环中这些局部变量都能生效，这样也就为 <code>func</code> 提供了额外的信息，因而为<strong>有状态的</strong>。</p>
<h3 id="实现面向对象">实现面向对象</h3>
<p>回顾一下面向对象三大特性：封装、继承、多态。下面分别讲一下 Lua 如何实现这几个特性。</p>
<h4 id="封装">封装</h4>
<p>我们知道 table 可以通过 <code>.</code> 的方式访问 key，不难发现这和 C++ 中访问成员变量的方式如出一辙。事实上我们完全可以通过 table 的这一特性实现成员变量。又因为 value 支持任意类型，当然也包括 function 类型，同理也可以实现成员函数。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>封装</span></div><code class="language-lua">obj <span class="token operator">=</span> <span class="token punctuation">{</span>member <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">}</span> <span class="token comment">-- 定义成员变量</span>
<span class="token function">print</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>           <span class="token comment">--&gt; table: 0x1449880</span>

<span class="token keyword">function</span> obj<span class="token punctuation">:</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">-- 定义成员函数</span>
    <span class="token function">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"obj.foo"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

obj<span class="token punctuation">:</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">--&gt; table: 0x1449880</span>
                     <span class="token comment">--&gt; obj.foo</span>

obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- 也可以通过这种方式定义成员函数</span>
    <span class="token function">print</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"obj.foo - new!"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token comment">--&gt; nil</span>
                     <span class="token comment">--&gt; obj.foo - new!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们发现了两种成员函数的定义方式，同时也发现了两种调用方式！虽然两种定义方式是等价的，但是调用方式却不等价。区别就在于，使用 <code>:</code> 调用成员函数会隐式传入 <code>self</code> 对象，也就是自身，而 <code>.</code> 的方式却不行。同时，我们不能通过 <code>:</code> 访问非 function 类型的 value，会报错，因为解释器默认在 <code>:</code> 后面的是 function 对象，是要跟圆括号的。所以既然 Lua 为我们专门提供了一种访问方式，那就不要跟他作对，用就是了。</p>
<h4 id="继承">继承</h4>
<p>指定 metatable 其实就可以看作「继承自基类」。在 C++ 中，「继承」（假设以 <code>public</code> 方式）能够使派生类访问基类的所有非私有成员变量和成员函数，那么在 Lua 中，这种性质由「指定 metatable.__index = metatable」的方式实现。这很合理，当我们尝试访问一个 table（派生类）中不存在的 key-value 时，就会通过 metatable.__index 去查找，也就相当于查找 metatable（基类）中的 key-value。</p>
<p>同时也允许派生类覆盖基类的成员变量/函数，只需要添加同名 key 即可（就不会走 metatable.__index 了）。</p>
<p>下面给出一个工厂函数示例，用于生成派生 table 对象。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>工厂函数</span></div><code class="language-lua">RectangleFactory <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>                          <span class="token comment">-- 基类</span>
RectangleFactory<span class="token punctuation">.</span>__index <span class="token operator">=</span> RectangleFactory    <span class="token comment">-- !这一步很关键，允许派生类访问基类的成员函数和成员变量</span>

<span class="token keyword">function</span> RectangleFactory<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span>length<span class="token punctuation">,</span> breadth<span class="token punctuation">)</span> <span class="token comment">-- 创建派生类的函数</span>
    <span class="token keyword">return</span> <span class="token function">setmetatable</span><span class="token punctuation">(</span>
        <span class="token punctuation">{</span>
            length <span class="token operator">=</span> length <span class="token keyword">or</span> <span class="token number">0</span><span class="token punctuation">,</span>
            breadth <span class="token operator">=</span> breadth <span class="token keyword">or</span> <span class="token number">0</span><span class="token punctuation">,</span>
            area <span class="token operator">=</span> length <span class="token operator">*</span> breadth
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        self
    <span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">function</span> RectangleFactory<span class="token punctuation">:</span><span class="token function">printArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> <span class="token string">"面积为"</span><span class="token punctuation">,</span> self<span class="token punctuation">.</span>area<span class="token punctuation">)</span>
<span class="token keyword">end</span>

rec <span class="token operator">=</span> RectangleFactory<span class="token punctuation">:</span><span class="token function">new</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">-- 此时 new() 中的 self 是 RectangleFactory</span>
<span class="token function">print</span><span class="token punctuation">(</span>rec<span class="token punctuation">)</span>                       <span class="token comment">--&gt; table: 0x243c740</span>
rec<span class="token punctuation">:</span><span class="token function">printArea</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                  <span class="token comment">--&gt; table: 0x243c740        面积为  2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在调用 <code>rec:printArea()</code> 时，由于其本身没有对应的 key，所以去 metatable（也就是 <code>RectangleFactory</code>）的 <code>__index</code> 中查找，最终调用了 <code>RectangleFactory:printArea()</code>。</p>
<p>这里我们发现，在调用 metatable 的成员函数时，传入的 <code>self</code> 是 <code>rec</code> 本身。从而得出一个额外的结论：<strong>对于一个 function 而言，如果它作为 table 的成员函数被调用，则内部的 <code>self</code> 取决于调用者，即 <code>:</code> 左侧的对象</strong>。</p>
<h4 id="多态">多态</h4>
<p>只需要在 table 中定义 metatable 的同名函数即可实现多态。</p>
<h3 id="模块-module-与包-package">模块(module)与包(package)</h3>
<p>我们可以在一个 <code>module.lua</code> 文件中通过 <code>return</code> 返回若干变量，其它 <code>.lua</code> 文件可以在开头通过 <code>require("module")</code> 语句获得这些变量的使用权。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>module.lua</span></div><code class="language-lua">mod <span class="token operator">=</span> <span class="token punctuation">{</span>foo <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span>

<span class="token keyword">function</span> mod<span class="token punctuation">:</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"call mod:func "</span> <span class="token operator">..</span> self<span class="token punctuation">.</span>foo<span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">function</span> <span class="token function">moduleFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"call moduleFunc"</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token keyword">return</span> mod<span class="token punctuation">,</span> moduleFunc<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>main.lua</span></div><code class="language-lua"><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"module"</span><span class="token punctuation">)</span> <span class="token comment">-- 会根据一定规则找到 module.lua 文件</span>

mod<span class="token punctuation">:</span><span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token comment">--&gt; call mod:func 1</span>
<span class="token function">moduleFunc</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment">--&gt; call moduleFunc</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>加载规则</strong>是：先找当前文件夹，再去环境变量 <code>LUA_PATH</code> 中查找。</p>
<blockquote>
<p>⚠️需要注意的是，使用的变量必须在 <code>module.lua</code> 文件中为全局变量。这很好理解，我们把一个文件看成一个单独的作用域，那么声明为 <code>local</code> 的变量也就只能在该文件中生效，即便被其它文件 <code>require</code>，相当于作用域发生变化，也就无法使用了。这很容易联想到 C 中的 <code>#include</code>、<code>static</code>、<code>extern</code> 相关用法。</p>
</blockquote>
<p>进阶玩法是，可以在某个 <code>package.lua</code> 中 <code>require</code> 许多 module，这样如果我们需要使用这些模块的时候，只需要 <code>require("package")</code> 即可（相当于形成了一种 table 的树状结构）。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>package.lua</span></div><code class="language-lua">package <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

package<span class="token punctuation">.</span>module1 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"mypackage.module1"</span><span class="token punctuation">)</span> <span class="token comment">-- 引入 ./mypackage/module1.lua</span>
package<span class="token punctuation">.</span>module2 <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"mypackage.module2"</span><span class="token punctuation">)</span> <span class="token comment">-- 引入 ./mypackage/module2.lua</span>

<span class="token keyword">return</span> package<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过模块和包，我们可以更好地组织代码，提高代码的可重用性，并降低代码之间的耦合度。</p>
<h3 id="Lua-C-交互">Lua &amp; C 交互</h3>
<p>之前说到 Lua 是 C 写的，可以容易地与 C 语言进行交互，下面讲讲是如何做到的。</p>
<h4 id="Lua-中调用-C-函数">Lua 中调用 C 函数</h4>
<p>具体方式是将 <code>.c</code> 文件生成动态链接库，令 Lua 执行相应的函数注册与调用行为。</p>
<pre class="line-numbers language-c" data-language="c"><div class="caption"><span>mylib.c</span></div><code class="language-c"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;lauxlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;lua.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;lualib.h&gt;</span></span>

<span class="token comment">// 所有要注册的函数都必须为 int (*)(lua_State *L) 类型</span>
<span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">cAdd</span><span class="token punctuation">(</span>lua_State <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">double</span> lhs <span class="token operator">=</span> <span class="token function">luaL_checknumber</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> rhs <span class="token operator">=</span> <span class="token function">luaL_checknumber</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">double</span> result <span class="token operator">=</span> lhs <span class="token operator">+</span> rhs<span class="token punctuation">;</span>
  <span class="token function">lua_pushnumber</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment">// 返回值的数量</span>
<span class="token punctuation">}</span>

<span class="token comment">// 如果链接成 *.so，那么就需要设置函数名为 luaopen_*</span>
<span class="token keyword">int</span> <span class="token function">luaopen_mylib</span><span class="token punctuation">(</span>lua_State <span class="token operator">*</span>L<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  luaL_Reg mylib<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token comment">// 注册函数名与函数指针，用 {NULL, NULL} 作为结束标识符</span>
    <span class="token punctuation">{</span><span class="token string">"add"</span><span class="token punctuation">,</span> cAdd<span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token function">luaL_newlib</span><span class="token punctuation">(</span>L<span class="token punctuation">,</span> mylib<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注册函数</span>
  <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash" data-language="bash"><div class="caption"><span>根据 mylib.c 生成动态链接库</span></div><code class="language-bash">$ gcc mylib.c <span class="token parameter variable">-fPIC</span> <span class="token parameter variable">-shared</span> <span class="token parameter variable">-o</span> mylib.so <span class="token parameter variable">-Wall</span>
$ <span class="token function">ls</span>
mylib.c mylib.so test.lua<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>test.lua</span></div><code class="language-lua"><span class="token keyword">local</span> mylib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"mylib"</span><span class="token punctuation">)</span>   <span class="token comment">-- 查找 mylib.so，并调用其中的 luaopen_mylib()</span>
                                 <span class="token comment">-- 注册 add() 函数对应到 cAdd()</span>

<span class="token keyword">local</span> result <span class="token operator">=</span> mylib<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token comment">-- 相当于调用 cAdd(10, 20)</span>
<span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>                    <span class="token comment">--&gt; 30</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="C-中执行-Lua-脚本">C 中执行 Lua 脚本</h4>
<p>这个比较简单，关键在于 <code>luaL_dofile()</code> 函数。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>main.c</span></div><code class="language-C">#include &lt;lauxlib.h&gt;
#include &lt;lua.h&gt;
#include &lt;lualib.h&gt;
#include &lt;stdio.h&gt;

int main() {
  lua_State *L = luaL_newstate();                         // 创建 Lua 虚拟机
  luaL_openlibs(L);                                       // 打开标准 Lua 库

  int error = luaL_dofile(L, "myLua.lua");                // 执行 Lua 脚本
  if (error) {
    fprintf(stderr, "Error: %s\n", lua_tostring(L, -1));  // 打印异常信息
    lua_pop(L, 1);                                        // 弹出异常信息
  }

  lua_close(L);                                           // 关闭 Lua 虚拟机
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="C-中执行调用了-C-函数的-Lua-脚本">C 中执行调用了 C 函数的 Lua 脚本</h4>
<p>这就是把上面两个合起来了。</p>
<p>当然此时也可以不生成动态链接库，直接执行一段字符串即可。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>main.c</span></div><code class="language-C">#include &lt;lauxlib.h&gt;
#include &lt;lua.h&gt;
#include &lt;lualib.h&gt;
#include &lt;stdio.h&gt;

static int cAdd(lua_State *L) {
  double lhs = luaL_checknumber(L, 1);
  double rhs = luaL_checknumber(L, 2);
  double result = lhs + rhs;
  lua_pushnumber(L, result);
  return 1;  // 返回值的数量
}

int main() {
  lua_State *L = luaL_newstate(); // 创建 Lua 虚拟机
  luaL_openlibs(L);               // 打开标准 Lua 库

  /**
   * 下面这个其实是一个宏
   * #define lua_register(L,n,f) (lua_pushcfunction(L, f), lua_setglobal(L, n))
   *
   * 其中：
   * lua_pushcfunction(L, cAdd); 将函数 cAdd() 转换为 Lua 的 function 并压入虚拟栈
   * lua_setglobal(L, "add");    弹出栈顶元素，并在 Lua 中用名为 add 的全局变量存储
   */
  lua_register(L, "add", cAdd);

  int error = luaL_dostring(L, "add(10, 20)");            // 执行 Lua 脚本
  if (error) {
    fprintf(stderr, "Error: %s\n", lua_tostring(L, -1));  // 打印异常信息
    lua_pop(L, 1);                                        // 弹出异常信息
  }

  lua_close(L);                                           // 关闭 Lua 虚拟机
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Lua-协程">Lua 协程</h3>
<p>Lua 协程和 C++20 的协程用法基本一致，由 <code>coroutine</code> 模块提供支持。这里我们直接通过一个生产者-消费者问题来了解什么是协程。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>coroutine.lua</span></div><code class="language-lua"><span class="token keyword">local</span> newProductor

<span class="token keyword">function</span> <span class="token function">productor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"productor"</span><span class="token punctuation">,</span> coroutine<span class="token punctuation">.</span><span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">-- 获取正在运行的 coroutine</span>
    <span class="token keyword">local</span> i <span class="token operator">=</span> <span class="token number">0</span>
    <span class="token keyword">repeat</span>
        <span class="token function">send</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
        i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span>
    <span class="token keyword">until</span> i <span class="token operator">&gt;</span> <span class="token number">3</span>
<span class="token keyword">end</span>

<span class="token keyword">function</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"consumer"</span><span class="token punctuation">,</span> coroutine<span class="token punctuation">.</span><span class="token function">running</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">-- 获取正在运行的 coroutine</span>
    <span class="token keyword">local</span> i <span class="token operator">=</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">while</span> i <span class="token keyword">do</span>
        i <span class="token operator">=</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">end</span>
<span class="token keyword">end</span>

<span class="token keyword">function</span> <span class="token function">receive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">local</span> status<span class="token punctuation">,</span> value <span class="token operator">=</span> coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>newProductor<span class="token punctuation">)</span> <span class="token comment">-- 启动 coroutine 并获取返回值</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"receive"</span><span class="token punctuation">,</span> value<span class="token punctuation">,</span> status<span class="token punctuation">)</span>
    <span class="token keyword">return</span> value
<span class="token keyword">end</span>

<span class="token keyword">function</span> <span class="token function">send</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
    <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"send"</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
    coroutine<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>                     <span class="token comment">-- 返回一个值并挂起</span>
<span class="token keyword">end</span>

<span class="token comment">-- 这里都是由 main thread 负责的</span>
newProductor <span class="token operator">=</span> coroutine<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>productor<span class="token punctuation">)</span> <span class="token comment">-- 创建但不启动 coroutine</span>
<span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">--&gt;  consumer        nil</span>
<span class="token comment">--&gt;  productor       thread: 0xc81020</span>
<span class="token comment">--&gt;  send    0</span>
<span class="token comment">--&gt;  receive 0</span>
<span class="token comment">--&gt;  send    1</span>
<span class="token comment">--&gt;  receive 1</span>
<span class="token comment">--&gt;  send    2</span>
<span class="token comment">--&gt;  receive 2</span>
<span class="token comment">--&gt;  send    3</span>
<span class="token comment">--&gt;  receive 3</span>
<span class="token comment">--&gt;  receive nil</span>

<span class="token function">print</span><span class="token punctuation">(</span>coroutine<span class="token punctuation">.</span><span class="token function">resume</span><span class="token punctuation">(</span>newProductor<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">--&gt; false    cannot resume dead coroutine</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<table>
<thead>
<tr>
<th style="text-align:left">序号</th>
<th style="text-align:left">描述</th>
<th style="text-align:center">控制权属于 main</th>
<th style="text-align:center">控制权属于 newProductor</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">首先，我们通过 <code>coroutine.create()</code> 创建了一个 thread 类型的对象 <code>newProductor</code>，绑定到函数 <code>productor()</code>。根据输出结果可以看到，此时其并未启动。</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">main 继续调用 <code>consumer()</code> 函数，并通过 <code>coroutine.resume()</code> 的方式启动 <code>newProductor</code>，并等着获取抛出的值。</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:left">3</td>
<td style="text-align:left"><code>newProductor</code> 启动，在 <code>productor()</code> 内部通过 <code>coroutine.yield(i)</code> 抛出一个值的同时将自身挂起；如果函数结束，则抛出 nil。</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">4.1</td>
<td style="text-align:left">如果 main 在 <code>receive()</code> 中获取到了非 nil 值，则重复第二步。</td>
<td style="text-align:center"></td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:left">4.2</td>
<td style="text-align:left">如果 main 在 <code>receive()</code> 中获取到了 nil 值，这意味着 <code>newProductor</code> 已经正常结束，那 main 也需结束</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:left">5</td>
<td style="text-align:left">截至目前 <code>status</code> 都是 true，但如果后续再次通过 <code>resume()</code> 尝试启动 <code>newProductor</code>，则会报错</td>
<td style="text-align:center">√</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>不难看出，其实协程就是通过用户编码的方式来将协程的切换行为委托给用户而非操作系统。虽然说是说 thread 类型的变量，但其实还是以用户态的形式运作的，和需要操作系统调度的「线程」有本质区别。</p>
<blockquote>
<p>跟 C++ 的协程非常像，但开发效率高了不少。</p>
</blockquote>
<h3 id="文件-I-O">文件 I/O</h3>
<p>基本的文件操作有「打开」、「关闭」、「读」、「写」这四种。Lua 内置了一个全局 table 变量 <code>io</code>，实现了文件相关的成员函数，比如要打开一个文件可以用 <code>io.open(file [, mode = "r"])</code>，其中第一个参数为「<strong>文件路径</strong>」，第二个参数为「<strong>打开方式</strong>」。这种打开文件的操作和 C/C++ 几乎一致，就不赘述了。</p>
<p><code>io.open()</code> 会返回一个文件句柄 <code>file</code>，其实现了以下成员函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">file 函数</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">file:close()</td>
<td style="text-align:left">关闭文件。也可以通过 <code>file=nil</code> 使其被垃圾回收，但回收时间随机，不建议。</td>
</tr>
<tr>
<td style="text-align:left">file:read(…)</td>
<td style="text-align:left">每个传入的参数为一种读取方式，对应一个返回值。有以下几种读取方式：<br><code>"l"</code>:（<strong>默认</strong>）读一行，不包括换行符。<strong>只能用于文本文件</strong>。<br><code>"L"</code>: 读一行，包括换行符。<strong>只能用于文本文件</strong>。<br><code>"n"</code>: 读一个 number。<br><code>"a"</code>: 从当前位置读整个文件。<br><code>number</code>: 传入一个整数，读 number 个字节。<br>如果读取失败则返回 nil。</td>
</tr>
<tr>
<td style="text-align:left">file:write(…)</td>
<td style="text-align:left">将所有入参（<strong>只能</strong>是 string 或 number）写入文件。写入行为取决于 <code>open()</code> 中指定的打开方式。如果失败则返回 nil, errstring。</td>
</tr>
<tr>
<td style="text-align:left">file:lines(…)</td>
<td style="text-align:left"><strong>迭代器函数</strong>，能够指定和 <code>read()</code> 一样的读取方式循环读取文件直至 EOF。</td>
</tr>
<tr>
<td style="text-align:left">file:flush()</td>
<td style="text-align:left">将缓冲区内容落盘。</td>
</tr>
<tr>
<td style="text-align:left">file:seek(whence, offset=0)</td>
<td style="text-align:left">修改文件当前位置为 <code>base+offset</code>。第一个参数为 string，用于指定 base。<br><code>"cur"</code>: （<strong>默认</strong>）base 为文件当前位置。<br><code>"set"</code>: base 为文件起始位置。<br><code>"end"</code>: base 为 EOF。<br>若成功则返回文件当前位置，否则返回 nil, errstring。</td>
</tr>
<tr>
<td style="text-align:left">file:setvbuf(mode, size)</td>
<td style="text-align:left">设置文件输出缓冲模式。<br><code>"no"</code>: 无缓冲，任何写入都会落盘。<br><code>"full"</code>: 全缓冲，仅当缓冲区满或显示调用 <code>flush()</code> 时落盘。<br><code>"line"</code>: 行缓冲，遇到换行符时落盘。</td>
</tr>
</tbody>
</table>
<p>一些基本操作如下：</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>file.lua</span></div><code class="language-lua">file <span class="token operator">=</span> io<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">"input.txt"</span><span class="token punctuation">,</span> <span class="token string">"a+"</span><span class="token punctuation">)</span>  <span class="token comment">-- 以 append &amp; 可读写 方式打开文件</span>

file<span class="token punctuation">:</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token string">"hello world\n"</span><span class="token punctuation">)</span>        <span class="token comment">-- 此时 file 当前位置为 EOF</span>

file<span class="token punctuation">:</span><span class="token function">seek</span><span class="token punctuation">(</span><span class="token string">"set"</span><span class="token punctuation">)</span>                   <span class="token comment">-- 重新指向起始位置</span>

<span class="token keyword">for</span> line <span class="token keyword">in</span> file<span class="token punctuation">:</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token string">"l"</span><span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span>                    <span class="token comment">--&gt; hello world</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至于为什么要用 <code>:</code> 方式调用函数呢，可能内部有一个 <code>cur</code> 指向当前位置，需要传入 <code>self</code> 去查改。</p>
<blockquote>
<p>虽然 <code>io</code> 对象也实现了若干成员函数，但只支持单文件操作，并不太想去了解。</p>
</blockquote>
<h3 id="异常处理">异常处理</h3>
<p>Lua 提供了两个<strong>基本</strong>异常处理函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>assert(v, message="assertion failed!")</code>: 若表达式 <code>v</code> 不为 true，则程序中断，输出异常信息 <code>message</code>；</p>
</li>
<li class="lvl-2">
<p><code>error(message, level=1)</code>: 中断程序，并输出异常信息 <code>message</code>。其中 <code>level</code> 用于控制位置信息，默认为 <code>1</code>，附带「文件名+函数内行号」，<code>0</code> 表示不添加位置信息，<code>2</code> 表示附带「文件名+调用函数行号」；</p>
</li>
</ul>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>error.lua</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">func0</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"haha"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">function</span> <span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"haha"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>
<span class="token keyword">function</span> <span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"haha"</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">end</span>

<span class="token function">func0</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">--&gt; lua: haha</span>
<span class="token function">func1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">--&gt; lua: error.lua:5: haha</span>
<span class="token function">func2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">--&gt; lua: error.lua:13: haha</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这两个函数都会在发生异常时中断程序，有些时候可能不是我们想要的行为。Lua 为我们提供了一种保护机制，使得即使某个函数抛出了异常，也能正确处理而非直接使程序终止，就是下面两个函数：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>pcall(func, ...)</code>: 全称「protected call」。第一个返回值为 boolean，表示是否成功运行，后续返回值是要么是 <code>func(...)</code> 的返回值（如果调用成功），要么是异常信息（如果发生错误）；</p>
</li>
<li class="lvl-2">
<p><code>xpcall(func, error_handler, ...)</code>: 比 <code>pcall()</code> 多了第二个参数，是一个只接受一个 string 参数的 function，当异常发生时会由 <code>error_handler(err)</code> 进行处理。第一个返回值为 boolean，表示是否成功运行，后续返回值是要么是 <code>func(...)</code> 的返回值（如果调用成功），要么是 <code>error_handler(err)</code> 的返回值（如果发生错误）；</p>
</li>
</ul>
<p>Lua 内置了一个 debug 库，为我们提供了两个通用的 error_handler：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>debug.debug()</code>：提供一个 Lua 提示符，让用户来检查错误的原因；</p>
</li>
<li class="lvl-2">
<p><code>debug.traceback()</code>：根据调用栈来构建一个扩展的错误消息；</p>
</li>
</ul>
<p>下面是基本用法</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>error_handle.lua</span></div><code class="language-lua"><span class="token keyword">function</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    n <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token keyword">nil</span>
<span class="token keyword">end</span>

success<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token function">pcall</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">--&gt; test.lua:2: attempt to perform arithmetic on global 'n' (a nil value)</span>

success<span class="token punctuation">,</span> res <span class="token operator">=</span> <span class="token function">xpcall</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> debug<span class="token punctuation">.</span>traceback<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">--&gt; test.lua:2: attempt to perform arithmetic on global 'n' (a nil value)</span>
            <span class="token comment">--&gt; stack traceback:</span>
            <span class="token comment">--&gt;         test.lua:2: in function &lt;test.lua:1&gt;</span>
            <span class="token comment">--&gt;         [C]: in function 'xpcall'</span>
            <span class="token comment">--&gt;         test.lua:12: in main chunk</span>
            <span class="token comment">--&gt;         [C]: ?</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>debug 库提供的 error_handler 也不止上面这两个，用到再学吧。</p>
</blockquote>
<h3 id="垃圾回收">垃圾回收</h3>
<p>C/C++ 中可以通过将对象分配在栈上，从而在生命周期结束时令其自动被回收，也可以通过 <code>free</code>/<code>delete</code> 来显式释放不再需要的堆上对象。但显式释放对象的缺点是，一旦忘记释放，但是丢失了这个对象的引用，就再也无法访问这个对象了，即存在「内存泄漏」。</p>
<p>Lua（在内的其他语言）内置了「<strong>垃圾回收</strong>」的功能，它天然能够在某一时刻检测哪些对象不再被其他变量/对象引用（这种对象称之为「<strong>不可达对象</strong>」），然后将它们回收，这就使得我们不需要把心思花在处理内存泄漏问题上，只需要专注于开发即可。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>垃圾回收简单例子</span></div><code class="language-lua">t <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
t <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span> <span class="token comment">-- {1, 2, 3} 此时为「不可达」，会在将来的某一时刻被回收</span>
t <span class="token operator">=</span> <span class="token keyword">nil</span>       <span class="token comment">-- 显式指定为不可达对象，之后会将 {4, 5, 6} 回收</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h4 id="≤Lua-5-0：简单标记扫描">≤Lua 5.0：简单标记扫描</h4>
<p>Lua 5.0 之前用的是一种简单的标记扫描算法，只有以下两步：</p>
<ol>
<li class="lvl-3">
<p>垃圾回收器从一组根对象开始（通常是全局变量、调用栈中的局部变量等），递归扫描这些根对象，并标记可以访问到的对象（下面称为<strong>子对象</strong>）为「<strong>活跃</strong>」（弱引用表除外）。</p>
</li>
<li class="lvl-3">
<p>垃圾回收器遍历保存所有对象的链表 <code>allgc</code>，回收所有未被标记为活跃的对象，同时清除活跃对象的标记。</p>
</li>
</ol>
<p>不难看出一次 GC 会进行全量扫描，并且每当解释器分配了一定数量的内存时，垃圾回收器也执行一次 GC，这样就会产生大量的开销。</p>
<p>更致命的是，GC 的过程会阻塞主程序的运行。所以基本没人用。</p>
<h4 id="Lua-5-0：小优化">Lua 5.0：小优化</h4>
<p>依然是进行全量 GC，只不过将执行 GC 的时刻延长至「内存分配量超过了上次 GC 后的两倍」。</p>
<p>值得一提的是，这个版本支持 <code>__gc</code> 元方法，会在被回收时调用。当一个 table 或 userdata 对象实现了该元方法，那么在创建/设置元表时就会加入到 <code>finobj</code> 链表上。</p>
<p>在回收阶段，将 <code>finobj</code> 上的不可达对象执行一遍 <code>__gc</code>，同时标记为「已经执行过 <code>__gc</code>」，然后将其加入 <code>allgc</code>，这样下一次 GC 周期就能正确回收了。</p>
<h4 id="Lua-5-1：三色扫描——渐进式-GC">Lua 5.1：三色扫描——渐进式 GC</h4>
<p>渐进式垃圾收集器会在虚拟机的正常指令逻辑间交错分布运行，尽量把每步的执行时间减到合理的范围。同时它使用了一种新的算法，即<strong>三色扫描</strong>，将每个对象分为三个状态：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>白色</strong>：不可达（这是所有对象的默认颜色）；</p>
</li>
<li class="lvl-2">
<p><strong>灰色</strong>：可达，但未进行递归扫描；</p>
</li>
<li class="lvl-2">
<p><strong>黑色</strong>：可达，且已完全扫描；</p>
</li>
</ul>
<blockquote>
<p>那么以下条件是恒成立的：</p>
<ul class="lvl-1">
<li class="lvl-2">灰色对象的子对象可以是白色的；</li>
<li class="lvl-2">黑色对象的子对象非黑即灰；</li>
</ul>
</blockquote>
<p>三色标记法的回收过程包括以下步骤：</p>
<ol>
<li class="lvl-3">
<p>将所有根对象标记为灰色；</p>
</li>
<li class="lvl-3">
<p>对根对象进行递归扫描，将访问到的对象标记为灰色。同时，将已经访问过的对象标记为黑色；</p>
</li>
<li class="lvl-3">
<p>未被标记为黑色的对象即为不可达对象，可以被回收；</p>
</li>
</ol>
<p>随着 GC 的运作，灰色对象会被转变为黑色对象。一旦所有灰色对象消失，整个 GC 过程也就完成了。</p>
<p>这样还有一个问题，就是当一个 table 被完全扫描并标为「黑色」后，再给它加入一个新的对象，此时这个新对象就是「白色」的，后续依然会被回收，就会出现不一致的问题。</p>
<p>此时有两种解决措施，一种是把新对象 <strong>barrier forward</strong> 为「灰色」，另一种是把 table <strong>barrier backward</strong> 为「灰色」。</p>
<p>在 Lua 实现中，对黑色 table 进行修改操作会默认使用 <strong>barrier backward</strong> 策略，将其改为「灰色」（并认为后续还可能进行修改），并把它单独放在一个独立的链表 <code>grayagain</code> 里，留待后面原子处理，避免它在「黑色」和「灰色」之间反复折腾。</p>
<blockquote>
<p>一种特殊情况是在栈上分配的 table，就不会让它变「黑色」，这样对栈的操作就不需要 barrier，提高栈写入的性能。</p>
</blockquote>
<p>如果是给对象设置一个 metatable，就可以采用 <strong>barrier forward</strong> 策略，即将 metatable 置「灰色」。</p>
<h4 id="Lua-5-2-5-4：分代-GC">Lua 5.2/5.4：分代 GC</h4>
<p>所谓分代 GC 指的是对象分为「<strong>老年代</strong>」和「<strong>新生代</strong>」。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>老年代</strong>指的是常驻的、长时间不需要 GC 的对象。之前的版本中，大量的时间都是在扫描标记这些对象，因此如果能够减少扫描标记老年代的话，性能就能达到提升；</p>
</li>
<li class="lvl-2">
<p><strong>新生代</strong>指的是是刚创建出来的对象，很有可能需要进行清理，比如在栈上创建的对象。针对新生代进行 GC 不只能够提升效率，还能保持内存占用的稳定；</p>
</li>
</ul>
<p>如果一个对象在「新生代」中存活足够长的时间（即在多次垃圾收集后仍然存活），它会被晋升到「老年代」。对「老年代」的回收频率显著低于「新生代」的回收频率。</p>
<p>当然依然存在老年代对象引用新生代对象，该如何修改状态的问题——新对象改为「老年代」，那「老年代」就会有特别多，起不到回收的作用；老对象改为「新生代」也是同理，需要进行更多的回收，起不到优化的作用。</p>
<p>所以引入了新的状态叫「<strong>触碰态</strong>」，一旦老对象引用了一个新的对象，则认为它处于「触碰态」，加入下次的扫描。如果「新生代」和「触碰态」被多次扫描到，就说明它有可能经常被用到，就将其转为「老年代」。</p>
<h4 id="弱表">弱表</h4>
<p><strong>弱表</strong>指内部元素为「<strong>弱引用</strong>」的表，是用户用来告诉 Lua 一个引用不应该阻碍对该对象的回收的机制。如果一个对象只被弱引用引用到，垃圾收集器就会回收这个对象。</p>
<p>table 的弱引用类型是通过其元表中的 <code>__mode</code> 字段来决定的。这个字段的值应为一个字符串：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果包含 <code>'k'</code>，那么这个 table 的 key 是弱引用的；</p>
</li>
<li class="lvl-2">
<p>如果包含 <code>'v'</code>，那么这个 table 的 value 是弱引用的；</p>
</li>
</ul>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>弱引用</span></div><code class="language-lua">a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token function">setmetatable</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">{</span>__mode <span class="token operator">=</span> <span class="token string">"k"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

k <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"v1"</span>

k <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
a<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"v2"</span>

<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; table: 0xd45960 v1</span>
                      <span class="token comment">--&gt; table: 0xd454a0 v2</span>
<span class="token keyword">end</span>

<span class="token function">collectgarbage</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token comment">-- "v1" 对应的 key 未被其他变量引用，会被回收</span>
                      <span class="token comment">-- "v2" 对应的 key 仍被 k 引用，所以不会被回收</span>

<span class="token keyword">for</span> key<span class="token punctuation">,</span> value <span class="token keyword">in</span> <span class="token function">pairs</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token keyword">do</span>
    <span class="token function">print</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token comment">--&gt; table: 0xd454a0 v2</span>
<span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>关键在于忽略了 table 对 key 的引用计数，因而也可以用于解决「<strong>循环引用</strong>」问题。</p>
<pre class="line-numbers language-lua" data-language="lua"><div class="caption"><span>循环引用</span></div><code class="language-lua">a <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span>
b <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">}</span>

<span class="token comment">-- a.other = b</span>
<span class="token comment">-- b.other = a</span>
<span class="token comment">-- 上面这种写法导致循环引用</span>

<span class="token function">setmetatable</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token punctuation">{</span>__mode <span class="token operator">=</span> <span class="token string">"v"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">setmetatable</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> <span class="token punctuation">{</span>__mode <span class="token operator">=</span> <span class="token string">"v"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

a<span class="token punctuation">.</span>other <span class="token operator">=</span> b
b<span class="token punctuation">.</span>other <span class="token operator">=</span> a

a <span class="token operator">=</span> <span class="token keyword">nil</span>
b <span class="token operator">=</span> <span class="token keyword">nil</span>
<span class="token function">collectgarbage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">-- 此时 {1, 2, 3} {4, 5, 6} 均会被回收</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Lua</category>
      </categories>
  </entry>
  <entry>
    <title>进程间通信(IPC)</title>
    <url>/operating-system/interprocesscommunication/</url>
    <content><![CDATA[<p>为了保护操作系统中进程互不干扰，需要使用进程隔离技术，以防不同进程能够修改其他进程数据。但进程之间又不能完全隔离，需要一定的通信手段，于是开发出了**进程间通信(IPC, InterProcess Communication)**技术。</p>
<span id="more"></span>
<h2 id="管道-Pipe">管道(Pipe)</h2>
<p>管道是最基本的通信机制，实质是一个半双工的通信方式，即数据只能单向流通，每次从头读取，向尾写入，并且遵循 <strong>FIFO(First In First Out)</strong> 原则，以<strong>字节流</strong>的方式进行传输，就仿佛一个单向队列。并且管道双方必须均处于「在线」状态，一旦一方退出，另一方也自动断开。</p>
<blockquote>
<p>如果双方相互通信时，则需要建立两个管道。</p>
</blockquote>
<p>根据<strong>是否存在于文件系统</strong>中，又可将管道分为<strong>匿名管道</strong>和<strong>命名管道</strong>两种。</p>
<blockquote>
<p>「<strong>名</strong>」指的就是路径名啦。</p>
</blockquote>
<h3 id="匿名管道">匿名管道</h3>
<p>Linux 中可以通过函数 <code>int pipe(int fd[2])</code> 建立匿名管道，其中 <code>fd[0]</code> 为读取端，<code>fd[1]</code> 为写入端，两个都是<strong>文件描述符</strong>，从而可以用 <code>read()/write()</code> 系统调用进行数据传输。比如下面这段代码：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>匿名管道</span></div><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;string.h&gt;

int main() {
  int fd[2];
  int ret = pipe(fd); // ret&gt;=0 for success, ret&lt;0 for fail
  if (ret &lt; 0) {
    printf("Pipe Create Failed!\n");
  }

  pid_t id = fork();
  if (id &lt; 0) {
    printf("Fork Failed\n");
  } else if(id == 0) {
    close(fd[0]); // 关闭读取才能写入
    int i = 0;
    char* msg = "I'm child";
    while(i++ &lt; 100) {
      write(fd[1], msg, strlen(msg));
      sleep(1);
    }
  } else {
    close(fd[1]); // 关闭写入才能读取
    int i = 0;
    char msg[100];
    while (i++ &lt; 100) {
      memset(msg, '\0', sizeof(msg));
      read(fd[0], msg, sizeof(msg));
      printf("%s\n", msg);
    }
  }

  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>事实上，匿名管道并<strong>不</strong>位于文件系统中，它本质上是一个位于<strong>内核空间</strong>中的缓冲区，只不过将两端以「文件」的形式提供了数据读写的渠道。如果缓冲区已满，则阻塞写入；如果缓冲区为空，则阻塞读取。</p>
<img src="1.png">
<p>同时，读写端的文件描述符仅仅位于通信双方公共祖先进程的地址空间内部，也是因为如此，匿名管道仅适用于<strong>父子进程</strong>这种有「亲缘关系」（或称相关）的进程之间的通信，而无法跨进程通信。</p>
<blockquote>
<p>毕竟调用 <code>fork()</code> 会进行一次完整的拷贝操作，也就会复制该 <code>fd[]</code>。</p>
</blockquote>
<p>同样，一旦进程销毁，该管道也随之被销毁。也就是说，匿名管道的<strong>生命周期完全由进程决定</strong>。</p>
<h3 id="命名管道">命名管道</h3>
<p>那么为了实现跨进程通信，不如就把上文中的缓冲区改为实际的文件，令其位于文件系统中，这样一来只要知道该<strong>管道文件</strong>的路径，就可以在任何进程之间进行通信了。</p>
<p>Linux 中可以通过函数 <code>int mkfifo(const char *path, mode_t mode)</code> 建立命名管道，其中 <code>path</code> 指明文件路径，<code>mode</code> 指明管道文件的存取权限。比如下面这段代码：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>命名管道 - server.c</span></div><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#define _PATH_NAME_ "/tmp/file.tmp"
#define _SIZE_ 100

int main() {
  int ret = mkfifo(_PATH_NAME_, S_IFIFO | 0666);
  if (ret == -1) {
    printf("Make File Error\n");
    return -1;
  }

  char buf[_SIZE_] = {0};
  int fd = open(_PATH_NAME_, O_WRONLY);
  while (true) {
    fget(buf, sizeof(buf) - 1, stdin);
    int ret = write(fd, buf, strlen(buf) + 1);
    if (ret &lt; 0) {
      printf("Write Error\n");
      break;
    }
  }
  close(fd);

  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>命名管道 - client.c</span></div><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;unistd.h&gt;
#define _PATH_NAME_ "/tmp/file.tmp"
#define _SIZE_ 100

int main() {
  int fd = open(_PATH_NAME_, O_RDONLY);
  if (fd &lt; 0) {
    printf("Open File Error\n");
    return 1;
  }

  char buf[_SIZE_] = {0};
  while (true) {
    int ret = read(fd, buf, sizeof(buf));
    if (ret &lt; 0) {
      printf("Read Error\n");
      break;
    }
    printf("%s\n", buf);
  }
  close(fd);

  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>服务端利用系统函数 <code>mkfifo()</code> 创建一个名为 <code>file.tmp</code> 的文件作为管道并写入。客户端同样也能打开该文件进行读取。而它们却是无关进程。</p>
<h2 id="信号-Signal">信号(Signal)</h2>
<p>信号是一种软中断，采用异步通信方式，内核可以利用信号来通知用户进程发生了哪些系统事件，一般源于<strong>硬件方式</strong>（用户按下 <code>Ctrl+C</code> 键）或<strong>软件方式</strong>（系统调用产生信号）</p>
<p>Linux 中共定义了 64 种信号，分为以下两种：</p>
<ol>
<li class="lvl-3">
<p><strong>不可靠信号</strong>：不支持排队，信号可能会丢失，发送多次相同的信号，进程只能收到一次. 信号值取值区间为 1~31；</p>
</li>
<li class="lvl-3">
<p><strong>可靠信号</strong>：支持排队，信号不会丢失，发多少次，就可以收到多少次，信号值取值区间为 32~64；</p>
</li>
</ol>
<h3 id="常见信号">常见信号</h3>
<table>
<thead>
<tr>
<th style="text-align:center">信号</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>SIGHUP</strong></td>
<td style="text-align:center">用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGINT</strong></td>
<td style="text-align:center">程序终止信号。程序运行过程中，按 <code>Ctrl+C</code> 键将产生该信号</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGQUIT</strong></td>
<td style="text-align:center">程序退出信号。程序运行过程中，按 <code>Ctrl+\</code> 键将产生该信号</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGBUS / SIGSEGV</strong></td>
<td style="text-align:center">进程访问非法地址</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGFPE</strong></td>
<td style="text-align:center">运算中出现致命错误，如除零操作、数据溢出等</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGKILL</strong></td>
<td style="text-align:center">用户终止进程执行信号。执行 <code>kill -9</code> 发送该信号</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGTERM</strong></td>
<td style="text-align:center">结束进程信号。执行 <code>kill pid</code> 发送该信号</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGALRM</strong></td>
<td style="text-align:center">定时器信号</td>
</tr>
<tr>
<td style="text-align:center"><strong>SIGCHLD</strong></td>
<td style="text-align:center">子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程</td>
</tr>
</tbody>
</table>
<h3 id="Linux-信号相关数据结构">Linux 信号相关数据结构</h3>
<p>Linux 在进程管理结构 <code>task_struct</code> 中定义了信号相关的变量。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>task_struct 定义</span></div><code class="language-C">struct task_struct {
  ...
  int sigpending; // 是否有待处理信号
  ...
  struct signal_struct *sig; // 定义了信号值对应的处理方法
  sigset_t blocked;          // 被屏蔽的信息，以 bit 表示
  struct sigpending pending; // 待处理信号队列
  ...
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>信号相关结构体定义</span></div><code class="language-C">#define  _NSIG  64

struct signal_struct {
  atomic_t count;
  struct k_sigaction action[_NSIG]; // 信号处理函数表
  spinlock_t siglock;
};

typedef void (*__sighandler_t)(int);

struct sigaction {
  __sighandler_t sa_handler; // 处理函数
  unsigned long sa_flags;
  void (*sa_restorer)(void);
  sigset_t sa_mask;
};

struct k_sigaction {
  struct sigaction sa;
};

struct sigqueue {
  struct sigqueue *next;
  siginfo_t info;
};

struct sigpending {
  struct sigqueue *head, **tail;
  sigset_t signal;
};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="信号发送流程">信号发送流程</h3>
<p>以 <code>kill()</code> 为例，其函数原型为 <code>int kill(pid_t pid, int sig)</code>。</p>
<p>当源进程(src)调用 <code>kill()</code> 打算将目标进程(dst)给杀掉时，该系统调用会进一步调用内核函数 <code>sys_kill()</code>：</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">asmlinkage long
sys_kill(int pid, int sig)
{
  struct siginfo info;

  info.si_signo = sig;
  info.si_errno = 0;
  info.si_code = SI_USER;
  info.si_pid = current-&gt;pid;
  info.si_uid = current-&gt;uid;

  return kill_something_info(sig, &amp;info, pid);
}

static int kill_something_info(int sig, struct siginfo *info, int pid)
{
  if (!pid) {
    return kill_pg_info(sig, info, current-&gt;pgrp);
  } else if (pid == -1) {
    int retval = 0, count = 0;
    struct task_struct * p;
    read_lock(&amp;tasklist_lock);
    for_each_task(p) {
      if (p-&gt;pid &gt; 1 &amp;&amp; p != current) {
        int err = send_sig_info(sig, info, p);
        ++count;
        if (err != -EPERM)
          retval = err;
      }
    }
    read_unlock(&amp;tasklist_lock);
    return count ? retval : -ESRCH;
  } else if (pid &lt; 0) {
    return kill_pg_info(sig, info, -pid);
  } else {
    return kill_proc_info(sig, info, pid);
  }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>从函数 <code>kill_something_info()</code> 可以得知，信号发送后具体的处理流程与 dst 的 <code>pid</code> 有很大关系，具体为：</p>
<ol>
<li class="lvl-3">
<p><code>pid &gt; 0</code> 时：直接发送给 <code>pid</code> 对应的进程；</p>
</li>
<li class="lvl-3">
<p><code>pid = 0</code> 时：发送给所有与 src 属同一个使用组的进程；</p>
</li>
<li class="lvl-3">
<p><code>pid = -1</code> 时：发送给 src 有权给其发送信号的所有进程，除了进程 1(init);</p>
</li>
<li class="lvl-3">
<p><code>pid &lt; -1</code> 时：发送给 -pid 为组标识的进程；</p>
</li>
</ol>
<p>这里只讨论第一种情况。当 pid&gt;0 时，调用 <code>kill_proc_info()</code> 函数，通过 <code>send_sig_info()</code> 发送信号。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">inline int
kill_proc_info(int sig, struct siginfo *info, pid_t pid)
{
  int error;
  struct task_struct *p;

  read_lock(&amp;tasklist_lock);
  p = find_task_by_pid(pid); // 获得 pid 对应的 task_struct
  error = -ESRCH;
  if (p) {
    error = send_sig_info(sig, info, p);
  }
  read_unlock(&amp;tasklist_lock);
  return error;
}

int
send_sig_info(int sig, struct siginfo *info, struct task_struct *t)
{
  unsigned long flags;
  int ret;

  ret = -EINVAL;
  if (sig &lt; 0 || sig &gt; _NSIG)
    goto out_nolock;

  ret = -EPERM;
  if (bad_signal(sig, info, t)) // 检查是否有权限发送，没有就直接返回
    goto out_nolock;

  ret = 0;
  if (!sig || !t-&gt;sig)
    goto out_nolock;

  spin_lock_irqsave(&amp;t-&gt;sigmask_lock, flags);
  handle_stop_signal(sig, t)

  if (ignored_signal(sig, t)) // 是否忽略该信号，是就不发送
    goto out;

  if (sig &lt; SIGRTMIN &amp;&amp; sigismember(&amp;t-&gt;pending.signal, sig)) // 不可靠信号如果已经在等待队列中，就不会再次入队
    goto out;

  ret = deliver_signal(sig, info, t); // 发送信号，并将 task_struct.pending 置为 1
out:
  spin_unlock_irqrestore(&amp;t-&gt;sigmask_lock, flags);
  if ((t-&gt;state &amp; TASK_INTERRUPTIBLE)&amp;&amp; signal_pending(t)) // 如果处于睡眠可中断状态且有信号待处理，将其唤醒
    wake_up_process(t);

out_nolock:
  return ret;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>至此，发送信号的流程已完成。</p>
<h3 id="信号处理流程">信号处理流程</h3>
<p>此时此刻信号已经发送给目标进程，为了尽快让信号得到处理，Linux 把信号处理过程放置在进程<strong>从内核态返回到用户态前</strong>，也就是操作系统决定调度目标进程的时候，然后检查 <code>sigpending</code> 是否为 1，若是，就调用 <code>do_signal()</code> 函数进行处理。</p>
<pre class="line-numbers language-C" data-language="C"><code class="language-C">int do_signal(struct pt_regs *regs, sigset_t *oldset)
{
  siginfo_t info;
  struct k_sigaction *ka;

  if ((regs-&gt;xcs &amp; 3)!= 3)
    return 1;

  if (!oldset)
    oldset = &amp;current-&gt;blocked;

  for (;;) {
    unsigned long signr;

    // 不断对信号队列进行 dequeue 取出头部，如果没有可取的就直接退出
    spin_lock_irq(&amp;current-&gt;sigmask_lock);
    signr = dequeue_signal(&amp;current-&gt;blocked, &amp;info);
    spin_unlock_irq(&amp;current-&gt;sigmask_lock);
    if (!signr)
      break;

    ka = &amp;current-&gt;sig-&gt;action[signr-1];
    if (ka-&gt;sa.sa_handler == SIG_IGN) { // ignore. 即如果忽视就直接跳过
      if (signr != SIGCHLD)
        continue;

      /* Check for SIGCHLD: it's special.  */
      while (sys_wait4(-1, NULL, WNOHANG, NULL)&gt; 0)
        /* nothing */;

      continue;
    }

    if (ka-&gt;sa.sa_handler == SIG_DFL) { // default. 即指定为默认就用系统的默认处理方法
      int exit_code = signr;

      /* Init gets no signals it doesn't want.  */
      if (current-&gt;pid == 1)
        continue;

      switch (signr) {
      case SIGCONT: case SIGCHLD: case SIGWINCH:
        continue;

      case SIGTSTP: case SIGTTIN: case SIGTTOU:
        if (is_orphaned_pgrp(current-&gt;pgrp))
          continue;
        /* FALLTHRU */

      case SIGSTOP:
        current-&gt;state = TASK_STOPPED;
        current-&gt;exit_code = signr;
        if (!(current-&gt;p_pptr-&gt;sig-&gt;action[SIGCHLD-1].sa.sa_flags &amp; SA_NOCLDSTOP))
          notify_parent(current, SIGCHLD);
        schedule();
        continue;

      case SIGQUIT: case SIGILL: case SIGTRAP:
      case SIGABRT: case SIGFPE: case SIGSEGV:
      case SIGBUS: case SIGSYS: case SIGXCPU: case SIGXFSZ:
        if (do_coredump(signr, regs))
          exit_code |= 0x80;
        /* FALLTHRU */

      default:
        sigaddset(&amp;current-&gt;pending.signal, signr);
        recalc_sigpending(current);
        current-&gt;flags |= PF_SIGNALED;
        do_exit(exit_code);
        /* NOTREACHED */
      }
    }
    ...
    handle_signal(signr, ka, &amp;info, oldset, regs); // 如果通过 signal() 注册了自定义处理方法，就用 handle_signal() 去处理
    return 1;
  }
  ...
  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>值得注意的是，用户定义的处理方法代码位于用户态，而在运行这段系统函数期间 CPU 还处于内核态，只能先返回用户态执行用户态代码，再回到内核态做后续工作。所以信号处理的开销还是蛮大的。</p>
</blockquote>
<h3 id="总结">总结</h3>
<p>发送进程通过 <code>sys_*()</code> 系统调用，将信号信息打包放到目标进程的 <code>task_struct</code> 中，下次操作系统调度进程时，检查这个进程是否有待处理的信号，如果有则先进行信号处理，之后在回到用户态继续执行之前的指令。</p>
<h2 id="消息队列-Msg-Queue">消息队列(Msg Queue)</h2>
<p>管道的一个劣势在于，数据都是以字节流进行传输，没有格式一说，这就要求管道的读取方和写入方必须事先约定好数据的格式与长度，比如多少字节算作一个消息/命令/记录等等。</p>
<p>为了打破这一限制，诞生了消息队列。其本质上是内核中的链表，每个节点是一个具有<strong>特定格式</strong>的消息，和 C++ 中的 <code>std::list&lt;Message&gt;</code> 很像。不同的队列以不同的**队列标识符(qid)**来区分，只有内核重启或显式删除后相关队列才会被移除。</p>
<p>和管道相同之处在于，如果管道/队列存放的数据/消息满了，写会被阻塞，读同理。</p>
<p>不同之处在于，虽然写都是写到末尾，但是消息队列可以根据消息字段<strong>随机读取</strong>，而不一定要从队首。并且，消息队列允许多个进程对其读写。</p>
<h3 id="消息队列使用">消息队列使用</h3>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>消息队列 - writer.c</span></div><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/types.h&gt;

struct msgbuf {  // 待写入消息节点数据结构，必须以 long 类型变量开始
  long mtype;
  char mtext[255];
};

int main() {
  int mq_id = msgget(123, IPC_CREAT | 0666);  // 创建一个消息队列
  if (mq_id != -1) {
    // 初始化要发生的消息
    struct msgbuf mybuf;
    mybuf.mtype = 1;
    strcpy(mybuf.mtext, "I'm send process.\n");

    // 发送消息
    if (msgsnd(mq_id, &amp;mybuf, sizeof(mybuf.mtext), 0)) {
      printf("success\n");
    } else {
      printf("msgsnd Fail\n");
    }
  } else {
    printf("msgget Fail\n");
  }

  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>消息队列 - reader.c</span></div><code class="language-C">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#include &lt;sys/types.h&gt;

struct msgbuf {  // 待读取消息节点数据结构，必须与消息队列节点格式一致
  long mtype;
  char mtext[255];
};

int main() {
  int mq_id = msgget(123, IPC_CREAT | 0666);  // 获取消息队列
  if (mq_id != -1) {
    struct msgbuf mybuf;
    // 接收第一条消息，存到 mybuf 中
    if (msgrcv(mq_id, &amp;mybuf, sizeof(mybuf.mtext), 0, IPC_NOWAIT) != -1) {
      printf("read success: %s\n", mybuf.mtext);
      // 删除这个消息队列
      if (msgctl(mq_id, IPC_RMID, 0) != -1) {
        printf("delete msg success\n");
      }
    } else {
      printf("msgsnd Fail\n");
    }

  } else {
    printf("msgget Fail\n");
  }

  return 0;
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="共享内存-Shared-Memory">共享内存(Shared Memory)</h2>
<p>共享内存是指将同一片内存映射到多个进程的虚拟地址空间，进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</p>
<p>当然，建立共享内存的过程无需进行数据复制，直接在内存中操作，是最快的可用通信机制。然而还需要一些信号量提供同步/互斥手段，否则会出现一致性的问题。</p>
<blockquote>
<p>管道、消息队列都需要将进程内部数据复制到内核空间/磁盘</p>
</blockquote>
<p>目前 Linux 系统有以下三种共享内存方案：</p>
<ol>
<li class="lvl-3">
<p>mmap 内存共享映射；</p>
</li>
<li class="lvl-3">
<p>XSI 共享内存；</p>
</li>
<li class="lvl-3">
<p>POSIX 共享内存；</p>
</li>
</ol>
<h3 id="mmap-共享内存">mmap 共享内存</h3>
<p>mmap 本来的是存储映射功能。它可以将一个文件映射到内存中，在程序里就可以直接使用内存地址对文件内容进行访问，这可以让程序对文件访问更方便。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>mmap api</span></div><code class="language-C">#include &lt;sys/mman.h&gt;

// 通过设置 fd，就可以映射到文件，返回值是相应的内存地址。
void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

// 移除地址 addr 上的共享内存
int munmap(void *addr, size_t length);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>由于这个系统调用的特性可以用在很多场合，所以 Linux 系统用它实现了很多功能，并不仅局限于存储映射，还可以进行共享内存，只需令 <code>mmap()</code> 中 <code>flags = MAP_SHARED|MAP_ANONYMOUS, fd = -1</code>。这样一来，配合 <code>fork()</code>，父子进程都可以获取相同的 <code>mmap()</code> 返回的共享内存地址，从而实现通信。样例代码如下：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>mmap.c</span></div><code class="language-C">#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;unistd.h&gt;
#include &lt;wait.h&gt;

#define COUNT 100

int do_child(int* count) {
  int interval;

  /* critical section */
  interval = *count;
  interval++;
  usleep(1);
  *count = interval;
  /* critical section */

  exit(0);
}

int main() {
  pid_t pid;
  int count;
  int* shm_p;

  shm_p = (int*)mmap(NULL, sizeof(int), PROT_WRITE | PROT_READ,
                     MAP_SHARED | MAP_ANONYMOUS, -1, 0);
  if (MAP_FAILED == shm_p) {
    perror("mmap()");
    exit(1);
  }

  *shm_p = 0;

  for (count = 0; count &lt; COUNT; count++) {
    pid = fork();
    if (pid &lt; 0) {
      perror("fork()");
      exit(1);
    }

    if (pid == 0) {
      do_child(shm_p);
    }
  }

  for (count = 0; count &lt; COUNT; count++) {
    wait(NULL);
  }

  printf("shm_p: %d\n", *shm_p);
  munmap(shm_p, sizeof(int));
  exit(0);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="XSI-共享内存">XSI 共享内存</h3>
<p>mmap 实现共享内存的方式需要 <code>fork()</code> 配合，只能支持相关进程。XSI 采取更为通用的手段，能够支持无关进程。</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>XSI api</span></div><code class="language-C">#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;sys/types.h&gt;

// 根据指定文件的 inode 编号和文件所在设备的设备编号来生成 key
key_t ftok(const char *pathname, int proj_id);

// 根据 key 生成/获取共享内存标识符 shmid
// Linux 限制了系统最大能创建的共享内存为 128 个
int shmget(key_t key, size_t size, int shmflg);

// 将 {虚拟地址: 物理地址} 的映射绑定到进程内，并令该共享内存的 `shm_nattach`
// 计数器加一
void *shmat(int shmid, const void *shmaddr, int shmflg);

// 移除映射，并令该共享内存的 `shm_nattach` 计数器减一
int shmdt(const void *shmaddr);

// 执行控制命令，如进行删除
int shmctl(int shmid, int cmd, struct shmid_ds *buf);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但根据管道的经验，无关进程之间的通信能且仅能通过文件来实现，每次根据 <code>path</code> 打开一个文件，进程内部都有一个文件描述符 <code>fd</code> 来指向该文件，从而进行操作。XSI 就是根据这个思路来设计的，<code>key</code> 对应了 <code>path</code>，<code>shmid</code> 对应了 <code>fd</code>。之所以说<strong>对应</strong>，是因为并不是真正的文件描述符，无法使用 <code>open()/write()</code> 这样的系统调用对其执行操作。事实上，内核里有一张名为 <code>shm_segs[]</code> 的表来存放共享内存相关信息，并根据 <code>shmid</code> 来索引。只要 <code>ftok</code> 的参数是一样的，那么生成的 <code>key</code> 也必然是一样且唯一的，根据 <code>shmget()</code> 得到的 <code>shmid</code> 也是唯一的，这就实现了任意进程能够对共享内存进行访问。样例代码如下：</p>
<pre class="line-numbers language-C" data-language="C"><div class="caption"><span>XSI.c</span></div><code class="language-C">#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/file.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/mman.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;unistd.h&gt;
#include &lt;wait.h&gt;

#define COUNT 100
#define PATHNAME "/etc/passwd"

int do_child(int proj_id) {
  int interval;
  int *shm_p, shm_id;
  key_t shm_key;
  // 使用 ftok() 产生shmkey
  if ((shm_key = ftok(PATHNAME, proj_id)) == -1) {
    perror("ftok()");
    exit(1);
  }

  // 在子进程中获取到已经在父进程中创建好的 shmid
  shm_id = shmget(shm_key, sizeof(int), 0);
  if (shm_id &lt; 0) {
    perror("shmget()");
    exit(1);
  }

  // 将相关共享内存段映射到本进程的内存地址
  shm_p = (int *)shmat(shm_id, NULL, 0);
  if ((void *)shm_p == (void *)-1) {
    perror("shmat()");
    exit(1);
  }

  /* critical section */
  interval = *shm_p;
  interval++;
  usleep(1);
  *shm_p = interval;
  /* critical section */

  // 解除本进程内对共享内存的地址映射
  if (shmdt(shm_p) &lt; 0) {
    perror("shmdt()");
    exit(1);
  }

  exit(0);
}

int main() {
  pid_t pid;
  int count;
  int *shm_p;
  int shm_id, proj_id;
  key_t shm_key;

  proj_id = 1234;

  // 使用约定好的文件路径和 proj_id 产生 shm_key
  if ((shm_key = ftok(PATHNAME, proj_id)) == -1) {
    perror("ftok()");
    exit(1);
  }

  // 创建一个共享内存，如果系统中已经存在此共享内存则报错退出，创建出来的共享内存权限为
  // 0600(-rw-------)
  shm_id = shmget(shm_key, sizeof(int), IPC_CREAT | IPC_EXCL | 0600);
  if (shm_id &lt; 0) {
    perror("shmget()");
    exit(1);
  }

  // 绑定映射
  shm_p = (int *)shmat(shm_id, NULL, 0);
  if ((void *)shm_p == (void *)-1) {
    perror("shmat()");
    exit(1);
  }

  *shm_p = 0;

  // 并发读写
  for (count = 0; count &lt; COUNT; count++) {
    pid = fork();
    if (pid &lt; 0) {
      perror("fork()");
      exit(1);
    }

    if (pid == 0) {
      do_child(proj_id);
    }
  }

  // 等待所有子进程执行完毕
  for (count = 0; count &lt; COUNT; count++) {
    wait(NULL);
  }

  // 解除映射
  if (shmdt(shm_p) &lt; 0) {
    perror("shmdt()");
    exit(1);
  }

  // 删除共享内存
  if (shmctl(shm_id, IPC_RMID, NULL) &lt; 0) {
    perror("shmctl()");
    exit(1);
  }

  exit(0);
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="POSIX-共享内存">POSIX 共享内存</h3>
<p>POSIX 共享内存本质上就是在 <code>/dev/shm</code> 上创建一个文件，并将其 mmap 之后映射其内存地址。</p>
<h2 id="套接字-Socket">套接字(Socket)</h2>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title>Linear Algebra 2</title>
    <url>/note/linearalgebra2/</url>
    <content><![CDATA[<p>书接上回。</p>
<span id="more"></span>
<h2 id="如何求解无解方程组？">如何求解无解方程组？</h2>
<p>在这个问题之前，我先做点铺垫。</p>
<h3 id="正交向量">正交向量</h3>
<p>若两向量 $\mathbf{a}, \mathbf{b}$ 正交，则必然有 $\mathbf{a}^T\mathbf{b} = \mathbf{b}^T\mathbf{a} = 0$</p>
<h3 id="正交子空间">正交子空间</h3>
<p>若子空间 $S$ 与子空间 $T$ 正交，则 $S$ 中任意向量与 $T$ 中任意向量正交。</p>
<p>不难发现，$R(A)$ 与 $N(A)$ 是正交的，而这两个空间恰好都是 $R^n$ 的子空间，更巧的是，<strong>其维数之和为</strong> $n$。</p>
<p>我们称这两个子空间为 $R^n$ 的<strong>正交补</strong>——它们将 $R^n$ 划分为了<strong>两个正交的子空间</strong>。</p>
<p>同样的，$C(A)$ 与 $L(A)$ 也互为正交补。</p>
<blockquote>
<p>两个互为正交补的子空间的维数之和，不能超过原空间的维数。</p>
</blockquote>
<h3 id="投影问题">投影问题</h3>
<p>这一问题的几何解释为：如何在向量 $\mathbf{a}$ 的方向上寻找与向量 $\mathbf{b}$ 距离最近的一点。假设这一点对应的向量为 $\mathbf{p}$，则 $\mathbf{e}=\mathbf{b}-\mathbf{p}$ 就是这一近似的误差。如图所示：</p>
<img src="image-20220929215857174.png" alt="image-20220929215857174" style="zoom:100%;">
<p>若令 $\mathbf{p} = \hat{x}\mathbf{a}$，因 $\mathbf{e}$ 与 $\mathbf{a}$ 正交，则有 $\mathbf{a}^T(\mathbf{b}-\hat{x}\mathbf{a}) = 0$，解得</p>
<p>$$
\hat{x} = \frac{\mathbf{a}<sup>T\mathbf{b}}{\mathbf{a}</sup>T\mathbf{a}}
\[2ex]
\mathbf{p} = \mathbf{a}\frac{\mathbf{a}<sup>T\mathbf{b}}{\mathbf{a}</sup>T\mathbf{a}}
$$</p>
<p>相当于把 $\mathbf{b}$ 以某种操作投影到了 $\mathbf{p}$ 上。若用<strong>投影矩阵</strong> $P$ 来描述这一操作，则有 $\mathbf{p} = P\mathbf{b}$，得</p>
<p>$$
P = \frac{\mathbf{a}\mathbf{a}<sup>T}{\mathbf{a}</sup>T\mathbf{a}}
$$</p>
<p>这是一个<strong>对称矩阵</strong>（$P<sup>T=P$），而且是**幂等矩阵**（$P</sup>2 = P$）</p>
<h3 id="如果考虑该问题在高维空间的版本">如果考虑该问题在高维空间的版本</h3>
<p>有一个向量空间 $V$ 与一个不在该空间上的向量 $\mathbf{b}$，如果把 $V$ 视为某一矩阵的列空间，且该空间的基为 $\mathbf{a_1}, \mathbf{a_2},\dots, \mathbf{a_n}$，则该矩阵可以用 $A = \begin{bmatrix}\mathbf{a_1} &amp; \mathbf{a_2} &amp; \cdots &amp; \mathbf{a_n} \end{bmatrix}$ 来描述。</p>
<p>令 $\mathbf{p}$ 为 $\mathbf{b}$ 在该向量空间上的投影，则 $\mathbf{p}$ 可以用 $\mathbf{p} = x_1\mathbf{a_1} + x_2\mathbf{a_2} + \dots + x_n\mathbf{a_n} = A\mathbf{\hat{x}}$ 来表示。</p>
<p>显然误差 $\mathbf{e}$ 与整个向量空间正交，则有 $\mathbf{a_1}^T\mathbf{e} = 0, \mathbf{a_2}^T\mathbf{e} = 0, \dots, \mathbf{a_n}^T\mathbf{e} = 0$</p>
<p>上式可以写为 $A^T\mathbf{e} = 0$</p>
<p>从而得到
$$
A^T(\mathbf{b} - A\mathbf{\hat{x}}) = 0 \quad \Rightarrow \quad \mathbf{\hat{x}} = (A<sup>TA)</sup>{-1}A^T\mathbf{b}
$$
那么得到一个<strong>非常优美的结论</strong>：
$$
\mathbf{p} = A(A<sup>TA)</sup>{-1}A^T\mathbf{b}
\[2ex]
P = A(A<sup>TA)</sup>{-1}A^T
$$
这里的 $P$ 同样满足对称性和幂等性。</p>
<p>这里 $\mathbf{p} \in C(A)$，同时惊喜的发现 $\mathbf{e}\in L(A)$，说明 $\mathbf{b} = \mathbf{p} + \mathbf{e}$ 由两部分组成，一部分（$\mathbf{p}$）投影到了 $C(A)$ 上，另一部分（$\mathbf{e}$）投影到了 $L(A)$ 上。对于 $\mathbf{e}$，我们发现可以通过 $\mathbf{e} = \mathbf{b} - \mathbf{p} = \mathbf{b} - P\mathbf{b} = (I-P)\mathbf{b}$ 表示，所以 $I-P$ 也是个投影矩阵，也具有和 $P$ 同样的性质。</p>
<p>当 $A$ 的列向量线性无关时，说明 $C(A)$ 就是 $R^n$，此时任意 $\mathbf{b}\in R^n$ 都必然在 $C(A)$ 中，投影矩阵就是 $I$。</p>
<p>对于 $A^TA$ 而言，其零空间与 $A$ 是一致的</p>
<ol>
<li class="lvl-3">
<p>对于 $A^TA\mathbf{x}=\mathbf{0}$，必然满足 $\mathbf{x}<sup>TA</sup>TA\mathbf{x} = (A\mathbf{x})^T A\mathbf{x} = \mathbf{0}$，从而 $A\mathbf{x}$ 与自身正交，那么 $A\mathbf{x} = \mathbf{0}$。</p>
</li>
<li class="lvl-3">
<p>对于 $A\mathbf{x}=\mathbf{0}$，必然满足 $A^TA\mathbf{x}=\mathbf{0}$</p>
</li>
</ol>
<p>因此当 $A$ 的列向量线性无关时，$A\mathbf{x}=\mathbf{0}$ 只有零解，$A^TA\mathbf{x}=\mathbf{0}$ 也只有零解。且 $A^TA$ 为方阵，行列满秩，必然可逆。</p>
<h3 id="回到最开始的问题：如何求解无解方程组？">回到最开始的问题：如何求解无解方程组？</h3>
<p>这个问题看似很离谱，实则我们可以用一个最优解 $\mathbf{\hat{x}}$ 去近似。对于方程 $A\mathbf{x} = \mathbf{b}$，如果其无解，说明 $\mathbf{b}$ 不在 $A$ 的列空间中。我们可以将 $\mathbf{b}$ 投影到 $C(A)$，将问题转换为求解方程 $A\mathbf{\hat{x}} = \mathbf{p}$，这个解就是我们想求的近似最优解。</p>
<p>根据上面描述的，我们能够很轻易地得到该解，即
$$
\mathbf{\hat{x}} = (A<sup>TA)</sup>{-1}A^T\mathbf{b}
$$</p>
<h3 id="最小二乘法">最小二乘法</h3>
<p>应用投影矩阵求方程组最优解的方法，最常用于"最小二乘法"拟合曲线，如图：</p>
<img src="image-20220929223041893.png" alt="image-20220929223041893" style="zoom:80%;">
<p>已知数据点，求一直线方程，使该直线尽可能经过所有点——所有点到该直线的距离尽可能小。</p>
<p>有一个思路是：这些数据点大概率不会共线，也就是说，将这些数据点代入直线方程利用待定系数法求其参数时，组成的线性方程组大多数情况下是无解的，此时就要用到上面的"求无解方程组最优解"的思路。</p>
<p>还有一个思路是，我们希望误差 $\mathbf{e}$ 尽可能小，也就是 $||\mathbf{e}||<sup>2=||A\mathbf{\hat{x}}-\mathbf{b}||</sup>2$ 尽可能小。这一等式可以写成一个 $n$ 元的方程，对该方程的所有变量求偏导并令偏导数为 0，则可以得到上面那个思路一样的结果。</p>
<h3 id="再回到正交向量">再回到正交向量</h3>
<p>现在说正交向量的升级版——<strong>标准正交向量</strong>，即满足以下条件的一组向量：
$$
\mathbf{q}_i^T\mathbf{q}_j = \begin{cases}1 \quad i = j\[2ex] 0 \quad i \neq j\end{cases}
$$</p>
<h3 id="正交矩阵">正交矩阵</h3>
<p>若令 $Q = \begin{bmatrix}\mathbf{q}_1 &amp; \mathbf{q}_2 &amp; \cdots &amp; \mathbf{q}_n \end{bmatrix}$，易得
$$
Q^TQ = I
$$
此矩阵 $Q$ 称为<strong>正交矩阵</strong>，且显然有 $Q<sup>T=Q</sup>{-1}$。</p>
<p>对于正交矩阵来说，在其列空间内关于投影问题的<strong>投影矩阵</strong>也可以<strong>简化为</strong> $P=Q(Q<sup>TQ)</sup>{-1}Q^T = QQ^T$。若 $Q$ 为方阵，还可以进一步得到 $P=I$，因为此时其列空间已经张成 $R^n$，投影操作不会对向量有任何改变。</p>
<p>对应的 $\mathbf{p} = P\mathbf{b} = QQ^T\mathbf{b} = Q\mathbf{\hat{x}}$</p>
<h3 id="施密特正交化">施密特正交化</h3>
<p>对于一组线性无关的向量 $\mathbf{a}_1, \mathbf{a}_2,\dots,\mathbf{a}_n$，若其能够张成空间 $V$，我们希望能找到该空间的<strong>正交矩阵</strong>表示——即找到一组<strong>标准正交向量</strong> $\mathbf{e}_1, \mathbf{e}_2, \dots, \mathbf{e}_n$，其恰好能张成同样的空间，也就是找到该空间的一组<strong>标准正交基</strong>。</p>
<blockquote>
<p>对一个向量的<strong>标准化</strong>过程就是令其除以其模长。</p>
</blockquote>
<p>我们不妨逐一分析：</p>
<ol>
<li class="lvl-3">
<p>第一个向量不作变动，即 $\displaystyle \mathbf{e}_1 = \frac{\mathbf{a}_1}{||\mathbf{a}_1||}$</p>
</li>
<li class="lvl-3">
<p>对于之后的所有向量 $\mathbf{a}_i$，由于我们已经求得一组标准正交向量 $\mathbf{e}<em>1, \dots, \mathbf{e}</em>{i-1}$，设求其施密特正交化后的向量为 $\mathbf{e}_i$，易得 $\mathbf{e}_i$ 垂直于 $\mathbf{e}<em>1, \dots, \mathbf{e}</em>{i-1}$，从而有$\mathbf{e}_i$ 垂直于 $\mathbf{e}<em>1, \dots, \mathbf{e}</em>{i-1}$ 张成的向量空间。此时可以把问题转换为<strong>投影问题</strong>，只不过我们这里需要求投影问题中的<strong>误差</strong>，也就是原向量 $\mathbf{a}_i$ 减去它在投影到所有基 $\mathbf{e}_k$ 上的分量 $\mathbf{p}_k$：</p>
<p>$$
\mathbf{e}_i = \mathbf{a}<em>i - \sum\limits</em>{k=1}^{i-1}\mathbf{p}_k
\[2ex]
\mathbf{p}_k = \frac{\mathbf{e}_k<sup>T\mathbf{a}_i}{\mathbf{e}_k</sup>T\mathbf{e}_k}\mathbf{e}_k
$$</p>
</li>
<li class="lvl-3">
<p>最后还需要对 $\mathbf{e}_i$ 进行标准化。</p>
</li>
</ol>
<h3 id="QR分解">QR分解</h3>
<p>我们把得到的标准正交基写成矩阵的形式 $Q = \begin{bmatrix}\mathbf{e}_1 &amp; \mathbf{e}_2 &amp; \cdots &amp; \mathbf{e}_n \end{bmatrix}$，若令 $A = \begin{bmatrix}\mathbf{a}_1 &amp; \mathbf{a}_2 &amp; \cdots &amp; \mathbf{a}_n \end{bmatrix}$，则 $C(Q)$ 与 $C(A)$ 是同一个向量空间。</p>
<h1>由于 $Q$ 的列向量是 $C(Q)$ 空间中的标准正交基，则 $A$ 的列向量必能由 $Q$ 的列向量线性表示。前文提到，列变换相当于右乘一个置换矩阵，所以我们可以通过 $A=QR$ 得到如下等式：
$$
\begin{bmatrix}
\mathbf{a}_1 &amp; \mathbf{a}_2 &amp; \cdots &amp; \mathbf{a}_n
\end{bmatrix}</h1>
<p>\begin{bmatrix}
\mathbf{e}_1 &amp; \mathbf{e}_2 &amp; \cdots &amp; \mathbf{e}_n
\end{bmatrix}
·
\begin{bmatrix}
\mathbf{a}_1^T\mathbf{e}_1 &amp; \mathbf{a}_2^T\mathbf{e}_1 &amp; \cdots &amp; \mathbf{a}_n^T\mathbf{e}_1
\
\mathbf{a}_1^T\mathbf{e}_2 &amp; \mathbf{a}_2^T\mathbf{e}_2 &amp; \cdots &amp; \mathbf{a}_n^T\mathbf{e}_2
\
\vdots &amp; \vdots &amp; &amp; \vdots
\
\mathbf{a}_1^T\mathbf{e}_n &amp; \mathbf{a}_2^T\mathbf{e}_n &amp; \cdots &amp; \mathbf{a}_n^T\mathbf{e}_n
\end{bmatrix}
$$
其中矩阵 $R$ 为列变换的置换矩阵。</p>
<p>根据我们求正交基的步骤，每一个 $\mathbf{e}_i$ 都正交于 $\mathbf{a}_j\ (j &lt; i)$，因为 $\mathbf{a}_j$ 属于 $\mathbf{e}_1, \mathbf{e}<em>2,\dots,\mathbf{e}</em>{i-1}$ 张成的向量空间，而 $\mathbf{e}_i$ 与该向量空间正交。从而当 $j &lt; i$ 时，有 $\mathbf{a}_j^T\mathbf{e}_i = 0$，得到 $R$ 为上三角矩阵。</p>
<p>更清楚的表示为：
$$
R =
\begin{bmatrix}
\mathbf{a}_1^T\mathbf{e}_1 &amp; \mathbf{a}_2^T\mathbf{e}<em>1 &amp; \cdots &amp; \mathbf{a}</em>{n-1}^T\mathbf{e}_1 &amp; \mathbf{a}_n^T\mathbf{e}_1
\
0 &amp; \mathbf{a}_2^T\mathbf{e}<em>2 &amp; \cdots &amp; \mathbf{a}</em>{n-1}^T\mathbf{e}_2 &amp; \mathbf{a}<em>n^T\mathbf{e}<em>2
\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots
\
0 &amp; 0 &amp; \cdots &amp;  \mathbf{a}</em>{n-1}^T\mathbf{e}</em>{n-1} &amp; \mathbf{a}<em>n^T\mathbf{e}</em>{n-1}
\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; \mathbf{a}_n^T\mathbf{e}_n
\end{bmatrix}
$$</p>
<h2 id="进入第二部分：行列式">进入第二部分：行列式</h2>
<p>跟国内教材上来就给学生塞一堆行列式的定义与性质让你记忆和做题不一样，GS 在讲完矩阵后，把 <strong>“行列式作为属于矩阵的一个特性，包含大量矩阵的信息”</strong> 教授给大家，并从<strong>三个基本性质</strong>开始。</p>
<blockquote>
<p>行列式记为 $det(A) = |A|$。矩阵必须为方阵。</p>
</blockquote>
<h3 id="行列式性质">行列式性质</h3>
<ol>
<li class="lvl-3">
<p>$det(I) = 1$</p>
</li>
<li class="lvl-3">
<p>交换任意两行后，$det(A)$ 取相反数。</p>
</li>
<li class="lvl-3">
</li>
</ol>
<pre><code>- 数乘：
    $$
    \begin{vmatrix}
    ta &amp; tb
    \\
    c &amp; d
    \end{vmatrix}
    =
    t
    \begin{vmatrix}
    a &amp; b
    \\
    c &amp; d
    \end{vmatrix}
    $$
- 相加：
    $$
    \begin{vmatrix}
    a+a' &amp; b+b'
    \\
    c &amp; d
    \end{vmatrix}
    =
    \begin{vmatrix}
    a &amp; b
    \\
    c &amp; d
    \end{vmatrix}
    +
    \begin{vmatrix}
    a' &amp; b'
    \\
    c &amp; d
    \end{vmatrix}
    $$
</code></pre>
<p>更多的性质可以从以上基本性质中推导出：</p>
<ol start="4">
<li class="lvl-3">
<p>任意两行相等，行列式为 0。</p>
</li>
<li class="lvl-3">
<p>任意一行加上/减去另一行的 $k$ 倍，行列式值不变。</p>
</li>
<li class="lvl-3">
<p>若某一行为 0，则行列式为 0。</p>
</li>
<li class="lvl-3">
<p>上三角/下三角行列式的值等于其主对角线所有元素的乘积。</p>
<blockquote>
<p>$$
\begin{vmatrix}
a &amp; b
\
c &amp; d
\end{vmatrix}
= ad - bc
$$</p>
</blockquote>
</li>
<li class="lvl-3">
<p>若 $det(A) = 0$，则 $A$ 奇异/不可逆；反之非奇异/可逆。</p>
</li>
<li class="lvl-3">
<p>$det(AB) = det(A)det(B)$	$det(A^{-1}) = 1/det(A)$	$det(kA) = k^ndet(A)$</p>
</li>
<li class="lvl-4">
<p>$det(A^T) = det(A)$</p>
</li>
</ol>
<h3 id="代数余子式">代数余子式</h3>
<p>讲完性质，就来讲怎么对高阶方阵的行列式求值了。</p>
<p>$n$ 阶行列式中，任意位置 $a_{ij}$ 对应的<strong>代数余子式</strong> $C_{ij}$ 等于将第 $i$ 行第 $j$ 列从行列式中移除后，剩下部分构成的 $n-1$ 阶行列式<strong>的值</strong>，且其正负性由 $(-1)^{i+j}$ 表示。</p>
<p>行列式的值，等于任意一行中所有元素与其代数余子式乘积再求和，即<strong>代数余子式展开</strong>：
$$
det(A) = a_{i1}C_{i1} + a_{i2}C_{i2} + \dots + a_{in}C_{in} \quad (1 \leq i \leq n)
$$
对列也有类似的展开方法。</p>
<blockquote>
<p>一般来说很少用这方法，以<strong>消元法化为上三角行列式</strong>为主。</p>
</blockquote>
<h3 id="逆矩阵公式">逆矩阵公式</h3>
<p>已知二阶矩阵 $A = \begin{bmatrix}a &amp; b \ c &amp; d\end{bmatrix}$ 的行列式公式，则其逆矩阵为 $\displaystyle A^{-1} = \frac{1}{ad-bc} \begin{bmatrix}d &amp; -b \ -c &amp; a\end{bmatrix}$</p>
<p>事实上，<strong>任意矩阵的逆</strong>都可以写为这样一个形式：</p>
<p>$$
A^{-1} = \frac{1}{det(A)}C^T
\[2ex]
C = \begin{bmatrix}
C_{11} &amp; C_{12} &amp; \cdots &amp; C_{1n}
\
C_{21} &amp; C_{22} &amp; \cdots &amp; C_{2n}
\
\vdots &amp; \vdots &amp; &amp; \vdots
\
C_{n1} &amp; C_{n2} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
$$</p>
<p>其中 $C_{ij}$ 为 $A$ 中元素 $a_{ij}$ 的<strong>代数余子式</strong>。代数余子式矩阵 $C$ 的转置 $C^T$ 也称为 $A$ 的<strong>伴随矩阵</strong>。</p>
<p>对上式进行左乘 $A$，则有
$$
\frac{1}{det(A)}AC^T = \frac{1}{det(A)}\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}
\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}
\
\vdots &amp; \vdots &amp; &amp; \vdots
\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}
\begin{bmatrix}
C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}
\
C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}
\
\vdots &amp; \vdots &amp; &amp; \vdots
\
C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
$$
主对角线元素很好判断，就是行列式的<strong>代数余子式展开</strong>；对于其它元素，以 $\sum\limits_{i=1}^na_{2i}C_{1i}$ 为例，它可以视为 $A$ 的第一行元素全由第二行替换后的新矩阵 $A’$ 按第一行代数余子式展开，根据<strong>性质 4</strong>，我们得到 $det(A’)=0$，即最终结果仅有主对角线元素全为 1，其它都是 0——单位矩阵 $I$，恰好是 $AA^{-1}$，故该等式是正确的。</p>
<h3 id="克拉默法则">克拉默法则</h3>
<p>对于可逆矩阵 $A$，方程 $A\mathbf{x} = \mathbf{b}$ 必有形如下式的解：$\mathbf{x} = A^{-1}\mathbf{b}$</p>
<p>代入上面得到的逆矩阵公式，有
$$
\begin{bmatrix}
x_1
\
x_2
\
\vdots
\
x_n
\end{bmatrix}
= \mathbf{x} = \frac{1}{det(A)}C^T\mathbf{b} = \frac{1}{det(A)}
\begin{bmatrix}
C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}
\
C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}
\
\vdots &amp; \vdots &amp; &amp; \vdots
\
C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
\begin{bmatrix}
b_1
\
b_2
\
\vdots
\
b_n
\end{bmatrix}
$$
根据之前得到的结论，$\sum\limits_{i=1}^nb_kC_{ik}$ 可以视为将 $A$ 的第 $k$ 列用 $\mathbf{b}$ 替换后得到的新矩阵 $B_k$ 的行列式值，从而得到
$$
x_k = \frac{det(B_k)}{det(A)}
$$</p>
<blockquote>
<p>评价为：<strong>没消元法好用，但确实也是一个可行的方法</strong>。</p>
</blockquote>
<h3 id="几何度量">几何度量</h3>
<p>二阶行列式 $|det(A)|$ 等于 $A$ 行（列）向量构成的平行四边形的面积。</p>
<p>三阶行列式 $|det(A)|$ 等于 $A$ 行（列）向量构成的平行六面体的体积。</p>
<h2 id="进入下一个议题：特征向量与特征值">进入下一个议题：特征向量与特征值</h2>
<p>将矩阵 $A$ 与向量 $\mathbf{x}$ 相乘当做是对向量的一种操作或者函数，输入 $\mathbf{x}$ 而输出 $A\mathbf{x}$ 。<strong>特征向量</strong>即在特定的向量 $\mathbf{x}$ 方向上输出的 $A \mathbf{x}$ 平行于 $\mathbf{x}$ ，即为：
$$
A\mathbf{x} = \lambda\mathbf{x}
$$
其中 $\mathbf{x}$ 为 $A$ 的<strong>特征向量</strong>，$\lambda$ 为 $A$ 的<strong>特征值</strong>。</p>
<h3 id="如何求解特征值与特征向量？">如何求解特征值与特征向量？</h3>
<p>直接上结论：<strong>求解特征值等价于求解方程</strong> $det(A-\lambda I) = 0$</p>
<p>并且有：</p>
<ol>
<li class="lvl-3">
<p>矩阵的<strong>迹</strong>（对角线所有元素之和）等于<strong>特征值之和</strong>。</p>
</li>
<li class="lvl-3">
<p>对称矩阵的特征向量<strong>正交</strong>。</p>
<blockquote>
<p>设 $\mathbf{x}_1, \mathbf{x}_2$ 分别是 $A$ 对应特征值 $\lambda_1, \lambda_2$ 的特征向量，有
$$
\begin{align}
A\mathbf{x}_1 &amp;= \lambda_1\mathbf{x}_1
\[2ex]
\mathbf{x}_2^TA\mathbf{x}_1 &amp;= \lambda_1\mathbf{x}_2^T\mathbf{x}_1
\[2ex]
(A<sup>T\mathbf{x}_2)</sup>T\mathbf{x}_1 &amp;= \lambda_2\mathbf{x}_2^T\mathbf{x}_1
\[2ex]
(\lambda_1 - \lambda_2)\mathbf{x}_2^T\mathbf{x}_1 &amp;= 0
\end{align}
$$</p>
<p>由于 $\lambda_1 \neq \lambda_2$，所以 $\mathbf{x}_2^T\mathbf{x}_1 = 0$，故其正交。</p>
</blockquote>
</li>
</ol>
<h3 id="对角化">对角化</h3>
<h1>如果矩阵 $A$ 有 $n$ 个线性无关的特征向量 $\mathbf{x_i}$ ，将其作为矩阵 $S$ 的列向量，则
$$
AS = A
\begin{bmatrix}
\mathbf{x_1} &amp; \mathbf{x_2} &amp; \cdots &amp; \mathbf{x_n}
\end{bmatrix}</h1>
<h1>\begin{bmatrix}
\lambda_1\mathbf{x_1} &amp; \lambda_2\mathbf{x_2} &amp; \cdots &amp; \lambda_n\mathbf{x_n}
\end{bmatrix}</h1>
<h1>\begin{bmatrix}
\mathbf{x_1} &amp; \mathbf{x_2} &amp; \cdots &amp; \mathbf{x_n}
\end{bmatrix}
·
\begin{bmatrix}
\lambda_1 &amp; 0 &amp; \cdots &amp; 0
\
0 &amp; \lambda_2 &amp; \cdots &amp; 0
\
\vdots &amp; \vdots &amp; &amp; \vdots
\
0 &amp; 0 &amp; \cdots &amp; \lambda_n
\end{bmatrix}</h1>
<p>S\Lambda
$$
我们得到 $S^{-1}AS = \Lambda$，其中 $\Lambda$ 为对角矩阵，其对角线上所有元素都是 $A$ 的特征值，而且这些特征值的排布与 $S$ 中特征向量的排布是一致的。同时我们可以得到这样一个<strong>新的分解方式</strong>：$A = S\Lambda S^{-1}$。</p>
<p>如果 $A\mathbf{x} = \lambda\mathbf{x}$，则有 $A^2\mathbf{x} = A ·\lambda\mathbf{x} = \lambda^2\mathbf{x}$，所以 $A^2$ 有着和 $A$ 同样的特征向量，且对应的特征值为 $\lambda^2$。</p>
<p>我们甚至能进一步推测出，如果 $A\sim\lambda$，则 $A<sup>k\sim\lambda</sup>k$，且有 $A^k = S\Lambda^k S^{-1}$。</p>
<blockquote>
<p>若 $|\lambda| &lt; 1$，则 $\lim\limits_{k\rightarrow\infty} A^k = O$</p>
</blockquote>
<p>式子 $S^{-1}AS = \Lambda$ 被称为矩阵的<strong>对角化</strong>。矩阵能够对角化的<strong>充要条件</strong>为：<strong>矩阵有 $n$ 个线性无关的特征向量</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果矩阵没有重复特征值，则根据前文描述，矩阵的特征向量必然线性无关，故必然可对角化。</p>
</li>
<li class="lvl-2">
<p>如果矩阵有重复特征值，则需要进一步深究——事实上，如果一个特征值重复了 $k$ 次（或称<strong>代数重度</strong>），我们希望它对应 $k$ 个线性无关的特征向量。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>Linear Algebra 1</title>
    <url>/note/linearalgebra1/</url>
    <content><![CDATA[<p>如果本科线代能有这样的教育方式和路线，我何苦现在还要来听这门公开课(</p>
<p>记录一下听的过程中觉得有用的信息好了。</p>
<span id="more"></span>
<h2 id="从线性方程组开始">从线性方程组开始</h2>
<p>教授（下简称 GS）认为线性代数的基本用途是解<strong>线性方程组</strong>，比如有这样一个方程组：
$$
\begin{cases}
2x-y = 0
\[2ex]
-x+2y=3
\end{cases}
$$
我们可以从以下三个角度考虑其解法。</p>
<ol>
<li class="lvl-3">
<p><strong>行图像</strong>：对于每个方程，我们都可以在二维平面上画出一条直线，这些直线的交点就是我们想要的解；</p>
</li>
<li class="lvl-3">
<p><strong>列图像</strong>：对于每个变量的参数，我们都可以把方程组写成若干向量线性组合的形式（本例中是 $x\left[\begin{matrix}2 \ -1\end{matrix}\right] + y\left[\begin{matrix}-1 \ 2\end{matrix}\right] = \left[\begin{matrix}0 \ 3\end{matrix}\right]$）。只要找到一个合适的组合，方程组得解；</p>
<blockquote>
<p>此处如果如果每次取任意的 x 与 y，则等式左侧的向量的组合能布满整个二维平面。</p>
<p>拓展到多元方程组也是同理。</p>
</blockquote>
</li>
</ol>
<p>我们构造一个系数矩阵 ${A} = \left[\begin{matrix}2 &amp; -1 \ -1 &amp; 2\end{matrix}\right]$，令 $\mathbf{x} = \left[\begin{matrix}x \ y\end{matrix}\right], \mathbf{b} = \left[\begin{matrix}0 \ 3\end{matrix}\right]$，然后方程组可以写成这样子：
$$
A\mathbf{x} = \mathbf{b}
$$</p>
<h3 id="是否有解？">是否有解？</h3>
<p>这时要考虑一个问题：是否任意 $\mathbf{b}$ 都能让上面那个方程有解呢？</p>
<p>从<strong>行图像</strong>的角度来讲，如果方程组有解，则所有方程在坐标系上对应的图像（直线、平面、体积）存在交集。如果某一个 $\mathbf{b}$ 不能满足上面条件，则无解（反之有解）。</p>
<p>从<strong>列图像</strong>的角度来讲，如果某一个 $\mathbf{b}$ 不能成为 ${A}$ 列向量的线性组合，则无解（反之有解）。</p>
<h3 id="如何求解？">如何求解？</h3>
<p>计算机软件（以及人类）计算时最常用的方法是<strong>高斯消元法</strong>，将原方程 ${A}\mathbf{x} = \mathbf{b}$ 转换为新的方程 ${U}\mathbf{x}=\mathbf{c}$。</p>
<blockquote>
<p>其中 ${U}$ 为行阶梯最简型矩阵。</p>
</blockquote>
<h3 id="消元过程">消元过程</h3>
<p>每一步消元都可以视为将原矩阵乘上一个<strong>置换矩阵</strong>。左乘置换矩阵可以完成原矩阵的行变换，右乘置换矩阵则为列变换。</p>
<h3 id="逆矩阵">逆矩阵</h3>
<p>对于消元过程，每一步都是可逆的。对于一个置换矩阵 $E_1$，我做了其相反的操作即可得到原矩阵，若这一相反的操作用 $E_1^{‘}$ 表示，则有 $E_1^{’}  E_1  A =  A$ 。</p>
<p>得到 $E_1^{‘}  E_1 =  {I}$，从而可以用 $E_1^{’} = { E_1}^{-1}$ 表示逆矩阵。第一个式子代表了逆矩阵的定义与性质。同样也有 $(E_1<sup>{'})</sup>{-1} = {E_1}$ 且 $E_1 E_1^{'} = {I}$ 。</p>
<blockquote>
<p>其中 $I$ 是<strong>单位矩阵</strong>（对角线元素全为 1，其它元素全为 0 的方阵）</p>
</blockquote>
<h3 id="怎么求逆矩阵？">怎么求逆矩阵？</h3>
<p><strong>高斯-若尔当消元法</strong>(Gauss-Jordan Elimination)告诉我们，通过构造 $\left[\begin{matrix}\ {A}\ |\ {I}\ \end{matrix}\right]$，再通过消元法将左侧矩阵变为单位矩阵 ${I}$，易得这一系列行变换操作对应的矩阵是 ${A}^{-1}$，相当于左乘了一个矩阵 ${A}^{-1}$，则右侧矩阵乘完后自然就变为了 ${A}^{-1}$。</p>
<h2 id="接下来引入拓展到向量空间">接下来引入拓展到向量空间</h2>
<h3 id="向量空间">向量空间</h3>
<p>一个向量空间应该满足这样一个<strong>封闭性</strong>条件：对于空间中的任意向量 $\mathbf{u}, \mathbf{v}$，其任意线性组合 $a\mathbf{u}+b\mathbf{v}(a, b\in R)$ 必然存在于空间中。显然，所有向量空间必须包括零向量。</p>
<h3 id="子空间">子空间</h3>
<p>包含于向量空间之内的一个向量空间称为原向量空间的一个子空间。</p>
<p>以 ${R}^3$ 为例（它代表具有三个实数分量的所有向量的集合），其子空间包括：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>其本身（三维）</p>
</li>
<li class="lvl-2">
<p>任一过原点的平面（二维）</p>
</li>
<li class="lvl-2">
<p>任一过原点的直线（一维）</p>
</li>
<li class="lvl-2">
<p>零向量</p>
</li>
</ul>
<h3 id="列空间">列空间</h3>
<p>矩阵 ${A}_{m\times n}$ 的所有列向量张成的空间称为其列空间，以 $C({A})$ 表示。$C({A})\subset R^m$</p>
<h3 id="零空间">零空间</h3>
<p>所有满足方程 ${A}\mathbf{x} = \mathbf{0}$ 的解的集合称为矩阵 ${A}_{m\times n}$ 的零空间，以 $N({A})$ 表示。$N({A})\subset R^n$</p>
<h3 id="计算零空间">计算零空间</h3>
<p>相当于求方程 ${A}\mathbf{x} = \mathbf{0}$ 的所有解。通过<strong>消元法与列交换</strong>构造出新的方程 ${U}\mathbf{x}=\mathbf{0}$，其中 ${U}$ 是由 $r$ 个<strong>主元列</strong>与 $n-r$ 个<strong>自由列</strong>组成的形如下式的行阶梯型矩阵：
$$
U =
\left[
\begin{matrix}
\quad I_{r\times r} &amp; F_{r\times n-r} \quad
\
\quad 0 &amp; 0 \quad
\end{matrix}
\right]
$$</p>
<blockquote>
<p>自由列可以表示为其左侧主元列的线性组合。</p>
</blockquote>
<p>原方程变为 ${U}$ 的主元行乘以 $\mathbf{x}$，即 $\left[\begin{matrix}\ {I}\ |\ {F}\ \end{matrix}\right] \left[\begin{matrix}\  \mathbf x_{pivot} \ \  \mathbf x_{free} \ \end{matrix}\right] =  0$。如果对 $\mathbf x_{free}$ 中 $n-r$ 的变量自由取值，我们能得到 $n-r$ 个线性无关的特解，$N({A})$ 则是由这些特解张成的向量空间（<strong>维度</strong>为 $n-r$）。若把这些特解作为列向量写到一个矩阵 ${N}$ 中，则有 ${U}{N} = {0}$，易得：
$$
N =
\left[\begin{matrix}\ {-F}<em>{r\times n-r} \ \ \ I</em>{n-r\times n-r} \ \end{matrix}\right]
$$
其中 ${-F}$ 对应 $\mathbf{x}<em>{pivot}$，${I}$ 对应 $\mathbf{x}</em>{free}$</p>
<h3 id="如果方程右侧不为零向量">如果方程右侧不为零向量</h3>
<p>首先抛出结论：若 $\mathbf{b} \in C({A})$，则方程 ${A}\mathbf{x} = \mathbf{b}$ 有解。</p>
<p>当方程有解时，可以先找到方程一个特解，再与 $N({A})$ 进行线性组合，即可得到最后的解。</p>
<h3 id="秩">秩</h3>
<p>矩阵的<strong>秩</strong>等于矩阵的主元数。若 $rank({A}_{m\times n}) = r$，则必有 $r\leq m, r\leq n$ 。</p>
<ol>
<li class="lvl-3">
<p><strong>列满秩</strong>：即 $r=n&lt;m$，每一列都是主元列，矩阵没有自由列，$N({A})$ 中只有零向量，方程 ${A}\mathbf{x} = \mathbf{b}$ 要么无解，要么有唯一解。</p>
</li>
<li class="lvl-3">
<p><strong>行满秩</strong>：即 $r=m\leq n$，方程 ${A}\mathbf{x} = \mathbf{b}$ 有无穷多解。</p>
</li>
<li class="lvl-3">
<p><strong>方阵满秩</strong>：即 $r=m=n$，方程 ${A}\mathbf{x} = \mathbf{b}$ 总有唯一解。</p>
</li>
<li class="lvl-3">
<p><strong>行列均不满秩</strong>：即 $r&lt;m, r&lt;n$，方程 ${A}\mathbf{x} = \mathbf{b}$ 要么无解，要么有无穷多解。</p>
</li>
</ol>
<h3 id="线性相关性">线性相关性</h3>
<p>若一组向量的非零线性组合可以得到零向量，则称这组向量<strong>线性相关</strong>；反之，则称其<strong>线性无关</strong>。</p>
<h3 id="基">基</h3>
<p>向量空间的<strong>基</strong>是一组<strong>线性无关的向量</strong>，且这些向量能够张成该向量空间。</p>
<h3 id="维数">维数</h3>
<p>空间中的每一组基都有相同的向量数，这个数值就是空间的<strong>维数</strong>，通常用 $dim$ 表示。</p>
<h3 id="基本子空间">基本子空间</h3>
<p>除了列空间和零空间，还有</p>
<ol>
<li class="lvl-3">
<p><strong>行空间</strong>：矩阵 ${A}_{m\times n}$ 的所有行向量张成的空间称为其列空间，以 $R({A})$ 表示。$R({A})\subset R^n$；</p>
</li>
<li class="lvl-3">
<p><strong>左零空间</strong>：所有满足方程 ${A^T}{x} = {0}$ 的解的集合称为矩阵 ${A}_{m\times n}$ 的左零空间，以 $L({A})$ 表示。$L({A})\subset R^m$；</p>
</li>
</ol>
<p>${A}$ 的 $r$ 个主元列构成了 $C({A})$ 的一组基。</p>
<p>${A}\mathbf{x}=\mathbf{0}$ 的一组特解对应于 ${A}$ 的 $n-r$ 个自由列，并构成了 $N({A})$ 的一组基。</p>
<p>则得到这样一个结论：</p>
<p>$$
rank(A) = # C_{pivot} = dim(C(A)) = r = dim(R(A))
$$</p>
<p>同样的：</p>
<p>$$
#C_{free} = dim(N(A)) = n - r
\[2ex]
dim(L(A)) = m-r
$$</p>
<p>不妨用下图来表示这一切</p>
<img src="image-20220929160748771.png" alt="image-20220929160748771" style="zoom:67%;">
]]></content>
      <categories>
        <category>Note</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 常用命令 の Note</title>
    <url>/linux/linuxcommandnote/</url>
    <content><![CDATA[<p>记录常用命令及对应的常用 option，方便查。</p>
<span id="more"></span>
<h2 id="切换用户当前工作目录-cd">切换用户当前工作目录 - cd</h2>
<p>全称为 <code>change directory</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">### example:</span>
<span class="token comment">## 绝对路径</span>
<span class="token builtin class-name">cd</span> /usr/bin

<span class="token comment">## 相对路径</span>
<span class="token builtin class-name">cd</span> ./foo/bar/dir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="打印当前工作目录-pwd">打印当前工作目录 - pwd</h2>
<p>全称为 <code>print working directory</code></p>
<h2 id="新建目录-mkdir">新建目录 - mkdir</h2>
<p>全称为 <code>make directory</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token punctuation">[</span>-mp<span class="token punctuation">]</span> <span class="token function">dirname</span>
<span class="token comment">## -m: 指定目录权限</span>
<span class="token comment">## -p: 若父级目录不存在，则一并新建</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="删除空目录-rmdir">删除空目录 - rmdir</h2>
<p>全称为 <code>remove directory</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rmdir</span> <span class="token punctuation">[</span>p<span class="token punctuation">]</span> <span class="token function">dirname</span>
<span class="token comment">## -p: 若父级目录为空，则一并删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="显示目录内容列表-ls">显示目录内容列表 - ls</h2>
<p>全称为 <code>list</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">ls</span> <span class="token punctuation">[</span>-al<span class="token punctuation">]</span> <span class="token punctuation">[</span>path<span class="token punctuation">]</span>
<span class="token comment">## -a: 列出所有文件，包括以 '.' 开头的隐藏文件</span>
<span class="token comment">## -l: 列出详细信息，包括文件属性、修改日期等</span>

<span class="token comment">## path: 若为目录，啧列出指定目录下内容；反之，打印 path</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="拷贝文件或目录-cp">拷贝文件或目录 - cp</h2>
<p>全称为 <code>copy</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> <span class="token punctuation">[</span>-filprs<span class="token punctuation">]</span> src dst
<span class="token comment">## -f: 强制执行</span>
<span class="token comment">## -i: 询问是否拷贝</span>
<span class="token comment">## -l: 改为建立 hard link</span>
<span class="token comment">## -p: 保留原权限，而非使用默认权限</span>
<span class="token comment">## -r: 递归拷贝</span>
<span class="token comment">## -s: 改为建立 soft link</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>拷贝得到的新文件/目录，其 user:group 为命令执行者</p>
</blockquote>
<h2 id="移动文件或目录-mv">移动文件或目录 - mv</h2>
<p>全称为 <code>move</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mv</span> <span class="token punctuation">[</span>-fi<span class="token punctuation">]</span> src dst
<span class="token comment">## -f: 强制执行</span>
<span class="token comment">## -i: 询问是否移动</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="删除文件或目录-rm">删除文件或目录 - rm</h2>
<p>全称为 <code>remove</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">rm</span> <span class="token punctuation">[</span>-fir<span class="token punctuation">]</span> 文件或目录
<span class="token comment">## -f: 强制删除</span>
<span class="token comment">## -i: 询问是否删除</span>
<span class="token comment">## -r: 递归删除</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="修改文件拥有者-chown">修改文件拥有者 - chown</h2>
<p>全称为 <code>change owner</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chown</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> username<span class="token punctuation">[</span>:groupname<span class="token punctuation">]</span> dirname/filename
<span class="token comment">## -R/--recursive: 递归处理</span>
<span class="token comment">## 若附带 :groupname 则会将所属群组一并修改</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="修改文件所属群组-chgrp">修改文件所属群组 - chgrp</h2>
<p>全称为 <code>change group</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">chgrp</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> dirname/filename <span class="token punctuation">..</span>.
<span class="token comment">## -R/--recursive: 递归处理</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="修改文件权限-chmod">修改文件权限 - chmod</h2>
<p>全称为 <code>change group</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment">### 数字类型</span>
<span class="token function">chmod</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> xyz 文件或目录
<span class="token comment">## -R: 进行递归(recursive)的持续变更，亦即连同次目录下的所有文件都会变更</span>
<span class="token comment">## xyz: 数字类型的权限属性，为 rwx 属性数值的相加。</span>

<span class="token comment">### 符号类型</span>
<span class="token function">chmod</span> <span class="token punctuation">[</span>-R<span class="token punctuation">]</span> <span class="token punctuation">[</span>ugoa<span class="token punctuation">]</span><span class="token punctuation">[</span>+-<span class="token operator">=</span><span class="token punctuation">]</span><span class="token punctuation">[</span>rwx<span class="token punctuation">]</span> 文件或目录
<span class="token comment">## u: user     +: 加上    r: 可读</span>
<span class="token comment">## g: group    -: 减去    w: 可写</span>
<span class="token comment">## o: other    =: 赋予    x: 可执行</span>
<span class="token comment">## a: all</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="连接多个文件并打印到标准输出-cat">连接多个文件并打印到标准输出 - cat</h2>
<p>全称为 <code>concatenate</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token punctuation">[</span>-ns<span class="token punctuation">]</span> file1 file2 <span class="token punctuation">..</span>.
<span class="token comment">## -n: 显示行号，等同于 nl</span>
<span class="token comment">## -s: 压缩连续的空行为一行</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="翻页显示文件内容-more-less">翻页显示文件内容 - more/less</h2>
<h2 id="打包、压缩与解压缩-tar">打包、压缩与解压缩 - tar</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token punctuation">[</span>-j<span class="token operator">|</span>-z<span class="token punctuation">]</span> <span class="token punctuation">[</span>-cv<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f dst<span class="token punctuation">]</span> filename<span class="token punctuation">..</span>. <span class="token comment">## 将 filename 打包为 dst</span>
<span class="token function">tar</span> <span class="token punctuation">[</span>-j<span class="token operator">|</span>-z<span class="token punctuation">]</span> <span class="token punctuation">[</span>-tv<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f src<span class="token punctuation">]</span>             <span class="token comment">## 查看档名</span>
<span class="token function">tar</span> <span class="token punctuation">[</span>-j<span class="token operator">|</span>-z<span class="token punctuation">]</span> <span class="token punctuation">[</span>-xv<span class="token punctuation">]</span> <span class="token punctuation">[</span>-f src<span class="token punctuation">]</span> <span class="token punctuation">[</span>-C dir<span class="token punctuation">]</span>    <span class="token comment">## 解压缩 src 至指定目录</span>
<span class="token comment">## -j: 以 bzip2 方式压缩/解压，后缀最好为 tar.bz2</span>
<span class="token comment">## -z: 以 gzip 方式压缩/解压，后缀最好为 tar.gz</span>

<span class="token comment">## -c: 创建压缩文件</span>
<span class="token comment">## -t: 查看压缩文件内容</span>
<span class="token comment">## -x: 解压</span>

<span class="token comment">## -C: 解压文件存放的位置，不加就放到当前目录</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>-c, -t, -x 三者不共存</p>
</blockquote>
<h2 id="查看磁盘使用情况-df">查看磁盘使用情况 - df</h2>
<p>全称为 <code>disk free</code></p>
<h2 id="显示文件或目录占用磁盘空间大小-du">显示文件或目录占用磁盘空间大小 - du</h2>
<p>全称为 <code>disk usage</code></p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">du</span> <span class="token punctuation">[</span>-schbkm<span class="token punctuation">]</span> /path/to/dir/or/file
<span class="token comment">## -s: 仅显示占用量之和</span>
<span class="token comment">## -c: 不仅显示单个占用量，也显示总和</span>
<span class="token comment">## -h: 以 K, M, G 为单位，提高可读性</span>
<span class="token comment">## -b: 以 Byte 为单位</span>
<span class="token comment">## -k: 以 KB 为单位</span>
<span class="token comment">## -m: 以 MB 为单位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="查看内存使用情况-free">查看内存使用情况 - free</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">free</span> <span class="token punctuation">[</span>-thbkmg<span class="token punctuation">]</span>
<span class="token comment">## -t: 显示总和</span>
<span class="token comment">## -h: 以 K, M, G 为单位，提高可读性</span>
<span class="token comment">## -b: 以 Byte 为单位</span>
<span class="token comment">## -k: 以 KB 为单位</span>
<span class="token comment">## -m: 以 MB 为单位</span>
<span class="token comment">## -g: 以 GB 为单位</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="实时显示内存使用情况-top">实时显示内存使用情况 - top</h2>
<h2 id="查看当前进程状态-ps">查看当前进程状态 - ps</h2>
<p>全称为 <code>process status</code></p>
<p>通常搭配 <code>aux</code> 选项，意思是查看当前<strong>所有终端(x)<strong>上</strong>所有用户(a)<strong>的进程状态，并输出</strong>用户标识符列(u)</strong>。</p>
<h2 id="杀掉进程-kill">杀掉进程 - kill</h2>
<p>它发送信号给指定的进程，让进程执行相应的操作。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">kill</span> <span class="token punctuation">[</span>-ls<span class="token punctuation">]</span> <span class="token operator">&lt;</span>PID<span class="token operator">&gt;</span>
<span class="token comment">## -l 列出可用的信号列表，常用的有：</span>
<span class="token comment">##     1 (SIGHUP)：挂起信号，通常用于重新加载配置文件。</span>
<span class="token comment">##     2 (SIGINT)：中断信号，通常由 Ctrl+C 发送，用于终止进程。</span>
<span class="token comment">##     9 (SIGKILL)：强制终止信号，立即终止进程，不允许进程做清理工作。</span>
<span class="token comment">##     15 (SIGTERM)：终止信号，通常用于优雅地终止进程。</span>
<span class="token comment">## -s &lt;SIGNAL&gt;: 指定要发送的信号名，默认为 15</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="显示网卡参数-ifconfig">显示网卡参数 - ifconfig</h2>
<h2 id="查看网络系统状态信息-netstat">查看网络系统状态信息 - netstat</h2>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>最长递增子序列 の O(nlogn)</title>
    <url>/algorithm/longestincreasingsubsequence/</url>
    <content><![CDATA[<p><strong>最长递增子序列</strong>(Longest Increasing Subsequence, LIS) 是非常经典的一个算法问题。</p>
<span id="more"></span>
<blockquote>
<p>在计算机科学中，<strong>最长递增子序列</strong>（longest increasing subsequence）问题是指，在一个给定的数值序列中，找到一个子序列，使得这个子序列元素的数值依次递增，并且这个子序列的长度尽可能地大。最长递增子序列中的元素在原序列中不一定是连续的。许多与数学、算法、随机矩阵理论、表示论相关的研究都会涉及最长递增子序列。</p>
<p>例如，对于以下的原始序列：</p>
<p><code>0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15</code></p>
<p>最长递增子序列为</p>
<p><code>0, 2, 6, 9, 11, 15</code></p>
<p>值得注意的是原始序列的最长递增子序列并不一定唯一，对于该原始序列，实际上还有以下三个最长递增子序列</p>
<p><code>0, 4, 6, 9, 11, 15</code></p>
<p><code>0, 4, 6, 9, 13, 15</code></p>
<p><code>0, 2, 6, 9, 13, 15</code></p>
<p>【以上摘自 <a href="https://zh.wikipedia.org/zh-cn/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97"><strong>wikipedia</strong></a>】</p>
</blockquote>
<h2 id="动态规划求解">动态规划求解</h2>
<p>动态规划所使用的时间复杂度为 $O(n^2)$</p>
<p>令当前元素为 <code>x</code>，对于之前的每个比其小的元素 <code>y</code>，以 <code>x</code> 结尾的最长递增子序列 $\text{LIS}_x$ 都有可能是在以 <code>y</code> 结尾的 $\text{LIS}_y$ 基础上将 <code>x</code> 执行 append，即 $\text{LIS}_x = \text{LIS}_y.\text{append}(x)$。</p>
<p>若要使 <code>LISx</code> 最长，就必须找到一个最长的 $\text{LIS}_y$。假设状态 $\text{LEN}_x$ 表示 $\text{LIS}_x$ 的最大长度，那么有</p>
<p>$$
\text{LEN}<em>x = \max(\text{LEN}</em>{y_i}) + 1, \quad y_i &lt; x
$$</p>
<p>转换成代码风格就是（以 C++ 代码为例）：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>LIS_dp.cpp</span></div><code class="language-cpp"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    maxLength <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span>maxLength<span class="token punctuation">,</span> len<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  len<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> maxLength <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后遍历所有元素结尾的 <code>LEN</code>，找到最大的那个即可。</p>
<h3 id="缺点">缺点</h3>
<p>动态规划方法的一个缺点在于——状态的<strong>冗余</strong>检查。极端情况下，如果一个序列严格递增，比如 <code>1, 2, 3, 4, 5, 6</code> ，那么其 <code>LIS</code> 就是本身，但在遍历到元素 <code>3</code> 的时候，其会把 $\text{LIS}_1$ 与 $\text{LIS}_2$ 都检查一遍。事实上， $\text{LIS}_2$ 包含了 $\text{LIS}_1$，对后者的检查是完全没有必要的。</p>
<p>更别说后面的 <code>4</code>, <code>5</code>, <code>6</code> 了。</p>
<blockquote>
<p>需要找到一个方法来消除该冗余，最好是遍历到某一元素 <code>x</code> 时，我们已经知道 $\text{LIS}_x$ 与前面所有元素的关系。</p>
</blockquote>
<h2 id="nlogn">nlogn</h2>
<p>换个思路，将所要存储的状态修改为「长度为 k 的 <code>LIS</code> 的最后一个元素」，看看事情是否有所转机？</p>
<p>以序列 <code>5, 1, 4, 2, 8, 7, 9, 0, 3, 6</code> 为例：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>i = 0</code> 时，<code>lastElementWithLength[1]</code> 为 5，这很显然；</p>
<blockquote>
<p>lastElementWithLength: 5</p>
</blockquote>
</li>
<li class="lvl-2">
<p><code>i = 1</code> 时，1 比 5 小，为了使后续元素更容易得到 append，将 <code>lastElementWithLength[1]</code> 改为 3；</p>
<blockquote>
<p>lastElementWithLength: 1</p>
</blockquote>
</li>
<li class="lvl-2">
<p><code>i = 2</code> 时，4 比 1 大，可以作为递增子序列 <code>1, 4</code> 的最后一个元素，所以令 <code>lastElementWithLength[2]</code> 为 4；</p>
<blockquote>
<p>lastElementWithLength: 1, 4</p>
</blockquote>
</li>
<li class="lvl-2">
<p><code>i = 3</code> 时，2 比 4 小，但比 1 大，根据前面的理论，将 <code>lastElementWithLength[2]</code> 改为 2。当然这并不是说前面的 <code>4</code> 就消失了，它依然可以作为递增子序列 <code>1, 4</code> 的一部分，但是一旦后续出现数字 <code>3</code>，它会更倾向于比自己小并且长度不低的 <code>2</code>；</p>
<blockquote>
<p>lastElementWithLength: 1, 2</p>
</blockquote>
</li>
</ul>
<p>以此类推，我们最终可以得到这样一个 <code>lastElementWithLength</code> 数组：</p>
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
</tr>
</tbody>
</table>
<p>可以得到 LIS 的长度为 4，并且以 <code>6</code> 结尾。</p>
<blockquote>
<p>LIS 为 <code>1, 2, 3, 6</code></p>
</blockquote>
<p>我们并不用在意之前有什么，只需要知道当前的元素必须被尽可能长的子序列 append 就可以了。对于那些末尾元素比自己还小的，肯定能进行 append 操作，而那些末尾元素比自身大的，则有可能取而代之，很典型的就是上面 <code>i=3</code> 时的情况。</p>
<p>事实上，在 <code>lastElementWithLength</code> 数组中，有且仅有第一个比自己大的那个元素 <code>first</code> 能进行取代，毕竟前面的那些再大也不会超过自身，<code>first</code> 也是在前者的基础上加入的数组，尽管取代了，也比之前的所有元素大。而后面的那些更大的元素，也必然是在 <code>first</code> 的基础上建立，其对应的递增子序列必然包含 <code>first</code>（或者更大的元素），一旦取代就会破坏 LIS 的规则。</p>
<p>所以问题又转变成了：在 <code>lastElementWithLength</code> 数组中找到第一个比自己大的元素。这不就<strong>二分法</strong>么？如果找不到，直接在末尾添加便是！</p>
<p>这样一来，遍历的过程中每个元素执行一次二分法，在最极端（也就是原始数组严格递增）的情况下也仅仅需要 $O(n\log n)$ 的时间复杂度，比起动态规划，开销大大降低。</p>
<h2 id="应用">应用</h2>
<p>传送门：</p>
<ol>
<li class="lvl-3">
<p><a href="https://leetcode.cn/problems/russian-doll-envelopes/">&gt;&gt;&gt; LeetCode 354 俄罗斯套娃信封问题(Hard) &lt;&lt;&lt;</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Algorithm</category>
      </categories>
  </entry>
  <entry>
    <title>Build Hexo in WSL</title>
    <url>/guide/makehexo/</url>
    <content><![CDATA[<p>配了台新机子，不想用 Windows 管理这些东西，遂使用更贴近使用习惯的 WSL。</p>
<span id="more"></span>
<h2 id="WSL-安装">WSL 安装</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">wsl <span class="token parameter variable">--install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>然后要求重启，重启后设置 <code>user</code> 和 <code>passwd</code>。</p>
<blockquote>
<p>现在每次进去都是 root 身份，可以通过 <code>wsl config --default-user &lt;username&gt;</code> 设置默认用户。</p>
</blockquote>
<h3 id="😏修改默认安装目录到其他盘-Optional">😏修改默认安装目录到其他盘(Optional)</h3>
<p>因为默认装在 C 盘，希望 C 盘纯净一点的可以这么干。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 获取 Name 列的值，比如我这里是 "Ubuntu"</span>
wsl <span class="token parameter variable">-l</span> <span class="token parameter variable">--all</span> <span class="token parameter variable">-v</span>

<span class="token comment"># 导出到 D 盘                     </span>
wsl <span class="token parameter variable">--export</span> Ubuntu D:/ubuntu.tar

<span class="token comment"># 注销原来的发行版</span>
wsl <span class="token parameter variable">--unregister</span> Ubuntu

<span class="token comment"># 将之前导出的 ubuntu.tar 导入到目录 D:/Ubuntu 下</span>
wsl <span class="token parameter variable">--import</span> Ubuntu D:/Ubuntu D:/ubuntu.tar <span class="token parameter variable">--version</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然后用 Vscode 直连即可。</p>
<h2 id="相关工具安装">相关工具安装</h2>
<h3 id="Git">Git</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">git</span>

<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.name <span class="token string">"your_github_name"</span>

<span class="token function">git</span> config <span class="token parameter variable">--global</span> user.email <span class="token string">"your_github_email"</span>

ssh-keygen <span class="token parameter variable">-t</span> rsa <span class="token parameter variable">-C</span> <span class="token string">"your_github_email"</span>

<span class="token comment"># 然后将 ~/.ssh/id_rsa.pub 的内容全部拷贝到 Github 中</span>
<span class="token comment"># 用 ssh -T git@github.com 验证</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="Node-js-npm">Node.js &amp; npm</h3>
<p>如果直接 <code>sudo apt install nodejs npm</code> 的话是无法正常进行后续工作的，因为版本太老了。正确做法是用 <code>nvm</code> 这个版本管理器。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt</span> <span class="token function">install</span> <span class="token function">curl</span>

<span class="token comment"># 这一步如果超时也可以直接进链接把内容拷贝过来运行</span>
<span class="token function">curl</span> -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh <span class="token operator">|</span> <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果用的是 zsh，则在 <code>~/.zshrc</code> 中加入下面这段。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">NVM_DIR</span><span class="token operator">=</span><span class="token string">"<span class="token environment constant">$HOME</span>/.nvm"</span>
<span class="token punctuation">[</span> <span class="token parameter variable">-s</span> <span class="token string">"<span class="token variable">$NVM_DIR</span>/nvm.sh"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>. <span class="token string">"<span class="token variable">$NVM_DIR</span>/nvm.sh"</span>  <span class="token comment"># This loads nvm</span>
<span class="token punctuation">[</span> <span class="token parameter variable">-s</span> <span class="token string">"<span class="token variable">$NVM_DIR</span>/bash_completion"</span> <span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">\</span>. <span class="token string">"<span class="token variable">$NVM_DIR</span>/bash_completion"</span>  <span class="token comment"># This loads nvm bash_completion</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>之后用 <code>nvm -v</code> 验证是否安装成功。</p>
<p>若安装成功，则用 <code>nvm install node</code> 安装最新的 NodeJS 发行版本。</p>
<p>为了防止这一步很慢，可以在 <code>~/.zshrc</code> 中加入下面这段，以修改 nvm 源。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">NVM_NODEJS_ORG_MIRROR</span><span class="token operator">=</span>https://npmmirror.com/mirrors/node
<span class="token builtin class-name">export</span> <span class="token assign-left variable">NVM_IOJS_ORG_MIRROR</span><span class="token operator">=</span>https://npmmirror.com/mirrors/iojs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>最后用 <code>node -v</code> 和 <code>npm -v</code> 验证结果。</p>
<h3 id="hexo">hexo</h3>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> hexo-cli <span class="token parameter variable">-g</span>
<span class="token function">sudo</span> <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git <span class="token parameter variable">--save</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>如果很慢，则可以用 <code>npm config set registry http://mirrors.cloud.tencent.com/npm/</code> 修改镜像源</p>
]]></content>
      <categories>
        <category>Guide</category>
      </categories>
  </entry>
  <entry>
    <title>使用 Oh-My-Zsh 美化终端</title>
    <url>/guide/ohmyzsh/</url>
    <content><![CDATA[<p>比 bash 好看太多</p>
<span id="more"></span>
<blockquote>
<p>这里使用的是 Ubuntu</p>
</blockquote>
<h2 id="安装-zsh">安装 zsh</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> <span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">sudo</span> <span class="token function">apt-get</span> upgrade <span class="token parameter variable">-y</span>
<span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">zsh</span> <span class="token function">git</span> <span class="token function">curl</span> <span class="token parameter variable">-y</span>
<span class="token function">sudo</span> chsh <span class="token parameter variable">-s</span> <span class="token variable">${which zsh}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<h2 id="安装-oh-my-zsh">安装 oh-my-zsh</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 国内镜像</span>
<span class="token function">sh</span> <span class="token parameter variable">-c</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span><span class="token function">curl</span> <span class="token parameter variable">-fsSL</span> https://gitee.com/pocmon/ohmyzsh/raw/master/tools/install.sh<span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="安装-powerlevel10k-主题">安装 powerlevel10k 主题</h2>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 安装主题与 自动补全、语法高亮 两大插件</span>
<span class="token function">git</span> clone <span class="token parameter variable">--depth</span><span class="token operator">=</span><span class="token number">1</span> https://gitee.com/romkatv/powerlevel10k.git <span class="token variable">${ZSH_CUSTOM<span class="token operator">:-</span>$HOME<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom}</span>/themes/powerlevel10k
<span class="token function">git</span> clone https://github.com/zsh-users/zsh-autosuggestions <span class="token variable">${ZSH_CUSTOM<span class="token operator">:-</span>~<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom}</span>/plugins/zsh-autosuggestions
<span class="token function">git</span> clone https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="token variable">${ZSH_CUSTOM<span class="token operator">:-</span>~<span class="token operator">/</span>.oh-my-zsh<span class="token operator">/</span>custom}</span>/plugins/zsh-syntax-highlighting<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>~/.zshrc</code> 如下设置。</p>
<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">ZSH_THEME</span><span class="token operator">=</span><span class="token string">"powerlevel10k/powerlevel10k"</span>
<span class="token punctuation">..</span>.
<span class="token assign-left variable">plugins</span><span class="token operator">=</span><span class="token punctuation">(</span>git zsh-autosuggestions zsh-syntax-highlighting<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>接着 <code>source ~/.zsh</code>，进入自定义主题配置阶段。</p>
<blockquote>
<p>后续也可以通过 <code>p10k configure</code> 重新配置。</p>
</blockquote>
]]></content>
      <categories>
        <category>Guide</category>
      </categories>
  </entry>
  <entry>
    <title>实时渲染管线(Real-Time Rendering Pipeline)</title>
    <url>/graphics/realtimerender/</url>
    <content><![CDATA[<p>之前在 <a href="../../note/games101note/#%E5%AE%9E%E6%97%B6%E6%B8%B2%E6%9F%93%E7%AE%A1%E7%BA%BFreal-time-rendering-pipeline">GAMES101</a> 中粗略提了一点，本文将对这个概念进行<del>详细</del>介绍。</p>
<span id="more"></span>
<p><strong>渲染管线</strong>通过给定虚拟相机、3D 场景物体以及光源等场景要素来渲染出 2D 的图像。它的功能主要有两个：一是将物体世界坐标转变为屏幕空间坐标，二是为屏幕每个像素点进行着色。</p>
<p>我们依然用 GAMES101 中提到的渲染管线流程来对本文进行章节划分，分别是：</p>
<ol>
<li class="lvl-3">
<p>几何阶段</p>
</li>
<li class="lvl-3">
<p>三角形处理阶段</p>
</li>
<li class="lvl-3">
<p>光栅化阶段</p>
</li>
<li class="lvl-3">
<p>片元处理阶段</p>
</li>
<li class="lvl-3">
<p>输出合成阶段</p>
</li>
</ol>
<img src="gpipe.png" style="zoom:50%">
<h2 id="几何阶段">几何阶段</h2>
<h3 id="顶点处理">顶点处理</h3>
<p>我们首先要定义世界中的所有几何体。这些物体是由一系列顶点构成的，在这一阶段我们只需要定义所有顶点的世界位置坐标即可。</p>
<blockquote>
<p>无论物体怎么变换，点与点之间的连接关系是保持不变的，同时因为每次处理顶点都是独立的，不需要额外考虑其他，对于计算而言更简便，所以进行这一步速度会相当快。</p>
</blockquote>
<p>当然除了坐标信息，还可以输入包括顶点颜色、顶点法线、纹理坐标等信息。</p>
<p>接下来还有相机的世界位置坐标。在 3D 渲染中，我们必须要设置一个相机来接收图像，这个相机的视野决定了 GPU 最终会让我们看到什么样的画面。</p>
<blockquote>
<p>此时我们就可以根据需要，进行更多顶点相关的操作，比如<strong>网格细分</strong>、<strong>位移贴图</strong>、<strong>顶点着色</strong>（计算光照信息、纹理采样）等。</p>
</blockquote>
<h3 id="投影">投影</h3>
<p>尽管至此 GPU 已经在三维空间中做了很多工作，但我们最终是要在一个二维的屏幕上查看我们渲染出来的图像，这就需要 GPU 把三维空间映射到二维平面上了。为了方便之后的运算，我们需要进行<strong>观测变换</strong>与<strong>投影变换</strong>。这一步是主要是将所有顶点从世界空间映射到相机的「<strong>裁剪空间</strong>」中，涉及到两个关键的变换矩阵。</p>
<p>由于是左乘矩阵的形式，所以观测变换矩阵先将顶点进行平移，然后执行相机「从末状态到起始状态的逆变换」。其中 $\mathbf{e}$ 表示相机位置，$\hat{g}$ 表示相机朝向，$\hat{t}$ 表示相机上方。</p>
<p>$$
\mathbf{M}<em>{view} =
\left(\begin{matrix}
x</em>{\hat{g}\times\hat{t}} &amp; y_{\hat{g}\times\hat{t}} &amp; z_{\hat{g}\times\hat{t}} &amp; 0\
x_{\hat{t}} &amp; y_{\hat{t}} &amp; z_{\hat{t}} &amp; 0\
x_{-\hat{g}} &amp; y_{-\hat{g}} &amp; z_{-\hat{g}} &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -x_e\
0 &amp; 1 &amp; 0 &amp; -y_e\
0 &amp; 0 &amp; 1 &amp; -z_e\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
$$</p>
<p>而透视变换则首先将视锥体进行「squish」，然后平移至原点，最后归一化成单位立方体。</p>
<p>$$
\mathbf{M}_{persp} =
\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2}\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2}\
0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2}\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\
0 &amp; n &amp; 0 &amp; 0\
0 &amp; 0 &amp; n+f &amp; -nf\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right) \
$$</p>
<blockquote>
<p>这里是右手系下的透视投影变换矩阵，且相机朝 $z$ 轴负半轴。</p>
</blockquote>
<img src="squish.png" alt="squish" style="zoom:80%">
<h3 id="映射与裁剪">映射与裁剪</h3>
<p>接下来，我们就需要将立方体中的所有顶点映射到「<strong>屏幕空间</strong>」中，这一步并不困难，只需要简单地进行缩放+平移即可。所执行的变换矩阵如下所示。</p>
<p>$$
\mathbf{M}_{viewport}
\left(
\begin{matrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2}\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2}\
0 &amp; 0 &amp; 1 &amp; 0\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right) \
$$</p>
<p>其中屏幕空间为 $[0, width]*[0, height]$。超出屏幕空间外的顶点将被剔除，不参与渲染，同时在线段与屏幕空间边界的交点处生成新的顶点——这就是裁剪。</p>
<img src="clip.png" style="zoom:50%">
<p>之后所有顶点的 $x, y$ 坐标就映射到了屏幕空间中，但是还有 $z$ 的信息呢！之所以保留这个信息，是因为我们还需要利用 $z$ 来进行物体之间是否存在遮挡的判断。该判断位于光栅化阶段中。</p>
<h2 id="三角形处理阶段">三角形处理阶段</h2>
<p>该阶段做的事很简单，即将顶点进行配对，生成点与点之间的关系，进行三角形的设置。</p>
<h2 id="光栅化阶段">光栅化阶段</h2>
<p>这一阶段主要是判断屏幕上的像素对应到屏幕空间中的哪些内容。</p>
<h3 id="采样">采样</h3>
<p>我们需要遍历所有三角形（仅使用 $x, y$ 坐标），判断哪些像素被该三角形包含，这一操作称为<strong>采样(Sample)</strong>。同一三角形包含的所有像素称为<strong>片元(Fragment)</strong>。为了降低开销，我们可以用三角形的 AABB 减少需要判断的像素点。</p>
<img src="sample.png" alt="所有红色点组成一个 Fragment" style="zoom:70%">
<blockquote>
<p>判断一个点 $O$ 是否落在三角形 $P_0P_1P_2$ 内很简单，只需要<strong>三次叉乘</strong>，如果 $\mathbf{OP_0}\times\mathbf{P_0P_1}, \mathbf{OP_1}\times\mathbf{P_1P_2}, \mathbf{OP_2}\times\mathbf{P_2P_0}$ 同号，则认为在内部，反之在外部。</p>
<p>也可以利用重心坐标来判断是否在三角形内，如果重心坐标的三个值均在 [0,1] 之间，那么就认为这个点在三角形内。</p>
</blockquote>
<p>有些像素可能仅仅只有部分含于三角形内部，这就存在<strong>锯齿(Jaggies)</strong>。抗锯齿技术的目的是使得显示的像素更连续，譬如<strong>多重采样抗锯齿(MultiSampling Anti-Aliasing，MSAA)</strong>。</p>
<img src="22supersample.png" style="zoom:50%">
<img src="afterss.png" style="zoom:50%">
<img src="result.png" style="zoom:50%">
<h2 id="片元处理阶段">片元处理阶段</h2>
<p>这是十分重要的阶段，它将根据顶点的信息，通过「插值」的方式为每个片元计算颜色，比如计算每个片元的光照效果（考虑光照模型、材质和光源等因素）；将纹理映射到片元上；甚至直接根据之前生成的顶点的着色信息进行片元着色……。总而言之，这一步的核心在于着色，或者说「<strong>计算像素 RGB 值</strong>」。对于透射投影，我们需要用到**透射校正插值(Perspetive-Correct-Interpolation)**来正确插值片段的颜色、纹理等信息。</p>
<blockquote>
<p>其实是可以和光栅化合并的。但是为了和 GAMES101 的说法对齐，故单独提取出来。</p>
</blockquote>
<h3 id="Z-Buffer">Z-Buffer</h3>
<p>有些像素可能会被多个三角形包含，那就要判断包含该像素的若干三角形谁离相机更近了。还记得我们之前说保留了屏幕空间中所有顶点的 $z$ 值，接下来通过插值的方式我们可以获取三角形中任意一点的 $z$ 值。</p>
<p>Z-Buffer 就是用来存每个像素「最接近相机」的 $z$ 值。对于一个三角形的所有采样点，如果发现某个点 $(x, y, z)$ 对应的深度 $|z|$ 超过 $\text{Z-Buffer}(x, y)$，那么就将其舍弃，反之用该点信息更新 Z-Buffer 以及一个叫**帧缓存(Frame Buffer)**的玩意。</p>
<blockquote>
<p>帧缓存维护所有像素点对应的像素 RGB 值。</p>
</blockquote>
<p>这样一来，帧缓存中的像素值就是经过了遮挡判断后的正确的值。</p>
<h2 id="输出合成阶段">输出合成阶段</h2>
<p>完成计算/渲染后，经过各种测试，将缓冲中的像素数据发送到显示设备，即可呈现给用户。</p>
<blockquote>
<p>GPU 会使用<strong>双重缓冲(Double Buffering)<strong>的策略，即屏幕上显示</strong>前置缓冲(Front Buffer)</strong>，而渲染好的像素值先被送入<strong>后置缓冲(Back Buffer)</strong>。</p>
</blockquote>
<h3 id="裁剪测试">裁剪测试</h3>
<h3 id="Alpha-测试">Alpha 测试</h3>
<h3 id="模板测试">模板测试</h3>
<h3 id="深度测试">深度测试</h3>
]]></content>
      <categories>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>线段树</title>
    <url>/data-structure/segmenttree/</url>
    <content><![CDATA[<p><strong>线段树</strong>是一种能够在 $O(\log n)$ 的时间复杂度下，动态维护区间信息的数据结构。</p>
<span id="more"></span>
<h2 id="树状数组">树状数组</h2>
<p><a href="../shu-zhuang-shu-zu"><strong>树状数组</strong></a>虽然也能支持 $O(\log n)$ 的区间查询，但仅仅是区间求和，对于区间最值问题显得有些无力。</p>
<h2 id="线段树">线段树</h2>
<p><strong>线段树</strong>将每个长度不为 1 的区间划分成左右两个区间递归求解，从而在逻辑上把整个区间划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。通常应用于<strong>区间求和</strong>、<strong>区间求最值</strong>等问题。</p>
<p>线段树建树的思想并不难理解：如果当前节点负责区间 <code>[left, right]</code>，那么左儿子节点负责 <code>[left, mid]</code>，右儿子节点负责 <code>[mid + 1, right]</code>，这样的以中点的划分能够尽可能让同一层所有节点负责的区间大小相近。</p>
<p>我们可以简单地用二叉树来构建，但这样就会存在开销（维护左右儿子的指针，在堆上分配内存）。然而根据建树的过程，我们也不难发现最后的树形结构与「满二叉树」非常接近，且当区间大小为 2 的幂时变满。此时我们就可以考虑用数组的方式来维护这棵树，如果我们使整棵树从下标 <code>index = 1</code> 开始，那么访问左儿子就是令 <code>index = index * 2</code>，访问右儿子就是令 <code>index = index * 2 + 1</code>。这样一来每个节点就比二叉树少维护了两个指针的信息，大大减少了内存开销。</p>
<blockquote>
<p>考虑到位运算的效率大于四则运算，上面访问儿子的方式也可以升级为 <code>index = index &lt;&lt; 1</code> 和 <code>index = (index &lt;&lt; 1) | 1</code>，证明略。</p>
</blockquote>
<h3 id="构建">构建</h3>
<p>从而根据序列 <code>nums</code> 构建线段树 <code>st</code> 的代码用 C++ 可以如下实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>构建线段树</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">build</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span>
          <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> mid <span class="token operator">=</span> left <span class="token operator">+</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> lchild <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> rchild <span class="token operator">=</span> <span class="token function">build</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> nums<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 根据左右区间的信息维护当前信息，比如下面是区间求和的代码</span>
  st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> lchild <span class="token operator">+</span> rchild<span class="token punctuation">;</span>
  <span class="token comment">// 求区间最大值则是用 st[idx] = std::max(lchild, rchild);</span>
  <span class="token comment">// 其他同理。</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查询">查询</h3>
<p>现在我们已经有了线段树数组了，如何进行查询呢？考虑到每个节点负责的区间是固定的，所以在递归查询的时候需要额外提供当前节点的区间边界信息。为了降低开销，我们只要找到一个极大的子区间，即可读取该区间的信息，而无需进一步访问子节点。</p>
<p>那么查询区间 <code>[left, right]</code> 信息的代码如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>区间查询</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> lbound<span class="token punctuation">,</span> <span class="token keyword">int</span> rbound <span class="token comment">// 当前节点负责区间 [lbound, rbound]</span>
          <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里依然以区间求和为例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">==</span> left <span class="token operator">&amp;&amp;</span> rbound <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 找到极大子区间</span>
    <span class="token keyword">return</span> st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> mid <span class="token operator">=</span> lbound <span class="token operator">+</span> <span class="token punctuation">(</span>rboud <span class="token operator">-</span> lbound<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待查询的区间与左子树负责的区间 [lbound, mid] 产生交集</span>
    res <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> lbound<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待查询的区间与右子树负责的区间 [mid + 1, rbound] 产生交集</span>
    res <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rbound<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="修改-懒惰标记">修改 &amp; 懒惰标记</h3>
<p>单点修改其实是区间修改中对应区间长度为 1 的情况，所以我们这里仅讨论区间修改。一种朴素的做法是遍历该区间，对其中每个元素，都去线段树中找到对应的长度为 1 的区间，然后自底向上修改。</p>
<p>这种做法的问题在于，需要进行若干次单点修改，即深入到叶节点去操作。可我们的线段树维护的是区间信息啊，完全可以只修改极大子区间，却暂不进一步修改更深的子节点。</p>
<p>那么子节点维护的区间信息肯定还是要去修改的，不然就会出现一致性的问题。那么什么时候修改呢？根据 LAZY 哲学，我们完全可以等到未来访问子区间的时候再去更新。显然如果未来并没有访问子区间，那我们就省下了若干修改操作，不得不说是很大的优化；即便访问了子区间，那么本次下推相当于将之前所有的累计更新放到这一次完成，也能大大优化时间开销。</p>
<p>此时就要用到一个称为「<strong>懒惰标记</strong>」的东西了。它会将我们修改的区间做上记号，表明这段区间已经在之前进行了整体的修改操作。</p>
<p>这样一来，如果后续的查询需要进入更深层次的节点，只需修改子节点的懒惰标记即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>区间修改 with 懒惰标记 - 记录修改量</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> lbound<span class="token punctuation">,</span> <span class="token keyword">int</span> rbound<span class="token punctuation">,</span>
            std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lazy<span class="token punctuation">,</span> <span class="token comment">// lazy: 懒惰标记数组，记录修改量</span>
            <span class="token keyword">int</span> change<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里依然以区间求和为例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">==</span> left <span class="token operator">&amp;&amp;</span> rbound <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+=</span> change<span class="token punctuation">;</span> <span class="token comment">// 记录对这个区间所有值的修改量，后续再下推到子节点</span>
    st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> change<span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> mid <span class="token operator">=</span> lbound <span class="token operator">+</span> <span class="token punctuation">(</span>rboud <span class="token operator">-</span> lbound<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">!=</span> rbound <span class="token operator">&amp;&amp;</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将之前的更新下推到左儿子</span>
    lazy<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 将之前的更新下推到右儿子</span>
    lazy<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> mid<span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 自身清空</span>
    lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与左子树负责的区间 [lbound, mid] 产生交集</span>
    <span class="token function">update</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> lbound<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与右子树负责的区间 [mid + 1, rbound] 产生交集</span>
    <span class="token function">update</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rbound<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> st<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的代码是将某个区间整体加上某个值 <code>change</code>，如果要将区间修改为目标值 <code>target</code>，则代码应当改为如下形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>区间修改 with 懒惰标记 - 记录目标值</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> lbound<span class="token punctuation">,</span> <span class="token keyword">int</span> rbound<span class="token punctuation">,</span>
            std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lazy<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> isUpdate<span class="token punctuation">,</span> <span class="token comment">// lazy: 懒惰标记数组，记录目标值。isUpdate: 记录是否修改</span>
            <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里依然以区间求和为例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">==</span> left <span class="token operator">&amp;&amp;</span> rbound <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> target<span class="token punctuation">;</span> <span class="token comment">// 记录修改后的值，后续再下推到子节点</span>
    st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> target<span class="token punctuation">;</span>
    isUpdate<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> mid <span class="token operator">=</span> lbound <span class="token operator">+</span> <span class="token punctuation">(</span>rboud <span class="token operator">-</span> lbound<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">!=</span> rbound <span class="token operator">&amp;&amp;</span> isUpdate<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将之前的更新下推到左儿子</span>
    lazy<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    isUpdate<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 将之前的更新下推到右儿子</span>
    lazy<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> mid<span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    isUpdate<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 自身清空</span>
    isUpdate<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与左子树负责的区间 [lbound, mid] 产生交集</span>
    <span class="token function">update</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> lbound<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与右子树负责的区间 [mid + 1, rbound] 产生交集</span>
    <span class="token function">update</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rbound<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> st<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> st<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="查询-懒惰标记">查询 &amp; 懒惰标记</h3>
<p>有了懒惰标记后，查询部分代码也应当做相应修改。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>区间查询 with 懒惰标记 - 记录修改量</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> lbound<span class="token punctuation">,</span> <span class="token keyword">int</span> rbound<span class="token punctuation">,</span>
          std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lazy<span class="token punctuation">,</span> <span class="token comment">// lazy: 懒惰标记数组，记录修改量</span>
          <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里依然以区间求和为例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">==</span> left <span class="token operator">&amp;&amp;</span> rbound <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> mid <span class="token operator">=</span> lbound <span class="token operator">+</span> <span class="token punctuation">(</span>rboud <span class="token operator">-</span> lbound<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">!=</span> rbound <span class="token operator">&amp;&amp;</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将之前的更新下推到左儿子</span>
    lazy<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 将之前的更新下推到右儿子</span>
    lazy<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> mid<span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token comment">// 自身清空</span>
    lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与左子树负责的区间 [lbound, mid] 产生交集</span>
    res <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> lbound<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与右子树负责的区间 [mid + 1, rbound] 产生交集</span>
    res <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rbound<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span> 
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>区间查询 with 懒惰标记 - 记录目标值</span></div><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">query</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> st<span class="token punctuation">,</span> <span class="token keyword">int</span> idx<span class="token punctuation">,</span> <span class="token keyword">int</span> lbound<span class="token punctuation">,</span> <span class="token keyword">int</span> rbound<span class="token punctuation">,</span>
          std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> lazy<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span><span class="token keyword">bool</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> isUpdate<span class="token punctuation">,</span> <span class="token comment">// lazy: 懒惰标记数组，记录目标值。isUpdate: 记录是否修改</span>
          <span class="token keyword">int</span> target<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 这里依然以区间求和为例</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">==</span> left <span class="token operator">&amp;&amp;</span> rbound <span class="token operator">==</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> st<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> mid <span class="token operator">=</span> lbound <span class="token operator">+</span> <span class="token punctuation">(</span>rboud <span class="token operator">-</span> lbound<span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>lbound <span class="token operator">!=</span> rbound <span class="token operator">&amp;&amp;</span> isUpdate<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 将之前的更新下推到左儿子</span>
    lazy<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>mid <span class="token operator">-</span> left <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    isUpdate<span class="token punctuation">[</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 将之前的更新下推到右儿子</span>
    lazy<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    st<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> mid<span class="token punctuation">)</span> <span class="token operator">*</span> lazy<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">;</span>
    isUpdate<span class="token punctuation">[</span><span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token comment">// 自身清空</span>
    isUpdate<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与左子树负责的区间 [lbound, mid] 产生交集</span>
    res <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">,</span> lbound<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&gt;=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 待修改的区间与右子树负责的区间 [mid + 1, rbound] 产生交集</span>
    res <span class="token operator">+=</span> <span class="token function">query</span><span class="token punctuation">(</span>st<span class="token punctuation">,</span> <span class="token punctuation">(</span>idx <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> rbound<span class="token punctuation">,</span> nums<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="空间复杂度">空间复杂度</h3>
<p>如果采用数组结构，则当序列长度为 $n$ 时，表明线段树存在 $n$ 个叶节点，易得线段树深度最大为 $\lceil\log{n}\rceil$。对应的数组存储最大容量为 $s = 2^{\lceil\log{n}\rceil + 1}$。这个最大值在 $n = 2^x+1$ 时取到，此时 $s = 2^{x+2} = 2^{\log(n-1)+2} = 4(n-1)$。所以我们可以简单地把数组的长度设置在 $4(n-1)$ 大小，保证不会出现越界。</p>
<h2 id="应用">应用</h2>
<ol>
<li class="lvl-3">
<p><a href="https://leetcode.cn/submissions/detail/554071441/">&gt;&gt;&gt; LeetCode 2940 找到 Alice 和 Bob 可以相遇的建筑(Hard) &lt;&lt;&lt;</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>data structure</category>
      </categories>
  </entry>
  <entry>
    <title>后缀自动机(Suffix Automaton)</title>
    <url>/data-structure/suffixautomaton/</url>
    <content><![CDATA[<p>翻阅网络资料两天后顿悟，遂写下心得。</p>
<blockquote>
<p>参考资料</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><a href="https://oi-wiki.org/string/sam/#%E6%A3%80%E6%9F%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%98%AF%E5%90%A6%E5%87%BA%E7%8E%B0">OI Wiki</a></p>
</li>
<li class="lvl-2">
<p><a href="https://zhuanlan.zhihu.com/p/410131141">知乎。并贴心地给出了构建过程的中间形态</a></p>
</li>
</ul>
</blockquote>
<span id="more"></span>
<h2 id="性质">性质</h2>
<p>关于**后缀自动机(SAM)**的所有概念，其实网上说的都已经差不多了。个人总结出以下几个关键的性质：</p>
<ol>
<li class="lvl-3">
<p>在 SAM 中，能够通过一个<strong>状态(State)<strong>来表示一组 endpos 相同的字符串，并且有一个</strong>起始 State</strong>（$Start$）来表示空字符串；</p>
<blockquote>
<p>所谓 endpos 其实就是字符串在「<strong>源串</strong>」（下面简称 <code>src</code>）中所有结束位置的集合。比如字符串 <code>"aabab"</code> 中 <code>"ab"</code> 的 endpos 就是 {2, 4}</p>
</blockquote>
</li>
<li class="lvl-3">
<p>SAM 可以表示为一个树形结构，并且树上的所有节点都是一个 State，且根节点对应 $Start$；</p>
</li>
<li class="lvl-3">
<p>如果将一个 State 表示的所有字符串以降序排序，假设得到的结果是 ${s_1, s_2, \dots, s_n}$，那么对于任意 $i&lt;j$，有 $s_j$ 是 $s_i$ 的<strong>真后缀</strong>，并且 $len(s_{i-1}) = len(s_i) - 1$；</p>
<blockquote>
<p>在上面的例子中，<code>"ab"</code> 和 <code>"b"</code> 属于同一 State（它们的 endpos 都是 {2, 4}），这两个字符串满足上述性质。为此，需要在 State 中维护一个 <code>length</code> 变量，意为 State 表示的所有字符串中的最大长度。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>对于某一 State $A$ 在树中的所有祖先 State $B$，可以得出 $B$ 表示的所有字符串 $b_i$ 都是 $A$ 中所有字符串 $a_i$ 的<strong>真后缀</strong>，同时 $endpos_A \subseteq endpos_B$；</p>
<blockquote>
<p>为此，需要在 State 中维护一个 <code>parent</code> 变量，以转移到父 State。通常这一步也叫「<strong>后缀压缩</strong>」。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>State 还需要能够通过某一字符 <code>ch</code> 转移到另一 State（如果存在这样一种转移的话），并且认为 State $A$ 表示的所有字符串 $a_i$ 在添加字符 <code>ch</code> 后的所有新字符串 $a_i’$ 是 $b_i$ 的<strong>后缀</strong>；</p>
<blockquote>
<p>为此，需要在 State 中维护一个 <code>next</code> 变量，通常是一个 unordered map&lt;char, int&gt;。当然如果字符集只有小写字母，也可以直接用一个长度为 26 的数组。</p>
</blockquote>
</li>
</ol>
<h2 id="构建">构建</h2>
<p>基于以上性质，其实不难理解 SAM 的构建代码了。因为这是一个 online 结构，我们可以随时添加新字符/字符串以更新自动机。每次新增一个字符 <code>ch</code>，相当于建立了一个新的 State $New$（此刻仅表示添加了 <code>ch</code> 后的新串 <code>newStr</code>，对应 endpos 为 $len(newStr)-1$）。</p>
<p>接下去这句个人理解我认为很关键：<strong>添加 $New$ 后重构 SAM 的过程，本质上就是找一个合适的 State 作为 $New$ 的 parent 的过程</strong>。</p>
<p>根据性质 4，这个所谓的合适的 State，其表示的所有字符串必须能作为 <code>newStr</code> 的后缀，且最长串应尽可能长。</p>
<p>如果我们能够把上一次添加字符所构建的 State $Last$ 考虑进来，问题就会变得很简单——$Last$ 所表示的字符串（暂且称为 <code>oldStr</code> 好了）在添加了 <code>ch</code> 后恰好就是 <code>newStr</code> 的后缀。</p>
<p>那么只需要遍历 $Last$ 的所有祖先即可。因为如果一个 State 不是 $Last$ 的祖先，其表示的字符串也不会是 $Last$ 所表示字符串的后缀，也就无法在添加 <code>ch</code> 后成为 <code>newStr</code> 的后缀了。这也是板子的前半段代码的基本思想。对于上述 States，需要在 <code>next</code> 中添加到 $New$ 的转移。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 新建状态</span>
automaton<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token operator">++</span>strLength_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
State<span class="token operator">&amp;</span> newState <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
stateIndex newStateIdx <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

stateIndex p<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> last_<span class="token punctuation">;</span> p <span class="token operator">!=</span> NIL <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 遍历 last 的祖先，添加转移</span>
  automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">=</span> newStateIdx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果直接遍历完在 $Start$ 的 parent 处停止，意味着 <code>ch</code> 没有在 <code>oldStr</code> 中出现过，可用反证法证明之。</p>
<p>那么如果遇到某个 State $P$（包括 $Start$），其已经能通过 <code>ch</code> 转移到其他 State $Q$ 了，说明 <code>ch</code> 肯定在 <code>oldStr</code> 中出现过。</p>
<p>由于此时此刻集合 endpos($New$) 的大小为 1，那么对于 <code>oldStr</code> 的所有后缀 $old_i$，如果子串 $old_i + ch$ 未在 <code>oldStr</code> 中出现过，那其必定与 <code>newStr</code> 对应同一 endpos 集合。否则，就像之前说的那样，$old_i$ 所属的 State $P$ 存在一个到另一 State $Q$ 的转移。</p>
<p>这需要分情况讨论，其实也就是所有资料都提到的两种情况：</p>
<ol>
<li class="lvl-3">
<p>$len(P) + 1 = len(Q)$</p>
</li>
<li class="lvl-3">
<p>$len(P) + 1 &lt; len(Q)$</p>
</li>
</ol>
<p>对于第一种情况，表明 $Q$ 就是我们要找的 parent。因为此时不存在一个 State 能够表示更长且与 <code>newStr</code> 的 endpos 不同的字符串了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span>automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  newState<span class="token punctuation">.</span>parent <span class="token operator">=</span> q<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>对于第二种情况，表明虽然 $Q$ 表示的最长串不一定是 <code>newStr</code> 的后缀，但 $old_i + ch$ 一定是，并且根据性质 5，$old_i + ch$ 必定能作为 $Q$ 表示的所有字符串的后缀。此时 $New$ 和 $Q$ 有了一个公共后缀 $old_i + ch$，并且此时 endpos($old_i + ch$) 就会与 endpos($Q$) 产生差异——多了一项 $len(newStr)-1$。</p>
<p>于是就又产生了一个新的 State，并且这个新的 State 是基于 $Q$ 的——对于 $P$ 及其所有祖先，一旦能够通过 <code>ch</code> 转移到 $Q$，那就必然能够转移到这个新的 State；同时又能继承 $Q$ 的所有转移（这很显然，毕竟是 $Q$ 的后缀）。所以一般把这个 State 称为 $Clone$。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token punctuation">{</span>
  automaton<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  State<span class="token operator">&amp;</span> cloneState <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stateIndex cloneStateIdx <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
  cloneState<span class="token punctuation">.</span>length <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// 别忘了修改 length</span>

  <span class="token comment">// 修改 p 的祖先中所有转移到 q 的 State</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> NIL<span class="token punctuation">;</span> p <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">auto</span> iter <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>iter <span class="token operator">==</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> iter<span class="token operator">-&gt;</span>second <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">break</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    iter<span class="token operator">-&gt;</span>second <span class="token operator">=</span> cloneStateIdx<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 最后 New 和 Q 都指向 Clone</span>
  automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> cloneStateIdx<span class="token punctuation">;</span>
  newState<span class="token punctuation">.</span>parent <span class="token operator">=</span> cloneStateIdx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后的最后，还要修改 $Last$ 使其指向 $New$。到这就大功告成了。完整实现如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">SuffixAutomaton</span><span class="token double-colon punctuation">::</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">char</span> ch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  automaton<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span><span class="token operator">++</span>strLength_<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  State<span class="token operator">&amp;</span> newState <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  stateIndex newStateIdx <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>

  stateIndex p<span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> last_<span class="token punctuation">;</span> p <span class="token operator">!=</span> NIL <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span> p <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>ch<span class="token punctuation">]</span> <span class="token operator">=</span> newStateIdx<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> NIL<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//  {p} + c is a suffix of {q}</span>
    stateIndex q <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">[</span>ch<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// endpoint({p} + c) change in sync with endpoint({q})</span>
      newState<span class="token punctuation">.</span>parent <span class="token operator">=</span> q<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token comment">// size(endpoint({p} + c)) &gt; size(endpoint({q})), so we should</span>
      <span class="token comment">// create a new intermidiate state "cloneState" to present {p} + c</span>
      automaton<span class="token punctuation">.</span><span class="token function">emplace_back</span><span class="token punctuation">(</span>automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      State<span class="token operator">&amp;</span> cloneState <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">back</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      stateIndex cloneStateIdx <span class="token operator">=</span> automaton<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
      cloneState<span class="token punctuation">.</span>length <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
      cloneState<span class="token punctuation">.</span>firstTime <span class="token operator">=</span>
          automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>firstTime <span class="token operator">+</span> automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>length <span class="token operator">-</span> cloneState<span class="token punctuation">.</span>length<span class="token punctuation">;</span>

      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> p <span class="token operator">!=</span> NIL<span class="token punctuation">;</span> p <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">auto</span> iter <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>iter <span class="token operator">==</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> iter<span class="token operator">-&gt;</span>second <span class="token operator">!=</span> q<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        iter<span class="token operator">-&gt;</span>second <span class="token operator">=</span> cloneStateIdx<span class="token punctuation">;</span>
      <span class="token punctuation">}</span>

      automaton<span class="token punctuation">[</span>q<span class="token punctuation">]</span><span class="token punctuation">.</span>parent <span class="token operator">=</span> cloneStateIdx<span class="token punctuation">;</span>
      newState<span class="token punctuation">.</span>parent <span class="token operator">=</span> cloneStateIdx<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span>p <span class="token operator">=</span> automaton<span class="token punctuation">[</span>newStateIdx<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">;</span> p <span class="token operator">!=</span> NIL<span class="token punctuation">;</span> p <span class="token operator">=</span> automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    automaton<span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">.</span>cnt<span class="token operator">++</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  last_ <span class="token operator">=</span> newStateIdx<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="应用">应用</h2>
<p>SAM 是处理字符串问题的利器，根据前文提到的几条性质，其实可以实现包括但不限于以下功能：</p>
<ol>
<li class="lvl-3">
<p>判断模式串是否匹配；</p>
</li>
<li class="lvl-3">
<p>不同子串数；</p>
</li>
<li class="lvl-3">
<p>模式串的出现次数；</p>
</li>
<li class="lvl-3">
<p>查找模式串的首个出现位置；</p>
</li>
<li class="lvl-3">
<p>最长公共子串；</p>
</li>
<li class="lvl-3">
<p>…</p>
</li>
</ol>
<p>所有的实现代码放在了<a href="https://github.com/Leager-zju/DataStructures/tree/main/SuffixAutomaton">仓库</a>中。只能说，理解 parent 和 next 很关键。</p>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
  </entry>
  <entry>
    <title>碰撞检测の分离轴定理(SAT)</title>
    <url>/graphics/seperatingaxistheorem/</url>
    <content><![CDATA[<p>在游戏中，涉及到碰撞检测的场景十分广泛——子弹打中角色、玩家移动时会被场景阻挡、……「如何高效地判断两个物体是否接触」，是游戏开发中必须思考的一个问题。虽然我们可以用 **AABB 包围盒(Axis-Aligned Bounding Boxes)**进行粗略的判断，但对于检测精度要求高的场景，AABB 便不能满足了，需要一种更加精确的检测方法。</p>
<span id="more"></span>
<h2 id="分离轴">分离轴</h2>
<p><strong>分离轴定理(Seperating Axis Theorem, SAT)<strong>适用于判断两个二维</strong>凸多边形</strong>之间是否相交。</p>
<blockquote>
<p>在几何学中，凸多边形是一种简单多边形，其不存在边自我相交的情况，且任两点之间连成的直线皆位于多边形内部，这个特性与内部为凸集的简单多边形等价。在凸多边形中，所有内角都小于或等于180度，而在严格凸多边形中，所有内角都严格小于180度。——摘自<a href="https://zh.wikipedia.org/wiki/%E5%87%B8%E5%A4%9A%E8%BE%B9%E5%BD%A2">维基百科</a></p>
</blockquote>
<p>SAT 揭示了这样一条性质：如果两个凸多边形不相交，那么它们之间必然存在「间隙」，也就必然存在一条直线，将这两个图形划分到两片区域，这条直线就是「<strong>分离轴</strong>」。</p>
<p>在这种情况下，想象存在一束与分离轴平行的光线，使得这两个图形在一条与分离轴垂直的直线（<strong>投影轴</strong>）上形成两条线段投影。如果这两个图形不相交，则投影必然也不相交。如下图所示</p>
<img src="project.png">
<p>虽然不一定保证对于任意的分离轴，两个图形形成的投影都不相交，但只要存在一条分离轴使得投影不相交，那么就认为这两个图形不相交——这就是 SAT 的核心思想了。</p>
<h2 id="利用分离轴定理检测碰撞">利用分离轴定理检测碰撞</h2>
<p>由上文引出两个问题：</p>
<ol>
<li class="lvl-3">
<p>二维空间中的直线数量是无穷大，我们不可能遍历所有直线，那么该如何精准的找出分离轴？</p>
</li>
<li class="lvl-3">
<p>对于给定的分离轴，如何判断投影是否相交？</p>
</li>
</ol>
<h3 id="如何找分离轴？">如何找分离轴？</h3>
<p>直接抛结论：<strong>如果两个凸多边形不相交，则这两个多边形中必然存在一条边 $e$，其与投影轴平行，且法向量与我们要找的分离轴平行。</strong></p>
<blockquote>
<p>这很好理解，如果两个凸多边形不相交，那么必然存在一条边，同一图形的其他各边都在此边的同旁。</p>
</blockquote>
<p>那么可以遍历所有边的法向量，求两个图形在投影轴上的投影，如果某一次迭代使得投影不相交，意味着找到了分离轴，也就能得出「两者不相交」的结论。</p>
<h3 id="如何求投影？">如何求投影？</h3>
<p>根据所学知识，无论分离轴和投影轴如何平移，图形在投影轴上的投影的相对关系是保持不变的。为了简化计算，我们可以将投影轴平移至通过原点。假设投影轴所在直线对应单位向量 $\mathbf{p}$，那么图形在其上的投影线段可以表示为 $k\mathbf{p}$，其中 $k$ 属于某个闭区间（下面称为「$k$ 区间」）。如果两个图形的 $k$ 区间相交，那么投影线段也就相交了。</p>
<blockquote>
<p>向量 $\mathbf{p}$ 可以由图形中两个相邻点对应的二元组做差，然后单位化得到。</p>
</blockquote>
<p>接下来问题又转换为，求两个图形对应的 $k$ 区间是否相交。不难发现，区间端点必然对应着图形某个顶点，所以只要遍历图形的顶点，作投影点，记为 $k_i\mathbf{p}$，求出 $k_i$ 的最值即可。这个问题就可以用向量点积来计算。</p>
<blockquote>
<p>顶点 $A_i$ 是由一个二元组表示的，也可以视为向量 $\mathbf{OA_i}$，那么从 $A_i$ 出发作 $\mathbf{p}$ 的垂线，与 $\mathbf{p}$ 的交点就是投影点，且该投影点可以表示为 $k_i\mathbf{p}$，其中 $k_i = \mathbf{OA_i}·\mathbf{p}$。</p>
</blockquote>
<p>求区间是否相交就容易多了，不再赘述。</p>
<h2 id="额外的讨论">额外的讨论</h2>
<h3 id="圆与圆的碰撞检测">圆与圆的碰撞检测</h3>
<p>这个情况很简单，因为对于圆我们总是维护两个信息：圆心 $M$ 和半径 $r$。那么判断两个圆是否相交，只需判断两个圆心的距离 $|\mathbf{M_1M_2}|$ 是否小于等于半径之和 $r_1+r_2$。</p>
<h3 id="多边形与圆的碰撞检测">多边形与圆的碰撞检测</h3>
<p>这个情况需要找到多边形离圆心 $M$ 最近的点 $A$，此时向量 $\mathbf{AM}$ 就是投影轴，而圆的 $k$ 区间端点则是 $\mathbf{AM}$ 与圆形成的两个交点处取得。</p>
<img src="多边形与圆.png">
<h3 id="为什么只能是凸多边形">为什么只能是凸多边形</h3>
<p>如下图所示，有一个图像是凹多边形。此时尽管两个图形并不相交，但是不存在一条分离轴将两个图形分开。</p>
<img src="凹多边形.png">]]></content>
      <categories>
        <category>Graphics</category>
      </categories>
  </entry>
  <entry>
    <title>TCP Things</title>
    <url>/computer-network/tcpthings/</url>
    <content><![CDATA[<p>聊聊传输控制协议(<strong>TCP</strong>, Transmission Control Protocol)。</p>
<span id="more"></span>
<h2 id="简述">简述</h2>
<p>TCP 位于传输层，是<strong>面向连接</strong>且<strong>基于字节流</strong>的<strong>可靠</strong>协议。</p>
<p>所谓<strong>面向连接</strong>，就是指如果使用 TCP 协议进行数据传输，那么必须在数据传输之前进行「一对一连接」，确认双方都能发送/接收数据后，才正式开始互发数据（全双工）。</p>
<p>所谓<strong>基于字节流</strong>，就是指 TCP 层不关心有效负载的内容，只是将其视为若干字节。发送数据时直接从 buffer 中取出若干字节，用 Header 包装后发给下层；收到数据时，取走 Header 直接交付给应用层。这也容易导致多份不同的应用层数据同时位于一个 TCP 报文段中，存在<strong>粘包问题</strong>。</p>
<p>所谓<strong>可靠</strong>，就是指 TCP 用重传机制保证数据尽可能全部到达，滑动窗口保证数据尽可能有序接收，拥塞控制保证网络尽可能不会同时收到过多报文而导致数据丢弃。</p>
<h2 id="TCP-Header">TCP Header</h2>
<img src="header.png" style="zoom:50%">
<p>TCP 能够提供上述服务，其首部中最关键的字段就是<strong>序列号</strong>和<strong>确认应答号</strong>，以及<strong>控制位</strong>。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>序列号</strong>：<strong>首次</strong>尝试建立连接(SYN:1)时会获取一个随机值作为初始序列号，随后每次数据发送，都会将当前序列号加上该次数据的<strong>字节数</strong>作为下一个报文的序列号；</p>
<blockquote>
<p>即使丢包重传也不会重置该值，以便服务端意识到这是一个重传</p>
</blockquote>
</li>
<li class="lvl-2">
<p><strong>确认应答号</strong>：收到数据后，告知发送端的<strong>下一个</strong>希望收到的序列号。一旦收到确认应答号有效(ACK:1)的报文，就可以认为之前所有数据都已被正确接收；</p>
</li>
<li class="lvl-2">
<p><strong>ACK</strong>：为 1 时，确认应答号字段有效；</p>
</li>
<li class="lvl-2">
<p><strong>RST</strong>：为 1 时，表明发生了预期之外的错误，需要强制终止连接；</p>
</li>
<li class="lvl-2">
<p><strong>SYN</strong>：为 1 时，表明发送方请求建立连接，同时也用于同步初始序列号；</p>
</li>
<li class="lvl-2">
<p><strong>FIN</strong>：为 1 时，表明发送方已无数据要发，请求正常终止连接；</p>
</li>
</ul>
<h2 id="面向连接">面向连接</h2>
<h3 id="如何唯一确认一个-TCP-连接？">如何唯一确认一个 TCP 连接？</h3>
<p>我们知道无论是使用 TCP 还是 UDP，在操作系统层面都是通过 socket 进行远程通信的，而一个 socket 由 {源 PORT、源 IP、目标 PORT、目标 IP} 四元组唯一标识，所以只要四元组中有一个字段发生变化，就是不同的 socket。而一次连接是无法同时绑定到两个 socket 上的，所以也可以通过四元组来确定一个 TCP 连接。</p>
<h3 id="TCP-建立连接——三次握手">TCP 建立连接——三次握手</h3>
<blockquote>
<p>今天小明给小红打电话，小明拨打后第一句话就是：「喂喂喂，能听得到我吗？」小红听到后也回复：「嗯嗯可以听到，你能听到我说话吗？」小明听到后意识到小红能听到他说话，那么他只需要告诉小红「可以的。既然我们都能听到对方讲话，那我就开始跟你聊天了！」即可。</p>
<p>这也表明只有两边都确认了双方能进行正常通话后，才能进行下去。否则，如果小明说话小红听不到（意味着小红没法做出回复），或小红说话小明听不到（小明不能确定小红是否能听见），又或是各自都听不到对方的声音，那么这次通话就是糟糕的，需要挂掉重新拨打。</p>
</blockquote>
<p>根据上面的情景，就可以大致揣摩发明三次握手的前辈的思路了。TCP 建立连接也是需要三次报文同步，如果是 client 主动向 server 发起连接请求，那么一个正常的 TCP 连接建立应该是下面这样的：</p>
<ol>
<li class="lvl-3">
<p><strong>第一次握手</strong>：client 发送 {<strong>Seq</strong>:a, <strong>SYN</strong>:1} 报文段。表明尝试建立连接，且本次连接生成的<strong>随机</strong>初始序列号为 a；</p>
</li>
<li class="lvl-3">
<p><strong>第二次握手</strong>：server 收到后，意识到有人尝试和自己建立连接，<strong>如果条件允许</strong>，就会发送一个 {<strong>Seq</strong>:b, <strong>Ack</strong>:a+1, <strong>SYN</strong>:1, <strong>ACK</strong>:1}。表明同意建立连接，且本次连接也<strong>随机</strong>生成一个初始序列号 b；</p>
</li>
<li class="lvl-3">
<p><strong>第三次握手</strong>：client 看到 server 的回复，意识到自己和 server 之间能正确进行数据交互，但是 server 不确定自己的数据能否被 client 收到。为了让 server 安心，client 回复一个 {<strong>Seq</strong>:a+1, <strong>Ack</strong>:b+1, <strong>ACK</strong>:1} 的报文段，作为对之前报文的回复，server 收到后，也能确立双方连接已建立；</p>
</li>
</ol>
<img src="3hand.png" style="zoom:50%">
<blockquote>
<p>上面是理想的情况，现实的网络中总存在这样那样的异常：进程可能崩溃、机器可能断电、传输可能超时……TCP 是一个牛逼的协议，它考虑到了种种情况，并且对每个情况都有相应的自洽的逻辑。</p>
</blockquote>
<h4 id="每次建立新的-TCP-连接时，初始序列号为什么要随机？">每次建立新的 TCP 连接时，初始序列号为什么要随机？</h4>
<p>如果每次初始序列号是一样的，那么<strong>无法区分收到的报文是这次连接发来的还是之前的连接发来的</strong>。</p>
<blockquote>
<p>TCP 仅通过 <strong>双方 IP 地址和端口</strong> 唯一标识一个 TCP 连接，而序列号仅仅是一个 64 位无符号整数，一旦到上限就归零重新计数。这也就意味着无法根据序列号来辨识。</p>
</blockquote>
<p>如果说上面这个原因可以通过四次挥手的 <strong>TIME WAIT</strong> 阶段解决，那么还有一个原因，就是如果每次序列号都是一样的，黑客就可以很轻易地伪造一个报文让 server 接收，从而进行攻击。</p>
<h4 id="什么是-TCP-keepalive">什么是 TCP-keepalive</h4>
<p>连接建立完成，在数据传输过程中，如果 client 挂了，对于 server 而言，如果一直没收到 client 的消息，最好的策略就是确认 client 是否挂掉，如果挂掉就及时断开该连接，腾出系统资源，这个策略就是 TCP-keepalive，也称<strong>保活机制</strong>。</p>
<p>具体为：server 会维护一个保活定时器，当收到 client 正常数据请求时，该定时器会重置；一旦定时器 timeout，就会主动给 client 发送一个「探测报文」</p>
<ol>
<li class="lvl-3">
<p>如果 client 正确回复，则定时器重置，server 会认为 client 还在，只是暂时不需要请求；</p>
</li>
<li class="lvl-3">
<p>如果 client 超时未回复，server 并不会立即认为 client 挂了，而是重传，直到达到重传次数上限，才会认为 client 挂了，此时主动断开连接，释放资源；</p>
</li>
</ol>
<h4 id="什么是-SYN-洪泛攻击">什么是 SYN 洪泛攻击</h4>
<p>Linux 内核会为三次握手维护两个队列：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>半连接队列</strong>：存放收到连接请求但未完成三次握手的 client 信息（<strong>SYN RCVD</strong>）；</p>
</li>
<li class="lvl-2">
<p><strong>全连接队列</strong>：存放已完成三次握手的 client 信息（<strong>ESATABLISHED</strong>）；</p>
</li>
</ul>
<p><strong>攻击者</strong>可以伪造不同 IP/端口向 server 发送 {<strong>SYN</strong>:1}，但是又不进行第三次握手，那么 server 就会有大量的 <strong>SYN RCVD</strong> 状态，半连接队列也会被逐渐占满（是的，并不是没有上限的），新的<strong>用户</strong>连接请求到达后，会因为队列满而被丢弃，那就没法提供正常的 TCP 服务了。</p>
<blockquote>
<p>所以如果 {<strong>SYN</strong>:1} 被 server 丢弃，则很有可能是 server 遭到了 SYN 攻击，连接队列满了。</p>
</blockquote>
<p>对于 server 而言，如果长时间处于 <strong>SYN RCVD</strong> 状态，肯定是不对的——它检测到超时就会进行重传，当重传到一定次数还没有收到 client 的第三次握手，则关闭连接，将其移出半连接队列，为正常连接腾出位置。</p>
<h4 id="为什么握手是三次而不是两次？四次？">为什么握手是三次而不是两次？四次？</h4>
<p>为了让双方确保各自均有发送和接收数据的能力——这个答案不错，但并不完整。使用三次握手而不是两次的还有一个关键原因在于，<strong>三次握手可以消除历史连接的影响</strong>。</p>
<blockquote>
<p>在真实网络中，<strong>丢包</strong>和<strong>超时</strong>是必须要考虑的两个异常状况。它们都会因为网络拥堵引起。其中超时报文可能会在遥远的未来到达，如果连接双方在这个报文起已经往前推进了，那么这个报文就是「<strong>历史</strong>」的。</p>
</blockquote>
<p>🎨<strong>考虑这样一种情况</strong>：<em>某 client 因为宕机导致前后发送了两个不同初始序列号的连接请求，并且因为网络拥塞等因素，client 在发送第二个连接请求后，收到了第一个连接请求的回复，client 发现该回复中的 ACK 字段与新生成的初始序列号不匹配，就回复一个 {<strong>RST</strong>:1} 强制终止这次连接</em>。</p>
<p>如果两次握手即可建立连接，server 会在收到 client 的第一个连接请求后进行资源分配，进入 <strong>ESTABLISHED</strong> 状态，之后又被强制终止，然后又收到 client 的第二个连接请求后再次进行资源分配，进入 <strong>ESTABLISHED</strong> 状态。如果 client 没有宕机呢？也可能会因为超时重传和第一个连接请求同样的报文段，server 重复收到多个连接请求，也就会多次进行资源分配与连接建立。</p>
<blockquote>
<p>这里仅仅是一个 client 的一次宕机/超时就导致 server 额外进行了不必要的连接建立，真实场景下一个 server 可能会收到海量 client 的连接，即使只有其中一小部分出现这种异常情况，那也会增加 server 不必要的资源浪费——而这只需要额外的一次握手即可解决。</p>
</blockquote>
<blockquote>
<p>至于连接建立后 client 宕机重启重连的情况，就参考下一个话题。</p>
</blockquote>
<p>而四次握手则是没有必要。就像最开始提到的<strong>电话问题</strong>，「你能听到吗？」和「可以。」分别对应了 连接请求 和 回复。小红只不过把连接请求和回复放在同一句话中，也就是将四次握手里的第二次和第三次合并，就成为了三次握手。</p>
<h4 id="在-ESTABLISHED-状态下，server-收到来自同一个-client-的连接请求-SYN-1-会怎么处理？">在 ESTABLISHED 状态下，server 收到来自同一个 client 的连接请求 {SYN:1} 会怎么处理？</h4>
<p>连接的建立，代表着双方都确认了对方的 socket/四元组，但即便是同一个 client，也可以用不同的 socket 建立连接。</p>
<blockquote>
<p>这里认为新的连接请求是 client 主观发起的，且旧连接已被弃用。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>如果新的连接请求和之前用的是<strong>不同的</strong> socket：server 会认为这是一个新的连接，那么就进行一个新连接该有的流程，并且原先的连接肯定不会再被 client 使用了，触发超时断开；</p>
</li>
<li class="lvl-3">
<p>如果新的连接请求和之前用的是<strong>同一个</strong> socket：server 会认为 client 是不是搞错了，发送一个携带了对应旧连接的 SEQ 和 ACK 的所谓 <strong>Challenge ACK</strong> 的报文给 client。这会使得 client 在 <strong>SYN SENT</strong> 阶段收到一个不匹配的 ACK，就回复一个 {<strong>RST</strong>:1} 给 server，强制终止这次连接；</p>
</li>
</ol>
<h3 id="TCP-断开连接——四次挥手">TCP 断开连接——四次挥手</h3>
<p>根据三次握手，我们也不难理解四次挥手的整个过程。</p>
<ol>
<li class="lvl-3">
<p><strong>第一次挥手</strong>：client 已经发完所有数据，决定断开连接，于是发送 {<strong>FIN</strong>:1}，进入 <strong>FIN WAIT 1</strong> 状态；</p>
</li>
<li class="lvl-3">
<p><strong>第二次挥手</strong>：server 收到该断开连接请求，但是可能自己还有数据没发完，就先用 {<strong>ACK</strong>:1} 同意 client 的请求，等到自己数据发完了再主动断开，这就进入了 <strong>CLOSE WAIT</strong> 状态。client 收到后，意识到 C-&gt;S 这个方向的连接已经断开，进入 <strong>FIN WAIT 2</strong> 状态；</p>
</li>
<li class="lvl-3">
<p><strong>第三次挥手</strong>：server 也发完数据了，决定断开连接，于是发送 {<strong>FIN</strong>:1}，等待 client 最后的回复，进入 <strong>LAST ACK</strong> 状态；</p>
</li>
<li class="lvl-3">
<p><strong>第四次挥手</strong>：client 收到该断开连接请求并用 {<strong>ACK</strong>:1} 同意，进入 <strong>TIME WAIT</strong> 等待 2MSL 后彻底断开连接，server 收到这条回复后，也彻底断开连接；</p>
</li>
</ol>
<img src="4hand.png" style="zoom:50%">
<p>当然四次握手也不一定非得是四次，之所以是四次是因为 server 在收到 client 的断开连接请求时，可能还有数据要发送。如果没有数据要发送的话，二三次挥手可以合并到一起，此时跳过了 client 的 <strong>FIN WAIT 2</strong> 状态。</p>
<h4 id="为什么-TIME-WAIT-要等-2MSL">为什么 TIME WAIT 要等 2MSL</h4>
<p>首先要知道 <strong>MSL</strong>(Maximum Segment Lifetime, 最大报文生存时间)是一个时间值，在网络上滞留时间超过这个值的报文将被丢弃，一般而言是 30s。而 2MSL 足以让本次连接中因为网络阻塞而滞留的报文全部消亡。即使极端情况下，从 client 发出到 server 接收，server 又作出回复，一来一回也最多需要两倍的时间，在这个时间段里所有收到的报文均会被 client 丢弃，剩下没收到的也会因为 IP 层的 TTL 归零而被路由器丢弃（MSL 必须大于 TTL 归零的时间）。</p>
<p>前面提到，历史的连接可能会对未来的连接造成影响，如果下一次连接中某个报文使用了和本次连接某个报文相同的序列号，且 client 没有等待历史报文销毁就创建新的连接，server <strong>可能</strong>会收到历史报文，并且认为是本次连接中 client 发出的，那不就发生错误了么？</p>
<blockquote>
<p>因为初始序列号是随机的，加上序列号超过上限会从零开始继续增加，所以前后两次连接出现相同序列号的报文是完全有可能的。</p>
</blockquote>
<p>除此之外，如果第四次挥手时 client 的回复超时未抵达或丢失，那么 server 会重传断开连接请求，client 收到后会重发 {<strong>ACK</strong>:1}，并且重置 <strong>TIME WAIT</strong> 计时器。2MSL 足以确保在只发生一次丢失的情况下还能正确完成四次挥手过程。你问如果 client 的回复和 server 的重传一直丢失呢？概率太小了，为此增大等待时长，跟为了研究生补助去读研有什么区别（bushi。</p>
<h4 id="服务端为什么会出现-TIME-WAIT-状态？该怎么解决？">服务端为什么会出现 TIME WAIT 状态？该怎么解决？</h4>
<p>要明确的一点是，<strong>只有主动断开连接的一方，才会进入 TIME WAIT</strong>。这就意味着服务端主动断开了连接，问题大概率和 <strong>HTTP 的长连接</strong>有关。</p>
<ol>
<li class="lvl-3">
<p><strong>没有使用长连接</strong>：需将双方 HTTP 的 Connection 字段设置为 <strong>Keep-Alive</strong>，只要有一方设为了 <strong>Close</strong>，server 就会在处理完一个 HTTP 请求后主动关闭连接；</p>
<blockquote>
<p>长连接的优势在于，一旦建立连接，后续可以用同个 TCP 连接进行数据交互，直至主动断开，而不是每进行一次数据传输就来一遍三握四挥，减少了开销。HTTP/1.0 是默认关闭的（Connection:Close），而 HTTP/1.1 起是默认开启的；</p>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>长连接超时</strong>：如果 client 没有主动断开连接，那么也不能让它一直占着系统资源，当过了某个阈值（如 nginx 中的 <strong>keepalive_timeout</strong>）一直没有收到后续请求后，就会触发回调函数关闭该连接，从而进入 <strong>TIME WAIT</strong>；</p>
</li>
<li class="lvl-3">
<p><strong>长连接请求数量达到上限</strong>：为了节省系统资源，server 能够维护的长连接数量是有限的，当超过这个上限（如 nginx 中的 <strong>keepalive_requests</strong>）时，就会主动关闭连接；</p>
</li>
</ol>
<h4 id="如果客户端大量连接处于-TIME-WAIT-状态，会导致什么问题？该怎么解决？">如果客户端大量连接处于 TIME WAIT 状态，会导致什么问题？该怎么解决？</h4>
<blockquote>
<p>client 通常作为主动断开连接的一方，极有可能出现大量连接同时处于 TIME WAIT 阶段。</p>
</blockquote>
<p>如果 client 的某个连接位于 <strong>TIME WAIT</strong>，那么在计时器结束前，该连接都不会被彻底释放，也就是说 client 的这个端口资源会被占用。如果大量连接处于 <strong>TIME WAIT</strong> 状态，一旦占满了所有端口资源，那么就无法对同一 server 建立新的连接。当然，除此以外，过多的 <strong>TIME WAIT</strong> 也会占用 client 的系统资源（CPU、文件描述符等）。</p>
<blockquote>
<p>但是不同的 server 还是可以的，只要四元组（源 IP，源端口，目的 IP，目的端口）有一个值不同，那么就是不同的连接，不会产生冲突。</p>
</blockquote>
<p>有以下几种方法可以解决大量连接处于 <strong>TIME WAIT</strong> 状态的问题：</p>
<ol>
<li class="lvl-3">
<p><strong>减少 MSL</strong>：减少 <strong>TIME WAIT</strong> 状态的持续时间，以快速释放端口资源；</p>
</li>
<li class="lvl-3">
<p><strong>重用端口</strong>：可以通过设置 Linux 内核参数 <code>net.ipv4.tcp_tw_reuse=1</code> 来启用端口重用功能，允许新的连接重用处于 TIME WAIT 状态超过 1s 的端口；</p>
<blockquote>
<p>注意只能用于客户端。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><strong>优化连接管理</strong>：及时关闭不再使用的连接，避免长时间处于 TIME WAIT 状态。这可以通过优化程序代码，确保连接在不再需要时及时关闭。</p>
</li>
<li class="lvl-3">
<p><strong>负载均衡</strong>：使用负载均衡来分担连接压力，将连接分发到多台服务器上，可以减少单台服务器上 TIME WAIT 状态连接的数量。</p>
</li>
</ol>
<h4 id="如果服务端大量连接处于-CLOSE-WAIT-状态，会导致什么问题？该怎么解决？">如果服务端大量连接处于 CLOSE WAIT 状态，会导致什么问题？该怎么解决？</h4>
<p>要明确的一点是，<strong>只有被动断开连接的一方，才会进入 CLOSE WAIT</strong>。这就意味着虽然客户端先一步主动断开了连接，但是服务端迟迟未断开，问题大概率和 server <strong>没有调用 <code>close()</code> 函数关闭连接</strong>有关。这就需要进行代码层面的排查，看看 <strong>epoll</strong> 流程是否有问题。</p>
<h2 id="基于字节流">基于字节流</h2>
<p>当用户消息通过 UDP 协议传输时，操作系统不会对消息进行拆分，在组装好 UDP 头部后就交给网络层来处理，所以发出去的每个 UDP 报文就是一个用户消息，这样接收方在接收到 UDP 报文后，读一个 UDP 报文（根据 UDP Header 的长度字段）就能读取到完整的用户消息。</p>
<p>而根据 TCP Header，我们发现 TCP 并没有像 UDP 那样设置了数据字段的长度，当应用层有多个用户消息需要发送时，TCP 只是单纯地将这些消息以 Byte 的形式放到 buffer 中，然后从中取出合适的字节数量进行组装并下发给网络层。所以一个 TCP 报文内可能有<strong>多个不完整</strong>的用户消息数据。</p>
<p>比如有两个消息 “How are you?” 和 “How old are you?” 要发送。</p>
<p>它们可能会组装到同一个 TCP 报文中：「How are you?How old are you?」</p>
<p>也可能会分散到两个报文：「How are you?」、「How old are you?」</p>
<p>也有可能会被截断：「How are」、「 you?How old are you?」</p>
<p>上面举的例子主要是为了说明，接收方收到一个报文后，并不能直接将解包后的数据视为一个完整的用户消息。这就是所谓的<strong>粘包问题</strong>，实际是应用层处理不当产生的问题。</p>
<h3 id="TCP-粘包如何解决">TCP 粘包如何解决</h3>
<p>粘包的问题出现是因为不知道一个用户消息的边界在哪，如果知道了边界在哪，接收方就可以通过边界来划分出有效的用户消息。应用层构造数据包时，可以用特殊字符串作为终止符（如 <code>char*</code> 的 <code>'\0'</code>），也可以加上「长度」字段……只要能明确边界即可。</p>
<h2 id="可靠传输">可靠传输</h2>
<h3 id="重传机制">重传机制</h3>
<h4 id="超时重传（时间驱动）">超时重传（时间驱动）</h4>
<p>每次发送报文时，会将其缓存在一个<strong>未确认队列</strong>中。当这些报文发出去后，如果<strong>在超时重传时间</strong>(<strong>RTO</strong>, <strong>R</strong>etransmission <strong>T</strong>ime<strong>O</strong>ut)内没有收到对这些报文的确认应答，则重传队列中的这些报文，并且将 RTO 加倍。一旦收到了确认，则会将 RTO 重置为初始值。</p>
<h4 id="快重传（数据驱动）">快重传（数据驱动）</h4>
<p>如果连续三次收到了相同的确认应答号 {<strong>Ack</strong>:n}，并且 {<strong>Seq</strong>:n} 已经发出去了，那么发送方会认为发出去的报文没被对方收到，此时马上进行重传。那么这里就会引发一个问题：只重传一个报文，还是重传该报文之后所有的报文？</p>
<p>如果 {<strong>Seq</strong>:n} 之后有 {<strong>Seq</strong>:m} 未收到，但是 {<strong>Seq</strong>:p} 已经被收到（<code>n &lt; m, n &lt; p</code>），无论重传 n，还是重传 n,m,p，都会存在问题。需要有一种机制，让发送方知道只有 n 和 m 没发出去，这就是<strong>选择性确认</strong>(<strong>SACK</strong>, <strong>S</strong>elective, <strong>ACK</strong>nowledgment)。只需要在双方 TCP Header 的「选项」字段里加入 SACK 即可。在 Linux 下，可以通过 <code>net.ipv4.tcp_sack</code> 参数打开这个功能（Linux 2.4 后默认打开）。</p>
<h3 id="滑动窗口">滑动窗口</h3>
<p>窗口机制使得发送方可以一次性发送若干报文，并且在接收方处理完毕后，对这些报文进行<strong>累计确认</strong>，而不是每次只进行单个报文的交互，这大大提高了网络吞吐量。</p>
<p>TCP Header 里的「窗口」字段指明了数据交互的窗口大小，也就是接收方的缓冲区的余量。接收方每次处理完数据后，会根据当前缓冲区的情况设置窗口大小，通知自己当前的处理能力；发送方会根据这个值调整下一次发送的数据量。</p>
<blockquote>
<p>如果发送方发送了超过这个值的数据量，那么会导致接收方缓冲区溢出而丢弃某些数据。</p>
</blockquote>
<p>通常这个值又会被称为<strong>接收窗口大小</strong>(<strong>RWS</strong>, <strong>R</strong>eceiver <strong>W</strong>indow <strong>S</strong>ize)。</p>
<blockquote>
<p>而发送方当前能发送的最大数据量称为<strong>发送窗口大小</strong>(<strong>SWS</strong>, <strong>S</strong>ender <strong>W</strong>indow <strong>S</strong>ize)，SWS 是由 RWS 和下面要提到的<strong>拥塞窗口大小</strong>(<strong>CWS</strong>, <strong>C</strong>ongestion <strong>W</strong>indow <strong>S</strong>ize)共同决定的，有 $\text{SWS} = \min(\text{RWS}, \text{CWS})$。</p>
<p>需要注意的是，已发送但未确认的报文也占用了发送窗口。只有当报文得到确认，窗口才能右移。</p>
</blockquote>
<h3 id="拥塞控制">拥塞控制</h3>
<p>如果当前网络拥堵，即使接收方的缓冲区十分空余，发送方也不能一次性发很多数据。发送方仅能通过接收方的反应来确定当前网络状况，如果出现了超时，或者连续多个 ACK，那么就认为当前网络可能不太良好，需要降低发送的数据量，而<strong>拥塞窗口</strong>就是用于控制发送量的另一个窗口值。CWS 的计算主要有以下 4 个原则：</p>
<ol>
<li class="lvl-3">
<p><strong>慢启动</strong>：当 CWS &lt; ssthresh 时，每收到一个 ACK，CWS = CWS+1，这使得 CWS 以<strong>指数</strong>增长；</p>
</li>
<li class="lvl-3">
<p><strong>拥塞避免</strong>：当 CWS &gt;= ssthresh 时，每收到一个 ACK，CWS = CWS+1/CWS，这使得 CWS 以<strong>线性</strong>增长；</p>
</li>
<li class="lvl-3">
<p><strong>拥塞发生</strong>：当发生了超时重传，ssthresh = CWS/2，CWS = 1，重新开始指数增长；</p>
</li>
<li class="lvl-3">
<p><strong>快恢复</strong>：当连续收到 3 个 ACK，ssthresh = CWS/2，CWS = CWS/2，此时进行线性增长；</p>
</li>
</ol>
<blockquote>
<p>ssthresh 又称<strong>慢启动门限</strong>，用于控制慢启动时期 CWS 不至于增长过快。CWS 初始为 1。</p>
</blockquote>
<img src="cc.png" style="zoom:50%">
<p><font size="3"></font></p><div style="text-align:center"><font size="3">图源 小林Coding</font></div><p></p>
<h2 id="TCP-和-UDP-比较">TCP 和 UDP 比较</h2>
<p>先来看看 UDP 的首部</p>
<img src="udp.png" style="zoom:70%">
<p>再来看看区别</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">TCP</th>
<th style="text-align:center">UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><strong>连接</strong></td>
<td style="text-align:center">面向连接，三握四挥</td>
<td style="text-align:center">无需建立连接，直接传输</td>
</tr>
<tr>
<td style="text-align:center"><strong>服务对象</strong></td>
<td style="text-align:center">一对一</td>
<td style="text-align:center">多对多</td>
</tr>
<tr>
<td style="text-align:center"><strong>可靠性</strong></td>
<td style="text-align:center">可靠传输，数据无差错、不丢失、不重复、按序到达</td>
<td style="text-align:center">尽最大努力交付，不保证可靠</td>
</tr>
<tr>
<td style="text-align:center"><strong>效率</strong></td>
<td style="text-align:center">低，连接的建立需要开销，网络拥塞会导致吞吐量降低</td>
<td style="text-align:center">高，既没有建立连接的开销，也不会受到网络拥塞的影响</td>
</tr>
<tr>
<td style="text-align:center"><strong>传输方式</strong></td>
<td style="text-align:center">基于字节流，可能会粘包</td>
<td style="text-align:center">基于消息流，有明确边界（首部「包长度」字段）</td>
</tr>
<tr>
<td style="text-align:center"><strong>分片</strong></td>
<td style="text-align:center">在传输层分片，阈值为 MSS</td>
<td style="text-align:center">交给 IP 层分片，阈值为 MTU</td>
</tr>
<tr>
<td style="text-align:center"><strong>应用场景</strong></td>
<td style="text-align:center">HTTP、HTTPS、FTP</td>
<td style="text-align:center">包总量较少的通信如：DNS、SNMP；或是对传输实时性要求较高的如：多媒体通信、广播通信</td>
</tr>
</tbody>
</table>
<h3 id="如何基于-UDP-实现可靠传输？">如何基于 UDP 实现可靠传输？</h3>
<p><a href="https://www.xiaolincoding.com/network/3_tcp/quic.html">QUIC</a></p>
<h3 id="TCP-和-UDP-可以-bind-到同一个端口吗？">TCP 和 UDP 可以 bind 到同一个端口吗？</h3>
<p>可以的，操作系统为两种协议提供了不同的模块，互相独立，互不干扰。</p>
<p>发送端创建 socket 的时候可以指定协议类别，从而调用 <code>send()</code> 的时候就会使用相应的模块处理；而接收端则会根据 IP Header 的协议字段来判断是 TCP 还是 UDP，从而使用相应模块处理。</p>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
  </entry>
  <entry>
    <title>TinyKV Project1 StandaloneKV</title>
    <url>/lab/tinykvproject1/</url>
    <content><![CDATA[<p>本 Project 需要我们基于 badger 实现一个独立存储引擎。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<h3 id="Part-A-Implement-standalone-storage-engine">Part A Implement standalone storage engine</h3>
<p>需要实现的代码在 <code>kv/storage/standalone_storage/standalone_storage.go</code>。</p>
<p><code>NewStandAloneStorage(conf *config.Config)</code> 是工厂函数，返回一个 <code>StandAloneStorage</code> 指针。在这里需要了解 <code>Config</code> 数据结构，里面存放了数据库文件路径等重要信息，并且在其他方法中也要用到，所以在 <code>StandAloneStorage</code> 结构体中需存放传入的 <code>Config</code> 信息，以及其包装的 badger DB 实例。</p>
<p><code>Start()</code> 函数驱动存储引擎运行，调用 <code>engine_util.CreateDB()</code> 并将返回值存在结构体中即可；同样的，<code>Stop()</code> 调用 <code>badger.DB.Close()</code> 即完成存储引擎的关闭。</p>
<p><code>Write()</code> 传入一个 <code>Modify</code> 切片。<code>Modify</code> 表示实现了 <code>Cf()/Key()/Value()</code> 三个函数的接口，可以是 <code>Put/Delete</code>（见 <code>kv/storage/modify.go</code>）。通过遍历该切片，执行类型转换，调用 <code>engine_util.PutCF()/engine_util.DeleteCF()</code> 方法即可。</p>
<p><code>Reader()</code> 需要返回一个 <code>StorageReader</code>。这是一个已经为我们定义好了的接口，我们要做的就是实现该接口，即定义一个 <code>StandAloneStorageReader</code> 及 <code>GetCF()/IterCF()/Close()</code> 三个函数，这样就能在调用 <code>Reader()</code> 时返回了。</p>
<blockquote>
<p>这三个函数其实分别对应了 util_engine 包中为我们实现好的 <code>GetCFFromTxn()/NewCFIterator()</code> 以及 <code>badger.Txn.Commit()</code>。所以新建结构体的时候还得包裹 <code>badger.Txn</code> 变量。</p>
</blockquote>
<h3 id="Part-B-Implement-service-handlers">Part B Implement service handlers</h3>
<p>需要实现的代码在 <code>kv/server/raw_api.go</code>.</p>
<p>这里需要实现的 4 个函数，其实就是获取传入的 <code>Request</code> 中的各种字段，调用 <code>Storage</code> 的 <code>Write</code>（对应 Put/Delete 请求）/<code>Reader</code>（对应 Get/Scan 请求），最后 return 一个 <code>Response</code> 即可。</p>
<blockquote>
<p>甚至给了我们 Hint，我哭死。</p>
</blockquote>
<p>需要注意的是 <code>RawScanRequest</code> 有一个 <code>Limit</code> 字段，在迭代器遍历过程中还要注意不要超限。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">limit <span class="token operator">:=</span> req<span class="token punctuation">.</span><span class="token function">GetLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> iter<span class="token punctuation">.</span><span class="token function">Seek</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">GetStartKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> iter<span class="token punctuation">.</span><span class="token function">Valid</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> limit <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> iter<span class="token punctuation">.</span><span class="token function">Next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// response.Kvs = append(response.Kvs, "the data we get")</span>
  limit<span class="token operator">--</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>其实符合 SQL 语句中的 limit 关键字。</p>
</blockquote>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>TinyKV Project2 RaftKV</title>
    <url>/lab/tinykvproject2/</url>
    <content><![CDATA[<p>本 Project 需要我们实现基础 Raft 算法。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<h3 id="Part-A-Raft">Part A Raft</h3>
<p>需要实现的代码在整个 <code>raft</code> 文件夹下。</p>
<p>这一 part 我们要实现三个模块，分别为</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>Leader election =&gt; 领导选举</p>
</li>
<li class="lvl-2">
<p>Log replication =&gt; 日志复制</p>
</li>
<li class="lvl-2">
<p>Raw node interface =&gt; 上层接口</p>
</li>
</ul>
<p>有了之前 <a href="../../mit6.824/6-824%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93">MIT6.824</a> 的经验，做这部分其实没啥压力，最大的困难点在于熟悉整个代码框架。</p>
<p>跟 6.824 不同之处在于，TinyKV 的 Raft 模块进行同步采用的消息队列的形式，由上层定时收取然后传输给其他存储节点的 Peer，上层收到消息后 push 到下层驱动 Raft 模块接收信息。</p>
<h4 id="1-Leader-Election">1 Leader Election</h4>
<p>领导选举的基本流程如下：</p>
<p>对于发起者：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>上层调用 <code>Tick()</code>；</p>
</li>
<li class="lvl-2">
<p>Raft 层检查是否满足发起选举条件，即 <code>electionElapsed &gt;= electionTimeout</code> 且不是 Leader；</p>
</li>
<li class="lvl-2">
<p>若超时，则视为收到收到一条本地 <code>MsgHup</code> 消息，对该消息的处理就是正式进入开始选举事件，即</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>raft/raft.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">Step</span><span class="token punctuation">(</span>m pb<span class="token punctuation">.</span>Message<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> m<span class="token punctuation">.</span>MsgType <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">case</span> pb<span class="token punctuation">.</span>MessageType_MsgHup<span class="token punctuation">:</span>
      <span class="token comment">// 开始选举</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-2">
<p>如果不是 Leader（防止恶趣味测试给 Leader 发一条 MsgHup），则成为候选人 <code>Candidate</code>（进入下一任期，投自己一票），并向其他 Peer （如果有）发送 <code>MsgRequestVote</code>。请求中除了自身 <code>CurrentTerm</code>，还需包含自己最后一个日志条目的 <code>LogTerm</code> 与 <code>LogIndex</code>；</p>
<blockquote>
<p><strong>存在只有自己一个 Peer 的情况，那就直接成为 Leader 不用发请求了</strong>；</p>
</blockquote>
</li>
<li class="lvl-2">
<p>对于收到的每一张票，首先检查发送方的 <code>Term</code>，判断是需要切换到 <code>Follower</code> 并更新任期。然后检查是同意还是拒绝，如果同意票过半则成为 Leader，如果反对票过半则退至 <code>Follower</code>，等待其他 Leader 发来消息或者下一次开始选举。</p>
</li>
</ul>
<p>对于接收者：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>上层调用 <code>Step()</code>；</p>
</li>
<li class="lvl-2">
<p>检查发送方的 <code>Term</code>，判断是需要切换到 <code>Follower</code> 并更新任期，还是返回一个拒绝；</p>
</li>
<li class="lvl-2">
<p>检查当前任期是否给发送方投过票，如果投给别人了那也拒绝，讲究一个先来后到；</p>
</li>
<li class="lvl-2">
<p>检查发送方最后一个日志条目的信息是否比自己更旧，如果是就拒绝，他不配当 Leader；</p>
</li>
<li class="lvl-2">
<p>返回一个同意票，并修改自身投票记录；</p>
</li>
</ul>
<p>需要注意的是，<code>electionTimeout</code> 应返回一个随机数，防止出现多个 Peer 不断同时发起选举的死局。这里我用一个函数代替，随机返回 1~3 倍的给定超时值。</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>raft/common.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>Raft<span class="token punctuation">)</span> <span class="token function">getElectionTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> rand<span class="token punctuation">.</span><span class="token function">Intn</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>r<span class="token punctuation">.</span>electionTimeout<span class="token punctuation">)</span> <span class="token operator">+</span> r<span class="token punctuation">.</span>electionTimeout
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>由于这里完全采用了同步的方案，故不需要用到 Goroutine 与并发相关代码。</p>
</blockquote>
<h4 id="2-Log-replication">2 Log replication</h4>
<p><strong>MsgAppend</strong>：</p>
<p>选举成功成为 Leader 后，需要立刻在自己的日志中增添一条空的日志条目，以快速提交旧日志（根据 raft paper 中的 figure 8，只能 commit 当前 Term 的日志）。一旦有任何日志被添加（成为 Leader 或收到 <code>MsgPropose</code> 消息），都会触发 Raft 的日志复制机制——向所有 Peer 发送 <code>MsgAppend</code>。</p>
<p>关于日志复制其实论文里讲的很清楚了。Raft 层维护所有 Peer 的两个变量：<code>Match</code> 和 <code>Next</code>。前者表示目前能够确定的其他 Peer 与自身一致的最后一个日志条目 <code>Index</code>，后者表示下一次 <code>MsgAppend</code> 要从哪个日志开始发。</p>
<blockquote>
<p>这两个字段都会在新建 Raft 节点时初始化为 0 和 LastLogIndex+1。</p>
</blockquote>
<blockquote>
<p><code>MsgAppend</code> 需要包含 <code>PrevLogTerm</code> 与 <code>PrevLogIndex</code> 以便接收方进行日志匹配。</p>
</blockquote>
<p>同时，消息还要附带一个 <code>Commit</code> 字段，让其他 Peer 知道哪些日志是已经拷贝到多数 Peer，并更新自己的 <code>Committed</code>，以便 Apply 到上层。</p>
<p>接收方收到 <code>MsgAppend</code> 并检查完发送方 <code>Term</code> 后，便开始进行匹配，如果<code>PrevLogTerm</code> 与 <code>PrevLogIndex</code> 不匹配，则拒绝该条消息。</p>
<p>反之遍历 <code>Entries</code>，直到第一条不匹配的为止，后续的都删掉，然后将新来的条目加到自己的日志中，即</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>raft/heartbeat.go</span></div><code class="language-go"><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>Entries<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
  firstNewLogIndex <span class="token operator">:=</span> m<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  newLogIndex <span class="token operator">:=</span> firstNewLogIndex
  <span class="token keyword">for</span> <span class="token punctuation">;</span> newLogIndex <span class="token operator">&lt;=</span> <span class="token function">min</span><span class="token punctuation">(</span>r<span class="token punctuation">.</span>RaftLog<span class="token punctuation">.</span><span class="token function">LastIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> lastNewLogIndex<span class="token punctuation">)</span><span class="token punctuation">;</span> newLogIndex<span class="token operator">++</span> <span class="token punctuation">{</span>
    newLogTerm<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> r<span class="token punctuation">.</span>RaftLog<span class="token punctuation">.</span><span class="token function">Term</span><span class="token punctuation">(</span>newLogIndex<span class="token punctuation">)</span>
    <span class="token keyword">if</span> newLogTerm <span class="token operator">!=</span> m<span class="token punctuation">.</span>Entries<span class="token punctuation">[</span>newLogIndex <span class="token operator">-</span> firstNewLogIndex<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetTerm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// If an existing entry conflicts with a new one (same index but different terms)</span>
      <span class="token comment">// Delete the existing entry and all that follow it</span>
      <span class="token keyword">break</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">;</span> newLogIndex <span class="token operator">&lt;=</span> lastNewLogIndex<span class="token punctuation">;</span> newLogIndex<span class="token operator">++</span> <span class="token punctuation">{</span>
    <span class="token comment">// Append any new entries not already in the log</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，根据消息中的 <code>Commit</code> 字段更新结构体字段，并发送同意回复，包含自身最后一条日志的 <code>Index</code>，让 Leader 更新 <code>Match/Next</code> 字段。</p>
<blockquote>
<p>如果消息中的 <code>Entries</code> 长度为 0，则至少可以确定 Leader 含有相同的日志 <code>{Term: PrevLogTerm, Index: PrevLogIndex}</code>，那么论文中提到的 “index of last new entry” 就是 <code>PrevLogIndex</code> 了。</p>
</blockquote>
<p>要注意，如果不同意该条 <code>MsgAppend</code>，则无需更新 <code>electionElapsed</code>，因为该 Leader 可能刚从分区的网络中放出来，马上要下台了。反之要重置一下自身选举相关的状态。</p>
<p>发送方收到 <code>MsgAppendResponse</code> 后，看看是不是要切到 <code>Follower</code>，然后看看是否为同意，是则更新 <code>Match = response.Index, Next = Match + 1</code>，然后根据所有 Peer 的 <code>Match</code> 更新自身的 <code>Commit</code>；反之令 <code>Next--</code>，重新发 <code>MsgAppend</code>。</p>
<p><strong>Heartbeat</strong>：</p>
<p>与 6.824 不同，TinyKV 将日志复制和心跳分开，算两种不同的消息。前者上文已经提过，后者则是在 Tick() 驱动至心跳超时或收到 <code>MsgBeat</code> 消息后，向所有 Peer 发送 <code>MsgHeartbeat</code>。心跳的作用不仅仅是巩固 Leader 地位，还要向 Peers 广播自己的 <code>Commit</code>，接收方如果发现 Leader 的 <code>Commit</code> 比自己最后一个日志的 <code>LastLogIndex</code> 还大，则需要告诉发送方这一信息，表明自己落后了，<strong>并拒绝该条消息</strong>；反之更新自身的 <code>Commit</code>。</p>
<p>发送方检查回复，如果 Peer 落后了，立刻发一条 <code>MsgAppend</code> 过去让它赶紧进入到最新的状态。</p>
<h4 id="3-Implement-the-raw-node-interface">3 Implement the raw node interface</h4>
<p><code>RawNode</code> 包裹了 Raft 层，其作用就是定期检查 Raft 的状态（日志、消息队列等）是否有更新，如果有则发送给上层进行处理，同时获取处理结果进行状态更新。</p>
<p>主要是实现 <code>raft/rawnode.go</code> 中的 <code>Ready()</code>，<code>HasReady()</code>，<code>Advance()</code> 三个函数。</p>
<blockquote>
<p>首先要明确的一点是，一个 Raft 日志会长成以下这个样子：</p>
<p>RaftLog manage the log entries, its struct look like:</p>
<p>snapshot/first…applied…committed…stabled…last</p>
<p>-------------|-------------------------------------------|</p>
<p>分别代表了快照截断、已被上层应用、Raft 层多数持有、已被持久化、最后一个日志的 Index。</p>
<p>因为存在快照截断点，故 <code>Index</code> 到切片下标需进行转换。这里我顺着 6.824 的习惯将 <code>entries[0]</code> 设置为截断点，于是有</p>
<p><code>idx = Index2idx(Index) = Index - entries[0].Index</code>。</p>
<p>于是可以实现 <code>raft/log.go</code> 中 <code>RaftLog</code> 的相关函数。实际上就是根据那些 point 返回对应范围的切片。</p>
<ul class="lvl-1">
<li class="lvl-2">
<p><code>allEntries() =&gt; entries[1:]</code></p>
</li>
<li class="lvl-2">
<p><code>unstableEntries() =&gt; entries[Index2idx(stabled):]</code></p>
</li>
<li class="lvl-2">
<p><code>nextEnts() =&gt; entries[Index2idx(applied):Index2idx(committed)]</code></p>
</li>
</ul>
</blockquote>
<p><code>Ready()</code> 函数是获取 Raft 层的（自上次调用以来）所有发生变化的字段。其中 <code>Ready.Entries</code> 字段表示未被持久化的日志条目，<code>Ready.CommittedEntries</code> 表示已被 Commit 但未被 Apply 的日志条目，<code>Ready.Snapshot</code> 表示未被上层应用的快照。</p>
<p>由于 <code>SoftState</code> 和 <code>HardState</code> 这两个字段无法直接看出变化，故要在 RawNode 中加上 <code>PrevSoftState</code> 与 <code>PrevHardState</code> 两个变量，通过 <code>isxxxEqual()</code> 判断是否有更新。</p>
<p><strong>注意</strong>：如果消息队列为空，则 <code>Ready.Messages</code> 应为 nil 而不是长度为 0 的切片。</p>
<p><code>HasReady()</code> 函数用于判断是否存在 <code>Ready</code>，即所需状态是否可以被收集——<code>SoftState/HardState</code> 是否有变、是否有 <code>unstableEntries/nextEnts</code>、是否有等待应用的 <code>snapshot</code>、以及消息队列是否为空。</p>
<blockquote>
<p>一旦下层状态发生变化，就需要马上收集并持久化。</p>
</blockquote>
<p><code>Advance()</code> 函数会在上层处理完 <code>Ready</code> 并持久化后调用（其实就是之前调用 <code>Ready()</code> 获取到的那个），旨在通知 Raft 层推进相关状态，比如 <code>RaftLog</code> 的 <code>stabled</code>、<code>applied</code> 这些。</p>
<blockquote>
<p>也很好理解，之前收集到的 <code>Entries</code> 就是 unstabled 的，现在处理完了那就有 <code>stabled = Entries.LastLogIndex</code> 了。其他也同理。</p>
</blockquote>
<h3 id="Part-B-FT-KV-server">Part B FT KV server</h3>
<p>需要实现的代码在 <code>kv/raftstore</code> 文件夹下。</p>
<p>这一 part 我们要实现两个模块，分别为</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>peer storage =&gt; 实现持久化</p>
</li>
<li class="lvl-2">
<p>Raft ready process =&gt; 实现客户端请求与答复</p>
</li>
</ul>
<blockquote>
<p>首先要明确的是，整个系统划分为若干逻辑上的 Cluster，每个 Cluster 又包含了若干物理 Storage 节点，分布在不同物理位置。节点内部的物理存储空间又划分为不同 Region，每个 Region 表示某一段连续的 Key。不同 Storage 节点上相同的 Region 由同个 RaftGroup 管理，这部分抽象为 RaftStore，应用同一套 Raft 和日志机制。下图就是一个典型的 Cluster：</p>
<img src="keyspace.png" style="zoom:30%;">
</blockquote>
<h4 id="1-Implement-peer-storage">1 Implement peer storage</h4>
<p><code>PeerStorage</code> 主要负责记录存储状态并执行持久化。TinyKV 使用两个 badger 来存放不同状态：raftDB 存日志条目和 Raft 层信息，kvDB 存状态机数据。</p>
<blockquote>
<p>我感觉这部分还是有点混乱的，还是得多看看文档&gt;_&lt;</p>
<table>
<thead>
<tr>
<th style="text-align:center">Key</th>
<th style="text-align:center">KeyFormat</th>
<th style="text-align:center">Value</th>
<th style="text-align:center">DB</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">raft_log_key</td>
<td style="text-align:center">0x01 0x02 region_id 0x01 log_idx</td>
<td style="text-align:center">Entry</td>
<td style="text-align:center">raft</td>
</tr>
<tr>
<td style="text-align:center">raft_state_key</td>
<td style="text-align:center">0x01 0x02 region_id 0x02</td>
<td style="text-align:center">RaftLocalState</td>
<td style="text-align:center">raft</td>
</tr>
<tr>
<td style="text-align:center">apply_state_key</td>
<td style="text-align:center">0x01 0x02 region_id 0x03</td>
<td style="text-align:center">RaftApplyState</td>
<td style="text-align:center">kv</td>
</tr>
<tr>
<td style="text-align:center">region_state_key</td>
<td style="text-align:center">0x01 0x03 region_id 0x01</td>
<td style="text-align:center">RegionLocalState</td>
<td style="text-align:center">kv</td>
</tr>
</tbody>
</table>
</blockquote>
<p>这个模块只需要实现一个函数，即 <code>SaveReadyState()</code>——将上层从 <code>RawNode</code> 那收到的 <code>Ready</code> 进行持久化。主要流程为：</p>
<ol>
<li class="lvl-3">
<p>根据 <code>Ready</code> 修改内存数据 <code>raftState</code>/<code>applyState</code>；</p>
</li>
<li class="lvl-3">
<p>利用 <code>WriteBatch.SetMeta()</code> 以及 <code>meta.xxxKey()</code> 往 wb 中加入批处理日志，设置好对应的 Key/Value 条目；</p>
</li>
<li class="lvl-3">
<p>最后调用 <code>WriteBatch.WriteToDB()</code> 写到 badger 中（持久化）；</p>
</li>
</ol>
<blockquote>
<p>如果数据没更新就不必写到 badger 中了。所以到这为止都要有一个「数据是否更新」的判断。</p>
</blockquote>
<h4 id="2-Implement-Raft-ready-process">2 Implement Raft ready process</h4>
<p>现在我们终于要实现上层怎么处理 Client 发来的请求，以及驱动下层获取 Ready 并持久化了。</p>
<blockquote>
<p>RaftStore 在启动时会新建一个含有消息管道 <code>CloseCh</code> 的 <code>RaftWorker</code>，然后创建一个 GoRoutine 不断从 <code>CloseCh</code> 中获取 Client 发来的消息。每收到一条消息，都会新建一个 <code>PeerMsgHandler</code> 处理该信息。handler 拥有相关的 <code>Peer</code> 以及上下文.</p>
</blockquote>
<p>整套流程应该是这样的：</p>
<ol>
<li class="lvl-3">
<p>Client 发一个包含 Request 的 Message 过来；</p>
</li>
<li class="lvl-3">
<p><code>RaftWorker</code> 调用 <code>PeerMsgHandler.HandleMsg()</code> 处理 Message，即检查其消息类型，然后调用相关的处理函数；</p>
</li>
<li class="lvl-3">
<p>目前语境下，消息类型为 <code>MsgRaftCmd</code>，那么会调用 <code>PeerMsgHandler.proposeRaftCommand()</code> 驱动下层（如果是 Leader） Propose 一条包含该命令的日志 L。与此同时，消息中还带有一个可以让我们发回复的管道，如果不是 Leader，就发个 <code>ErrNotLeader</code> 回去。反之，由于要等到很久以后应用日志才能回复，故需记录 L 的 <code>Index</code>/<code>Term</code> 在 <code>PeerMsgHandler.Proposals</code> 中以便后续应用 L 时回复；</p>
</li>
<li class="lvl-3">
<p>随后调用 <code>PeerMsgHandler.HandleRaftReady()</code> 收集新增的日志以及要向 Peers 发送 <code>MsgAppend</code> 消息；</p>
</li>
<li class="lvl-3">
<p>Peers 收到消息后也会发一个 <code>MsgAppendResponse</code> 回来；</p>
</li>
<li class="lvl-3">
<p>等待同个 RaftGroup 的大多数都持有该日志后，下次 <code>PeerMsgHandler.HandleRaftReady()</code> 的调用就会收集已提交但未应用的日志，并将命令应用到 badger 中；</p>
</li>
<li class="lvl-3">
<p>然后如果是 Leader，还要发个回复给当前日志对应的 <code>Proposal</code>，系统会收取 Response 发给 Client；</p>
</li>
<li class="lvl-3">
<p>日志应用完毕后通知 <code>PeerStorage</code> 进行相关数据的持久化，以及 <code>RawNode</code> 推进状态；</p>
</li>
</ol>
<blockquote>
<p>任务书给的伪代码是在应用日志前持久化，但我觉得应用日志完 applied 会发生变化，后面照样还要落盘，就干脆把持久化放在最后了。</p>
<p>要注意的是，在应用日志时似乎不能把 <code>WriteToDB()</code> 放在最后，防止出现 Read After Write 但由于未写入出现 Stale Read 的情况。我这里就这样设置了：</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/raftstore/peer_msg_handler.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>peerMsgHandler<span class="token punctuation">)</span> <span class="token function">HandleRaftReady</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> entry <span class="token operator">:=</span> <span class="token keyword">range</span> ready<span class="token punctuation">.</span>CommittedEntries <span class="token punctuation">{</span>
    kvWB <span class="token operator">:=</span> <span class="token function">new</span><span class="token punctuation">(</span>engine_util<span class="token punctuation">.</span>WriteBatch<span class="token punctuation">)</span>
    d<span class="token punctuation">.</span><span class="token function">applyCommittedEntry</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>entry<span class="token punctuation">,</span> kvWB<span class="token punctuation">)</span>
    kvWB<span class="token punctuation">.</span><span class="token function">MustWriteToDB</span><span class="token punctuation">(</span>d<span class="token punctuation">.</span>ctx<span class="token punctuation">.</span>engine<span class="token punctuation">.</span>Kv<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token operator">...</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发送回复时，遍历 Proposals 发现 <code>Index</code> 相同但 <code>Term</code> 不同，则发个 <code>ErrStaleCommand</code>。</p>
</blockquote>
<h3 id="Part-C-Snapshot">Part C Snapshot</h3>
<p>需要对前两个 Part 所涉及的文件进行修改。</p>
<p>这一 part 我们要实现快照。snapshot 有两条路线能走，上层<strong>主动</strong>截断并向下通知，或是<strong>被动</strong>接受 Peers 传来的 snapshot 并在 Ready 中告知上层。</p>
<p>在有快照的情况下，我们需要修改以下数据：</p>
<ol>
<li class="lvl-3">
<p>删除 badger 中的遗留日志；</p>
</li>
<li class="lvl-3">
<p>修改 PeerStorage 中的 applyState 并持久化；</p>
</li>
<li class="lvl-3">
<p>修改 RaftLog 的相关数据；</p>
</li>
</ol>
<h4 id="1-主动快照">1 主动快照</h4>
<p>系统定时 Tick，向 handler 发送 <code>MsgTypeTick</code> 消息，触发 <code>PeerMsgHandler.OnTick()</code> =&gt; <code>PeerMsgHandler.onRaftGCLogTick()</code>，检查已应用日志大小是否超过 <code>RaftLogGcCountLimit</code>，如果超过了，就生成一条类型为 <code>CompactLog</code> 的 adminRequest 并向下 propose。</p>
<p>等到该日志被 Ready 捕获时，上层就知道可以安全截断日志了，即调用 <code>PeerMsgHandler.ScheduleCompactLog()</code> 删除冗余日志。由于 <code>PeerStorage</code> 没法通过 Ready 修改 <code>applyState</code> 中的 <code>TruncatedState</code>，那就在 apply 里头改了。</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/raftstore/peer_msg_handler.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>d <span class="token operator">*</span>peerMsgHandler<span class="token punctuation">)</span> <span class="token function">applyAdminRequest</span><span class="token punctuation">(</span>adminReq <span class="token operator">*</span>AdminRequest<span class="token punctuation">,</span> entry <span class="token operator">*</span>Entry<span class="token punctuation">,</span> wb <span class="token operator">*</span>WriteBatch<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> adminReq<span class="token punctuation">.</span>CmdType <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    <span class="token keyword">case</span> raft_cmdpb<span class="token punctuation">.</span>AdminCmdType_CompactLog<span class="token punctuation">:</span>
      <span class="token comment">// 1. do the actual log deletion work</span>
      d<span class="token punctuation">.</span><span class="token function">ScheduleCompactLog</span><span class="token punctuation">(</span>compactLogIndex<span class="token punctuation">)</span>

      <span class="token keyword">if</span> d<span class="token punctuation">.</span>peer<span class="token punctuation">.</span>peerStorage<span class="token punctuation">.</span>applyState<span class="token punctuation">.</span>TruncatedState<span class="token punctuation">.</span><span class="token function">GetIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> compactLogIndex <span class="token punctuation">{</span>
        <span class="token comment">// 2. update applystate</span>
      <span class="token punctuation">}</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样一来，后续对 <code>RawNode</code> 的 Advance 就需要加上一点修改。如果 <code>Ready.CommittedEntries</code> 非空，说明存在应用了 <code>CompactLog</code> 的可能，需要调用 <code>RaftLog</code> 中预先为我们声明好的 <code>maybeCompact()</code> 函数。接下来需要做的就是实现它。由于先前已经修改了 <code>PeerStorage</code>，那么可以直接通过 <code>Storage</code> 的接口 <code>FirstIndex()</code> 来获取日志截断点，从而进一步判断是否需要对日志进行压缩。</p>
<p>到此，所有需要修改的数据均已修改完毕。</p>
<h4 id="2-被动快照">2 被动快照</h4>
<p>Leader 一定是最先主动快照的那个，之后在需要发送 <code>MsgAppend</code> 的时候会检查 Peer 的 <code>Next</code> 字段。有些 Peer 可能由于网络断开或宕机重启等原因，没有对之前的 <code>MsgAppend</code> 进行回复去更新 <code>Next</code>，或没收到之前的 <code>CompactLog</code> 日志，这样就导致后续 Leader 对日志截断后，这些 Peer 的 <code>Next</code> 甚至比截断点 <code>truncatedIndex</code> 还小，那么此时 Leader 就需要发 <code>MsgSnapshot</code> 给他们了。</p>
<p>发送该消息的话，需要把本地数据库的快照数据也一并发过去，这样 Peer 才能尽快赶上进度。通过调用 <code>Storage.Snapshot()</code> 可以产生快照数据，但了解了 <code>PeerStorage</code> 的该函数执行流程后发现，首次调用只会发条消息给 Worker，叫他去干活，把数据处理好后通过管道发回来，在后续的调用才会拿到这部分数据，于是有</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">newSnapshot<span class="token punctuation">,</span> err <span class="token operator">:=</span> r<span class="token punctuation">.</span>RaftLog<span class="token punctuation">.</span>storage<span class="token punctuation">.</span><span class="token function">Snapshot</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">==</span> ErrSnapshotTemporarilyUnavailable <span class="token punctuation">{</span>
  <span class="token keyword">return</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>通过 <code>HandleRaftReady</code> 收集消息队列并发送，Peer 收到了 <code>MsgSnapshot</code>，触发 <code>Raft.handleSnapshot()</code>，还是一样的先判断发送方的 Term，接着如果发送方的截断点 <code>truncatedIndex &lt; CommittedIndex</code>，是没有应用这个快照的必要的，因为之前的日志会不断被 apply，那么 <code>CompactLog</code> 必然会被上层捕获从而主动截断。</p>
<blockquote>
<p>这里还需要发一个 <code>MsgAppendResponse</code> 回去，以便 Leader 收到拒绝后修改 <code>Next</code> 字段。</p>
</blockquote>
<p>最后才修改 Raft 层与 RaftLog 的相关数据，并令 <code>RaftLog.pendingSnapshot = msg.snapshot</code>（可以认为该数据一定不是 nil），这样下次收集 Ready 的时候会拿到待应用的快照数据，在 <code>SaveReadyState</code> 中调用 <code>PeerStorage.ApplySnapshot()</code> 将快照落实到 badger 中并修改 <code>ApplyState</code>。</p>
<p>到此，所有需要修改的数据均已修改完毕。</p>
<h2 id="一些坑">一些坑</h2>
<ol>
<li class="lvl-3">
<p><code>newRaft</code> 时传入的 <code>peers</code> 切片只在 2A 的测试中用到，实际上 peers 信息是通过 <code>Storage.InitialState()</code> 返回的 <code>confState.Nodes</code> 给出；</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>TinyKV Project3 Multi-Raft</title>
    <url>/lab/tinykvproject3/</url>
    <content><![CDATA[<p>本 Project 需要我们实现多个存储节点之间的管理。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<h3 id="Part-A-Leadership-Membership-Change-in-Raft">Part A Leadership/Membership Change in Raft</h3>
<p>需要修改的代码位于 <code>raft/raft.go</code>。</p>
<p>在 3A 中我们仅需修改 Raft 层的逻辑，而完整的 Change 流程将在 3B 中实现。</p>
<h4 id="1-Leadership-Change">1 Leadership Change</h4>
<p>Raft 层首先会 <code>Step</code> 一条 <code>MsgTransferLeader</code>。由于任何节点都有可能收到该消息，故需根据身份分类讨论：</p>
<p><strong>Non-Leader</strong>：将消息转发给 Leader;</p>
<p><strong>Leader</strong>：如果迁移目标 <code>transferee</code> 是自己，则什么也不干（已经是 Leader 无需迁移）；反之：</p>
<ol>
<li class="lvl-3">
<p>检查其是否有资格上任（即日志是否和自己一样新）;</p>
</li>
<li class="lvl-3">
<p>如果 <code>transferee</code> 的日志不是最新的，则 Leader 应该向其发送 <code>MsgAppend</code>（并停止进行任何之后的 <code>Propose</code>）直到其符合条件——这需要在后续的 <code>HandleAppendEntriesResponse()</code> 中进行判断;</p>
</li>
<li class="lvl-3">
<p>一旦满足迁移条件，Leader 应该立即向其发送一条<code>MsgTimeoutNow</code>，<code>transferee</code> 在收到消息后立即开始新的选举——即 <code>Step(MsgHup)</code>——从而依靠最新的 <code>Term</code> 和 <code>LastLog</code> 当选领导人;</p>
</li>
<li class="lvl-3">
<p>如果 <code>transferee</code> 的日志不是最新的，则 Leader 应该向其发送 <code>MsgAppend</code>（并停止进行任何之后的 <code>Propose</code>）直到其符合条件——这需要在后续的 <code>HandleAppendEntriesResponse()</code> 中进行判断;</p>
</li>
<li class="lvl-3">
<p>一旦满足迁移条件，Leader 应该立即向其发送一条<code>MsgTimeoutNow</code>，<code>transferee</code> 在收到消息后立即开始新的选举——即 <code>Step(MsgHup)</code>——从而依靠最新的 <code>Term</code> 和 <code>LastLog</code> 当选领导人;</p>
</li>
</ol>
<h4 id="2-Membership-Change">2 Membership Change</h4>
<p>这里我们仅需修改 <code>Raft.addNode()</code> 与 <code>Raft.removeNode()</code>。</p>
<p>节点的增减其实就是对 <code>Raft.Prs</code> 哈希表的修改：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果待增加节点未出现在 <code>RaftGroup</code> 中，则新增一个条目;</p>
</li>
<li class="lvl-2">
<p>如果待删除节点出现在 <code>RaftGroup</code> 中，则删除一个条目;</p>
</li>
</ul>
<p>对节点的增删会导致「大多数」发送变化：若节点增加，则新节点等待 <code>AppendEntries</code> 即可。若节点减少，则需要重新更新 <code>committed</code> 并发送;</p>
<h3 id="Part-B-Implement-Admin-Commands">Part B Implement Admin Commands</h3>
<p>3B 中我们就要正式实现加上<strong>域分裂</strong>(Region Split)在内的所有 Admin Commands 了。需要实现的代码位于 <code>kv/Raftstore/peer_msg_handler.go</code> 与 <code>kv/Raftstore/peer.go</code> 中。</p>
<p>写 3B 之前我们需要粗略回顾一下整个系统的构成。</p>
<p>在我们之前实现的 Raft 算法中，所有 <code>Peer</code> 位于不同存储节点上，对于一个分布式系统而言，这样能保证一个节点挂掉的同时依旧能依靠剩下的节点来提供服务。而在所有节点构成的图中，并非所有节点都两两连通，那么就需要根据不同的连通分量进行划分，这个划分单位就是 <code>Cluster</code>。</p>
<p>一个 <code>Cluster</code> 中包含了多个存储节点 <code>Raftstore</code>，每个 <code>Raftstore</code> 存储大量 KV 对，如果只用一个 Raft Group 对其进行管理，则消耗的资源太大——生成一个 Snapshot 可能就会把整个系统搞慢，于是开发者很聪明，将这些 KV 对根据哈希算法划分为不同区间，每个区间各由一个 Raft Group 来管理，这就是 <code>Region</code>。可以认为一个 <code>Region</code> 本质上就是一个 Raft Group + [StartKey, EndKey)。</p>
<p>当 <code>Client</code> 针对某个 Key 进行增删改查操作时，会将该命令发给 <code>Cluster</code>。<code>Cluster</code> 手上掌握着管辖范围内所有 <code>Raftstore</code> 的信息以及所有 <code>Region</code> 的信息，保存在一个叫 <code>Scheduler</code> 的结构中。有了这些信息，<code>Cluster</code> 就可以根据 Key 找到是哪个 <code>Region</code> 存着，进一步找到该 <code>Region</code> 中 Leader 所在的存储节点，向该节点发送命令，命令除了一些关于操作的信息，命令头 <code>Header</code> 中还存有目标 <code>Region</code> 的相关信息作为校验码，如 <code>RegionId</code>, <code>RegionEpoch</code> 以便进行校对。</p>
<p>此外，<code>Cluster</code> 还承担自我修正的功能，即 <code>Cluster</code> 会通过 <code>RegionHeartbeat()</code> 函数不断接收所有 <code>Region</code> 发来的<strong>心跳信息</strong>（区别于 Raft 层 Heartbeat），这些心跳信息包含 <code>Region</code> 的当前信息，包括 <code>RegionEpoch</code>, Leader 等，<code>Cluster</code> 根据这些信息决定是否向对应的 <code>Region</code> 做出一些调整措施。</p>
<blockquote>
<p>在 MockClient 里，测试用例做出的操作会被缓存，等到下次 <code>RegionHeartbeat()</code> 时，判断对应 <code>Region</code> 是否有未执行完毕的操作，如果有，则在 Response 中告知。</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/test_raftstore/scheduler.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>r <span class="token operator">*</span>SchedulerTaskHandler<span class="token punctuation">)</span> <span class="token function">Handle</span><span class="token punctuation">(</span>t worker<span class="token punctuation">.</span>Task<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">switch</span> task <span class="token operator">:=</span> t<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token keyword">case</span> <span class="token operator">*</span>SchedulerRegionHeartbeatTask<span class="token punctuation">:</span>
    r<span class="token punctuation">.</span><span class="token function">onHeartbeat</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span> <span class="token comment">// 调用 RegionHeartbeat</span>
  <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m <span class="token operator">*</span>MockSchedulerClient<span class="token punctuation">)</span> <span class="token function">RegionHeartbeat</span><span class="token punctuation">(</span>req <span class="token operator">*</span>schedulerpb<span class="token punctuation">.</span>RegionHeartbeatRequest<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
  <span class="token comment">// check if BootStrap</span>

  <span class="token comment">// update pending peers and leader of region</span>

  <span class="token comment">// check region epoch</span>

  resp <span class="token operator">:=</span> <span class="token function">makeResp</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span>
  <span class="token keyword">if</span> op <span class="token operator">:=</span> m<span class="token punctuation">.</span>operators<span class="token punctuation">[</span>regionID<span class="token punctuation">]</span><span class="token punctuation">;</span> op <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
     <span class="token keyword">if</span> m<span class="token punctuation">.</span><span class="token function">tryFinished</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> req<span class="token punctuation">.</span>Region<span class="token punctuation">,</span> req<span class="token punctuation">.</span>Leader<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">delete</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>operators<span class="token punctuation">,</span> regionID<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      m<span class="token punctuation">.</span><span class="token function">makeRegionHeartbeatResponse</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> resp<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// send response to store where the leader is located</span>
  <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而在 3C 中则要实现真实的 Scheduler。</p>
</blockquote>
<p>以 Mock 版本为例，每个 <code>Peer</code> 都有一个 <code>PeerMsgHandler</code>，用于接收从 <code>Cluster</code> 发来的消息，见 <code>HandleMsg()</code>。在 Part B 中，我们主要谈以下 3 个 Admin Commands。</p>
<p>这 3 种 Commands 所位于的 Message Type 均为 <code>MsgTypeRaftCmd</code>，那么首先会来到 <code>proposeRaftCommand()</code> 函数中。</p>
<h4 id="1-Propose-transfer-leader">1 Propose transfer leader</h4>
<p>因为领导迁移仅仅是一个操作，无需所有节点进行复制，所以收到该类型的 Command 时，直接调用 <code>RawNode.TransferLeader()</code> 即可。</p>
<h4 id="2-Implement-conf-change-in-Raftstore">2 Implement conf change in Raftstore</h4>
<p>一次完整的 conf change 流程如下</p>
<ol>
<li class="lvl-3">
<p>调用 <code>RawNode.ProposeConfChange()</code> 给 Leader Propose 一条 <code>EntryConfChange</code> 的<strong>特殊类型</strong>日志;</p>
</li>
<li class="lvl-3">
<p>apply 到这条命令时，首先检查该命令是否有效，即 <code>RegionId</code> 与 <code>RegionEpoch</code> 是否匹配，若不匹配，说明在收到消息之前已经进行过 Peer Change 或 Region Split，返回一个 <code>error</code>;</p>
</li>
<li class="lvl-3">
<p>令当前 <code>RegionEpoch</code> 中的 <code>confVersion</code> 字段自增 <code>1</code>;</p>
</li>
<li class="lvl-3">
<p>根据 <code>ChangeType</code> 执行新 <code>Peer</code> 的添加 or 已有 <code>Peer</code> 的删除，表现为：修改 <code>Region</code> 中的 <code>Peers</code>，以及调用 <code>insertPeerCache()</code>/<code>removePeerCache()</code>;</p>
</li>
</ol>
<blockquote>
<p>注意，如果删除自身节点，则要执行 <code>destroyPeer()</code>，会删除包括 <code>RegionRanges</code> 在内的诸多字段，故后续步骤无需再管，直接 return 即可，此时完成当前 entry apply 后应直接退出，不能将数据写到 badger 里。</p>
<p>如果待添加的 <code>Peer</code> 已在 Group 中则啥也不做，同理，如果待删除的 <code>Peer</code> 不在了也啥也不做，而不是返回 <code>error</code>。</p>
</blockquote>
<ol>
<li class="lvl-3">
<p>更新 <code>storeMeta</code>，注意这是个临界变量，在真实并发场景下对其的修改需要<strong>加锁</strong>;</p>
</li>
<li class="lvl-3">
<p>调用 <code>rawnode.ApplyConfChange()</code>，然后根据命令类型进行 <code>Raft</code> 层的节点变动;</p>
</li>
<li class="lvl-3">
<p>如果当前节点在 <code>Raft</code> 层是 Leader 的身份，则需要返回 Response，并且给 <code>Scheduler</code> 发一则心跳信息，表示该操作已完成;</p>
</li>
</ol>
<p>接下来我们不禁心生疑惑：<strong>对于 <code>AddPeer</code> 而言，新加入的 <code>Peer</code> 所在 <code>Raftstore</code> 是怎么知道他需要创建一个 <code>Peer</code>？这个 <code>Peer</code> 又是怎么知道他在哪个 <code>Region</code> 中的呢？<code>Region</code> 中原来的那些 <code>Peer</code> 是怎么知道新的 <code>Peer</code> 已经加入了呢？</strong></p>
<p>首先要了解的是，测试代码里所使用的只是模拟的 <code>Cluster</code>，不妨称它为 <code>MockCluster</code>（当然代码里面它就叫 <code>Cluster</code>，在文件 <code>kv/test_raftstore/cluster.go</code> 中）。</p>
<p>这个 <code>MockCluster</code> 持有一个 <code>NodeSimulator</code> 来模拟大型分布式集群的节点间通信，以及 C/S 之间的通信。所有的测试用操作，包括 <code>MustPut()</code>/<code>MustGet()</code>/<code>MustDelete()</code> 等都会一步步通过 <code>MockCluster.CallCommandOnLeader()</code> 到 <code>MockCluster.CallCommand()</code> 再到 <code>NodeSimulator.CallCommandOnStore()</code>，最后通过目标 <code>Raftstore</code> 对应的 <code>RaftstoreRouter</code> 的结构进行发送。</p>
<p>之前 <code>HandleRaftReady()</code> 时调用 <code>send()</code> 函数将 <code>Ready</code> 中的 Msgs 发出去，本质上就是通过 <code>RaftstoreRouter.SendRaftMessage()</code> 执行发送操作。</p>
<blockquote>
<p>因为这里都是在本地模拟，所以不用考虑远程调用、网络流之类的问题。</p>
</blockquote>
<p><code>SendRaftMessage()</code> 函数做的事其实很简单——先调用 <code>send()</code> 发 <code>MsgTypeRaftMessage</code> 类型的消息（通过 <code>peerSender</code> 这个管道进行传递），如果出现错误，再调用 <code>sendStore()</code> 发 <code>MsgTypeStoreRaftMessage</code> 类型的消息（通过 <code>storeSender</code> 这个管道进行传递）。</p>
<p>消息进了这两个管道，最后会从哪里被接受呢？</p>
<p>首先，<code>RaftstoreRouter</code> 会在 <code>Raftstore</code> 生成时一并创建，见函数 <code>CreateRaftstore()</code>。本质上一个 <code>Raftstore</code> 内所有部分都共享同一个 <code>router</code>，无论是 <code>Raftstore.router</code> 还是 <code>ctx.router</code>，都指向同一个数据结构。下面都叫它 <code>router</code> 了。</p>
<p>每个 <code>Raftstore</code> 在启动时都会调用 <code>startWorkers()</code>，然后启动 <code>raftWorker</code> 和 <code>storeWorker</code> 这俩 GoRoutine，它们均接收从 <code>router</code> 中传来的消息，前者用的是 <code>router.peerSender</code> 这个管道，后者从 <code>router.storeSender</code> 这个管道取消息。问题得到了解答。</p>
<p>同时我们也发现，在 <code>send()</code> 函数中，如果发现当前 <code>Raftstore</code> 并没有目标 <code>Region</code> 存在，则返回一个 <code>error</code>，消息也会直接送到 <code>storeWorker</code> 手上。<code>storeWorker</code> 拿到后发现是一条 <code>MsgTypeStoreRaftMessage</code>，便调用 <code>onRaftMessage()</code> 进行后续处理。走到这里，我们又有新发现了，那就是任务书中也提到了的 <code>maybeCreatePeer()</code> 函数，其注释是这么写的：<em>If target peer doesn’t exist, create it.</em></p>
<blockquote>
<p>这里新建 <code>Peer</code> 的操作我们也应认真看看，包括：修改 <code>StoreMeta</code>，调用 <code>router.register()</code> 进行<strong>注册</strong>，以及发送一条 <code>MsgTypeStart</code> 消息<strong>唤醒</strong>其启动 <code>ticker</code> 正式开始工作。</p>
</blockquote>
<p>再来看之前的疑惑，第一个问题其实得到解答了：随着上述步骤 4, 6 的执行，新 <code>Peer</code> 的信息已经加载到 <code>PeerCache</code> 中了，Raft 层也将新的 <code>Peer</code> 加载到 <code>Prs</code> 表中。当 Leader 下一次群发 heartbeat 或 append 时，会给新 <code>Peer</code> 也发一份 RaftMessage，目标 <code>Raftstore</code> 收到后发现没有目标 <code>Region</code> 存在，也就开始了后续的创建操作。</p>
<p>对于第二个问题，在创建 <code>Peer</code> 之前，<code>Raftstore</code>收到的消息就含有 <code>Region</code> 相关信息。</p>
<p>第三个问题，Follwers/Candidates 在 apply conf change 时仅仅是将其加到了 <code>Prs</code> 中，如果网络一切良好，其实不用做出任何操作。而 Leader 不一样，在添加 <code>Prs</code> 时，<code>Match</code>/<code>Next</code> 字段其实都应该赋 <strong>0</strong>——因为该 <code>Peer</code> 尚未初始化——这样一来，一旦发送 append 消息中遍历到新 <code>Peer</code> 时，发现其 <code>Next=0</code>，无论如何都会小于 <code>truncatedIndex</code>，Leader 会立刻发送 snapshot 过去。由于是通过 <code>replicatePeer()</code> 的方式进行创建，我们会发现这种方式创建的 <code>Peer</code>，其 Raft 层的 <code>Prs</code> 最开始是空的，甚至不包含自身，在这种状态下可以认为其属于一个「<strong>待机</strong>」状态，只允许处理 <code>MsgSnapshot</code>，其余消息一律作废。</p>
<p>只有收到了 snapshot 并更细状态后，<code>Prs</code> 也被正确赋值，其才知道了其他节点的存在，此时脱离「<strong>待机</strong>」状态。</p>
<p>等到 Leader 收到回复后，新 <code>Peer</code> 才算正式加入 Group。</p>
<blockquote>
<p>当然，如果网络很差，snapshot 并没有收到，反而 Leader 早早挂了，那么新 <code>Peer</code> 并未被初始化，也无法参与原有节点在 election timeout 后发起的选举，可能会导致该 Group 彻底死掉——只有两个 <code>Peer</code> 时，Candidate 无论如何也无法从另一个未初始化的 <code>Peer</code> 处得到选票，也就无法成为 Leader。</p>
<p>但是在 apply snapshot 之前又不能回应其余消息——谁知道 apply snapshot 后会不会拒绝呢？</p>
<p>3B 的最后几个测试中概率出现这种情况，我的做法是：算我过了。</p>
</blockquote>
<p>由于 conf change 和后面的 region split 会导致 <code>RegionEpoch</code> 发生变化，所有 apply 之前都应当检查 <code>Request.Header</code> 中的校验字段是否匹配，除了 <code>RegionId</code> 是否一致、<code>RegionEpoch</code> 是否匹配，对于根据 <code>Key</code> 进行的操作，还要检查 <code>Key</code> 是否在 <code>Region</code> 中。很典型的例子就是目标 <code>Key</code> 因之前进行了 region split 跑到另一个 <code>Region</code> 里去了，此时再执行操作必然破坏一致性。</p>
<h4 id="Implement-split-region-in-Raftstore">Implement split region in Raftstore</h4>
<p>一次完整的 region split 流程如下：</p>
<ol>
<li class="lvl-3">
<p><code>ticker</code> 定期通过 <code>onSplitRegionCheckTick()</code> 向 <code>splitChecker</code> 发送 <code>SplitCheckTask</code> 检查是否需要进行 split，如果需要则通过 <code>router</code> 发送一条 <code>MsgTypeSplitRegion</code> 消息;</p>
</li>
<li class="lvl-3">
<p>收到该消息后，<code>Peer</code> 执行 <code>onPrepareSplitRegion()</code>，首先校验该 split 是否合理，若是，则给 <code>Scheduler</code> 发送一则 <code>SchedulerAskSplitTask</code>;</p>
</li>
<li class="lvl-3">
<p>随后 <code>Scheduler</code> 生成新的 <code>RegionId</code> 以及新的 <code>PeerId</code>，包裹在 <code>Split</code> 的 Admin Command 中，通过 <code>router</code> 发松;</p>
</li>
<li class="lvl-3">
<p>handler 收到消息，给 Leader propose 一条命令;</p>
</li>
<li class="lvl-3">
<p>apply 到这条命令时，首先检查该命令是否有效，即 <code>RegionId</code> 与 <code>RegionEpoch</code> 是否匹配，若不匹配，说明在收到消息之前已经进行过 Peer Change 或 Region Split，返回一个 <code>error</code>;</p>
</li>
<li class="lvl-3">
<p>根据命令中包含的 <code>splitKey</code> 划分为两个 <code>Region</code>，值区间分别为 <code>[startKey, splitKey)</code> 与 <code>[splitKey, endKey)</code>，且 <code>RegionEpoch</code> 中的 <code>Version</code> 字段均在原基础上加 <code>1</code>;</p>
<blockquote>
<p>其中前者为原 <code>Region</code>，后者为新 <code>Region</code></p>
</blockquote>
</li>
<li class="lvl-3">
<p>根据命令中的 <code>NewPeerIds</code>，为新 <code>Region</code> 的 <code>Peers</code> 修改 <code>PeerId</code>，<code>StoreId</code> 不变;</p>
</li>
<li class="lvl-3">
<p>调用 <code>createPeer()</code> 在当前 <code>Raftstore</code> 上创建 <code>Peer</code>，并如同 <code>maybeCreatePeer()</code> 的那样进行注册与唤醒等操作;</p>
</li>
<li class="lvl-4">
<p>更新 <code>storeMeta</code>，分裂出的两个 <code>Region</code> 都要更新;</p>
</li>
<li class="lvl-4">
<p>如果当前节点在 <code>Raft</code> 层是 Leader 的身份，则需要返回 Response，并且给 <code>Scheduler</code> 发一则心跳信息，表示该操作已完成;</p>
</li>
</ol>
<p>region split 中并没有很难处理的疑难杂症。</p>
<h3 id="Part-C-Scheduler">Part C Scheduler</h3>
<p>需要修改的代码位于 <code>scheduler/server/cluster.go</code> 与 <code>scheduler/server/schedulers/balance_region.go</code>，分别需要实现 <code>processRegionHeartbeat()</code> 函数与 <code>Schedule()</code> 函数。总体来讲比 3B 简单许多，根据任务书一步步来即可，仅有少量小bug需要根据测试的打印结果来调整。</p>
<h4 id="1-Collect-region-heartbeat">1 Collect region heartbeat</h4>
<p>根据 3B 中描述的整体系统流程，每个集群 <code>Cluster</code> 所持有的总调度器 <code>Scheduler</code> 会根据 <code>Region</code> 发来的心跳信息为其分配任务（PeerChange、RegionSplit 等）。在真实网络下，心跳信息会以不可预知的速度到达 <code>Scheduler</code>，同时也可能因为网络分区而收到来自同个 <code>Region</code> 不同 Leader 的信息——这就需要我们记录下每个 <code>Region</code> 的重要信息（用 <code>RegionInfo</code> 这个数据结构来表示），以防收到 stale heartbeat。</p>
<p>先来介绍一下整体流程，其实和 3B 中的 Mock 差不多：</p>
<p>首先，<code>Region</code> 的 Leader 发送心跳，<code>Server</code> 通过 <code>RegionHeartbeat()</code> 不断收取心跳信息，并从中提取出发送方的 <code>RegionInfo</code>，然后下放到 <code>Cluster</code>，通过 <code>HandleRegionHeartbeat()</code> 根据当前 <code>RegionInfo</code> 进行处理：</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>scheduler/server/grpc_service.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">RegionHeartbeat</span><span class="token punctuation">(</span>stream schedulerpb<span class="token punctuation">.</span>Scheduler_RegionHeartbeatServer<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>
    request<span class="token punctuation">,</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">Recv</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">...</span>
    region <span class="token operator">:=</span> core<span class="token punctuation">.</span><span class="token function">RegionFromHeartbeat</span><span class="token punctuation">(</span>request<span class="token punctuation">)</span>
    <span class="token operator">...</span>
    err <span class="token operator">=</span> cluster<span class="token punctuation">.</span><span class="token function">HandleRegionHeartbeat</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span>
    <span class="token operator">...</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在处理的过程中，<code>Cluster</code> 首先调用 <code>processRegionHeartbeat()</code> 更新信息，若成功且该 <code>Region</code> 拥有至少一个 <code>Peer</code>，就调用 <code>Dispatch(Heartbeat)</code> 检查是否有对该 <code>Region</code> 待执行的命令 <code>Operator</code>：</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>scheduler/server/cluster_worker.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>RaftCluster<span class="token punctuation">)</span> <span class="token function">HandleRegionHeartbeat</span><span class="token punctuation">(</span>region <span class="token operator">*</span>core<span class="token punctuation">.</span>RegionInfo<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span><span class="token function">processRegionHeartbeat</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span><span class="token punctuation">;</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> err
  <span class="token punctuation">}</span>

  c<span class="token punctuation">.</span><span class="token function">RLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  co <span class="token operator">:=</span> c<span class="token punctuation">.</span>coordinator
  c<span class="token punctuation">.</span><span class="token function">RUnlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  co<span class="token punctuation">.</span>opController<span class="token punctuation">.</span><span class="token function">Dispatch</span><span class="token punctuation">(</span>region<span class="token punctuation">,</span> schedule<span class="token punctuation">.</span>DispatchFromHeartBeat<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>对于该 <code>Operator</code>：</p>
<ol>
<li class="lvl-3">
<p>如果尚未执行完毕（每个 <code>Operator</code> 集成了多个步骤 <code>OpStep</code>，可能只执行到中间的某一步）且未超时，检查该 <code>Region</code> 的 <code>ConfVersion</code> 是否完全由该 <code>Operator</code> 修改：若是，则调用 <code>SendScheduleCommand()</code> 执行下一步命令——发送相应 <code>RegionHeartbeatResponse</code>，当 <code>Region</code> 收到后便会 propose 相应命令；反之，说明该 <code>Operator</code> 已过时，将其移除，并将状态设置为 <code>OperatorStatus_CANCEL</code>;</p>
</li>
<li class="lvl-3">
<p>如果已执行完毕，将其移除，并将状态设置为 <code>OperatorStatus_SUCCESS</code>;</p>
</li>
<li class="lvl-3">
<p>如果超时，将其移除，并将状态设置为 <code>OperatorStatus_TIMEOUT</code>;</p>
</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>scheduler/server/schedule/operator_controller.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>oc <span class="token operator">*</span>OperatorController<span class="token punctuation">)</span> <span class="token function">Dispatch</span><span class="token punctuation">(</span>region <span class="token operator">*</span>core<span class="token punctuation">.</span>RegionInfo<span class="token punctuation">,</span> source <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> op <span class="token operator">:=</span> oc<span class="token punctuation">.</span><span class="token function">GetOperator</span><span class="token punctuation">(</span>region<span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> op <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    timeout <span class="token operator">:=</span> op<span class="token punctuation">.</span><span class="token function">IsTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> step <span class="token operator">:=</span> op<span class="token punctuation">.</span><span class="token function">Check</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span><span class="token punctuation">;</span> step <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>timeout <span class="token punctuation">{</span>
      origin <span class="token operator">:=</span> op<span class="token punctuation">.</span><span class="token function">RegionEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      latest <span class="token operator">:=</span> region<span class="token punctuation">.</span><span class="token function">GetRegionEpoch</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      changes <span class="token operator">:=</span> latest<span class="token punctuation">.</span><span class="token function">GetConfVer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> origin<span class="token punctuation">.</span><span class="token function">GetConfVer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token keyword">if</span> source <span class="token operator">==</span> DispatchFromHeartBeat <span class="token operator">&amp;&amp;</span>
        changes <span class="token operator">&gt;</span> <span class="token function">uint64</span><span class="token punctuation">(</span>op<span class="token punctuation">.</span><span class="token function">ConfVerChanged</span><span class="token punctuation">(</span>region<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> oc<span class="token punctuation">.</span><span class="token function">RemoveOperator</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          oc<span class="token punctuation">.</span>opRecords<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> schedulerpb<span class="token punctuation">.</span>OperatorStatus_CANCEL<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
      oc<span class="token punctuation">.</span><span class="token function">SendScheduleCommand</span><span class="token punctuation">(</span>region<span class="token punctuation">,</span> step<span class="token punctuation">,</span> source<span class="token punctuation">)</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> op<span class="token punctuation">.</span><span class="token function">IsFinish</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> oc<span class="token punctuation">.</span><span class="token function">RemoveOperator</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oc<span class="token punctuation">.</span>opRecords<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> schedulerpb<span class="token punctuation">.</span>OperatorStatus_SUCCESS<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> timeout <span class="token operator">&amp;&amp;</span> oc<span class="token punctuation">.</span><span class="token function">RemoveOperator</span><span class="token punctuation">(</span>op<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      oc<span class="token punctuation">.</span>opRecords<span class="token punctuation">.</span><span class="token function">Put</span><span class="token punctuation">(</span>op<span class="token punctuation">,</span> schedulerpb<span class="token punctuation">.</span>OperatorStatus_TIMEOUT<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们只需要实现函数 <code>processRegionHeartbeat()</code>。</p>
<p>首先检查该 <code>RegionInfo</code> 的可信度：</p>
<ol>
<li class="lvl-3">
<p>如果在已有的表中记录过同一 <code>RegionId</code> 的 info，并且新 info 的 <code>RegionEpoch</code> 中的两个字段 <code>ConfVersion</code>, <code>Version</code> 只要有一个比已有的小，就认为不可信，返回 <code>ErrRegionIsState</code>;</p>
</li>
<li class="lvl-3">
<p>如果存在那些与新 info 对应的 Key 区间有重合的 info（这种情况发生于 Region Split 操作），并且新 info 的 <code>RegionEpoch</code> 中的两个字段 <code>ConfVersion</code>, <code>Version</code> 只要有一个比已有的小，就认为不可信，返回 <code>ErrRegionIsState</code>;</p>
</li>
</ol>
<p>检查通过后，调用 <code>putRegion()</code> 将该 info 插入表中，并删除原有 info（如果有的话）。</p>
<p>最后，调用 <code>updateStoreStatusLocked()</code> 更新集群中所有存储节点状态。</p>
<p>此处没有什么疑难杂症，很快就能完成。</p>
<h4 id="2-Implement-region-balance-scheduler">2 Implement region balance scheduler</h4>
<p>上面提到的 <code>Operator</code> 是怎么来的呢？有一部分就是 <code>Scheduler</code> 产生的。</p>
<p><code>Cluster</code> 一经创建便持有一个 <code>Coordinator</code>，其会通过 <code>runScheduler()</code> 来调用 <code>scheduler.Schedule()</code>，定期检查是否有存储节点超载，就需要找到该节点 <code>src</code> 的一个<strong>合适</strong>的 <code>Region</code>，将位于 <code>src</code> 中从属于该 <code>Region</code> 的 <code>Peer</code> 转移到某个<strong>合适</strong>的目标节点 <code>dst</code>，从而达成负载均衡，并通过函数返回的 <code>MovePeerOperator</code> 加到该 <code>Region</code> 对应的「待执行命令」中，等待下一次该 <code>Region</code> 发来心跳信息时执行。</p>
<blockquote>
<p>一个 <code>MovePeerOperator</code> 包含以下步骤：</p>
<ol>
<li class="lvl-3">删除原节点的 <code>Peer</code>（即 <code>RemovePeer</code> 操作）;</li>
<li class="lvl-3">如果必要则还要进行 <code>transferLeader</code>;</li>
<li class="lvl-3">将新 <code>Peer</code> 加入 <code>Region</code>（即 <code>AddPeer</code> 操作）;</li>
</ol>
<p>最后等待该新 <code>Peer</code> 收到消息正式加入 Group。</p>
</blockquote>
<p>上文提到<strong>合适</strong>，那么究竟何谓<strong>合适</strong>？</p>
<p>首先是<strong>合适</strong>的 <code>Region</code>，任务书指出：</p>
<ol>
<li class="lvl-3">
<p>First, it will try to select a <code>pending region</code> because pending may mean the disk is overloaded;</p>
</li>
<li class="lvl-3">
<p>If there isn’t a pending region, it will try to find a <code>follower region</code>;</p>
</li>
<li class="lvl-3">
<p>If it still cannot pick out one region, it will try to pick <code>leader regions</code>;</p>
</li>
</ol>
<blockquote>
<p>可以利用框架提供的三个函数 <code>GetPendingRegionsWithLock()</code>, <code>GetFollowersWithLock()</code> and <code>GetLeadersWithLock()</code> 进行挑选。</p>
</blockquote>
<p><code>dst</code> 的确定原则也很简单：在所有满足 src.RegionSize - dst.RegionSize &gt; 2 * region.ApproximateSize 中选出那个 <code>RegionSize</code> 最小的节点。如果 <code>RegionSize</code> 差值不够大，那么在迁移后很可能重新迁移回去。</p>
<blockquote>
<p>当然，目标节点必须不包含同一 <code>Region</code>，原因不言而喻，需要在 coding 中特别注意。</p>
</blockquote>
<p>确定下来后，我们就可以在 <code>dst</code> 上调用 <code>AllocPeer()</code> 分配空间了，然后根据已有信息创建一个 <code>MovePeerOperator</code> 并返回。</p>
<p>值得注意的是，我们进行检查的所有节点必须为 <strong>suitable</strong>，即：a suitable store should be <code>up</code> and the <code>down time</code> cannot be longer than <code>MaxStoreDownTime</code> of the cluster, which you can get through <code>cluster.GetMaxStoreDownTime()</code>.</p>
<p>整个代码如下：</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>scheduler/server/cluster.go</span></div><code class="language-go"><span class="token keyword">var</span> originalRegion <span class="token operator">*</span>core<span class="token punctuation">.</span>RegionInfo
<span class="token keyword">var</span> originalStore <span class="token operator">*</span>core<span class="token punctuation">.</span>StoreInfo
<span class="token keyword">var</span> targetStore <span class="token operator">*</span>core<span class="token punctuation">.</span>StoreInfo
stores <span class="token operator">:=</span> <span class="token function">GetAllSortedSuitableStores</span><span class="token punctuation">(</span>cluster<span class="token punctuation">)</span>

<span class="token comment">// find original region and original store</span>
cb <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>container core<span class="token punctuation">.</span>RegionsContainer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  originalRegion <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">RandomRegion</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span> store <span class="token operator">:=</span> <span class="token keyword">range</span> stores <span class="token punctuation">{</span>
  <span class="token keyword">if</span> originalRegion <span class="token operator">=</span> <span class="token function">SelectSuitableRegion</span><span class="token punctuation">(</span>cb<span class="token punctuation">)</span><span class="token punctuation">;</span> originalRegion <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
    originalStore <span class="token operator">=</span> stores<span class="token punctuation">[</span>i<span class="token punctuation">]</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> originalStore <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

<span class="token comment">// find target store</span>
<span class="token keyword">for</span> target <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>stores<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> target <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> target<span class="token operator">--</span> <span class="token punctuation">{</span>
  regionInTargetStore <span class="token operator">:=</span> <span class="token function">RegionIsInStore</span><span class="token punctuation">(</span>originalRegion<span class="token punctuation">,</span> stores<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token operator">!</span>regionInTargetStore <span class="token operator">&amp;&amp;</span> <span class="token function">isDifferenceBigEnough</span><span class="token punctuation">(</span>stores<span class="token punctuation">[</span>original<span class="token punctuation">]</span><span class="token punctuation">,</span> stores<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">,</span> originalRegion<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    targetStore <span class="token operator">=</span> stores<span class="token punctuation">[</span>target<span class="token punctuation">]</span>
    <span class="token keyword">break</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> targetStore <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>

newPeer <span class="token operator">:=</span> <span class="token function">AllocPeer</span><span class="token punctuation">(</span>cluster<span class="token punctuation">,</span> stores<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">return</span> <span class="token function">CreateMovePeerOperator</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">GetName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cluster<span class="token punctuation">,</span> originalRegion<span class="token punctuation">,</span> operator<span class="token punctuation">.</span>OpBalance<span class="token punctuation">,</span> stores<span class="token punctuation">[</span>original<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> stores<span class="token punctuation">[</span>target<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">GetID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> newPeer<span class="token punctuation">.</span><span class="token function">GetId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>并且由于 <code>RaftGroup</code> 随时可能变化，故对于不在组内的节点而言，任何消息都是无效的——即便收到消息，也不能做任何事。对于新加入组的节点而言，Raft 层的 <code>Prs</code> 可能未被正确初始化，所以如果收到一条 peer 的消息而该 peer 又不在 <code>Prs</code> 中时，将其加入。</p>
</blockquote>
<p>有一点不能理解的是，虽然任务书中表示 <code>RegionEpoch.ConfVer</code> 会在 confchange 中改变，但并没有说 <code>RegionEpoch.Version</code> 也会改，只说了在 split 中改变。然而测试用例会不通过「只修改了 confver 而不修改 version」的代码。</p>
<h4 id="3-RegionSplit">3 RegionSplit</h4>
<p>不同 RaftGroup 负责不同 Region，随着时间推进必然会有一些 Region 会超出一个值 <code>RegionSplitSize</code>，为了负载均衡，必须将这些过大的 Region 一分为二。</p>
]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>TinyKV Project4 Transaction</title>
    <url>/lab/tinykvproject4/</url>
    <content><![CDATA[<p>本 Project 需要我们实现基于 MVCC 的事务模块。</p>
<span id="more"></span>
<h2 id="思路">思路</h2>
<h3 id="Part-A-Mvcc-Txn">Part A Mvcc Txn</h3>
<p>需要实现的代码在文件夹 <code>kv/transaction/mvcc</code> 下。</p>
<p>这一 part 需要我们实现支持 MVCC(多版本并发控制, Multiversion Concurrency Control) 的事务 api。</p>
<p>一个事务在时间点 <code>t</code> 处新建时，会被赋予当前存储的 <code>Reader</code> 以及时间戳 <code>StartTS = t</code>。所有的 api 相关操作都是基于时间线来进行处理。</p>
<blockquote>
<p>另外还有一个隐性的规则是：两个不同事务的 <code>StartTS</code> 一定不相等。</p>
</blockquote>
<p>TinyKV 存储使用 3 个 CF 来存放不同类型数据，分别为：</p>
<table>
<thead>
<tr>
<th style="text-align:center">CF</th>
<th style="text-align:center">Key</th>
<th style="text-align:center">Value</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">default</td>
<td style="text-align:center">UserKey_StartTs</td>
<td style="text-align:center">Value</td>
</tr>
<tr>
<td style="text-align:center">lock</td>
<td style="text-align:center">UserKey</td>
<td style="text-align:center">Lock Data Structure To Byte</td>
</tr>
<tr>
<td style="text-align:center">Write</td>
<td style="text-align:center">UserKey_CommitTs</td>
<td style="text-align:center">Write Data Structure To Byte</td>
</tr>
</tbody>
</table>
<blockquote>
<p>存储按 key 字母序递增排序。同个 key 按存储时间戳降序排序，即越新的在越前面。</p>
</blockquote>
<h4 id="1-Put-Delete">1 Put/Delete</h4>
<p>所有写操作都只需要为事务的 <code>writes</code> 切片添加新的 <code>Modify</code> 即可。注意使用实现好的 <code>EncodeKey()</code> 函数将 Key 重新编码为正确格式，以及使用 <code>engine_util</code> 包下的三个 CF 常量: <code>CfDefault</code>, <code>CfLock</code>, <code>CfWrite</code>。</p>
<h4 id="2-Get">2 Get</h4>
<p>对于 <code>Lock</code> 的读取是简单的，因为任意一个 <code>UserKey</code> 只会对于一个 <code>Lock</code> 变量，调用 <code>txn.Reader.GetCF()</code> 后进行 <code>ParseLock()</code> 即可。</p>
<p>对于 <code>Value</code> 的读取返回在当前时间戳<strong>有效</strong>的值，则需要考虑在当前事务之前最后一个提交的 <code>Write</code>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>如果不存在符合要求的 <code>Write</code>，说明该 <code>Value</code> 尚未被任何一个事务 commit，这种数据是禁止读取的，否则可能破坏一致性;</p>
</li>
<li class="lvl-2">
<p>如果最后一个 <code>Write</code> 类型是 <code>Delete</code>，说明该 Key 在最近的一次事务提交时被删除，那么当前时间点的读取是得不到任何数据的;</p>
</li>
<li class="lvl-2">
<p>如果最后一个 <code>Write</code> 类型是 <code>Put</code>，说明在时间戳 <code>Write.StartTs</code> 处修改的值是有效的，且一定有 <code>Write.StartTs &lt;= txn.StartTs</code>，即键 <code>EncodeKey(UserKey, Write.StartTs)</code> 对应的 <code>Value</code> 就是我们想要的;</p>
</li>
</ul>
<blockquote>
<p>即数据在 <code>LastCommitWrite</code> 有效且类型为 <code>Put</code> 时可读。</p>
</blockquote>
<p>对于 <code>Write</code> 则有 2 种不同的 Get</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>CurrentWrite</code>：读取当前事务对给定 Key 施加的 <code>Write</code> 及其 <code>CommitTs</code>，即满足 <code>StartTs == txn.StartTs</code> 的 <code>Write</code>;</p>
</li>
<li class="lvl-2">
<p><code>MostRecentWrite</code>：读取给定 Key 的最后一次 <code>Write</code> 及其 <code>CommitTs</code>，</p>
</li>
</ul>
<blockquote>
<p>用 <code>IterCF()</code> 获取迭代器，因为排序方法的限制，不能用 <code>iter.Seek()</code>，这只会得到 <code>commit &lt;= txn.StartTs</code> 的 <code>Write</code>（即前文提到的 <code>LastCommitWrite</code>）。需要遍历 <code>CfWrite</code> 下的所有 K/V。</p>
</blockquote>
<h3 id="Part-B-TinyKV-Server-1">Part B TinyKV Server 1</h3>
<p>需要实现的代码在文件夹 <code>kv/server</code> 下。</p>
<p>这一 Part 需要我们实现 TinyKV Server 的三大基本 RPC api。</p>
<h4 id="1-KvGet">1 KvGet</h4>
<p><code>KvGet</code> 实现单键读取。对于一个给定的 <code>Key</code> 以及当前时间戳 <code>Version</code>，首先需要检查当前是否被上锁，如果是，则说明必然有某个事务正在对其进行写操作，需要向客户端报告错误。</p>
<blockquote>
<p>一把锁的有效时间范围在 <code>[lock.Ts, lock.Ts + lock.Ttl]</code> 中（如果 <code>lock.Ttl = 0</code> 则表明永久有效，直到被删除）。</p>
</blockquote>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/server/server.go</span></div><code class="language-go">lock <span class="token operator">:=</span> <span class="token function">getLock</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token keyword">if</span> lock<span class="token punctuation">.</span><span class="token function">IsLockedAt</span><span class="token punctuation">(</span>Version<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// err: the key has been locked</span>
  response<span class="token punctuation">.</span>Error <span class="token operator">=</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>KeyError<span class="token punctuation">{</span>
    Locked<span class="token punctuation">:</span> lock<span class="token punctuation">.</span><span class="token function">Info</span><span class="token punctuation">(</span>Key<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> response<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果未上锁，则正式读取，调用 <code>txn.GetValue()</code> 即可。如果返回值为 <code>nil</code> 则修改 <code>response.NotFound = true</code>。</p>
<h4 id="2-KvPreWrite">2 KvPreWrite</h4>
<p><code>kvPreWrite</code> 对应 2PC 的上升阶段。</p>
<p>在执行过程中首先需要对每个 Key 判断是否被上锁，如果上锁了就跟 <code>KvGet</code> 一样报告错误。</p>
<p>其次检查该 Key 的最后一次修改是否与当前事务冲突，即获取 <code>MostRecentWrite</code> 并检查区间 <code>[StartTs, CommitTs]</code> 是否与当前请求时间戳重合，若是则说明存在其他客户端已经发起请求并对数据进行了修改，报告错误。（要保证对同一个 Key 所有修改的时间区间 <code>[StartTs, CommitTs]</code> 不发生重叠）</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/server/server.go</span></div><code class="language-go">mostRecentWrite<span class="token punctuation">,</span> commitTs<span class="token punctuation">,</span> err <span class="token operator">:=</span> txn<span class="token punctuation">.</span><span class="token function">MostRecentWrite</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
<span class="token keyword">if</span> mostRecentWrite <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token operator">&amp;&amp;</span> mostRecentWrite<span class="token punctuation">.</span>StartTS <span class="token operator">&lt;</span> StartVersion <span class="token operator">&amp;&amp;</span> commitTs <span class="token operator">&gt;=</span> StartVersion <span class="token punctuation">{</span>
  <span class="token comment">// err: conflict with another transaction</span>
  response<span class="token punctuation">.</span>Errors <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>Errors<span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>KeyError<span class="token punctuation">{</span>
    Conflict<span class="token punctuation">:</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>WriteConflict<span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> response<span class="token punctuation">,</span> err
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果安全，则上锁，并根据修改类型对 <code>CfDefault</code> 中的数据进行修改。最后调用 <code>server.storage.Write()</code> 将修改落实到数据库中。</p>
<blockquote>
<p>如果中途报错，会直接返回，也就不会走到 server.storage.Write 这一步，更不会对数据库进行修改。</p>
</blockquote>
<h4 id="3-KvCommit">3 KvCommit</h4>
<p><code>KvCommit</code> 对应 2PC 的下降阶段。提交操作并不修改 <code>CfDefault</code> 中的数据，而是通过修改 <code>CfLock</code> 与 <code>CfWrite</code> 来标志该数据已提交。</p>
<p>对于每个 Key，首先检查是否重复 commit，即是否存在 <code>CurrentWrite</code>，若有则说明后续所有 Key 都确定被提交，直接返回即可。当然如果这个 <code>Write</code> 是 <code>Rollback</code>，那么还需要修改 <code>Retryable</code> 并报错。</p>
<p>再检查是否由<strong>当前事务上锁</strong>，即</p>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/server/server.go</span></div><code class="language-go">lock <span class="token operator">:=</span> <span class="token function">getLock</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> key<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">IsLockedAt</span><span class="token punctuation">(</span>req<span class="token punctuation">.</span><span class="token function">GetStartVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span>Error <span class="token operator">=</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>KeyError<span class="token punctuation">{</span>
    Retryable<span class="token punctuation">:</span> <span class="token string">"Unlocked"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> response<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> lock<span class="token punctuation">.</span>Ts <span class="token operator">!=</span> req<span class="token punctuation">.</span><span class="token function">GetStartVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span>Error <span class="token operator">=</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>KeyError<span class="token punctuation">{</span>
    Retryable<span class="token punctuation">:</span> <span class="token string">"Locked By Another Txn"</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> response<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果能够安全提交，则删除之前上的锁，并在 <code>CfWrite</code> 下添加相应条目。最后调用 <code>server.storage.Write()</code> 将修改落实到数据库中。</p>
<h3 id="Part-C-TinyKV-Server-2">Part C TinyKV Server 2</h3>
<h4 id="1-KvScan">1 KvScan</h4>
<p><code>KvScan</code> 获取当前时间戳下所有有效的值。任务书建议我们用 <code>Scanner</code> 来包装操作，相关文件为 <code>kv/transaction/mvcc/scan.go</code>。</p>
<p><code>Scanner</code> 应内置一个迭代器，并在创建时初始化至给定的<code>StartKey</code> 位置处。执行时不断遍历 <code>CfDefault</code> 并检查当前值是否有效。由于排列方式，我们对同一个 Key 最早遍历到的肯定是最新的版本，并且同一个 Key 一定会连续出现，如果</p>
<ol>
<li class="lvl-3">
<p>该 Key 之前已经被返回过（故 <code>Scanner</code> 还需内置一个 <code>LastKey</code> 变量来记录最后一个成功返回的 Key）;</p>
</li>
<li class="lvl-3">
<p>该 Key 版本晚于当前事务;</p>
</li>
<li class="lvl-3">
<p>对应的 <code>LastCommitWrite</code> 为 nil，说明尚未提交，或类型非 <code>Put</code>;</p>
</li>
</ol>
<p>则跳到下一个，否则返回当前 K/V。</p>
<h4 id="2-KvCheckTxnStatus">2 KvCheckTxnStatus</h4>
<p><code>KvCheckTxnStatus</code> 检查给定 PrimaryKey 的当前状态，并执行可能的改动。</p>
<ol>
<li class="lvl-3">
<p>如果存在 <code>CurrentWrite</code>，则无需进行改动。如果该类型非 <code>Rollback</code> 则还需告知 <code>CommitTs</code>;</p>
</li>
<li class="lvl-3">
<p>检查是否存在 <code>Lock</code>，若无则回滚;</p>
</li>
<li class="lvl-3">
<p>检查 <code>Lock</code> 是否超时，若超时则删除原有 <code>Value</code> 与 <code>Lock</code> 并回滚;</p>
</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/server/server.go</span></div><code class="language-go">lock <span class="token operator">:=</span> <span class="token function">getLock</span><span class="token punctuation">(</span>txn<span class="token punctuation">,</span> PrimaryKey<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">ExistAt</span><span class="token punctuation">(</span>CurrentTs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span>Action <span class="token operator">=</span> Action_LockNotExistRollback
  txn<span class="token punctuation">.</span><span class="token function">PutWrite</span><span class="token punctuation">(</span>PrimaryKey<span class="token punctuation">,</span> LockTs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mvcc<span class="token punctuation">.</span>Write<span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> lock<span class="token punctuation">.</span><span class="token function">IsExpiredAt</span><span class="token punctuation">(</span>CurrentTs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span>Action <span class="token operator">=</span> Action_TTLExpireRollback
  txn<span class="token punctuation">.</span><span class="token function">DeleteValue</span><span class="token punctuation">(</span>PrimaryKey<span class="token punctuation">)</span>
  txn<span class="token punctuation">.</span><span class="token function">DeleteLock</span><span class="token punctuation">(</span>PrimaryKey<span class="token punctuation">)</span>
  txn<span class="token punctuation">.</span><span class="token function">PutWrite</span><span class="token punctuation">(</span>PrimaryKey<span class="token punctuation">,</span> LockTs<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mvcc<span class="token punctuation">.</span>Write<span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="3-KvBatchRollback">3 KvBatchRollback</h4>
<p><code>KvBatchRollback</code> 实现多键批量回滚操作。</p>
<ol>
<li class="lvl-3">
<p>如果该 Key 已被回滚，则跳过后续操作，检查下一个 Key;</p>
</li>
<li class="lvl-3">
<p>如果该 Key 已被提交，则报错并返回;</p>
</li>
<li class="lvl-3">
<p>如果该 Key 之前被本事务上锁，则删除原有 <code>Value</code> 与 <code>Lock</code>;</p>
</li>
<li class="lvl-3">
<p>添加一条 <code>Rollback</code> 条目;</p>
</li>
<li class="lvl-3">
<p>最后调用 <code>server.storage.Write()</code> 将修改落实到数据库中。</p>
</li>
</ol>
<h4 id="4-KvResolveLock">4 KvResolveLock</h4>
<p><code>KvResolveLock</code> 需收集由本事务上锁的所有 Key，并根据请求中的 <code>CommitVersion</code> 字段执行不同操作。</p>
<ol>
<li class="lvl-3">
<p><code>CommitVersion = 0</code>: 执行 <code>BatchRollback</code>;</p>
</li>
<li class="lvl-3">
<p><code>CommitVersion != 0</code>: 执行 <code>Commit</code>;</p>
</li>
</ol>
<pre class="line-numbers language-go" data-language="go"><div class="caption"><span>kv/server/server.go</span></div><code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>server <span class="token operator">*</span>Server<span class="token punctuation">)</span> <span class="token function">KvResolveLock</span><span class="token punctuation">(</span><span class="token boolean">_</span> context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> req <span class="token operator">*</span>kvrpcpb<span class="token punctuation">.</span>ResolveLockRequest<span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span>kvrpcpb<span class="token punctuation">.</span>ResolveLockResponse<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token operator">...</span>
  <span class="token keyword">if</span> CommitVersion <span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    commitResponse<span class="token punctuation">,</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">KvCommit</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>CommitRequest<span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    response<span class="token punctuation">.</span>RegionError<span class="token punctuation">,</span> response<span class="token punctuation">.</span>Error <span class="token operator">=</span> commitResponse<span class="token punctuation">.</span><span class="token function">GetRegionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> commitResponse<span class="token punctuation">.</span><span class="token function">GetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> response<span class="token punctuation">,</span> err
  <span class="token punctuation">}</span>
  <span class="token comment">// else</span>
  rollbackResponse<span class="token punctuation">,</span> err <span class="token operator">:=</span> server<span class="token punctuation">.</span><span class="token function">KvBatchRollback</span><span class="token punctuation">(</span>context<span class="token punctuation">.</span><span class="token function">TODO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>kvrpcpb<span class="token punctuation">.</span>BatchRollbackRequest<span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

  response<span class="token punctuation">.</span>RegionError<span class="token punctuation">,</span> response<span class="token punctuation">.</span>Error <span class="token operator">=</span> rollbackResponse<span class="token punctuation">.</span><span class="token function">GetRegionError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> rollbackResponse<span class="token punctuation">.</span><span class="token function">GetError</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token keyword">return</span> response<span class="token punctuation">,</span> err
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      <categories>
        <category>Lab</category>
      </categories>
  </entry>
  <entry>
    <title>训练安排</title>
    <url>/life/train/</url>
    <content><![CDATA[<p>三分化，双循环。</p>
<span id="more"></span>
<h2 id="周一-周四">周一 &amp; 周四</h2>
<p><strong>胸</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>杠铃平板卧推 4×8</p>
</li>
<li class="lvl-2">
<p>杠铃上斜卧推 4×8</p>
</li>
<li class="lvl-2">
<p>蝴蝶机夹胸 4×8</p>
</li>
</ul>
<p><strong>三头</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>绳索下拉 4×8</p>
</li>
</ul>
<h2 id="周二-周五">周二 &amp; 周五</h2>
<p><strong>背</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>高位下拉 4×8</p>
</li>
<li class="lvl-2">
<p>坐姿划船 4×8</p>
</li>
<li class="lvl-2">
<p>俯身下压 4×8</p>
</li>
</ul>
<p><strong>二头</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>弯举 4×8</p>
</li>
</ul>
<h2 id="周三">周三</h2>
<p><strong>腿</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>深蹲 4×8</p>
</li>
</ul>
<h2 id="周六">周六</h2>
<p><strong>肩</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>坐姿哑铃推肩 4×12</p>
</li>
<li class="lvl-2">
<p>哑铃侧平举 4×12</p>
</li>
<li class="lvl-2">
<p>面拉 4×12</p>
</li>
</ul>
<p><strong>腹</strong>：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>龙门卷腹 4×12</p>
</li>
<li class="lvl-2">
<p>支撑举腿 4×12</p>
</li>
</ul>
<h2 id="周日">周日</h2>
<p>睡觉去吧你。</p>
]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title>Unreal Engine の 动画系统</title>
    <url>/unreal/ueanimsystem/</url>
    <content><![CDATA[<blockquote>
<p>「<strong>动画系统</strong>」由多个动画工具和编辑器构成，其将基于骨架的变形与基于变形的顶点变形相结合，从而构建出复杂的动画。该系统可以用于播放和混合预先准备好的动画序列让基本玩家运动显得更加真实，创建自定义特殊动作，如伸缩台阶和墙壁（使用动画蒙太奇），通过变形目标应用伤害效果或面部表情，使用骨架控制直接控制骨骼变形，或创建基于逻辑的 状态机 来确定角色在指定情境下应该使用哪个动画。——<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/animation-system-overview?application_version=4.27">虚幻官方文档</a></p>
</blockquote>
<span id="more"></span>
<h2 id="骨骼与骨架">骨骼与骨架</h2>
<p>在虚幻引擎中，<strong>骨架</strong>用于定义角色中的<strong>骨骼</strong>，同时关联动画数据，从而驱动动画。</p>
<p>骨骼是骨架的基本组成单元，并在骨架中以树状结构组织。<strong>根骨骼</strong>是骨架层级结构的根节点。除了根骨骼外，每个骨骼都有一个<strong>父骨骼</strong>。此外，每个骨骼还有用于唯一标识符的<strong>名称</strong>以及用于确定在空间中状态的<strong>变换信息</strong>。</p>
<blockquote>
<p>变换信息指的是<strong>位置</strong>、<strong>旋转</strong>、<strong>缩放</strong>这些信息。如果每个骨骼记录的变换信息都基于世界坐标，那么角色在运动时几乎所有骨骼都需要进行更新。可以将父骨骼的局部坐标系作为参照，只记录相对变换，从而降低开销。</p>
</blockquote>
<p>在 C++ 中，骨架被定义为类 <code>USkeleton</code>。骨骼完整的信息存放在 <code>FReferenceSkeleton</code> 类型的成员变量 <code>ReferenceSkeleton</code> 中。该变量的部分内容如下</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>ReferenceSkeleton</span></div><code class="language-cpp"><span class="token keyword">struct</span> <span class="token class-name">FMeshBoneInfo</span>
<span class="token punctuation">{</span>
  <span class="token comment">// Bone's name.</span>
  FName Name<span class="token punctuation">;</span>

  <span class="token comment">// INDEX_NONE if this is the root bone. </span>
  int32 ParentIndex<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">struct</span> <span class="token class-name">FReferenceSkeleton</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">//RAW BONES: Bones that exist in the original asset</span>
  <span class="token comment">/** Reference bone related info to be serialized **/</span>
  TArray<span class="token operator">&lt;</span>FMeshBoneInfo<span class="token operator">&gt;</span>	RawRefBoneInfo<span class="token punctuation">;</span>
  <span class="token comment">/** Reference bone transform **/</span>
  TArray<span class="token operator">&lt;</span>FTransform<span class="token operator">&gt;</span>		RawRefBonePose<span class="token punctuation">;</span>

  <span class="token comment">//FINAL BONES: Bones for this skeleton including user added virtual bones</span>
  <span class="token comment">/** Reference bone related info to be serialized **/</span>
  TArray<span class="token operator">&lt;</span>FMeshBoneInfo<span class="token operator">&gt;</span>	FinalRefBoneInfo<span class="token punctuation">;</span>
  <span class="token comment">/** Reference bone transform **/</span>
  TArray<span class="token operator">&lt;</span>FTransform<span class="token operator">&gt;</span>		FinalRefBonePose<span class="token punctuation">;</span>

  <span class="token comment">/** TMap to look up bone index from bone name. */</span>
  TMap<span class="token operator">&lt;</span>FName<span class="token punctuation">,</span> int32<span class="token operator">&gt;</span>		RawNameToIndexMap<span class="token punctuation">;</span>
  TMap<span class="token operator">&lt;</span>FName<span class="token punctuation">,</span> int32<span class="token operator">&gt;</span>		FinalNameToIndexMap<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>每个骨骼的信息用 <code>FMeshBoneInfo</code> 结构体描述，有名称以及父骨骼在 TArray 中的索引。此外 <code>FReferenceSkeleton</code> 中还有骨骼的变换信息以及名称到数组索引的映射。</p>
<h2 id="骨架网格体">骨架网格体</h2>
<p><strong>骨架网格体</strong>是设置了骨架的模型资源，本质上是将<strong>几何数据</strong>、<strong>骨架信息</strong>、<strong>蒙皮权重</strong>进行结合得到的产物。其中，几何数据指的是模型<strong>顶点</strong>、三角形表面、UV 坐标、法线、切线等用于图像渲染的数据。在这里，我们只关注顶点这一概念。</p>
<p>而蒙皮权重是骨架网格体中最重要的概念之一。在骨架网格体中，每根骨骼都与骨架网格体的一部分顶点相关联。当骨骼移动或旋转时，与其关联的顶点也会随之移动，从而实现模型的变形。其中，蒙皮权重定义了每个骨骼应用变换时对每个顶点的影响程度。权重越高，顶点受该骨骼的影响越大。</p>
<h2 id="动画模式">动画模式</h2>
<p>每个 Character 是默认带有 <code>SkeletalMeshComponent</code> 的 Pawn，其中 <code>SkeletalMeshComponent</code> 下面有一个名为「<strong>Animation Mode</strong>」的设置，其中比较主流的是「<strong>Use Animation Asset</strong>」和「<strong>Use Animation Blueprint</strong>」两种选项。</p>
<img src="animmode.png" style="zoom:100%;">
<h2 id="动画序列">动画序列</h2>
<p><strong>动画序列</strong>是最简单的 Animation Asset。在任一时间点，一个骨架网格体中所有骨骼变换信息的集合又被称为<strong>姿势</strong>。动画序列包含了一系列带有姿势信息的关键帧，通过播放序列中的这些关键帧，并再将它们互相混合（比如插值混合），使得骨架网格体可以产生平滑的动画效果。</p>
<blockquote>
<p>每个动画序列专门针对一个特定骨架，且只能在该骨架上播放。换言之，对于不同的骨架网格体，只要使用的骨架相同，那么就可以共享动画序列。</p>
</blockquote>
<h2 id="动画蓝图">动画蓝图</h2>
<p><strong>动画蓝图</strong>用于管理和控制 Character 的动画行为，包含以下两个主要部分。</p>
<p><strong>事件图表</strong>可以构建基于蓝图的逻辑，用于定义节点的属性和包含其他图表区域信息的变量。</p>
<img src="event.png" style="zoom:80%;">
<p><strong>动画图表</strong>通常为当前帧评估骨架网格体的最终姿势。也就意味着动画图表每一帧都会执行。</p>
<img src="anim.png" style="zoom:80%;">
<p>在动画图表中还可以利用<strong>状态机</strong>输出最终姿势。其功能是将不同的动画作为一系列状态，然后按照转换规则管理这些状态，转换规则可控制从一个状态混合到另一个状态，通常用于角色的移动逻辑。</p>
<img src="sm1.png" style="zoom:80%;">
<img src="state.png" style="zoom:80%;">
<h2 id="动画混合">动画混合</h2>
<p><strong>混合</strong>是指将两个或多个值或状态组合在一起的过程，以产生一个平滑的过渡或最终结果。而<strong>动画混合</strong>，指的就是多个动画序列里的每一条变换信息相互之间基于权重的运算过程，本质上是对每个时间点的姿势进行混合。</p>
<p>通过动画混合，我们能够平滑地过渡和组合不同的动画姿势，从而创造出更自然的角色动画。比如根据角色的速度和方向，动态地在行走和跑步之间平滑过渡；或者将换弹与跑步相混合，得到一个奔跑时换弹的融合动作。</p>
<h3 id="变换信息运算方式">变换信息运算方式</h3>
<p>变换信息的运算有以下两种方式：<strong>覆写</strong>和<strong>叠加</strong>。</p>
<p>覆写是直接将目标变换设置为<code>源变换 * 权重</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Overrite Transform</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
FORCEINLINE <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">BlendTransform</span><span class="token generic class-name"><span class="token operator">&lt;</span>ETransformBlendMode<span class="token double-colon punctuation">::</span>Overwrite<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  <span class="token keyword">const</span> FTransform<span class="token operator">&amp;</span> Source<span class="token punctuation">,</span> FTransform<span class="token operator">&amp;</span> Dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">float</span> BlendWeight
<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> ScalarRegister <span class="token function">VBlendWeight</span><span class="token punctuation">(</span>BlendWeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Dest <span class="token operator">=</span> Source <span class="token operator">*</span> VBlendWeight<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而叠加是在目标变换的基础上加上<code>源变换 * 权重</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>Accumulate Transform</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
FORCEINLINE <span class="token keyword">void</span> <span class="token generic-function"><span class="token function">BlendTransform</span><span class="token generic class-name"><span class="token operator">&lt;</span>ETransformBlendMode<span class="token double-colon punctuation">::</span>Accumulate<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>
  <span class="token keyword">const</span> FTransform<span class="token operator">&amp;</span> Source<span class="token punctuation">,</span> FTransform<span class="token operator">&amp;</span> Dest<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">float</span> BlendWeight
<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">const</span> ScalarRegister <span class="token function">VBlendWeight</span><span class="token punctuation">(</span>BlendWeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Dest<span class="token punctuation">.</span><span class="token function">AccumulateWithShortestRotation</span><span class="token punctuation">(</span>Source<span class="token punctuation">,</span> VBlendWeight<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="姿势混合">姿势混合</h3>
<p>姿势混合将两个或多个动画的姿势组合在一起，以创建新的姿势，从而得到混合后的新的动画。</p>
<p>虚幻引擎中的动画蓝图提供了以下几种基于混合节点的姿势混合方式：</p>
<ol>
<li class="lvl-3">
<p><strong>叠加混合</strong>。对应于动画蓝图中的「<strong>Apply Additive</strong>」/「<strong>Apply Mesh Space Additive</strong>」节点，根据权重值 Alpha 在 Base 姿势上叠加 Additive 姿势，即 <code>Dest = Additive + Base * Alpha</code>。其中，Additive 姿势记录的是相对于参考姿势的<strong>偏移量</strong>，而不是绝对姿势。</p>
 <table border="0" cellspacing="0" cellpadding="0"><tbody><tr>
 <td><img src="additive.png" style="zoom:100%;"></td>
 <td><img src="additive1.png" style="zoom:100%;"></td>
 </tr></tbody></table>
</li>
<li class="lvl-3">
<p><strong>线性插值混合</strong>。对应于动画蓝图中的「<strong>Blend</strong>」节点，根据权重值 Alpha 简单地混合两个输入姿势 A 和 B，即 <code>Dest = A * (1-Alpha) + B * Alpha</code>。</p>
 <img src="blend.png" style="zoom:100%;">
</li>
<li class="lvl-3">
<p><strong>骨骼分层混合</strong>。对应于动画蓝图中的「<strong>Layered blend per bone</strong>」节点，仅针对选中的骨骼将 Base 与 Blend 进行线性插值混合。这些骨骼都有单独的「<strong>Bone Blend Weights</strong>」，并乘上「<strong>Blend Weights</strong>」作为最终权重。</p>
 <img src="layeredblend.png" style="zoom:100%;">
<p>节点有以下两种混合模式：</p>
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>Branch Filter</strong>。需在「<strong>层设置</strong>」-&gt;「<strong>分支过滤器</strong>」中指定骨骼名称（以 bone 为例）。当「<strong>Blend Depth</strong>」参数为 0/1 时，bone 所在整条骨骼链的「<strong>Bone Blend Weights</strong>」均为 1；参数为 N(N&gt;=2) 时，从 bone 开始「<strong>Bone Blend Weights</strong>」是 1/N, 2/N, …, 1, 1…；参数为 -1 时，整条骨骼链的「<strong>Bone Blend Weights</strong>」均为 0，即完全使用「<strong>Base Pose</strong>」。</p>
</li>
</ul>
 <img src="branchfilter.png" style="zoom:100%;">
<ul class="lvl-2">
<li class="lvl-6">
<p><strong>Blend Mask</strong>。可以在骨骼网格体的「<strong>骨骼树</strong>」-&gt;「<strong>选项</strong>」-&gt;「<strong>Add Blend Mask</strong>」自定义一个「<strong>Blend Mask Profile</strong>」配置项，该配置为每个骨骼单独定义「<strong>Bone Blend Weights</strong>」，从而精确控制哪些骨骼参与混合，哪些骨骼不参与混合。</p>
</li>
</ul>
</li>
</ol>
<h3 id="混合空间">混合空间</h3>
<p><strong>混合空间</strong>能够通过一个或多个输入参数在多个动画序列之间平滑地混合。这些参数通常是角色的属性，例如速度、方向、攻击角度等。</p>
<p>混合空间由一系列采样点组成。每个采样点对应于一个特定的输入参数值，并指定要播放的动画序列。当输入参数的值发生变化时，混合空间会根据当前输入参数值，在<strong>相邻</strong>的采样点之间进行混合。</p>
<blockquote>
<p>比如在混合空间 1D 中，设置「速度」为参数，在数值 0 处设置动画序列「Idle」的采样点，在数值 x1 处设置动画序列「Walk」的采样点，在数值 x2 处设置动画序列「Run」的采样点。那么在速度为 0~x1 时，混合空间会采用<strong>线性插值</strong>的方式，驱动网格体的姿势从 Idle 平滑过渡到 Walk。在速度为 x1~x2 时同理。</p>
<img src="blendspace.png" style="zoom:100%;">
<p>而在混合空间 2D 中，则会采用<strong>双线性插值</strong>的方式来混合。</p>
</blockquote>
<p>虽然都是进行「混合」，但与混合节点不同，混合空间更像是“参数驱动的过渡工具”，确保动画连续性，</p>
<h2 id="动画蒙太奇">动画蒙太奇</h2>
<h3 id="实现原理">实现原理</h3>
<p>状态机将循环播放角色当前所处状态的动画序列，是持续性的，但这些动画序列必须预先静态绑定到每个状态中，无法在运行时通过参数动态指定不同的动画。当我们想实现「<strong>触发某些条件播放一次动画</strong>」这一功能时，如果使用状态机，则必须设置一个新状态，随着动画逻辑的增加，状态网络复杂性提升，得不偿失。</p>
<p><strong>蒙太奇</strong>。所有 Slot 由一个全局变量「<strong>Anim Slot Manager</strong>」管理。下面的例子中，Slot 名为「<strong>DefaultGroup.UpperBody</strong>」，其中「<strong>DefaultGroup</strong>」是<strong>插槽组</strong>，一个蒙太奇中所有的 Slot 必须是同一组的。</p>
<img src="slot.png" style="zoom:80%;">
<p>我们可以利用动画图表表中的同名<strong>插槽节点</strong>，便可在播放蒙太奇时覆盖之前节点的输出姿势。在下面的例子中，「<strong>FullBody</strong>」节点置于状态机后，以覆盖的形式插入动画，用于全身的互动动作或者表情动作；「<strong>UpperBody</strong>」搭配「<strong>Layered blend per bone</strong>」节点，实现按上半身骨骼的姿势混合。</p>
<img src="slotnode.png" style="zoom:80%;">
<p>Slot Node 相当于一个过滤器，当且仅当执行 Play Montage 操作时，对应的 Slot Node 会被激活，从而覆盖前面的输出；反之，Slot Node 会直接将 Source 设置为 Output。</p>
<h3 id="源码剖析">源码剖析</h3>
<p>在 C++ 中，Play Montage 操作实际上会调用 <code>UAnimInstance::Montage_Play()</code> 方法，并进一步走到 <code>UAnimInstance::Montage_PlayInternal()</code> 中。如果传入参数 <code>bStopAllMontages</code> 为 true（默认值），那么会终止第一个 Slot 所在 Group 内的其他蒙太奇。接下来，将执行以下几个比较重要的步骤：</p>
<ol>
<li class="lvl-3">
<p>首先是创建了一个 <code>FAnimMontageInstance</code> 类型的蒙太奇实例；</p>
</li>
<li class="lvl-3">
<p>然后根据 <code>BlendInSettings</code> 设置蒙太奇混入的权重以及时间等配置数据；</p>
</li>
<li class="lvl-3">
<p>并将该蒙太奇实例加入 <code>MontageInstances</code> 变量中，表示当前活跃的蒙太奇。</p>
</li>
</ol>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">UAnimInstance</span><span class="token double-colon punctuation">::</span><span class="token function">Montage_PlayInternal</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  FAnimMontageInstance<span class="token operator">*</span> NewInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">FAnimMontageInstance</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">check</span><span class="token punctuation">(</span>NewInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token keyword">float</span> MontageLength <span class="token operator">=</span> MontageToPlay<span class="token operator">-&gt;</span><span class="token function">GetPlayLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  NewInstance<span class="token operator">-&gt;</span><span class="token function">Initialize</span><span class="token punctuation">(</span>MontageToPlay<span class="token punctuation">)</span><span class="token punctuation">;</span>
  NewInstance<span class="token operator">-&gt;</span><span class="token function">Play</span><span class="token punctuation">(</span>InPlayRate<span class="token punctuation">,</span> BlendInSettings<span class="token punctuation">)</span><span class="token punctuation">;</span>
  NewInstance<span class="token operator">-&gt;</span><span class="token function">SetPosition</span><span class="token punctuation">(</span><span class="token class-name">FMath</span><span class="token double-colon punctuation">::</span><span class="token function">Clamp</span><span class="token punctuation">(</span>InTimeToStartMontageAt<span class="token punctuation">,</span> <span class="token number">0.f</span><span class="token punctuation">,</span> MontageLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  MontageInstances<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>NewInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
  ActiveMontagesMap<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>MontageToPlay<span class="token punctuation">,</span> NewInstance<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>主线程的相关内容就到此为止了，接下来是 Tick 时间。在每个 Tick 都会执行 <code>USkinnedMeshComponent::TickComponent()</code> 方法，然后一层层调用到 <code>UAnimInstance::UpdateAnimation()</code> 方法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token class-name">UAnimInstance</span><span class="token double-colon punctuation">::</span><span class="token function">UpdateAnimation</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token punctuation">{</span>
    <span class="token function">UpdateMontage</span><span class="token punctuation">(</span>DeltaSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// now we know all montage has advanced</span>
    <span class="token comment">// time to test sync groups</span>
    <span class="token function">UpdateMontageSyncGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// Update montage eval data, to be used by AnimGraph Update and Evaluate phases.</span>
    <span class="token function">UpdateMontageEvaluationData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>UpdateMontage()</code> 对蒙太奇进行混合权重的更新和时间轴的推进；</p>
</li>
<li class="lvl-2">
<p><code>UpdateMontageSyncGroup()</code> 略；</p>
</li>
<li class="lvl-2">
<p><code>UpdateMontageEvaluationData()</code> 会将 <code>MontageInstances</code> 中所有活跃的蒙太奇相关数据加入到 <code>FAnimInstanceProxy::MontageEvaluationData</code> 里。</p>
</li>
</ul>
<p>每个 Tick 还会在上面的方法结束后调用 <code>FAnimNode_Slot::Update_AnyThread()</code> 和 <code>FAnimNode_Slot::Evaluate_AnyThread()</code> 方法，其中 <code>FAnimNode_Slot</code> 就是对应的 Slot Node。前者计算出当前混合权重，后者从 <code>FAnimInstanceProxy::MontageEvaluationData</code> 中获取拥有相同 Slot Name 的活跃蒙太奇，最后结合 Source 以及相关权重计算出 Output。</p>
<p>事实上，如果 <code>bStopAllMontages</code> 为 false，那么实际上会和所有活跃的蒙太奇一起混合。</p>
<blockquote>
<p>播放/结束蒙太奇时，前后一帧不可能与状态机的输出完全一致，如果直接修改则会很突兀，所以需要用 BlendIn 和 BlendOut 作首尾的混合，因此需要计算权重。</p>
</blockquote>
<h2 id="动画曲线">动画曲线</h2>
<p><strong>动画曲线</strong>是一种基于时间轴的关键帧动画控制机制，本质上是 float 曲线，x 轴为时间轴，与对应的动画序列等长；y 轴为自定义参数，每一帧都有对应的数值。在动画蓝图中，可以通过「<strong>Get Curve Value</strong>」节点获取当前时间帧对应的曲线值，默认为 0（即使该动画序列中没有同名曲线，也返回 0）。</p>
<h3 id="曲线混合">曲线混合</h3>
<p>当对多个动画序列进行混合时，会对同名曲线也进行混合，同时「<strong>Get Curve Value</strong>」获取的曲线值一定是若干曲线的混合结果值。</p>
<p>使用「<strong>Blend</strong>」节点进行混合时，「<strong>Get Curve Value</strong>」得到的曲线值的计算逻辑为 <code>CurveA * (1-Alpha) + CurveB * Alpha</code>，这与 Pose 的混合逻辑完全一致。</p>
<p>使用「<strong>Layered blend per bone</strong>」节点进行混合时，则因「<strong>曲线混合选项</strong>」而异，具体如下表所示，假设输入姿势「<strong>Blend Poses i</strong>」对应的曲线为 $Curve_i$。</p>
<p>|选项|计算逻辑||
|:-😐:-😐
|Override|同名曲线中取最后一次出现的，即 $i$ 最大的|
|Do Not Override|同名曲线中取第一次出现的，即 $i$ 最小的|
|Blend by Weight|$Curve = BaseCurve + \sum\limits_0^n BlendWeights_i<em>Curve_i$|
|Normalize by Weight|$\displaystyle{Curve = \frac{BaseCurve + \sum\limits_0^n BlendWeights_i</em>Curve_i}{1+\sum\limits_0^n BlendWeights_i}}$|
|Use Base Pose|取 Base Pose 对应曲线值|
|Use Max Value|取所有 Poses 对应曲线的最大值（不考虑不存在）|
|Use Min Value|取所有 Poses 对应曲线的最小值（不考虑不存在）|</p>
<blockquote>
<p>上述 BlendWeights 会被 clamp 到 (0, 1) 间。</p>
</blockquote>
<h3 id="变形目标-Morph-Targets">变形目标 Morph Targets</h3>
<p><strong>Morph Targets</strong> 本质上是一个变量，通过修改该变量的值，能够改变模型的顶点位置，从而实现形状的动态变化，常用于角色面部表情、物体形变等场景。这玩意一般是美术创建好，和 SkeletalMesh 一起导入 UE 中的，可以在骨骼网格体页面的「<strong>变形目标预览器</strong>」处查看。此时，应用于该骨骼网格体的动画序列可以直接创建已知变形目标变量的曲线。</p>
<h2 id="动画通知">动画通知</h2>
<p><strong>动画通知</strong>可以在动画播放到某个时间点的时候发送一次通知（Anim Notify），或持续发送通知直到结束点（Anim Notify State）。本质上是绑定了**动画通知类（Anim Notify Class）**的 callback，当触发通知后会调用类内部的 <code>Notify()</code> 函数。</p>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Unreal Engine の 委托</title>
    <url>/unreal/uedelegate/</url>
    <content><![CDATA[<blockquote>
<p>「<strong>委托</strong>」是一种泛型但类型安全的方式，可在 C++ 对象上调用成员函数。可使用委托动态绑定到任意对象的成员函数，之后在该对象上调用函数，即使调用程序不知对象类型也可进行操作。——<a href="https://dev.epicgames.com/documentation/zh-cn/unreal-engine/delegates-and-lamba-functions-in-unreal-engine">虚幻官方文档</a></p>
</blockquote>
<span id="more"></span>
<p>委托本质上是基于「<strong>观察者模式</strong>」的，也就是有「<strong>订阅</strong>」的行为，在委托中称为「<strong>绑定</strong>」。</p>
<p>要使用委托，首先要用 <code>DECLARE*</code> 宏进行特定委托的类型声明，之后才允许用 <code>Bind*()</code>/<code>Add*()</code> 函数将「<strong>订阅者</strong>」（一个可调用对象）绑定到委托对象上。这样一旦某些事件触发，就可以通过 <code>Execute()</code>/<code>BroadCast()</code> 通知这些订阅者。</p>
<p>委托的基本类型有三种。</p>
<ol>
<li class="lvl-3">
<p>单播委托</p>
</li>
<li class="lvl-3">
<p>多播委托</p>
</li>
<li class="lvl-3">
<p>动态委托</p>
</li>
</ol>
<h2 id="单播委托-动态单播委托">单播委托 &amp; 动态单播委托</h2>
<p>单播，顾名思义就是最多只能绑定<strong>一个</strong>可调用对象，并且不支持反射和序列化。优点是支持返回值。</p>
<p>而「动态」的意思是会在执行时实时根据给定的「函数名」去查找对应的函数（需要用 <code>UFUNCTION()</code> 修饰），因此执行速度很慢。此外，动态单播并不支持反射和序列化。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>单播委托</span></div><code class="language-cpp"><span class="token comment">/**
 * 声明一个名为 DelegateType 的委托类型
 * 允许绑定的函数类型为 void(*)(ParamType1, ParamType2, ...)
 * 相当于 using DelegateType = TDelegate&lt;void(ParamType1, ParamType2, ...)&gt;;
 * 无返回值
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_DELEGATE</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamType2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/**
 * 声明动态委托类型
 * 允许绑定的函数类型为 void(*)(ParamType1 ParamName1, ...)
 * 相当于定义了一个继承自 TBaseDynamicDelegate 的类
 * 无返回值
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_DYNAMIC_DELEGATE</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamName1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/**
 * 允许绑定的函数类型为 RetValType(*)(ParamType1, ParamType2, ...)
 * 相当于 using DelegateType = TDelegate&lt;RetValType(ParamType1, ParamType2, ...)&gt;;
 * 有返回值
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_DELEGATE_RetVal</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>RetValType<span class="token punctuation">,</span> DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamType2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/**
 * 允许绑定的函数类型为 RetValType(*)(ParamType1 ParamName1, ...)
 * 有返回值
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_DYNAMIC_DELEGATE_RetVal</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamName1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="多播委托-动态多播委托">多播委托 &amp; 动态多播委托</h2>
<p>多播则是允许绑定多个可调用对象，但不支持返回值和反射。</p>
<p>动态多播同样需要用 <code>UFUNCTION()</code> 修饰，但支持反射以及序列化，也就是可以在蓝图中进行绑定，此时需要使用 <code>BlueprintAssignable</code> 修饰符。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>多播委托</span></div><code class="language-cpp"><span class="token comment">/**
 * 多播委托类型
 * 相当于 using DelegateType = TMulticastDelegate&lt;void(ParamType1, ParamType2, ...)&gt;;
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_MULTICAST_DELEGATE</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamType2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/**
 * 线程安全多播类型
 * 相当于 using DelegateType = TMulticastDelegate&lt;RetValType(ParamType1, ParamType2, ...)， FDefaultTSDelegateUserPolicy&gt;;
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_TS_MULTICAST_DELEGATE</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamType2<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span>

<span class="token comment">/**
 * 动态多播类型
 * 相当于定义了一个继承自 TBaseDynamicMulticastDelegate 的类
 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">DECLARE_DYNAMIC_MULTICAST_DELEGATE</span><span class="token expression"><span class="token operator">*</span><span class="token punctuation">(</span>DelegateType<span class="token punctuation">,</span> ParamType1<span class="token punctuation">,</span> ParamName1<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="事件">事件</h2>
<p>除了上面 7 个宏族，UE 里还有一种声明方式是 <code>DECLARE_EVENT*()</code>。它和多播很像，但指定了 Owner，即只能在 Owner 类的成员函数中调用 <code>BroadCast()</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>EVENT 委托源码</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FUNC_DECLARE_EVENT</span><span class="token expression"><span class="token punctuation">(</span> OwningType<span class="token punctuation">,</span> EventName<span class="token punctuation">,</span> ReturnType<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token keyword">class</span> <span class="token class-name">EventName</span> <span class="token operator">:</span> <span class="token keyword">public</span> TMulticastDelegate<span class="token operator">&lt;</span><span class="token function">ReturnType</span><span class="token punctuation">(</span>__VA_ARGS__<span class="token punctuation">)</span><span class="token operator">&gt;</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">{</span> </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">friend</span> <span class="token keyword">class</span> <span class="token class-name">OwningType</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">;</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可以看到用了友元类来进行访问权限的控制。</p>
<h2 id="绑定-解绑">绑定 &amp; 解绑</h2>
<h3 id="非动态委托">非动态委托</h3>
<p><code>Bind*()</code> 系用于单播绑定，<code>Add*()</code> 系用于多播绑定。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>非动态委托</span></div><code class="language-cpp"><span class="token comment">/* 绑定类的静态函数 */</span>
MyUnicastDelegate<span class="token punctuation">.</span><span class="token function">BindStatic</span><span class="token punctuation">(</span><span class="token comment">/* A static function pointer */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
MyMulticastDelegate<span class="token punctuation">.</span><span class="token function">AddStatic</span><span class="token punctuation">(</span><span class="token comment">/* &amp;MyClass::MyStaticFunc */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 绑定 lambda 函数，可能出现悬垂引用的问题 */</span>
<span class="token function">BindLambda</span><span class="token punctuation">(</span><span class="token comment">/* Lambda */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddLambda</span><span class="token punctuation">(</span><span class="token comment">/* [this](...) {...} */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 绑定 Weak lambda 函数，区别在于如果 this 无效不会执行 lambda */</span>
<span class="token function">BindWeakLambda</span><span class="token punctuation">(</span><span class="token comment">/* User Object */</span><span class="token punctuation">,</span> <span class="token comment">/* Lambda */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddWeakLambda</span><span class="token punctuation">(</span><span class="token comment">/* this */</span><span class="token punctuation">,</span> <span class="token comment">/* [this](...) {...} */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 绑定到继承自 UObject 对象上的某个函数 */</span>
<span class="token function">BindUObject</span><span class="token punctuation">(</span><span class="token comment">/* UObject* */</span><span class="token punctuation">,</span> <span class="token comment">/* A function pointer */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddUObject</span><span class="token punctuation">(</span><span class="token comment">/* this */</span><span class="token punctuation">,</span> <span class="token comment">/* &amp;MyClass::MyFunc */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 绑定到不继承自 UObject 的对象上的函数，同样可能出现悬垂引用的问题 */</span>
<span class="token function">BindRaw</span><span class="token punctuation">(</span><span class="token comment">/* Raw Pointer */</span><span class="token punctuation">,</span> <span class="token comment">/* A function pointer */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddRaw</span><span class="token punctuation">(</span><span class="token comment">/* Other */</span><span class="token punctuation">,</span> <span class="token comment">/* &amp;OtherClass::OtherFunc */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 在上面的基础上，传入对象为 Shared Pointer */</span>
<span class="token function">BindSP</span><span class="token punctuation">(</span><span class="token comment">/* Shared Pointer */</span><span class="token punctuation">,</span> <span class="token comment">/* A function pointer */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddSP</span><span class="token punctuation">(</span><span class="token comment">/* Other.ToSharedRef() */</span><span class="token punctuation">,</span> <span class="token comment">/* &amp;OtherClass::OtherFunc */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 上面的线程安全版本 */</span>
<span class="token function">BindThreadSafeSP</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddThreadSafeSP</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 基于函数名进行绑定，需要用 UFUNCTION() 修饰 !!开销很大!! */</span>
<span class="token function">BindUFunction</span><span class="token punctuation">(</span><span class="token comment">/* User Object */</span><span class="token punctuation">,</span> <span class="token comment">/* Function name */</span><span class="token punctuation">,</span> <span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">AddUFunction</span><span class="token punctuation">(</span><span class="token comment">/* this */</span><span class="token punctuation">,</span> <span class="token comment">/* "MyFunction" */</span><span class="token punctuation">,</span> <span class="token comment">/* ... */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 单播/动态单播 解除绑定 */</span>
<span class="token function">UnBind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 多播/动态多播 解除某个绑定 */</span>
<span class="token function">Remove</span><span class="token punctuation">(</span><span class="token comment">/* this */</span><span class="token punctuation">,</span> <span class="token comment">/* &amp;MyClass::MyFunc */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Remove</span><span class="token punctuation">(</span><span class="token comment">/* Delegate Handle */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 多播/动态多播 解除所有绑定 */</span>
<span class="token function">RemoveAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">Clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>对于单播而言，后续的绑定会覆盖之前的。</p>
</blockquote>
<h3 id="动态委托">动态委托</h3>
<p>动态委托绑定的函数必须用 <code>UFUNCTION()</code> 修饰，否则无效。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>动态委托</span></div><code class="language-cpp"><span class="token comment">/* 动态单播 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">BindDynamic</span><span class="token expression"><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName <span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__Internal_BindDynamic</span><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
                                <span class="token expression"><span class="token function">STATIC_FUNCTION_FNAME</span><span class="token punctuation">(</span> <span class="token function">TEXT</span><span class="token punctuation">(</span> #FuncName <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>

<span class="token function">BindDynamic</span><span class="token punctuation">(</span><span class="token comment">/* User Object */</span><span class="token punctuation">,</span> <span class="token comment">/* A function poiter */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 动态多播 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">AddDynamic</span><span class="token expression"><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName <span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__Internal_AddDynamic</span><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
                               <span class="token expression"><span class="token function">STATIC_FUNCTION_FNAME</span><span class="token punctuation">(</span> <span class="token function">TEXT</span><span class="token punctuation">(</span> #FuncName <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>

<span class="token function">AddDynamic</span><span class="token punctuation">(</span><span class="token comment">/* this */</span><span class="token punctuation">,</span> <span class="token comment">/* &amp;MyClass::MyFunc */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 动态多播 且去重 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">AddUniqueDynamic</span><span class="token expression"><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName <span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__Internal_AddUniqueDynamic</span><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
                                     <span class="token expression"><span class="token function">STATIC_FUNCTION_FNAME</span><span class="token punctuation">(</span> <span class="token function">TEXT</span><span class="token punctuation">(</span> #FuncName <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>

<span class="token function">AddUniqueDynamic</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 移除 */</span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">RemoveDynamic</span><span class="token expression"><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName <span class="token punctuation">)</span> </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">__Internal_RemoveDynamic</span><span class="token punctuation">(</span> UserObject<span class="token punctuation">,</span> FuncName<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
                                  <span class="token expression"><span class="token function">STATIC_FUNCTION_FNAME</span><span class="token punctuation">(</span> <span class="token function">TEXT</span><span class="token punctuation">(</span> #FuncName <span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">)</span></span></span>

<span class="token function">RemoveDynamic</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这几个其实都是宏定义，而不是类的成员函数（所以 intellisense 没法识别）。</p>
<h2 id="通知">通知</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>通知</span></div><code class="language-cpp"><span class="token comment">/* 单播/动态单播 通知，可能存在函数指针无效的问题，此时会报错 */</span>
<span class="token function">Execute</span><span class="token punctuation">(</span><span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 上面的安全版本，如果函数指针无效则不执行 */</span>
<span class="token function">ExecuteIfBound</span><span class="token punctuation">(</span><span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">/* 多播/动态多播 通知所有订阅者 */</span>
<span class="token function">BroadCast</span><span class="token punctuation">(</span><span class="token comment">/* Parameters */</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>注意 <code>Execute*()</code> 都可以有返回值，但 <code>BroadCast()</code> 不行。</p>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Unreal Engine の Gameplay 框架</title>
    <url>/unreal/uegameplay/</url>
    <content><![CDATA[<span id="more"></span>
<h2 id="UObject">UObject</h2>
<blockquote>
<p>部分参考 <a href="https://zhuanlan.zhihu.com/p/24319968">InsideUE4 - UObject</a></p>
</blockquote>
<p><code>UObject</code> 是 UE 中所有 C++ 对象的根基类，它是 UE 对象系统的重要组成部分。通过 UObject，UE 支持以下功能：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>垃圾回收</p>
</li>
<li class="lvl-2">
<p>引用更新</p>
</li>
<li class="lvl-2">
<p>映象</p>
</li>
<li class="lvl-2">
<p>序列化</p>
</li>
<li class="lvl-2">
<p>默认属性变化自动更新</p>
</li>
<li class="lvl-2">
<p>自动属性初始化</p>
</li>
<li class="lvl-2">
<p>自动编辑器整合</p>
</li>
<li class="lvl-2">
<p>运行时类型信息可用</p>
</li>
<li class="lvl-2">
<p>网络复制</p>
</li>
<li class="lvl-2">
<p>…</p>
</li>
</ul>
<p>它有以下五个继承自 <code>UObjectBase</code> 的关键变量。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">/**
 * 用于描述一个对象。比如
 *   - RF_ClassDefaultObject 表明它是 ClassDefaultObject；
 *   - RF_MarkAsRootSet 表明它不应被 GC，即使不被引用；
 *   - RF_NeedInitialization 表明该对象还未初始化完成状态；
 *   - ...
 * 这些描述符体现为一个 32 位无符号整数的 bit
 */</span>
EObjectFlags ObjectFlags<span class="token punctuation">;</span>

<span class="token comment">/**
 * GUObjectArray 的索引，用于实现「内存管理」与「垃圾回收」。
 * 其中 GUObjectArray 是一个全局 UObject 数组。
 * 每构造一个对象，都会在构造函数中调用 AddObject() 将其加入到数组中。
 */</span>
int32        InternalIndex<span class="token punctuation">;</span>

<span class="token comment">/** 该 Object 所属的 UClass，用于实现「反射」 */</span>
ObjectPtr_Private<span class="token double-colon punctuation">::</span>TNonAccessTrackedObjectPtr<span class="token operator">&lt;</span>UClass<span class="token operator">&gt;</span> ClassPrivate<span class="token punctuation">;</span>

<span class="token comment">/** 该 Object 的名字，用于实现「反射」 */</span>
FName        NamePrivate<span class="token punctuation">;</span>

<span class="token comment">/**
 * 拥有该 Object 的 Object。
 * 在运行时引用自己的对象可能有无穷个，但自己的 Outer 有且仅有一个。
 * Outer 语义上就是真正拥有自己的那个对象。
 */</span>
ObjectPtr_Private<span class="token double-colon punctuation">::</span>TNonAccessTrackedObjectPtr<span class="token operator">&lt;</span>UObject<span class="token operator">&gt;</span> OuterPrivate<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>后面四个对象都可以通过一个 public 接口 <code>GetXXX()</code> 获取。</p>
<h3 id="UObject-的内存管理">UObject 的内存管理</h3>
<p>UObject 与 UE 内存管理相关的所有逻辑是在其基类 <code>UObjectBase</code> 中实现的。</p>
<h4 id="构造函数">构造函数</h4>
<p>首先观察 UObjectBase 的构造函数，发现执行了关键的一条函数 <code>AddObject()</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UObjectBase.cpp</span></div><code class="language-cpp"><span class="token class-name">UObjectBase</span><span class="token double-colon punctuation">::</span><span class="token function">UObjectBase</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token function">check</span><span class="token punctuation">(</span>ClassPrivate<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Add to global table.</span>
  <span class="token function">AddObject</span><span class="token punctuation">(</span>InName<span class="token punctuation">,</span> InInternalFlags<span class="token punctuation">,</span> InInternalIndex<span class="token punctuation">,</span> InSerialNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>	

<span class="token keyword">void</span> <span class="token class-name">UObjectBase</span><span class="token double-colon punctuation">::</span><span class="token function">AddObject</span><span class="token punctuation">(</span>FName InName<span class="token punctuation">,</span> EInternalObjectFlags InSetInternalFlags<span class="token punctuation">,</span>
                            int32 InInternalIndex<span class="token punctuation">,</span> int32 InSerialNumber<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  EInternalObjectFlags InternalFlagsToSet <span class="token operator">=</span> InSetInternalFlags<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  GUObjectArray<span class="token punctuation">.</span><span class="token function">AllocateUObjectIndex</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> InternalFlagsToSet<span class="token punctuation">,</span>
                                     InInternalIndex<span class="token punctuation">,</span> InSerialNumber<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">HashObject</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里主要关注其中两步，即 <code>AllocateUObjectIndex()</code> 和 <code>HashObject()</code>。</p>
<h4 id="AllocateUObjectIndex">AllocateUObjectIndex()</h4>
<p>这个函数的作用是将 Object 放到一个全局的名为 <code>GUObjectArray</code> 的对象中。顾名思义，该对象用于管理所有 UObject 的信息，之后要提的垃圾回收也是基于这个对象进行的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UObjectArray.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">FUObjectArray</span><span class="token double-colon punctuation">::</span><span class="token function">AllocateUObjectIndex</span><span class="token punctuation">(</span>UObjectBase<span class="token operator">*</span> Object<span class="token punctuation">,</span>
                                         EInternalObjectFlags InitialFlags<span class="token punctuation">,</span>
                                         int32 AlreadyAllocatedIndex<span class="token punctuation">,</span>
                                         int32 SerialNumber<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  int32 Index <span class="token operator">=</span> INDEX_NONE<span class="token punctuation">;</span>
  <span class="token function">LockInternalArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 如果已经分配过了</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>AlreadyAllocatedIndex <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Index <span class="token operator">=</span> AlreadyAllocatedIndex<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 如果开启了忽略 GC 的优化</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>OpenForDisregardForGC <span class="token operator">&amp;&amp;</span> <span class="token function">DisregardForGCEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    Index <span class="token operator">=</span> <span class="token operator">++</span>ObjLastNonGCIndex<span class="token punctuation">;</span>
    <span class="token comment">// 如果超过 忽略 GC 的最大 Object 数量，则需要扩容。</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ObjLastNonGCIndex <span class="token operator">&gt;=</span> MaxObjectsNotConsideredByGC<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      Index <span class="token operator">=</span> ObjObjects<span class="token punctuation">.</span><span class="token function">AddSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    MaxObjectsNotConsideredByGC <span class="token operator">=</span> <span class="token class-name">FMath</span><span class="token double-colon punctuation">::</span><span class="token function">Max</span><span class="token punctuation">(</span>MaxObjectsNotConsideredByGC<span class="token punctuation">,</span>
                                             ObjLastNonGCIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 剩下就是有 GC 的情况</span>
  <span class="token keyword">else</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 这里用「空闲列表」是因为后续回收的 Object 索引是不确定的</span>
    <span class="token comment">// 要用空闲列表防止产生碎片</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ObjAvailableList<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      Index <span class="token operator">=</span> ObjAvailableList<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">const</span> int32 AvailableCount <span class="token operator">=</span> ObjAvailableList<span class="token punctuation">.</span><span class="token function">Num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token function">checkSlow</span><span class="token punctuation">(</span>AvailableCount <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span> <span class="token comment">// 如果空间不足，就扩容</span>
    <span class="token punctuation">{</span>
      Index <span class="token operator">=</span> ObjObjects<span class="token punctuation">.</span><span class="token function">AddSingle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
    <span class="token punctuation">}</span>
    <span class="token comment">// 这个 check 信息量很大</span>
    <span class="token comment">// 可以得到 ObjFirstGCIndex &gt; ObjLastNonGCIndex 总是成立的</span>
    <span class="token comment">// 这意味着 ObjectArray 划分为两部分，前面为 NonGC，后面为 NeedGC</span>
    <span class="token comment">// 同时 NonGC 会优先于 NeedGC 创建</span>
    <span class="token comment">// GC 过程不会访问 NonGC Object，它们也不能有指向 NeedGC 的引用</span>
    <span class="token comment">// 这样可以加快 GC 速度，因为只需遍历较少 Object。</span>
    <span class="token function">check</span><span class="token punctuation">(</span>Index <span class="token operator">&gt;=</span> ObjFirstGCIndex <span class="token operator">&amp;&amp;</span> Index <span class="token operator">&gt;</span> ObjLastNonGCIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  FUObjectItem<span class="token operator">*</span> ObjectItem <span class="token operator">=</span> <span class="token function">IndexToObject</span><span class="token punctuation">(</span>Index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 根据 Index 获取 ObjectArray 中的 Item，进行一些初始化工作</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token function">UnlockInternalArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 最后挨个通知订阅了 ObjectCreated 事件的 Listener</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="HashObject">HashObject()</h4>
<p>这个函数是利用 FName 的唯一性，求出 FName 的哈希值 Hash 后，建立 Hash 到 Object 的映射，从而实现根据名字访问对象。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">HashObject</span><span class="token punctuation">(</span>UObjectBase<span class="token operator">*</span> Object<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  FName Name <span class="token operator">=</span> Object<span class="token operator">-&gt;</span><span class="token function">GetFName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Name <span class="token operator">!=</span> NAME_None<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    int32 Hash <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>

    FUObjectHashTables<span class="token operator">&amp;</span> ThreadHash <span class="token operator">=</span> <span class="token class-name">FUObjectHashTables</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    FHashTableLock <span class="token function">HashLock</span><span class="token punctuation">(</span>ThreadHash<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token comment">// 因为一个 FName 唯一确定一个 Object</span>
    <span class="token comment">// 所以可以直接用 FName 进行 Hash</span>
    Hash <span class="token operator">=</span> <span class="token function">GetObjectHash</span><span class="token punctuation">(</span>Name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    ThreadHash<span class="token punctuation">.</span><span class="token function">AddToHash</span><span class="token punctuation">(</span>Hash<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>PTRINT Outer <span class="token operator">=</span> <span class="token punctuation">(</span>PTRINT<span class="token punctuation">)</span>Object<span class="token operator">-&gt;</span><span class="token function">GetOuter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
      <span class="token comment">// 这次 Hash 会加入 Outer 的信息</span>
      Hash <span class="token operator">=</span> <span class="token function">GetObjectOuterHash</span><span class="token punctuation">(</span>Name<span class="token punctuation">,</span> Outer<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      ThreadHash<span class="token punctuation">.</span>HashOuter<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Hash<span class="token punctuation">,</span> Object<span class="token operator">-&gt;</span><span class="token function">GetUniqueID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token comment">// ObjectOuterMap(Outer).Add(Object)</span>
      <span class="token function">AddToOuterMap</span><span class="token punctuation">(</span>ThreadHash<span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// ClassToObjectListMap(Object.Class).Add(Object)</span>
    <span class="token function">AddToClassMap</span><span class="token punctuation">(</span> ThreadHash<span class="token punctuation">,</span> Object <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="FreeUObjectIndex">FreeUObjectIndex()</h4>
<p>该函数和 <code>AllocateUObjectIndex()</code> 对应，但是只在析构函数中调用，作用是回收 <code>GUObjectArray</code> 中的 item。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>UObjectArray.cpp</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token class-name">FUObjectArray</span><span class="token double-colon punctuation">::</span><span class="token function">FreeUObjectIndex</span><span class="token punctuation">(</span>UObjectBase<span class="token operator">*</span> Object<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token comment">// This should only be happening on the game thread (GC runs only on game thread when it's freeing objects)</span>
  <span class="token function">check</span><span class="token punctuation">(</span><span class="token function">IsInGameThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token function">IsInGarbageCollectorThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// No need to call LockInternalArray(); here as it should already be locked by GC</span>
  int32 Index <span class="token operator">=</span> Object<span class="token operator">-&gt;</span>InternalIndex<span class="token punctuation">;</span>
  FUObjectItem<span class="token operator">*</span> ObjectItem <span class="token operator">=</span> <span class="token function">IndexToObject</span><span class="token punctuation">(</span>Index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// 将 ObjectItem 重置回默认值</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>Index <span class="token operator">&gt;</span> ObjLastNonGCIndex <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>GExitPurge <span class="token operator">&amp;&amp;</span> bShouldRecycleObjectIndices<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    ObjAvailableList<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Index<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="UObject-的创建">UObject 的创建</h3>
<p>因为 UObject 将其所有构造函数都设为了 private，所以我们只能通过以下两种方式构造一个 UObject：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><code>NewObject&lt;ObjectClass&gt;()</code></p>
</li>
<li class="lvl-2">
<p><code>CreateDefaultSubobject&lt;ObjectClass&gt;()</code></p>
</li>
</ul>
<p>实际上内部都是将参数统一打包成一个 <code>FStaticConstructObjectParameters</code> 结构体，传入并调用 <code>StaticConstructObject_Internal()</code> 函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UObject<span class="token operator">*</span> <span class="token function">StaticConstructObject_Internal</span><span class="token punctuation">(</span><span class="token keyword">const</span> FStaticConstructObjectParameters<span class="token operator">&amp;</span> Params<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  UObject<span class="token operator">*</span> Result <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token comment">// Subobjects are always created in the constructor,</span>
  <span class="token comment">//   no need to re-create them unless their archetype != CDO</span>
  <span class="token comment">//   or they're blueprint generated.</span>
  <span class="token comment">// If the existing subobject is to be re-used</span>
  <span class="token comment">//   it can't have BeginDestroy called on it</span>
  <span class="token comment">//   so we need to pass this information to StaticAllocateObject.	</span>
  <span class="token keyword">const</span> <span class="token keyword">bool</span> bIsNativeClass <span class="token operator">=</span> InClass<span class="token operator">-&gt;</span><span class="token function">HasAnyClassFlags</span><span class="token punctuation">(</span>CLASS_Native <span class="token operator">|</span> CLASS_Intrinsic<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">bool</span> bIsNativeFromCDO <span class="token operator">=</span> bIsNativeClass <span class="token operator">&amp;&amp;</span>
      <span class="token punctuation">(</span>
      <span class="token operator">!</span>InTemplate <span class="token operator">||</span>
      <span class="token punctuation">(</span>InName <span class="token operator">!=</span> NAME_None <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>Params<span class="token punctuation">.</span>bAssumeTemplateIsArchetype <span class="token operator">||</span> InTemplate <span class="token operator">==</span> <span class="token class-name">UObject</span><span class="token double-colon punctuation">::</span><span class="token function">GetArchetypeFromRequiredInfo</span><span class="token punctuation">(</span>InClass<span class="token punctuation">,</span> InOuter<span class="token punctuation">,</span> InName<span class="token punctuation">,</span> InFlags<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token keyword">bool</span> bCanRecycleSubobjects <span class="token operator">=</span> bIsNativeFromCDO <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>InFlags <span class="token operator">&amp;</span> RF_DefaultSubObject<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token class-name">FUObjectThreadContext</span><span class="token double-colon punctuation">::</span><span class="token function">Get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>IsInConstructor<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">bool</span> bRecycledSubobject <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>	
  Result <span class="token operator">=</span> <span class="token function">StaticAllocateObject</span><span class="token punctuation">(</span>InClass<span class="token punctuation">,</span> InOuter<span class="token punctuation">,</span> InName<span class="token punctuation">,</span> InFlags<span class="token punctuation">,</span> Params<span class="token punctuation">.</span>InternalSetFlags<span class="token punctuation">,</span> bCanRecycleSubobjects<span class="token punctuation">,</span> <span class="token operator">&amp;</span>bRecycledSubobject<span class="token punctuation">,</span> Params<span class="token punctuation">.</span>ExternalPackage<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// Don't call the constructor on recycled subobjects, they haven't been destroyed.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bRecycledSubobject<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">(</span><span class="token operator">*</span>InClass<span class="token operator">-&gt;</span>ClassConstructor<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">FObjectInitializer</span><span class="token punctuation">(</span>Result<span class="token punctuation">,</span> Params<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> Result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这里的逻辑相对来说比较复杂。首先看最开始的三个 <code>const bool</code>。</p>
<p>首先看第一个 <code>bIsNativeClass</code>，其内容比较好理解，就是判断当前的类是不是 <code>CLASS_Native</code>/<code>CLASS_Intrinsic</code> 二者之一。前者代表这个类是在 C++ 而不是蓝图中定义的，而后者则表示该类是由 C++ 直接声明，未经过 UHT 生成反射代码，一般是引擎内部的类才会用到。</p>
<p>第二个 <code>bIsNativeFromCDO</code> 指的是是否根据**类默认对象(Class Default Object, CDO)**创建。</p>
<p>第三个 <code>bCanRecycleSubobjects</code> 指的是是否可以重复利用<strong>子对象(Subobject)</strong>。其中 <code>RF_DefaultSubObject</code> 标签只会在 CreateDefaultSubobject 时被赋予。也就是说如果一个对象不是通过 CDO 创建，且不是一个创建中的 Subobject，那么就可以对原来的 Subobject 进行重复利用。</p>
<p>至于为什么有「重复利用」一说，还得接着看后续的 <code>StaticAllocateObject()</code> 函数做了什么。</p>
<h4 id="StaticAllocateObject">StaticAllocateObject()</h4>
<p>这个函数实际做的工作是创建一个 Object 实例或者替换一个已经存在的 Class/Outer/Name 都一样的 Object。执行替换操作时，原 Object 将会被销毁，新 Object 将会占用其内存空间。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">UObject<span class="token operator">*</span> <span class="token function">StaticAllocateObject</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  UObject<span class="token operator">*</span> Obj <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>InName <span class="token operator">==</span> NAME_None<span class="token punctuation">)</span>
  <span class="token punctuation">{</span> <span class="token comment">// 如果创建时没有设置 Name，则生成一个独一无二的 Name</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    InName <span class="token operator">=</span> <span class="token function">MakeUniqueObjectName</span><span class="token punctuation">(</span>InOuter<span class="token punctuation">,</span> InClass<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 查找是否存在 Outer Name 一样的 Object</span>
    Obj <span class="token operator">=</span> <span class="token function">StaticFindObjectFastInternal</span><span class="token punctuation">(</span> <span class="token comment">/*Class=*/</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> InOuter<span class="token punctuation">,</span> InName<span class="token punctuation">,</span> <span class="token boolean">true</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 类型必须一致，否则 fatal</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Obj <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>Obj<span class="token operator">-&gt;</span><span class="token function">GetClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token function">IsChildOf</span><span class="token punctuation">(</span>InClass<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span> Obj <span class="token operator">==</span> <span class="token keyword">nullptr</span> <span class="token punctuation">)</span>
  <span class="token punctuation">{</span>	<span class="token comment">// 如果不存在上述 Object，就调用 AllocateUObject() 进行内存分配</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    Obj <span class="token operator">=</span> <span class="token punctuation">(</span>UObject <span class="token operator">*</span><span class="token punctuation">)</span>GUObjectAllocator<span class="token punctuation">.</span><span class="token function">AllocateUObject</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span>
  <span class="token punctuation">{</span> <span class="token comment">// 否则，直接替换	</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bCreatingCDO <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token operator">!</span>bCanRecycleSubobjects <span class="token operator">||</span> <span class="token operator">!</span>Obj<span class="token operator">-&gt;</span><span class="token function">IsDefaultSubobject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">// 如果不是 CDO ，或者是蓝图类，那就要进行 Destory</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Obj<span class="token operator">-&gt;</span><span class="token function">HasAnyFlags</span><span class="token punctuation">(</span>RF_FinishDestroyed<span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token punctuation">{</span>
        <span class="token comment">// 如果没完成 Destroy，则销毁原来的 Object</span>
        Obj<span class="token operator">-&gt;</span><span class="token function">ConditionalBeginDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
        Obj<span class="token operator">-&gt;</span><span class="token function">ConditionalFinishDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
      Obj<span class="token operator">-&gt;</span><span class="token operator">~</span><span class="token function">UObject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">else</span>
    <span class="token punctuation">{</span>
      bSubObject <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bSubObject<span class="token punctuation">)</span>
  <span class="token punctuation">{</span> <span class="token comment">// 在此之前已经在这块内存上调用过析构函数，故需要重新格式化一下</span>
    <span class="token comment">// 并用 placement new 构造一个 Object</span>
    <span class="token class-name">FMemory</span><span class="token double-colon punctuation">::</span><span class="token function">Memzero</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>Obj<span class="token punctuation">,</span> TotalSize<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>Obj<span class="token punctuation">)</span> <span class="token function">UObjectBase</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">else</span>
  <span class="token punctuation">{</span> <span class="token comment">// 反之，只需要修改原 Object 的一些变量即可，也就是进行了重用</span>
    Obj<span class="token operator">-&gt;</span><span class="token function">SetFlags</span><span class="token punctuation">(</span>InFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Obj<span class="token operator">-&gt;</span><span class="token function">SetInternalFlags</span><span class="token punctuation">(</span>InternalSetFlags<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
  <span class="token keyword">return</span> Obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 placement new 的过程中，就会执行 <code>UObject</code> 的构造函数，进而执行一些和 <code>GUObjectArray</code> 的交互行为。随着 <code>return Obj;</code> 的执行，至此，一个新的 UObject 就被创建好了。</p>
<h3 id="UObject-的销毁">UObject 的销毁</h3>
<h4 id="自动销毁">自动销毁</h4>
<p>可以将指向 UObject 的指针置空，这样后续就会被 UE 自动回收掉</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>自动销毁</span></div><code class="language-cpp">Obj <span class="token operator">=</span> <span class="token generic-function"><span class="token function">NewObject</span><span class="token generic class-name"><span class="token operator">&lt;</span>UObject<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"Obj"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Obj <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h4 id="主动销毁">主动销毁</h4>
<p>UObject::ConditionalBeginDestroy()</p>
<p>异步执行且对象在当前帧内持续有效等待下次GC
Obj-&gt;ConditionalBeginDestroy();
Obj = nullptr;
MarkPendingKill()</p>
<p>标记为PendingKill，等待回收。指向此实例的指针将设置为NULL，并在下一次GC时删除。
IsPendingKill 判断是否处于 PendingKill 状态
ClearPendingKill 清除 PendingKill 状态
Obj-&gt;MarkPendingKill();
Obj = nullptr;
Engine\Config \BaseEngine.ini 更改下面参数，设置销毁时间间隔</p>
<p>gc.TimeBetweenPurgingPendingKillObjects=60
强制垃圾回收
UWorld::ForceGarbageCollection 弃用</p>
<p>GEngine-&gt;ForceGarbageCollection</p>
<p>GEngine-&gt;ForceGarbageCollection(true);</p>
<h2 id="UClass">UClass</h2>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Unreal Engine の 垃圾回收</title>
    <url>/unreal/uegarbagecollection/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>Unreal Engine の 字符串处理</title>
    <url>/unreal/uetext/</url>
    <content><![CDATA[<p>在 UE 中主要有三种字符串实现，分别是 <code>FName</code>，<code>FText</code>，<code>FString</code>。参考官方文档，对这三种实现进行深入剖析。</p>
<span id="more"></span>
<h2 id="TCHAR">TCHAR</h2>
<p>C++ 支持两种字符集，ANSI 和 Unicode，实际对应的字符类型分别是 <code>char</code> 和 <code>wchar_t</code>。为了在不同平台环境下，使用不同的字符类型，UE 使用 <code>TCHAR</code> 对 <code>char</code> 和 <code>wchar_t</code> 进行封装，将其中的操作进行了统一，使程序具有可移植性。</p>
<blockquote>
<p>Either ANSICHAR or WIDECHAR, depending on whether the platform supports wide characters or the requirements of the licensee.</p>
</blockquote>
<p>对于一个字符串字面量 <code>"hello"</code> 而言，默认使用的是 <code>char</code> 类型。如果前面多加个 L，成为 <code>L"hello"</code>，就表示 <code>wchar_t</code>。UE 通过一个 <code>TEXT()</code> 宏包裹来选择适合当前平台的编码方式。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>TEXT() 宏定义</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">UTF8TEXT_PASTE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  u8 </span><span class="token punctuation">##</span> <span class="token expression">x</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">UTF16TEXT_PASTE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> u </span><span class="token punctuation">##</span> <span class="token expression">x</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">PLATFORM_WIDECHAR_IS_CHAR16</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">WIDETEXT_PASTE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token function">UTF16TEXT_PASTE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">WIDETEXT_PASTE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span>  L </span><span class="token punctuation">##</span> <span class="token expression">x</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression"><span class="token operator">!</span><span class="token function">defined</span><span class="token punctuation">(</span>TEXT<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>UE_BUILD_DOCS</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">if</span> <span class="token expression">PLATFORM_TCHAR_IS_UTF8CHAR</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TEXT_PASTE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">UTF8TEXT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">else</span></span>
    <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TEXT_PASTE</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">WIDETEXT</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>
  <span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">TEXT</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token function">TEXT_PASTE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">endif</span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">UTF8TEXT</span><span class="token expression"><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">(</span>UE<span class="token double-colon punctuation">::</span>Core<span class="token double-colon punctuation">::</span><span class="token class-name">Private</span><span class="token double-colon punctuation">::</span><span class="token function">ToUTF8Literal</span><span class="token punctuation">(</span><span class="token function">UTF8TEXT_PASTE</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">WIDETEXT</span><span class="token expression"><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token function">WIDETEXT_PASTE</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不难发现，会根据 <code>PLATFORM_TCHAR_IS_UTF8CHAR</code> 这个宏来选择相应的编码方式。而 UE 中的所有字符串都作为 FString 或 TCHAR 数组以 UTF-16 格式存储在内存中，所以内部设置字符串变量文字时应使用 <code>TEXT()</code> 宏。</p>
<h3 id="编码转换">编码转换</h3>
<p>UE 提供了一些宏，可以将字符串转换为各种编码或从各种编码转换字符串。这些宏使用局部范围内声明的类实例，并在堆栈上分配空间，因此<strong>保留</strong>指向这些宏的指针非常重要。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// TCHAR* -&gt; char*</span>
<span class="token function">TCHAR_TO_ANSI</span><span class="token punctuation">(</span>TcharString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// TCHAR* -&gt; wchar_t*</span>
<span class="token function">TCHAR_TO_UTF8</span><span class="token punctuation">(</span>TcharString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// char* -&gt; TCHAR*</span>
<span class="token function">ANSI_TO_TCHAR</span><span class="token punctuation">(</span>CharString<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// wchar_t* -&gt; TCHAR*</span>
<span class="token function">UTF8_TO_TCHAR</span><span class="token punctuation">(</span>WChartString<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="FName">FName</h2>
<p>FName 在语义上指的是资源的<strong>名字</strong>。其具有<strong>大小写不敏感</strong>，<strong>不可变</strong>，<strong>唯一</strong>这三个特性。</p>
<h3 id="底层实现">底层实现</h3>
<p>FName 本质上是一个<strong>索引</strong>，内部只有三个整型变量，而不存储任何字符串内容。</p>
<p>其唯一性是通过「基于哈希表的存储系统」实现的。在用字符串进行 FName 的构造时，首先会将字符串做一次哈希，映射到哈希表中，并得到在哈希表中的索引号，这样保证不会有重复的字符串出现在表中的同时，又能通过索引号进行快速查询。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>class FName in NameTypes.h</span></div><code class="language-cpp"><span class="token comment">/**
 * Index into the Names array (used to find String portion
 * of the string/number pair used for comparison)
 */</span>
FNameEntryId	ComparisonIndex<span class="token punctuation">;</span>
<span class="token comment">/**
 * Number portion of the string/number pair (stored internally
 * as 1 more than actual, so zero'd memory will be the default, no-instance case)
 */</span>
uint32			Number<span class="token punctuation">;</span>
<span class="token comment">/**
 * Index into the Names array (used to find String portion
 * of the string/number pair used for display)
 */</span>
FNameEntryId	DisplayIndex<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>ComparisonIndex</code> 和 <code>DisplayIndex</code> 表示 string portion 在表中的索引，里面只有一个 uint32 的索引值，而 <code>number</code> 是 number portion。所以整体内存占 12B。</p>
<blockquote>
<p>形如 <code>XYZ_123</code> 这样的字符串会被分为 <code>XYZ</code> 和 <code>123</code> 两部分。前者为 string portion，后者为 number portion。</p>
<p>之所以这么搞是因为当在关卡中拷贝一个名为 <code>Name</code> 的 Actor 时，新生成的那份会在名字后面加一个后缀，成为 <code>Name_1</code>。后续的拷贝就是 <code>_2</code>，<code>_3</code>，……如果把每个 Actor 的名字都加入表中，那内存开销就是 O(n)。而如果划分为 string/number 两个部分，就只需要存一份字符串即可，同时又会把 number 部分以 uint32 的形式存储起来，可以用于 compare，大大节省了内存开销。</p>
</blockquote>
<p><code>ComparisonIndex</code> 和 <code>DisplayIndex</code> 的区别在于，索引到的 string portion 是否区分大小写。比如 <code>ABC</code> 和 <code>abc</code> 两个 FName，当进行比较时，会用 ComparisonIndex 去 IgnoreCase 的那张表查询，得到的结果一致，认为是两个相同的 FName；而用于显示时，则用 DisplayIndex 去 CaseSensitive 的表查询，这张表存的就是原始字符串了。</p>
<h3 id="为何快">为何快</h3>
<p>两个 FName 之间的比较并不执行字符串的对比，而是进行<strong>数值</strong>的对比，这可极大地节约 CPU 开销。该数值是通过一个内部函数 <code>ToUnstableInt()</code> 进行计算的，这个函数会将 <code>ComparisonIndex</code> 和 <code>Number</code> 组装成一个 uint64 的值，然后返回。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>NameTypes.h</span></div><code class="language-cpp">FORCEINLINE uint64 <span class="token function">ToUnstableInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>
<span class="token punctuation">{</span>
  <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token function">STRUCT_OFFSET</span><span class="token punctuation">(</span>FName<span class="token punctuation">,</span> ComparisonIndex<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token function">STRUCT_OFFSET</span><span class="token punctuation">(</span>FName<span class="token punctuation">,</span> Number<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">static_assert</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token function">STRUCT_OFFSET</span><span class="token punctuation">(</span>FName<span class="token punctuation">,</span> Number<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>Number<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  uint64 Out <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token class-name">FMemory</span><span class="token double-colon punctuation">::</span><span class="token function">Memcpy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Out<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span>uint64<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> Out<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了优化字符串，在游戏开发过程中，如果可以确定哪些字符串是固定不变的数据且无需考虑文本本地化，应该尽可能对它们使用 FName，只在必要的时候才将 FName 转换为其他字符串类型进行操作。</p>
<h3 id="查找与添加">查找与添加</h3>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 若不在表中，则构造函数结果为 NAME_None/FName()，但不进行添加。</span>
FName res1 <span class="token operator">=</span> <span class="token function">FName</span><span class="token punctuation">(</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FNAME_Find<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 若不在表中，则添加；反之做和 Find 一样的行为。</span>
FName res2 <span class="token operator">=</span> <span class="token function">FName</span><span class="token punctuation">(</span><span class="token function">TEXT</span><span class="token punctuation">(</span><span class="token string">"bar"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> FNAME_Add<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="FText">FText</h2>
<p>FText 是一种静态字符串。当字符串需要显示给玩家时，使用 FText 以支持文本本地化和增强字体渲染性能。</p>
<h3 id="底层实现-2">底层实现</h3>
<p>FText 对象内部用一个带<strong>引用计数</strong>的智能指针 <code>TRefCountPtr&lt;ITextData&gt;</code> 来指向实际存储的数据，这样就使得拷贝一个 FText 的成本很低。</p>
<h2 id="FString">FString</h2>
<p>FString 则是是对 string 进行的一个封装，和 <code>std::string</code> 非常相似，但底层字符串是用 <code>TArray&lt;TCHAR&gt;</code> 进行存储的。其着重于字符串的操作，提供了大量对字符串的操作接口，是三者中唯一<strong>可修改</strong>的字符串类型，但其它两种字符串来说消耗更高，性能更低。</p>
<h2 id="三者之间的转换">三者之间的转换</h2>
<table>
<thead>
<tr>
<th style="text-align:center">从</th>
<th style="text-align:center">到</th>
<th style="text-align:center">函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">FName</td>
<td style="text-align:center">FText</td>
<td style="text-align:center"><code>FText::FromName(name)</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FName</td>
<td style="text-align:center">FString</td>
<td style="text-align:center"><code>name.ToString()</code></td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">FText</td>
<td style="text-align:center">FName</td>
<td style="text-align:center"></td>
<td style="text-align:center">FText 不能直接转换到 FName，可先转换为 FString，再转换为 FName</td>
</tr>
<tr>
<td style="text-align:center">FText</td>
<td style="text-align:center">FString</td>
<td style="text-align:center"><code>txt.ToString()</code></td>
<td style="text-align:center">对于某些语言来说可能存在损耗。</td>
</tr>
<tr>
<td style="text-align:center">FString</td>
<td style="text-align:center">FName</td>
<td style="text-align:center"><code>FName(*str)</code></td>
<td style="text-align:center"><strong>不可靠</strong>。因为 FName 不区分大小写，所以转换存在损耗。</td>
</tr>
<tr>
<td style="text-align:center">FString</td>
<td style="text-align:center">FText</td>
<td style="text-align:center"><code>FText::FromString(str)</code></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>Unreal</category>
      </categories>
  </entry>
  <entry>
    <title>点击 Url 到显示网页之间发生了什么？</title>
    <url>/computer-network/whathappenedafterclickurl/</url>
    <content><![CDATA[<p>经典网络问题，贯穿整个计算机网络学习始终，每个阶段拿出来回味都有不同的感受与收获。</p>
<span id="more"></span>
<blockquote>
<p>参考资料：《网络是怎样运行的》 by 户根勤</p>
</blockquote>
<h2 id="通过-DHCP-拿-IP-地址">通过 DHCP 拿 IP 地址</h2>
<p>假设这台主机刚刚插上网线准备接入互联网，那么此时此刻我们能够知道的仅有<strong>本机（或称之为客户端）的 MAC 地址</strong>这一信息，毕竟出厂就烧在 ROM 里。如果希望其能在网络中与其他节点进行通信，就需要知道<strong>客户端的 IP 地址</strong>。由于刚开始完全不知道任何信息，那么最先要做的事，就是去获得最近的 DHCP 服务器（下面简称 DS） 的 IP 地址，只有这样才能有足够的信息去构建请求消息，让其分配一个。</p>
<p>那么怎么获得呢？最直接的做法就是广播一条只有 DS 收到后会回复的消息，这样我们拿到这条回复后就知道 DS 的信息了。这条广播消息长这样：</p>
<table>
<thead>
<tr>
<th style="text-align:left">链路层(MAC)</th>
<th style="text-align:left">网络层(IP)</th>
<th style="text-align:left">传输层(PORT/TYPE)</th>
<th style="text-align:left">描述(DESCRIPTION)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>From</strong>: 客户端 MAC 地址<br><strong>To</strong>: FF-FF-FF-FF-FF-FF</td>
<td style="text-align:left"><strong>From</strong>: 0.0.0.0<br><strong>To</strong>: 255.255.255.255</td>
<td style="text-align:left"><strong>UDP</strong><br><strong>From</strong>: 68<br><strong>To</strong>: 67</td>
<td style="text-align:left"><strong>DHCP DISCOVER</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>这条消息或许会经过交换机，那么交换机此时会记录下 &lt;客户端 MAC 地址, 连接该主机的端口&gt; 这一条目以构建转发表，这样从 DS 发来的回复就快速定位到特定端口而无需广播。</p>
</blockquote>
<p>因为该消息的 MAC 地址为广播地址，就从所有端口出发进行广播。DS 收到该消息后，发现是个 <strong>DISCOVER</strong> 类型的消息，就知道有个小兔崽子在找我，我得赶紧告诉他，然后构建一条 <strong>OFFER</strong> 消息交给网卡去发送，包含自己的 IP 地址与 MAC 地址等信息。</p>
<p>客户端收到 OFFER 后，就开始正式发起请求了，就是发一条 <strong>REQUEST</strong> 消息过去，只不过这次的消息中 MAC 头部与 IP 头部的 <code>To</code> 字段都明确了。</p>
<blockquote>
<p>当然，可能有多个 DS 收到该广播消息，它们都会回复 <strong>OFFER</strong>，那么就由客户端来选择向哪个 DS 请求 IP 地址。如果跳过这一个来回，直接广播 <strong>REQUEST</strong>，就有可能收到多个为客户端分配的 IP 地址，而我们只有一个能设置，其他的就浪费了。</p>
</blockquote>
<p>DS 收到后会发一个 <strong>ACK</strong> 回来，告知客户端的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，客户端收到后进行配置，并在其 IP 转发表中安装默认网关。此刻我们正式完成了连接互联网的准备工作。</p>
<p>此时此刻，我们已知的信息有：<strong>客户端 MAC 地址</strong>、<strong>客户端 IP 地址</strong>、<strong>默认网关 IP 地址</strong>、<strong>DNS 服务器 IP 地址</strong>。</p>
<h2 id="通过-DNS-获取-Web-服务器的-IP-地址">通过 DNS 获取 Web 服务器的 IP 地址</h2>
<p>在浏览器内输入链接敲回车，或点击链接后，浏览器应当解析该链接生成 HTTP GET 请求，然后调用 Socket 库委托协议栈生成消息发出去。这之间还有一些工作要完成，最先要完成的就是获取 Web 服务器的目的 IP 地址，这一步是通过向 DNS 服务器发起查询完成的，理由和请求分配 IP 地址一样。这条查询会被组装为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">链路层(MAC)</th>
<th style="text-align:left">网络层(IP)</th>
<th style="text-align:left">传输层(PORT/TYPE)</th>
<th style="text-align:left">描述(DESCRIPTION)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>From</strong>: 客户端 MAC 地址<br><strong>To</strong>: <em>网关路由器 MAC 地址</em></td>
<td style="text-align:left"><strong>From</strong>: 客户端 IP 地址<br><strong>To</strong>: 网关路由器</td>
<td style="text-align:left"><strong>UDP</strong><br><strong>From</strong>:<br><strong>To</strong>:</td>
<td style="text-align:left"><strong>DNS Query FOR url ‘xxx.xx.xxx’</strong></td>
</tr>
</tbody>
</table>
<p>然而<em>网关路由器 MAC 地址</em>这一信息我们是不知道的，只知道其 IP 地址。网络中有一项协议为我们提供了<strong>根据 IP 地址查询 MAC 地址</strong>的功能，那就是 <strong>ARP</strong>。客户端生成下面这样一个 ARP 查询消息后，通过交换机广播出去：</p>
<table>
<thead>
<tr>
<th style="text-align:left">链路层(MAC)</th>
<th style="text-align:left">网络层(IP)</th>
<th style="text-align:left">传输层(PORT/TYPE)</th>
<th style="text-align:left">描述(DESCRIPTION)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>From</strong>: 客户端 MAC 地址<br><strong>To</strong>: FF-FF-FF-FF-FF-FF</td>
<td style="text-align:left"><strong>From</strong>: 客户端 IP 地址<br><strong>To</strong>: 网关路由器 IP 地址</td>
<td style="text-align:left"><strong>UDP</strong><br><strong>From</strong>:<br><strong>To</strong>:</td>
<td style="text-align:left"><strong>ARP</strong></td>
</tr>
</tbody>
</table>
<p>网关路由器收到后，就会回复其 MAC 地址，这样客户端就知道了。</p>
<blockquote>
<p>当然如果每次都这样广播一次的话倒也不是很有必要，一般情况下都会有一个 ARP Cache，每次想知道 MAC 地址的时候先去 Cache 里查一查，如果有就不用广播了。</p>
</blockquote>
<p>fine，这下可以正式发送 DNS 服务器查询请求了。</p>
<ol>
<li class="lvl-3">
<p>首先搜索<strong>浏览器的 DNS 缓存</strong>，缓存中维护一张域名与 IP 地址的对应表;</p>
</li>
<li class="lvl-3">
<p>如果没有命中，则继续搜索<strong>操作系统的 DNS 缓存</strong>;</p>
</li>
<li class="lvl-3">
<p>如果依然没有命中，则操作系统将域名发送至<strong>本地 DNS 服务器</strong>，它查询自己的 DNS 缓存，查找成功则返回结果；</p>
</li>
<li class="lvl-3">
<p>如果没有命中‍，则向上级域名服务器进行迭代查询，最终得到该域名对应的 IP 地址，返回给操作系统，操作系统又将 IP 地址返回给浏览器（这三者还会将得到的 IP 地址进行缓存）；</p>
</li>
</ol>
<p>这下所有手续齐全了，可以正式开始数据交互了。</p>
<p>此时此刻，我们新增的已知信息有：<strong>Web 服务器 IP 地址</strong>、<strong>默认网关 MAC 地址</strong>、<strong>DNS 服务器 MAC 地址</strong>。</p>
<h2 id="TCP-三次握手建立连接">TCP 三次握手建立连接</h2>
<p>由于 HTTP 请求常常交给 TCP 协议，而 TCP 又需要保证在数据的传输之前，双方建立起了稳定的连接。首先客户端会创建一个 socket，用于唯一标识连接——毕竟可能存在多个网页同时点击该链接——同时会为客户端分配一个端口 <code>p</code>，该 socket 应当长成这样：</p>
<table>
<thead>
<tr>
<th style="text-align:center">源 IP 地址与端口</th>
<th style="text-align:center">目的 IP 地址与端口</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;客户端 IP 地址, p&gt;</td>
<td style="text-align:center">&lt;Web 服务器 IP 地址, 80&gt;</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Web 服务器固定以 80 作为端口。</p>
</blockquote>
<p>上面这些信息都是已知的，所以可以毫无阻碍的进行创建。然后协议栈生成一个连接请求发送给 Web 服务器：</p>
<table>
<thead>
<tr>
<th style="text-align:left">链路层(MAC)</th>
<th style="text-align:left">网络层(IP)</th>
<th style="text-align:left">传输层(PORT/TYPE)</th>
<th style="text-align:left">描述(DESCRIPTION)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>From</strong>: 客户端 MAC 地址<br><strong>To</strong>: 默认网关 MAC 地址</td>
<td style="text-align:left"><strong>From</strong>: 客户端 IP 地址<br><strong>To</strong>: Web 服务器 IP 地址</td>
<td style="text-align:left"><strong>TCP</strong><br><strong>From</strong>: p<br><strong>To</strong>: 80</td>
<td style="text-align:left"><strong>SYN=1</strong></td>
</tr>
</tbody>
</table>
<blockquote>
<p>网关路由器收到该消息后，根据 ARP 获取到 Web 服务器将链路层头部改为：</p>
<table>
<thead>
<tr>
<th style="text-align:left">链路层(MAC)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><strong>From</strong>: 默认网关 MAC 地址<br><strong>To</strong>: <em>下一个</em> MAC 地址</td>
</tr>
</tbody>
</table>
<p>这里的 <code>下一个</code> 由路由器的转发表决定。如果距离 Web 服务器之间还有若干路由器，那就根据寻路算法填下一个路由器的 MAC 地址，让其进行下一步的转发；如果直达，那就是 Web 服务器的 MAC 地址。所以其实 MAC 地址就是指明发到哪一个 Router/Host/Server。</p>
</blockquote>
<p>Web 服务器收到该连接请求后，会取出传输层头部检查自己是否有这个端口（我们这个情况下是有的，而且会有一个目的 IP 和目的端口均为空的 {&lt;null, null&gt;, &lt;IP, 80&gt;} 这样一个 socket 处于监听状态），一看哦有啊，就创建一个该 socket 的副本，然后填入客户端的 IP 地址和端口，并发送一个 SYN=1, ACK=1 的回复。</p>
<blockquote>
<p>这个副本并不会影响原来的 socket，因为一个 socket 是由四个要素决定的，如果不创建副本直接连接，原来那个 socket 就会被本次连接占用，那就没有 socket 进行监听，后续的所有来自其他 host/server 的连接都得排队或 abort 了。</p>
</blockquote>
<p>客户端收到这条回复后，再发一个 ACK 回去表明收到了服务器发来的回复，如果一段时间内没有收到重复消息，说明这条 ACK 也被服务器收到了，连接正式确立。</p>
<h2 id="进行数据传输">进行数据传输</h2>
<p>此时此刻，客户端与 Web 服务器各有一个 socket 被用于该连接，两边的数据传输也是基于各自的 socket 进行。所有工作做完后，对于客户端而言，就是生成 HTTP GET 请求然后不断加上协议栈各层的头部通过网卡发送出去，其中链路层头部就是客户端 MAC 地址与网关 MAC 地址，网络层与传输层的源地址与目标地址直接根据 socket 确立。经过交换机、路由器的层层转发，消息终于来到了 Web 服务器的 80 端口，然后 Web 服务器验证有效性后将消息进行拆解，发现是一条 GET 请求，遂将本地的 html 文件以二进制的形式进行答复。</p>
<p>客户端收到该答复后，将二进制数据交给浏览器进行渲染，显示出网页。如果还有其他图片、视频等要素，依然也是通过上面的手段进行获取。</p>
]]></content>
      <categories>
        <category>Computer Network</category>
      </categories>
  </entry>
  <entry>
    <title>切换进程/线程前后发生了什么？</title>
    <url>/operating-system/whathappenedafterswitchprocess/</url>
    <content><![CDATA[<p>该问题是<strong>进程与线程的区别</strong>中的一个核心问题。</p>
<span id="more"></span>
<h2 id="进程有什么">进程有什么</h2>
<p>一个进程需要存放若干数据，以及若干指令，那么首先其会有一片内存，在分页机制下，所有进程都必须有其独立的<strong>页表(PT, Page Table)</strong>，从而完成虚拟地址到物理地址（<em>用户地址空间</em>）的转换。</p>
<p>有页表，就肯定需要一个访问机制。目前操作系统一般都采用二级页表，也就是访页时最先进入<strong>页目录(PD, Page Directory)</strong>，再根据里面的页目录项获取页表物理地址。需要一个寄存器来存储该目录的物理地址，即<strong>页目录表寄存器(PDBR, Page Directory Base Register)</strong>（x86_64 下使用 <strong>CR3</strong>）通过向该寄存器赋予页目录基地址（物理），便可随时访问页目录。</p>
<p>以及<strong>页表缓存(TLB, Translation Lookaside Buffer)</strong>，用于加快虚拟地址-&gt;物理地址的转换。</p>
<p>此外，进程在执行程序时，必须要有一个<strong>指令指针寄存器(IP, Instruction Pointer)</strong>，来告诉 CPU 即将执行的指令在代码段中的偏移量，和一个<strong>代码段寄存器(CS, Code Segment)</strong>，用来存放内存代码段区域的入口地址。这两个寄存器合在一起为我们指示了 CPU 当前要读取指令的地址（虚拟），最后根据页表对应到实际的物理地址进行取指令操作。</p>
<blockquote>
<p>物理地址 = CS &lt;&lt; 4 + IP</p>
</blockquote>
<p>程序的运行必然是由若干函数组合起来运行的。当一个函数在运行时，需要为它在栈中创建一个栈帧用来记录运行时产生的相关信息，因此每个函数在执行前都会创建一个栈帧，在它返回时会销毁该栈帧。栈由高地址向低地址拓展，为了访问栈，就必须要有<strong>栈基址(BP, Base Pointer)</strong>，以及<strong>栈顶指针(SP, Stack Pointer)</strong>。</p>
<h2 id="线程有什么">线程有什么</h2>
<p>线程与进程的关系，就好比函数与程序的关系。同一进程下的所有线程都共享同一地址空间，包括全局变量与代码段。但每个线程有各自的<strong>栈</strong>空间与 <strong>CS:IP</strong>，就好比不同函数对应的参数与返回地址都不同，所执行的指令所处位置也不一定相同。</p>
<blockquote>
<p>Linux 中进程与线程都被抽象为 <code>task_struct</code>，各自拥有 <code>pid</code>，但其内存所指 <code>mm_struct</code> 是相同的。</p>
</blockquote>
<h2 id="进程与线程切换开销">进程与线程切换开销</h2>
<p>进程的切换，必然伴随着上文提到的种种寄存器的保存与加载。除了这些，最大的开销来源于：从一个进程切换到另一个进程时，对应的地址空间也将切换，那么 TLB 是需要被清空的，这样就导致 TLB miss 以及访页速率降低，当然，Cache miss 率也会提高。</p>
<p>然而，<strong>同一进程内</strong>的线程切换并不涉及地址空间的切换，仅仅保存其 BP, SP 以及若干寄存器即可。</p>
<blockquote>
<p>如果是不同进程之间的线程切换，那依然会涉及进程切换。</p>
</blockquote>
<p>这也就是为什么，进程切换的开销比线程切换大得多。</p>
]]></content>
      <categories>
        <category>Operating System</category>
      </categories>
  </entry>
  <entry>
    <title>屎寄</title>
    <url>//shi-ji/</url>
    <content><![CDATA[<p>群友答辩操作</p>
<span id="more"></span>
<h2 id="黑名单">黑名单</h2>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">夜归霜</td>
<td style="text-align:center">尼菈 狗 玉足</td>
</tr>
<tr>
<td style="text-align:center">angzia</td>
<td style="text-align:center">船长</td>
</tr>
</tbody>
</table>
<h2 id="捞包">捞包</h2>
<h3 id="潘森之让队友帮忙挡大招">潘森之让队友帮忙挡大招</h3>
<p><video src="ps.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
<h3 id="波比贴贴">波比贴贴</h3>
<p><video src="bbtr.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
<h3 id="牛头贴贴">牛头贴贴</h3>
<p><video src="nttt.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
<h2 id="秉泽">秉泽</h2>
<h3 id="绝望之墙">绝望之墙</h3>
<p><video src="bnbq.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
<h3 id="一鱼二吃">一鱼二吃</h3>
<p><video src="yyec.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
<h2 id="盼盼">盼盼</h2>
<h3 id="大三元">大三元</h3>
<p><video src="dsy.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
<h2 id="dlt">dlt</h2>
<h3 id="杰斯暗爪">杰斯暗爪</h3>
<p><video src="jsaz.webm" position="absolute" width="100%" height="100%" controls="controls"></video></p>
]]></content>
      <categories>
        <category>💩</category>
      </categories>
  </entry>
  <entry>
    <title>树状数组</title>
    <url>/data-structure/shu-zhuang-shu-zu/</url>
    <content><![CDATA[<p><strong>树状数组</strong>，也称作<strong>二叉索引树</strong>(Binary Indexed Tree)或 <strong>Fenwick 树</strong>。 它可以在 $O(\log n)$ 的时间复杂度下实现<strong>单点修改</strong>与<strong>区间查询</strong>两个操作。</p>
<span id="more"></span>
<p>参考自 <a href="https://oi-wiki.org/ds/fenwick/">OI wiki</a>。</p>
<blockquote>
<p>无特殊说明，本文所有数组下标均从 <strong>1</strong> 开始。</p>
</blockquote>
<h2 id="前缀和">前缀和</h2>
<p>初学者最先接触到的支持<strong>区间查询</strong>的数据结构就是前缀和数组了，对于原始数组 <code>nums</code> 而言，对应的前缀和数组 <code>prefixSum</code> 满足：</p>
<p>$$
\text{prefixSum}[i] = \sum\limits_{j=1}^{i}\text{nums}[j]
$$</p>
<h3 id="区间查询">区间查询</h3>
<p>如果想求区间 <code>nums[a:b]</code> 之和，只需简单的进行 <code>prefixSum[b]-prefixSum[a-1]</code> 即可。对于一个已经构建好的 <code>prefixSum</code> 而言，其<strong>区间查询</strong>时间复杂度为 $O(1)$。</p>
<h3 id="单点修改">单点修改</h3>
<p>然而，<code>prefixSum</code> 的<strong>单点修改</strong>却不如人意，如果修改了 <code>nums[i]</code>，需要将 <code>prefixSum</code> 中区间 <code>[i:n]</code> 的所有值均修改一遍，这样子时间复杂度为 $O(n)$。</p>
<blockquote>
<p>现实场景下的操作往往是动态的，特别是某些数据库中需要进行大量的写操作。如果该<strong>写频繁</strong>数据库中维护区间和采用的是前缀和的做法，那么它一定活不过压测😒。</p>
</blockquote>
<h3 id="思考">思考</h3>
<p>根据上文可知，<strong>写</strong>是前缀和的根本劣势，一旦写操作极度频繁，对于海量数据而言，时间开销将会非常大。究其原因，还是在于 <code>prefixSum</code> 中的每个元素都出现了冲突的管辖范围，负载并不均衡，最极端的，第一个元素 <code>nums[1]</code> 几乎被所有的 <code>prefixSum[i]</code> 计算了一遍，而最后一个元素 <code>nums[n]</code> 却仅仅参与了一次计算。</p>
<p>如果能将这一冗余计算进行减负，说不定能提高一点性能？</p>
<h2 id="树状数组">树状数组</h2>
<p>树状数组的本质思想在于<strong>分治</strong>，即将原始数组不断划分为等长的区间 <code>nums[1 : n/2]</code> 与 <code>nums[n/2+1 : n]</code>，分别由 <code>biTree[n/2]</code> 与 <code>biTree[n]</code> 去管辖这两个区间。这样一来，每个子区间中进行的<strong>写</strong>并不会给其他区间增加负载，而求前缀和只需将多个区间和相加即可。</p>
<p>「既然最后整个区间和就是 <code>biTree[n/2] + biTree[n]</code>，那不如让 <code>biTree[n]</code> 干脆管整个区间好了！」</p>
<p>于是，整个区间的管辖级别就浮现出来了，以 <code>n=8</code> 为例：</p>
<img src="1.png" style="zoom:80%;">
<p>由于这种管辖级别像树一样，所以就叫树状数组了，而每个树状数组中的元素对应着的就是其管辖区间内原数组的所有元素之和。</p>
<h3 id="区间查询-2">区间查询</h3>
<p>先来看看树状数组的<strong>读</strong>性能如何。对于原始数组 <code>nums</code>，为了求 <code>sum(i)</code>（即 <code>nums[1:i]</code> 之和），则要考虑怎么取树状数组中的区间。</p>
<p>以 <code>sum(6)</code> 为例，根据上图，我们很容易能得到最后的结果是 <code>biTree[6] + biTree[4]</code>；同样的，<code>sum(7)</code> 对应 <code>biTree[7] + biTree[6] + biTree[4]</code>；……</p>
<p>如果仅考虑上图，不难发现 <code>sum(i)</code> 其实就是以 <code>biTree[i]</code> 为起点，一直往左上方遍历求和即可（<code>biTree[6]</code> 的左上方只有 <code>biTree[4]</code>）。那么问题就转化为：如何遍历到下一个，也就是左上方的树状数组元素？</p>
<p>这里就有一个 trick：只需要将 <code>i</code> 对应二进制最后一个 <code>1</code> 移除，就能得到下一个要遍历的元素下标，直到 <code>i</code> 返回到 0；</p>
<h4 id="lowbit-x">lowbit(x)</h4>
<p><code>lowbit(x)</code> 是一种用于快速找出数 <code>x</code> 对应二进制最后一个 <code>1</code> 的位置的方法，其表达式为：</p>
<p>$$
\text{lowbit}(x) = x\ &amp;\ (-x)
$$</p>
<p>以 <code>10</code> 为例，其二进制为 <code>01010</code>，而 <code>-10</code> 的二进制为 <code>10110</code>，两者进行<strong>按位与</strong>运算后所得结果为 <code>00010</code>，也就是 <code>10</code> 的最后一个 <code>1</code>。</p>
<blockquote>
<p>毕竟补码是取反码然后 +1，对于 <code>...100...000</code> 而言，其反码为 <code>...011...111</code>，再加一得到 <code>...100...000</code>，而高位全部取反，那么进行按位与后只有最后一个 <code>1</code> 会剩下。</p>
</blockquote>
<h4 id="结论">结论</h4>
<p>根据上面的理论，只要不断把最后一个 <code>1</code> 去掉就行，那么可以得到这样一个实现区间查询的函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>区间查询</span></div><code class="language-cpp"><span class="token comment">// rangeQuery returns the sum of nums[1:n]</span>
<span class="token keyword">int</span> <span class="token function">rangeQuery</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    res <span class="token operator">+=</span> biTree<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
    n <span class="token operator">-=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度为 <code>n</code> 对应二进制中 <code>1</code> 的个数，最坏情况下为 $O(\log n)$</p>
<h3 id="单点修改-2">单点修改</h3>
<p>如果对某个 <code>nums[i]</code> 进行了修改，则需要将所有管辖该元素的 <code>biTree[j]</code>——即<strong>数组树</strong>中的父节点——也进行修改，这样才能保证一致性。</p>
<p>从子节点定位到直接父节点的方法与上面的恰好相反，证明略。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>单点修改</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">,</span> <span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>n <span class="token operator">&lt;</span> biTree<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    biTree<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">+=</span> delta<span class="token punctuation">;</span>
    n <span class="token operator">+=</span> <span class="token function">lowbit</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>时间复杂度为 $O(\log n)$。</p>
<p>这个函数也可以用于树状数组的初始化，只需要保证 <code>biTree</code> 最开始所有元素均为 0 即可：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>初始化</span></div><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>vector<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">update</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="应用">应用</h2>
<ol>
<li class="lvl-3">
<p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">&gt;&gt;&gt; LeetCode 315 计算右侧小于当前元素的个数(Hard) &lt;&lt;&lt;</a></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Data Structure</category>
      </categories>
  </entry>
</search>
