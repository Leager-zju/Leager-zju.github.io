<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CRAQ</title>
    <url>/6-824/CRAQ/</url>
    <content><![CDATA[<p>6.824 的第五篇论文是 <strong>CRAQ</strong>——一种以读取为主的工作负载的高吞吐量链式复制。它对原先的 Chain Replication 进行了一定的改进，在保持强一致性的同时大大提高了读取吞吐量。通过在所有对象副本之间分配负载，CRAQ 随链大小线性扩展，而不会增加一致性协调。</p>
<span id="more"></span>
<h4 id="chain-replication">Chain Replication</h4>
<p>在传统的 CR 策略中，所有服务器按照链排列，第一个服务器称为 <strong>HEAD</strong>，最后一个服务器称为 <strong>TAIL</strong>。HEAD 处理所有写请求，TAIL 处理所有读请求。写请求沿链传播，TAIL 收到后会返回 ack。</p>
<p><img src="image-20221009141338449.png" alt="image-20221009141338449" style="zoom:67%;" /></p>
<p>CR 本身是线性一致的，在没有故障时，从一致性的角度来说，整个系统就像只有 TAIL 一台服务器一样，TAIL 可以看到所有的写请求，也可以看到所有的读请求，它一次只处理一个请求，读请求可以看到最新写入的数据。</p>
<h5 id="与-raft-相比">与 Raft 相比</h5>
<ul>
<li>Raft 的 Leader 在处理写请求时，会将该请求广播给其他所有 raft node，而 CR 的 HEAD 只会将请求发送给链中的下一个服务器。同等条件下，CR 的网络负担更小，单位时间内也能处理更多请求。</li>
<li>对于读请求，Raft 中也是只有 Leader 一人承担，而 CR 中则由 TAIL 处理，相当于 CR 的 HEAD 和 TAIL 各自分担了读写负载。</li>
<li>CR 的<strong>故障恢复</strong>相对而言更简单：
<ol type="1">
<li>如果 HEAD 崩溃了，则由下一个服务器成为 HEAD。没发出去的请求就不管了，发出去的请求照样沿链传播。</li>
<li>如果 TAIL 崩溃了，其前一个服务器成为 TAIL。这是很自然的，因为前一个服务器知道的信息必然不少于挂掉的 TAIL。</li>
<li>如果中间的服务器崩溃了，则需要将其移除，就像在链表中移除一样，并且可能需要有消息的重发。</li>
</ol></li>
</ul>
<h5 id="缺陷">缺陷</h5>
<ol type="1">
<li>所有的读请求都会被发到 TAIL，从而导致潜在的 <strong>hotspot</strong> 以及负载不平衡，且并不能通过增加节点数量来提高读吞吐量。</li>
<li>存在脑裂(<strong>split-brain</strong> 问题。</li>
</ol>
<p>第二个问题很好解决，可以通过设置一个 <strong>Configuration Manager</strong> 来安排 chain 的配置。该配置中描述了链的定义，包括所有节点，HEAD 和 TAIL。Configuration Manager 监测节点活性，一旦有节点挂了，则会重新生成并发送新的配置。它不能否认自己，从而解决脑裂问题。</p>
<h4 id="chain-replication-with-apportioned-queries">Chain Replication with Apportioned Queries</h4>
<h5 id="一致性模型">一致性模型</h5>
<ul>
<li><strong>强一致性</strong>：对对象的所有读写操作都以某种顺序执行，且对对象的读取总是看到最新的写入值。</li>
<li><strong>最终一致性</strong>：虽然对不同节点的读取可能会在一段时间内返回旧数据，但一旦所有副本都收到写请求，则读操作永远不会返回比最新提交的写入更旧的版本。</li>
<li><strong>具有最大有界不一致性</strong>：允许读操作在提交之前返回新写入的对象，但仅限于某个点。</li>
</ul>
<h5 id="改进">改进</h5>
<p>CRAQ 对传统 CR 的改进之处在以下几点：</p>
<ol type="1">
<li>节点存放对象的多个版本，每个版本都包含一个单调增的版本号和该版本是否 dirty 的附加属性；</li>
<li>当节点收到对象新版本的写入时，节点会将这个版本附加到其对象列表中，并且：
<ul>
<li>若该节点不是 TAIL，将此版本标记为 <code>dirty = true</code>；</li>
<li>反之，将此版本标记为 <code>dirty = false</code>，此时将对象的版本称为 <strong>committed</strong>，然后向前发送 ack 通知其它节点。与此同时，该节点也可以在本地处理读取操作。</li>
</ul></li>
<li>当返回的 ack 到达节点时，节点将该版本标记为 <code>dirty = false</code>，然后可以删除该对象的所有先前版本。</li>
<li>当一个节点收到对象的读请求时：
<ul>
<li>若最新版本号并不 dirty，则返回；</li>
<li>反之，联系 TAIL 并查询该对象最后提交的版本号并返回。</li>
</ul></li>
</ol>
<p><img src="image-20221009142355628.png" alt="image-20221009142355628" style="zoom:80%;" /></p>
<p>在这样的策略下，无论写请求是否到该节点，以及 ack 是否传回该节点，对对象的读操作也能表现地像 CR 那样——因为读请求总是 <strong>serialized with respect to the TAIL.</strong></p>
<blockquote>
<p>也可以隐式确定对象的 <code>dirty</code> 属性，即对象列表中不止一个版本，则必然是脏的，反之同理。</p>
<p>前提是收到 ack 后立即删除旧版本。</p>
</blockquote>
<p>CRAQ 对 CR 的吞吐量改进体现在以下两个场景：</p>
<ol type="1">
<li><strong>Read-Mostly Workloads</strong>：大部分读请求由 <span class="math inline">\(C-1\)</span> 个非 TAIL 节点处理，故这些场景中的吞吐量与链长 <span class="math inline">\(C\)</span> 呈线性关系。</li>
<li><strong>Write-Heavy Workloads</strong>：对非 TAIL 节点的大多数读请求都是脏的，因此需要对 TAIL 进行版本查询，而这种查询比读取完整的数据对象更加轻量，故总吞吐量仍然高于 CR。</li>
</ol>
<h4 id="craq-布局">CRAQ 布局</h4>
<h5 id="链布局策略">链布局策略</h5>
<p>使用分布式存储服务的应用程序的需求可能多种多样，可能有以下常见情况：</p>
<ul>
<li>对对象的大部分或全部写入可能源自单个数据中心。</li>
<li>某些对象可能只与数据中心的子集相关。</li>
<li>热对象可能需要大量复制，而冷对象可能很少。</li>
</ul>
<p>CRAQ 通过使用对象的<strong>两级命名层次结构</strong>来满足这些要求，对象标识符由<strong>链标识符</strong>和<strong>键标识符</strong>组成。</p>
<h6 id="隐式数据中心-全局链长">隐式数据中心 &amp; 全局链长</h6>
<p><span class="math inline">\(\{num\_datacenters,\ chain\_size\}\)</span></p>
<p>这种方法中仅定义了数据中心是数量，并未实际指明。为确定哪些数据中心存储了链，还需要用到一致性哈希。</p>
<h6 id="显式数据中心-全局链长">显式数据中心 &amp; 全局链长</h6>
<p><span class="math inline">\(\{chain\_size,\ dc_1,\ dc_2,\ \dots, dc_N\}\)</span></p>
<p>每个数据中心都使用相同链长，链头位于 <span class="math inline">\(dc_1\)</span> 内，链尾位于 <span class="math inline">\(dc_N\)</span> 内，并且根据提供的数据中心列表对链排序。若 <code>chain_size = 0</code>，说明链应该使用数据中心内的所有节点。</p>
<h6 id="显式数据中心链长">显式数据中心链长</h6>
<p><span class="math inline">\(\{dc_1,\ chain\_size_1,\ \dots, dc_N,\ chain\_size_N\}\)</span></p>
<p>每个数据中心的链长单独指定，允许链负载不均衡。<code>chain_size i</code> 也可以设为 0。</p>
<h5 id="数据中心内的-craq">数据中心内的 CRAQ</h5>
<p>目前，CRAQ 使用一致性哈希将链放在数据中心内，将尽可能多的链标识符映射到单个 HEAD。</p>
<h5 id="跨数据中心的-craq">跨数据中心的 CRAQ</h5>
<p>当链跨域时，CRAQ 从任何节点读的特性能够降低其延迟——client 可以就近读取，而无需发送跨域网络请求。</p>
<p>尽管随着数据中心数量的增加，写延迟也会增加，但 CRAQ 允许写入沿链<strong>流水线化</strong>，故与 primary/backup 方法相比，还是能够极大提高写入吞吐量。应用程序可能进一步优化链的选择，从而最大限度减少写入延迟和网络成本。</p>
<h5 id="zookeeper-协调服务">ZooKeeper 协调服务</h5>
<p>目前的 CRAQ 利用 ZooKeeper 来跟踪组成员身份与存储链数据。通过 ZooKeeper，可以保证 CRAQ 节点在有节点加入/退出链，或某些数据发生变化时收到通知。</p>
<h4 id="总结">总结</h4>
<p>CRAQ 通过串行的方法提供了另一种有趣的复制方式，且提供了与 Raft 不一样的属性，它也给 Aurora 提供了一定的策略支持。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>FaRM</title>
    <url>/6-824/FaRM/</url>
    <content><![CDATA[<p>6.824 的第九篇论文是 <strong>FaRM</strong>——一个通过为分布式事务提供序列化、高性能、持久性和高可用性的<strong>主存分布式计算平台</strong>。</p>
<span id="more"></span>
<p>FaRM 利用以下两种<strong>硬件趋势</strong>做到这一点：</p>
<ul>
<li>非易失 DRAM（通过将 DRAM 写入 SSD 实现）</li>
<li>快速 RDMA</li>
</ul>
<p>这消除了存储和网络瓶颈，却带来了新的 CPU 瓶颈。FaRM 通过遵循以下三个原则来解决这一 bottleneck：</p>
<ul>
<li><p>减少消息量</p>
<blockquote>
<p>FaRM 允许事务与存储对象跨机器分布；</p>
<p>使用具有 replica 的垂直 Paxos 以及直接与 Primary/Backup 通信的非复制 <strong>coordinator</strong>；</p>
<p>使用<strong>乐观并发控制</strong>和<strong>四阶段提交协议</strong>(4PC: lock, validation, commit backup, commit primary)。</p>
</blockquote></li>
<li><p>使用单侧 RDMA 进行读写，而不是传递消息</p>
<blockquote>
<p>不使用远程 CPU，且避免了大部分 local CPU 开销。但这样一来传统的基于 CPU 的 failure-recovery 就失效了，需要考虑<strong>新的 failure-recovery protocol</strong>：</p>
<ol type="1">
<li><strong>precise membership</strong>：FaRM servers 不根据它们的 lease 到期而拒绝传入的请求，因为请求由不支持 lease 的网卡(<strong>NIC</strong>)提供服务；使用 precise membership 来确保机器同意当前的成员配置，并只向配置中的成员机器发送 RDMA；</li>
<li><strong>reservations</strong>：因为事务记录被写入日志而不涉及 CPU，FaRM 使用 reservations 来确保在开始 commit 之前，日志中有足够空间用于 commit 和 truncate 事务。</li>
</ol>
</blockquote></li>
<li><p>有效利用并行性</p>
<blockquote>
<p>它将每个状态的恢复均匀地分布在集群中，并在每台机器之间并行恢复。它使用<strong>两个优化</strong>来允许事务执行与恢复并行进行：</p>
<ol type="1">
<li>事务在锁定恢复阶段之后开始访问受故障影响的数据；</li>
<li>不受故障影响的事务继续执行而不会阻塞。</li>
</ol>
</blockquote></li>
</ul>
<h4 id="硬件趋势">硬件趋势</h4>
<h5 id="非易失-dram">非易失 DRAM</h5>
<p>发生电源故障时，分布式不间断电源(<strong>UPS</strong>)使用电源中的能量将内存中的数据保存到 SSD，从而提高 DRAM 耐用性。</p>
<h5 id="rdma-网络">RDMA 网络</h5>
<p>FaRM 尽可能使用单侧 RDMA 操作，从而有效减少了 CPU 开销与需传递的消息数量——RPC 需要的消息量是单侧 RDMA 的两倍。</p>
<h4 id="编程模型">编程模型</h4>
<p>FaRM 提供<strong>全局地址空间</strong>的抽象，其 API 为事务提供对对象的透明访问。</p>
<p>FaRM 事务使用<strong>乐观并发控制</strong>。对数据的修改会先在本地缓存，且只在成功提交后才对其他事务可见。</p>
<p>FaRM 为所有成功提交的事务提供严格的<strong>可串行化</strong>：</p>
<ul>
<li><strong>单对象读取</strong>是原子的：只读取已提交的值，且由事务写入的对象的读取返回最新写入的值。FaRM API 还为单对象 RO 事务提供<strong>无锁读取</strong>和<strong>位置提示</strong>，使程序员能够在同一组机器上共同定位相关对象。</li>
<li><strong>多对象读取</strong>不保证原子性：保证事务不会提交，同时确保提交的事务是严格可串行化的。这样可以将一致性检查推迟到提交时间。</li>
</ul>
<h4 id="整体架构">整体架构</h4>
<p><img src="image-20221021142633067.png" alt="image-20221021142633067" style="zoom:67%;" /></p>
<h5 id="协调与配置">协调与配置</h5>
<p>FaRM 使用 Zookeeper 作为协调服务。</p>
<p>FaRM 实例会随着时间的推移更新<strong>配置</strong>。配置是一个元组 <code>(i, S, F, CM)</code>，其中 <code>i</code> 是<strong>配置标识符</strong>，<code>S</code> 是配置中的<strong>机器集合</strong>，<code>F</code> 是从机器到 <strong>failure region</strong> 的<strong>映射</strong>，<code>CM</code> 是<strong>配置管理器</strong>，且 CM ∈ S。</p>
<p><strong>CM</strong>(Configuration Manager) 实现管理租约、检测故障或协调恢复。每次配置更改时，CM 都会调用 Zookeeper 来更新配置以达成共识。</p>
<h5 id="内存管理">内存管理</h5>
<p>FaRM 中的地址空间由多个 2GB 大小的 <strong>region</strong> 组成。每个 region 分布在一个 primary 和 <span class="math inline">\(f\)</span> 个 backup 上，对于每个机器而言，region 存储在其 DRAM 中并且可以被 RDMA 读取。</p>
<p>所有的 read 都落到 primary 上（如果 region 在本地，则直接通过本地内存访问；反之，则使用单侧 RDMA 读取）。</p>
<p>CM 存储 region 标识符到其 primary/backup 的映射。这些映射可被其他机器按需获取、缓存到本地并复制。</p>
<h5 id="region-分配">region 分配</h5>
<p>机器联系 CM 以分配新 region。CM 为 new region 分配一个标识符，并为其选择 replicas。对 replica 的选择应尽量<strong>均衡负载</strong>，并且满足：</p>
<ul>
<li>有足够的容量；</li>
<li>每个 replica 位于不同的 failure region 中；</li>
<li>当应用程序指定局部性约束时，该 region 与目标 region 位于同一位置。</li>
</ul>
<p>然后 CM 利用 <strong>2PC</strong> 进行 region 分配。</p>
<h5 id="logmsg-队列">Log/Msg 队列</h5>
<p>每台机器存储一个基于 <strong>FIFO</strong> 的环形缓冲区，用于<strong>事务日志或消息队列</strong>。每个接收者都有单独的 log queue 和 msg queue。发送者使用单侧 RDMA 将记录附加到日志尾部，写入由 NIC 发送 ack，不涉及 CPU；接收者定期轮询日志的头部以处理记录。</p>
<h4 id="分布式事务与复制">分布式事务与复制</h4>
<p>下图展示了 FaRM 事务提交时间线。</p>
<p><img src="image-20221025170135679.png" alt="image-20221025170135679" style="zoom:67%;" /></p>
<h5 id="执行阶段">执行阶段</h5>
<ul>
<li>事务使用单侧 RDMA 读取对象并写入本地缓存。</li>
<li>coordinator 记录所有访问对象的地址和版本号。</li>
<li>对于与 coordinator 在同一台机器上的 primary/backup，对象对日志的读取和写入使用本地内存访问而不是 RDMA。</li>
</ul>
<h5 id="提交阶段">提交阶段</h5>
<p><img src="image-20221025172808292.png" alt="image-20221025172808292" style="zoom:70%;" /></p>
<ol type="1">
<li><p><strong>Lock</strong>：coordinator 将 LOCK 记录写入每台涉及写的 primary。primary 通过尝试使用 compare-and-swap 将对象在指定版本处 lock，并回复是否成功获取所有锁。若失败，则中止事务。</p></li>
<li><p><strong>Validate</strong>：coordinator 通过从 primary 中读取 被事务读取但未写入的所有对象 的版本来执行 VALIDATE。如果任何对象已更改，则中止事务。</p>
<blockquote>
<p>默认使用单侧 RDMA 读，而对于拥有 <span class="math inline">\(t_r\)</span> 以上对象的 primary，则用 RPC（阈值 <span class="math inline">\(t_r\)</span> 反映了 RPC 相对于 RDMA 读取的 CPU 成本）。</p>
</blockquote></li>
<li><p><strong>Commit Backup</strong>：coordinator 将 <code>COMMIT-BACKUP</code> 记录写入所有 backup 的日志，然后等待来自 NIC 硬件的 ack，无需 CPU 干涉。</p></li>
<li><p><strong>Commit Primary</strong>：在确认所有 <code>COMMIT-BACKUP</code> 写入后，coordinator 将 <code>COMMIT-PRIMARY</code> 记录写入每个 primary 的日志中。接下来 primary 更新对象及其版本并 unlock。coordinator 会在收到至少一个 primary 的 ack 时向应用程序报告完成。</p></li>
<li><p><strong>Truncate</strong>：primary/backup 将记录保留在其日志中直到被截断。coordinator 在收到所有 primary 的确认后，它会在其他日志记录中捎带截断事务的标识符会从而延迟截断。backup 在截断时将更新应用于其对象副本。</p></li>
</ol>
<p><img src="image-20221025172832254.png" alt="image-20221025172832254" style="zoom:70%;" /></p>
<h4 id="故障恢复">故障恢复</h4>
<h5 id="故障检测">故障检测</h5>
<p>FaRM 使用 <strong>lease</strong> 来检测故障。每台机器都在 CM 处持有 lease，而 CM 在其他每台机器上都持有 lease。任何 lease 到期都会触发故障恢复。FaRM 使用 <strong>3 次握手</strong>授予 lease。每台机器都会向 CM 发送一个 lease 请求，CM 在授权响应中捎带 CM 的 lease 请求，最后机器回复 CM 的 lease 许可。</p>
<blockquote>
<p>FaRM 租期很短，以保证高可用性。</p>
</blockquote>
<p>FaRM 为 lease 维护一个专用消息队列，以及时处理请求。可靠传输将要求 CM 为每台机器添加一个额外的队列。</p>
<p>默认情况下，每过租期的 1/5 会尝试更新租约，以防止消息丢失。还必须及时在 CPU 上安排续租。 FaRM 使用以最高用户空间优先级运行的专用租用管理器线程。</p>
<h5 id="重新配置">重新配置</h5>
<p>单侧 RDMA 要求重新配置协议使用 <strong>lease</strong> 实现一致性，服务器在回复访问对象的请求之前检查它们是否持有对象的lease。从配置中被驱逐的服务器存储的对象在 lease 到期之前不被改变。</p>
<p>但由于 CPU 无法检查是否持有 lease，且 NIC 也不支持 lease。这一问题可用 <strong>precise membership</strong> 来解决：发生故障后，新配置中的所有机器必须在允许对象变更之前就其成员关系达成共识。配置内的机器不会发起/接受配置外机器的 RDMA 请求。</p>
<p><img src="image-20221026112640579.png" alt="image-20221026112640579" style="zoom:80%;" /></p>
<ol type="1">
<li><p><strong>Suspect</strong>：CM 怀疑机器 lease 到期时，会启动重新配置，并开始阻止所有外部 client 请求；机器怀疑 CM lease 到期时，它首先要求 CM backup 中的一个启动重新配置。如果超时，那么它会自己尝试成为新的 CM 并重新配置。</p></li>
<li><p><strong>Probe</strong>：新 CM 向配置中的所有机器发出 RDMA 读取（任何读取失败的机器也被 SUSPECT），仅当新 CM 获得<strong>大多数</strong> probe 的响应时，它才会继续进行重新配置。</p>
<blockquote>
<p>这确保了如果网络被分区，CM 不会在较小的分区中。</p>
</blockquote></li>
<li><p><strong>Update Configuration</strong>：新 CM 更新 Zookeeper 中存储的配置数据。使用 znode 序列号来实现原子 <strong>compare-and-swap</strong>。</p>
<blockquote>
<p>这确保了即使多台机器同时尝试从具有标识符 c 的配置更改配置，也只有一台机器可以成功地将系统移动到具有标识符 c +1 的配置（并成为 CM）。</p>
</blockquote></li>
<li><p><strong>Remap Regions</strong>：新 CM 重新分配 region。若 primary 故障，它会将某个 backup 提升为新的 primary，以减少恢复时间。</p></li>
<li><p><strong>Send New Configuration</strong>：CM 向所有机器发送<code>NEW-CONFIG</code> 消息。如果 CM 改变，<code>NEW-CONFIG</code> 还会重置 lease 协议。</p></li>
<li><p><strong>Apply New Configuration</strong>：当机器接收到配置标识符大于自己的配置标识符的 <code>NEW-CONFIG</code> 时，它会应用新配置，此后拒绝任何配置外机器的请求。机器用 <code>NEW-CONFIG-ACK</code> 消息回复 CM。如果 CM 发生了变化，则会向新 CM 重新授予/请求 lease。</p></li>
<li><p><strong>Commit New Configuration</strong>：一旦 CM 接收到所有 <code>NEW-CONFIG-ACK</code> 消息，它就会等待配置外的机器的 lease 都已过期。然后 CM 向所有配置成员发送 <code>NEW-CONFIG-COMMIT</code>（同时授予 lease）。之后所有成员都解除 <strong>Suspect</strong> 中对外部 client 请求的阻止，并启动事务恢复。</p></li>
</ol>
<h5 id="事务状态恢复">事务状态恢复</h5>
<p>FaRM 在配置更改后使用日志来恢复事务状态。下图为事务恢复时间线：</p>
<p><img src="image-20221026140042960.png" alt="image-20221026140042960" style="zoom:80%;" /></p>
<ol type="1">
<li><p><strong>Block Access To Recovering Regions</strong>：当 region 的 primary 发生故障时，其中一个 backup 会在重新配置期间提升为新的 primary。在更新 region 的所有事务都反映在新的 primary 上之前不能允许访问该 region，直到第 4 步 Lock Recover 结束。</p></li>
<li><p><strong>Drain Logs</strong>：所有机器在收到 <code>NEW-CONFIG-COMMIT</code> 消息时都会处理其日志中的所有记录。完成后，它们将最新配置标识符记录在变量 <code>LastDrained</code> 中。FaRM 事务具有在 commit 开始时分配的唯一标识符，配置标识符小于或等于 <code>LastDrained</code> 的事务的日志记录将被拒绝。</p>
<blockquote>
<p>NIC 会向 COMMIT-BACKUP/PRIMARY 发送 ack，无论它们是在何种配置中发出的。由于 coordinator 在向应用程序公开更新并报告成功之前只等待这些 ack，因此 FaRM 不能仅仅拒绝来自旧配置的消息来达到<strong>跨配置一致性</strong>。</p>
</blockquote></li>
<li><p><strong>Finding Recovering Transactions</strong>： recovering transaction 是指在 commit 阶段进行跨配置更改的事务。需要在 Drain Logs 期间检查所有日志记录以确定 RT 的集合。所有机器必须就给定事务是否为 RT 达成一致。CM 在 Probe Read 阶段读取每台机器上的 <code>LastDrained</code>。对于自 <code>LastDrained</code> 以来 replica 归属变化的每个 region <span class="math inline">\(r\)</span>，CM 在 <code>NEW-CONFIG</code> 消息中捎带两个配置标识符：</p>
<ul>
<li><code>LastPrimaryChange[r]</code>：primary 最后一个配置标识符；</li>
<li><code>LastReplicaChange[r]</code>：所有 replica 最后一个配置标识符。</li>
</ul>
<p>在配置 <span class="math inline">\(c-1\)</span> 中开始提交的事务在配置 <span class="math inline">\(c\)</span> 中恢复，除非：</p>
<ul>
<li>包含由事务<strong>读取</strong>对象的所有 region <span class="math inline">\(r\)</span>，<code>LastPrimaryChange[r] &lt; c</code>；</li>
<li>包含由事务<strong>修改</strong>对象的所有 region <span class="math inline">\(r&#39;\)</span>，<code>LastReplicaChange[r'] &lt; c</code>；</li>
<li>配置 <span class="math inline">\(c\)</span> 中 coordinator 尚未被移除。</li>
</ul>
<p>region 的每个 replica 都会向 primary 发送一条 <code>NEED-RECOVERY</code> 消息。</p></li>
<li><p><strong>Lock Recover</strong>：每个 region 的 primary 一直等待，直到本地机器 Drain Log 结束并且从每个 replica 接收到 <code>NEED-RECOVERY</code> 消息，以构建影响该 region 的完整 RT 集。然后它对 RT 分片。并行地，primary 线程从 backup 中获取尚未存储在本地的事务日志记录并给相关对象上锁。当一个 region 的 Lock Recover 完成后，该 region 可访问。</p></li>
<li><p><strong>Replicate Log Records</strong>：primary 线程通过向 backup 发送 <code>REPLICATE-TX-STATE</code> 消息来复制日志记录，以免丢失事务。</p></li>
<li><p><strong>Vote</strong>：coordinator 根据 region 的投票决定 commit/abort 事务。投票由 primary 发起。primary 线程将 <code>RECOVERY-VOTE</code> 消息发送到 coordinator 中的对等线程。</p>
<ul>
<li>若 replicas 看到 <code>COMMIT-PRIMARY</code> 或 <code>COMMIT-RECOVERY</code>，则投票 <code>commit-primary</code>；</li>
<li>否则，若 replicas 看到 <code>COMMIT-BACKUP</code> 但没看到 <code>ABORT-RECOVERY</code>，则投票 <code>commit-backup</code>；</li>
<li>否则，若 replicas 看到 <code>LOCK</code> 记录且没有 <code>ABORT-RECOVERY</code> ，则投票 <code>lock</code>；</li>
<li>否则，它会投票 <code>abort</code>。</li>
</ul></li>
<li><p><strong>Decide</strong>：</p>
<ul>
<li>若 coordinator 收到来自所有 region 的 <code>commit-primary</code> 投票，则提交事务；</li>
<li>否则，等待所有 region 投票。若至少一个 region 投票 <code>commit-backup</code>，且由事务修改的所有其他 region 投票 <code>lock</code>、<code>commit-backup</code> 或 <code>truncated</code>，则提交；</li>
<li>否则，中止。</li>
</ul>
<p>然后它向所有 replicas 发送 <code>COMMIT-RECOVERY</code> 或 <code>ABORT-RECOVERY</code>。在 coordinator 收到来自所有 primary/backup 的 ack 后，它会发送一条 <code>TRUNCATE-RECOVERY</code> 消息。</p></li>
</ol>
<h5 id="数据恢复">数据恢复</h5>
<p>当 primary 的所有 region 可访问时，每台机器都会向 CM 发送 <code>REGIONS-ACTIVE</code> 消息。然后 CM 向配置中的所有机器发送 <code>ALL-REGIONS-ACTIVE</code> 消息，此时开始数据恢复。</p>
<p>如果对象的版本高于本地版本，则 replicas 会通过 CAS 上锁，更新后解锁；否则，不应用恢复。</p>
<h5 id="分配器状态恢复">分配器状态恢复</h5>
<p>FaRM 分配器将 region 拆分为 <strong>block</strong> (1 MB)，这些 block 用作分配小对象的 <strong>slab</strong>。它保留了两个元数据：</p>
<ul>
<li>block header：包含对象大小；</li>
<li>slab 空闲列表。</li>
</ul>
<p>分配新 block 时，BH 会复制到 replica 中。由于块头用于数据恢复，因此新 primary 在收到 <code>NEW-CONFIG-COMMIT</code> 后立即将它们发送到所有 replicas。</p>
<p>slab 空闲列表仅保留在 primary 中，以减少对象分配的开销。</p>
<p>每个对象的 header 中都有一个 bit 位，表示该对象已分配或被清理。这一 bit 也会在事务提交期间被复制。通过并行扫描故障 region 中的对象，在新的 primary 上恢复空闲列表。为了尽量减少对事务 lock recovery 的影响，分配器恢复在收到 <code>ALL-REGIONS-ACTIVE</code> 后开始，在 slab 空闲列表恢复后释放对象。</p>
<h4 id="总结">总结</h4>
<p>这是 6.824 事务与复制的最后一个系列了，用 RDMA 而不是 RPC 很有创新点。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Frangipani</title>
    <url>/6-824/Frangipani/</url>
    <content><![CDATA[<p>6.824 的第七篇论文是 <strong>Frangipani</strong>——一种建立在 Petal（一种可扩展、高可用性、自动管理的分布式存储服务）上的可扩展的分布式文件系统，并使用分布式锁来确保一致性。</p>
<span id="more"></span>
<h4 id="frangipani-初探">Frangipani 初探</h4>
<h5 id="特点">特点</h5>
<p>Frangipani 有一个显著特点，就是它采用<strong>一组协作机器使用一个公共存储</strong> Petal 的内部结构，使用锁进行访问同步，同时具备以下特性：</p>
<ol type="1">
<li>为所有用户提供同一组文件的一致视图，即对于同一个文件，所有用户在访问时都能看到相同的数据；</li>
<li>可以任意添加服务器到 Frangipani 架构中以增加存储容量和吞吐量，而无需更改现有服务器的配置或中断其运行；</li>
<li>系统管理员可以添加新用户，而无需担心哪些机器将管理他们的数据或哪些磁盘存这些数据；</li>
<li>系统管理员可以对整个文件系统进行完整且一致的备份，而无需将其关闭，同时允许用户快速访问意外删除的文件；</li>
<li>文件系统能容忍并从故障中恢复而无需人工干预。</li>
</ol>
<h5 id="系统结构">系统结构</h5>
<p>如下图所示，Petal 表现得就像一块被所有用户使用的，基于网络的共享虚拟磁盘，它会运行在一些不同的服务器上。当 Frangipani 需要读写数据时，它会向正确的 <strong>Petal server</strong> 发送 RPC。</p>
<p><img src="image-20221010155347871.png" alt="image-20221010155347871" style="zoom:80%;" /></p>
<p>用户通过标准操作系统调用借口访问 Frangipani，对一台机器上的文件或目录进行的修改会立即对其他人可见。</p>
<p>Frangipani 采用 <strong>Cache</strong> 来缓存文件，这样在一段时间内对文件的修改只需要在本地进行，而无需耗费更高的时间成本进行 RPC 的调用。同时，在下一个用户访问该文件前，不会将修改后的数据持久化到 Petal，但会将元数据的修改操作记录到 <strong>WAL</strong> 中。WAL 保存在 Petal 中，这样当 Frangipani 崩溃时，其它服务器可以访问 WAL 并进行故障恢复。</p>
<p>每个 Petal server 持有一个 <strong>lock manager</strong>，它有一个表单，存放文件对应的锁以及持有锁的用户，来协调对 Petal 的访问以及保持多个 Frangipani 之间的缓冲区的<strong>缓存一致性</strong>。两个 <strong>Frangipani server</strong> 间无需直接通信，而是通过 LM 通信，这也简化了成员的变化操作。</p>
<h4 id="锁服务">锁服务</h4>
<p>Frangipani 中的锁服务提供<strong>共享读锁</strong>与<strong>排他写锁</strong>。当一个 Fserver 访问文件时，它会向对应的 Pserver 中的 LM 发起 <strong>Request</strong> 请求该文件合适的锁，并在得到 LM 的 <strong>Grant</strong> 回复后才获得锁，从而正式读取文件或修改文件。之后，Fserver 会<strong>一直持有文件锁</strong>（但可能不使用它）而不主动释放，这种惰性释放锁的策略也一定程度上提高了性能——在没有其它 Fserver 请求访问的前提下，后续对相同文件的修改不用再次请求锁。</p>
<p>若有其它的 Fserver 发起了冲突的锁请求，LM 检查当前有一个 Fserver 正持有锁，它会向该 Fserver 发起一个 <strong>Revoke</strong> 请求，持有文件锁的 Fserver 等到当前没有对该文件进行的任何操作，<u>它会将对该文件的所有修改应用到 Pserver 上</u>，这一步完成后才释放锁，向 LM 发出 <strong>Release</strong> 请求。LM 随后删除表单中原先该锁对应的条目，再重新执行一次锁分配的操作。</p>
<p>通过 LM 的协调服务，我们可以实现良好的 <strong>缓存一致性 Cache Consistency</strong>——A 对本地缓存进行的修改，能够被 B 感知到。同时，只要保证 Fserver 在操作期间一致持有锁，就能保证对文件操作的<strong>原子性 atomicity</strong>。</p>
<h4 id="故障处理">故障处理</h4>
<h5 id="日志">日志</h5>
<p>如前文所述，每个 Frangipani server 都会在 Petal 的某个地方存放自己那部分 WAL。当 Frangipani 需要对文件元数据进行修改时，它首先创建一个修改记录并 append 到本地内存的日志中，这些日志被定期（大概 30s）写入 Petal，只有在日志完整写入 Petal 后，Petal 才会永久修改实际的元数据。<strong>事实上，在 Release 锁前，Fserver 会先将日志写入 Pserver，再传输脏数据</strong>。</p>
<h5 id="恢复">恢复</h5>
<p>LM 使用 <strong>lease</strong> 来处理故障，也就是说，当对一个锁进行 Revoke 时，过了 lease 规定的时间没有得到 Release 回复，它会认为这个 Fserver 发生了故障，从而进行故障处理。</p>
<p><strong>dead</strong> 发生故障后，Pserver 会让另一个 Frangipani（称为 <strong>demon</strong>）读取其日志并进行恢复。demon 会隐式接管 dead 挂前持有的锁，并从日志开始按顺序进行重做，执行完成后，释放 dead 的锁，之后整个系统按正常状态运行。</p>
<p>这里有可能的几个发生故障的时刻：</p>
<ol type="1">
<li><strong>还没发送日志就挂了</strong>：此时文件系统会和 Fserver 开始修改前保持一致，故不用进行任何操作。</li>
<li><strong>日志发送到一半挂了</strong>：说明 Fserver 尚未发送脏数据，只需执行已发送的那部分日志即可。</li>
<li><strong>脏数据传到一半挂了</strong>：说明 Fserver 必然已经发完了所有日志，那么对所有日志重做就好了。</li>
</ol>
<p>无论是哪种情况，都有一个共同点：<strong>只需要执行已写到 Pserver 内的日志</strong>。</p>
<p>为了防止 demon 在进行故障恢复时其它 Fserver 对 Petal 的干扰，在日志条目中增加<strong>版本号</strong>的属性：当且仅当日志中元数据的版本号高于 Petal 中存储的数据的版本时，才执行日志。如果是 Petal 中的版本更高，那说明已经有 Fserver 在 dead 修改之后对元数据进行了修改，不能进行回退。</p>
<p>且 demon 无需关心元数据上是否持有锁。如果有锁，那大可以放心读取；如果锁已经被释放了，那脏数据肯定已经被写进去了，不用执行也没时。</p>
<h4 id="总结">总结</h4>
<p>Frangipani 提供了实现 Cache Consistency 的新思路，但由于时代的限制，它并没有对存储系统的演进产生任何影响，也无法应用到分布式系统的主要应用场景中。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>GFS</title>
    <url>/6-824/GFS/</url>
    <content><![CDATA[<p>6.824 的第一篇论文是 Google “<strong>三驾马车</strong>”之一的 <strong>GFS</strong>(Google File System)——一个用于大型分布式数据密集型应用程序的可扩展分布式文件系统。</p>
<span id="more"></span>
<h3 id="问题的提出背景">问题的提出背景</h3>
<ol type="1">
<li>系统时常发生组件故障，其成因有许多：应用程序故障、操作系统故障、人为因素等。因此系统需要一定的持续监控、错误检测、容错和自动恢复能力。</li>
<li>多 GB 文件很常见，然而传统系统在管理海量小文件时显得比较笨拙，必须重新对 I/O 操作和文件块大小等进行参数的设计。</li>
<li>大多数文件是通过<strong>追加</strong>(append)新数据而不是<strong>重写</strong>(overwrite)现有数据来改变的，不存在对文件的随机写入。一旦写入，文件就只能被读取，而且通常只能按顺序读取。这与在<strong>客户端</strong>(client)缓存数据块相性不合。</li>
<li>统一应用程序和文件系统的 API 能够增加系统的灵活性。放宽 GFS 的一致性模型以极大地简化文件系统，而不会给应用程序带来繁重的负担。</li>
</ol>
<h3 id="设计总览">设计总览</h3>
<h4 id="系统的应用场景假设">系统的应用场景假设</h4>
<ol type="1">
<li>该系统由许多经常发生故障的廉价商品组件构建而成。它必须不断地自我监控，并定期检测、容忍组件故障并迅速从组件故障中恢复。</li>
<li>系统应有效管理大文件存储。同时必须支持小文件，但不需要针对它们进行优化。</li>
<li>工作负载主要包括两种读取：大型流式读取和小型随机读取。在大型流式读取中，单个操作通常读取数百 KB，更常见的是 1 MB 或更多。来自同一 client 的连续操作通常会读取文件的连续区域；小型随机读取通常会在某个任意偏移量处读取几个 KB，注重性能的应用程序经常对这些小读取进行批处理和排序，以稳定地遍历文件而不是来回移动。</li>
<li>系统必须为多个 client 同时对同一文件进行 append 定义良好的语义。我们的文件通常使用生产者-消费者队列或多路合并。可能同时会有数百个生产者将数据追加到一个文件中，故具有最小同步开销的原子性是必不可少的。</li>
<li>高持续带宽比低延迟更重要。大多数目标应用程序都非常重视以高速率批量处理数据，而少数目标应用程序对单个读取或写入具有严格的响应时间要求。</li>
</ol>
<h4 id="接口">接口</h4>
<p>GFS 提供并支持常规的文件系统接口：create、delete、open、close、read 和 write （尽管它没有实现诸如 POSIX 之类的标准 API），且文件在目录中分层组织由路径名标识。</p>
<p>此外，GFS 具有<strong>快照</strong>(snapshot)和<strong>记录追加</strong>(record append)操作。snapshot 以低成本创建文件或目录树的副本。record append 允许多个 client 同时向同一个文件追加数据，并保证每个 client 追加的原子性，而无需额外的锁策略。</p>
<h4 id="系统结构">系统结构</h4>
<p>GFS 集群(cluster)由单个<strong>主服务器</strong>(master server)和多个<strong>块服务器</strong>(chunk server)组成，并由多个 client 访问。其中每一个 client 通常都是运行用户级服务器进程的 Linux 机器。</p>
<blockquote>
<p>只要机器资源允许，并能够容忍由于运行可能不稳定的应用程序代码而导致较低的可靠性，也可以在同一台机器上同时运行 chunk server 和 client。</p>
</blockquote>
<p><img src="image-20220925142136479.png" alt="image-20220925142136479" style="zoom:80%;" /></p>
<p>GFS 将文件分成固定大小的<strong>块</strong>(chunk)，并以 <strong>Linux 文件</strong>的形式存放在多个 chunk server 的本地磁盘上。</p>
<blockquote>
<p>这样读写操作自然就会变得很快。因为可以从多个服务器上同时读取同一个文件，进而获得更高的聚合吞吐量。将文件分割存储还可以在存储系统中保存比单个磁盘还要大的文件。</p>
</blockquote>
<p>每个 chunk 由 master 在创建时分配的不变且全局唯一的 64 位<strong>块句柄</strong>(chunk handle)标识。chunk server 读取或写入由 chunk handle 和字节范围指定的 chunk data。每个 chunk 都在多个 chunk server 上复制以实现可靠性。</p>
<blockquote>
<p>默认存储三个副本，尽管用户可以为文件命名空间的不同区域指定不同的复制级别。</p>
</blockquote>
<p>client 实现文件系统 API，并与 master 和 chunk server 通信来读取或写入数据。client 与 master 交互进行元数据操作，但所有承载数据的通信都直接进入 chunk server。以一次<strong>读文件操作</strong>为例：</p>
<ol type="1">
<li>client 向 master 发出文件请求，该请求包含了 file name 与操作范围在文件中的偏移量 offset。</li>
<li>master 在 table 中寻找 file name 到 chunk ID 的映射（一个 file 对应若干 chunk）。</li>
<li>之后，master 再根据 offset % chunk size = chunk index 找到对应的 chunk，向 client 发回 chunk handle 和 chunk location。</li>
<li>client 收到回复后，根据 chunk location 寻找 chunk server，使用 chunk handle 进行文件操作。</li>
</ol>
<p>client 和 chunk server 都不缓存文件数据。大多数应用程序要么工作集太大，要么通过大文件流式传输，client 无法缓存。chunk server 不需要缓存文件数据，因为 chunk 存储为本地文件，Linux 的缓冲区缓存已经将频繁访问的数据保存在内存中。</p>
<blockquote>
<p>但 client 会缓存元数据，也会缓存一定的 chunk server 信息，以避免与 master 的重复交互。</p>
</blockquote>
<h4 id="块大小chunk-size">块大小(chunk size)</h4>
<p>论文中选取的是 <strong>64 MB</strong>，并且仅在需要时进行扩展。其优势如下：</p>
<ol type="1">
<li><p>减少了 client 与 master 的交互次数，对同一个 chunk 的读取和写入只需要向 master 发出一个初始请求以获取 chunk location。</p>
<blockquote>
<p>这对于那些主要是按顺序读取和写入大文件的应用程序而言很有帮助。即使对于小的随机读取，client 也可以轻松地缓存多 TB 工作集的所有 chunk location。</p>
</blockquote></li>
<li><p>当增大 chunk size 时，client 更有可能将操作集中在同一 chunk 上，从而可以通过在较长时间内保持与 chunk server 的持久 TCP 连接来减少网络开销。</p></li>
<li><p>它减少了存储在 master 上的元数据的大小（chunk size 越小，同一 file name 映射到的 chunk set 容量也会越大），这允许我们将元数据保存在内存中。</p></li>
</ol>
<p>另一方面，如果许多 client 访问同一个文件，存储其 chunk 的 chunk server 可能会成为<strong>热点</strong>(hotspot)。</p>
<blockquote>
<p>现实中，hotspot 并不是一个主要问题，因为应用程序大多是按顺序读取大型多块文件。而当批处理队列系统使用 GFS 时，出现 hotspot 的问题：少数 chunk server 被数百个 client 同时请求，从而超载。可以通过以更高的复制因子存储此类文件，或者使批处理队列系统错开应用程序启动时间来解决此问题。另一个长期解决方案是允许 client 在这种情况下从其他 client 中读取数据。</p>
</blockquote>
<h4 id="元数据metadata">元数据(metadata)</h4>
<p>master 维护以下三种类型的 metadata：命名空间、从 file name 到 chunk ID 的映射以及 <strong>chunk 的当前位置</strong>(chunk location)。所有 metadata 都保存在 master 的内存中。前两种类型（名称和文件到块的映射）也通过将<strong>操作记录</strong>(operation log)存储到 master 的本地磁盘上并在远程机器上复制 log 来保证持久性。</p>
<blockquote>
<p>使用 log 可以简单、可靠地更新 master 状态，并且不会在 master 崩溃时遭遇不一致的风险。</p>
</blockquote>
<p>由于 metadata 存储在内存中，master 能实现很快的操作速度。而这种存储策略的一个潜在问题是，chunk 的数量以及整个系统的容量受到 master 内存大小的限制（然而这并不是一个严重的瓶颈）。master 为每个 64 MB chunk 维护少于 64 B 的 metadata。大多数 chunk 已满，只有最后一个可能未被完全使用。同样，每个文件的命名空间数据通常需要少于 64 B，因为它使用前缀压缩技术存储文件名。</p>
<blockquote>
<p>如果需要支持更大的文件系统，则需要向 master 添加额外内存，这与获得的好处相比代价非常小。</p>
</blockquote>
<h5 id="块位置chunk-location">块位置(chunk location)</h5>
<p>master 不会将哪些 chunk server 具有给定 chunk 的副本这一信息给持久化存储，而是在启动时轮询 chunk server 以获取该信息，之后定期通过 HeartBeat 请求数据，这使得 master 始终保持自己处于最新状态，且消除了在 chunk server 加入和离开集群、修改名称、失败、重新启动等时保持 master 和 chunk server 同步的问题——这要比将数据持久化到本地磁盘简单得多。</p>
<blockquote>
<p>在拥有大量服务器的集群中，这些事件经常发生。</p>
</blockquote>
<p>另一种理解思路是，chunk server 对它在本地磁盘上拥有哪些 chunk 拥有最终决定权。尝试在 master 上持久化此信息没有意义，因为 chunk server 上的一些故障可能会导致 chunk 失效（e.g，磁盘可能会损坏并被禁用）或者 chunk server 被重命名。</p>
<h5 id="操作日志operation-log">操作日志(operation log)</h5>
<p>operation log 存储对 metadata 修改的持久的历史记录，还用作定义并发操作顺序的逻辑时间线。它是 GFS 的核心。因此，需要对 operation log 进行可靠存储，并且在对 metadata 的修改被持久化之前不让修改对 client 可见。否则，即使 chunk 本身不发生故障，也会丢失整个文件系统或最近的 client 操作。</p>
<p>这一可靠存储的方法为，<strong>将其复制到多台远程机器上</strong>，并且只有在将相应的日志记录更新到本地和远程磁盘后才能响应 client 操作。master 在更新前将多个日志记录进行批处理，从而减少了更新和复制对整个系统吞吐量的影响。</p>
<p>重启后，master 可以通过重新实施 operation log 来恢复其文件系统状态。为了最小化启动时间，必须保持 log 很小。每当 log 超过一定大小时，master 都会检查其状态，以便它可以通过从本地磁盘加载最新的<strong>检查点</strong>(checkpoint)并仅重新实施之后有限数量的 log 记录。</p>
<blockquote>
<p>checkpoint 采用紧凑的 B 树形式，可以直接映射到内存并用于命名空间查找，无需额外解析。这进一步加快了恢复并提高了可用性。</p>
</blockquote>
<p>建立一个 checkpoint 需要一段时间，为了避免延缓传入的修改，master 可以通过切换到一个新的 log 文件并在一个单独的线程中创建新的 checkpoint。新的 checkpoint 包括切换之前的所有修改。完成后，它会同时写入本地和远程的磁盘。</p>
<p>只需要最新的完整 checkpoint 和存放后续 log 记录的文件即可进行系统恢复。旧的 checkpoint 和 log 文件可以删除，但也会保留一些以防止灾难发生。checkpoint 期间的失败不会影响正确性，因为恢复代码会检测并跳过不完整的 checkpoint。</p>
<h4 id="持久化模型">持久化模型</h4>
<p>GFS 有一个宽松的一致性模型，可以很好地支持这一高度分布式应用程序，且实现起来相对简单且高效。</p>
<h5 id="一致性保证">一致性保证</h5>
<p>文件命名空间的修改（如文件创建）是原子的，它们由 master 专门处理，并通过给命名空间加锁来保证原子性和正确性。master 的操作日志决定了这些操作的全局总顺序。数据修改后文件域的状态取决于修改的类型、成功或失败以及是否存在并发修改。下表总结了结果：</p>
<ol type="1">
<li>如果所有 client 能够始终看到相同的数据，无论他们从哪个副本中读取，则文件域是 <strong>consistent</strong> 的。</li>
<li>如果在文件数据修改之后是 consistent 的，并且 client 将看到该次修改完整写入的内容，则文件域是 <strong>defined</strong> 的。</li>
<li>当修改成功且不受并发写入者的干扰时，那么受影响的文件域是 <strong>defined</strong> 的（同时也为 consistent）。因为所有 client 将始终看到修改写入的内容。</li>
<li>并发成功的修改使文件域 <strong>undefined but consistent</strong>。虽然所有 client 都看到相同的数据，但它可能无法反映任何一个修改写入的内容，通常，它由来自多个修改的混合片段组成。</li>
<li>失败的修改使文件域变得 <strong>inconsistent</strong>（因此也 undefined）：不同的 client 可能在不同的时间看到不同的数据。</li>
</ol>
<p><img src="image-20220925205531561.png" alt="image-20220925205531561" style="zoom: 80%;" /></p>
<p>数据修改可能是 write（将数据写入应用程序指定的文件偏移处）或 record append（将数据在 GFS 选择的偏移处原子性地 append 至少一次，即便在存在并发修改的情况下，相反，常规追加只是在 client 认为是当前文件结尾的偏移处写入）。偏移量会被返回给 client 并在包含该记录的 defined 文件域的开始处做上标记。此外，GFS 可能会在其间插入填充或记录重复项。它们占据 inconsistent 的文件域，并且通常少于用户数据量。</p>
<p>在一系列成功的修改之后，经修改的文件域一定是 defined 的，并包含最后一个写入的数据。 GFS 通过</p>
<ol type="1">
<li>在 chunk 的所有副本上以相同的顺序对其应用修改；</li>
<li>使用 chunk 版本号</li>
</ol>
<p>来检测任何已经过时的副本——它在它的副本中因 chunk server 的关闭而错过了修改。过时的副本永远不会参与修改，也不会被提供给向 master 询问 chunk location 的 client，它们会马上被 garbage collect。</p>
<p>由于 client 会缓存 chunk location，故它们可能会在更新这一信息前从过时的副本中读取数据。这个窗口受限于缓存条目的超时和文件的下一次打开（这会从缓存中清除该文件所有 chunk 的信息）。</p>
<p>成功修改后，组件故障仍然会破坏数据。 GFS 通过 master 和所有 chunk server 之间的定期握手来识别失败的 chunk server，并通过校验和检测数据损坏。一旦出现问题，数据会尽快从有效的副本中恢复。只有在 GFS 能够做出反应之前（通常在几分钟内）丢失所有副本时，一个 chunk 才会不可逆地丢失。即使在这种情况下，它也变得不可用，而不是损坏——应用程序将收到明确的错误而不是损坏的数据。</p>
<h5 id="对应用的影响">对应用的影响</h5>
<p>GFS 应用程序可以通过一些已经被应用于其他目的的简单技术来适应宽松的一致性模型：依赖 append 而不是 overwrite 、checkpoint 和编写自我验证、自我识别的记录。</p>
<blockquote>
<p>在一个典型的应用场景中，Writer 自始至终只生成一个文件。它在写入所有数据后自动将文件重命名为永久名称，或者定期检查已成功写入的数据量。checkpoint 还可能包括应用程序级校验和。Reader 仅验证和处理直到最后一个 checkpoint 的文件域，该检查点已知处于 defined 状态。无论一致性和并发性问题如何，这种方法都很好地为我们服务。与随机写入相比，append 更有效且对应用程序故障更具弹性。checkpoint 允许 Writer 以增量方式重新启动，并阻止 Reader 处理成功写入的文件数据，这些数据从应用程序的角度来看仍然不完整。</p>
</blockquote>
<blockquote>
<p>在另一种典型应用场景中，许多 Writers 同时将数据 append 到文件以获取合并结果或作为生产者-消费者队列。record append 的 “append-at-least-once” 语义保留了每个 Writer 的输出。Reader 按如下方式处理偶尔的填充和重复：Writer 准备的每条记录都包含额外的信息（如校验和），以便验证其有效性。Reader 可以使用校验和识别和丢弃冗余的填充和记录片段。如果 Reader 不能容忍偶尔的重复（例如如果它们会触发非幂等操作），它可以使用记录中的唯一标识符将它们过滤掉，这通常是命名相应的应用程序实体（例如 Web 文档）所必需的。这些用于记录 I/O 的功能（重复 delete 除外）位于应用程序共享的库代码中，适用于 Google 的其他文件接口实现。这样，相同的记录序列（与偶尔的重复），总会被传递给 Reader 并做好记录。</p>
</blockquote>
<h3 id="系统交互">系统交互</h3>
<p>设计系统以尽量减少 master 在所有操作中的参与。</p>
<h4 id="租约和修改顺序">租约和修改顺序</h4>
<p>每个修改在所有块的副本上执行。我们使用<strong>租约</strong>(lease)来保持副本之间一致的修改顺序。master 向其中一个副本授予 lease，我们将其称为 primary。primary 指定对 chunk 的所有修改的序列顺序。应用修改时，所有副本都遵循此顺序。</p>
<blockquote>
<p>全局修改顺序首先由 master 选择的 lease 授予顺序决定；而对于每段 lease 时间，则由相应 primary 分配的序列号定义。</p>
</blockquote>
<p>lease 机制旨在最大限度地减少 master 的管理开销。lease 的初始超时时间为 60 s。然而，只要 chunk 被改变，primary 就可以无限期地向 master 请求并得到续期授予。这些续期请求和授权被搭载在 master 和所有 chunk server 之间定期交换的 HeartBeat 消息上。 master 有时可能会在 lease 到期之前尝试撤销 lease（例如，当 master 想要禁用正在重命名的文件上的修改时）。即使 master 失去与 primary 的通信，它也可以在旧 lease 到期后将新 lease 授予另一个副本。这一机制总体流程如下：</p>
<ol type="1">
<li>client 询问 master 哪个 chunk server 持有该 chunk 的当前 lease 以及其他副本的位置。如果没有 server 拥有 lease，则 master 将 lease 授予它选择的副本；</li>
<li>master 回复 primary 的身份和其他副本(secondary)的位置。client 缓存此数据以备未来可能的修改。只有在 primary 变得无法访问或回复它不再持有 lease 的时候才需要再次联系 master；</li>
<li>client 将数据按任何顺序推送到所有副本。每个 chunk server 都会将数据存储在内部 LRU 缓冲区缓存中，直到数据被使用或过期。通过将数据流与控制流解耦，可以通过基于网络拓扑调度昂贵的数据流来提高性能，而不用管 primary 是谁；</li>
<li>一旦所有副本都确认接收到数据，client 向 primary 发送请求。该请求标识了之前推送的数据。primary 将连续的序列号分配给它接收到的所有修改，可能来自多个 client，这提供了必要的序列化。它按序列号顺序将修改应用于自己的本地状态；</li>
<li>primary 将写请求转发给所有 secondary。每个 secondary 按照 primary 分配的相同序列号顺序应用修改；</li>
<li>secondary 回复 primary 操作完成；</li>
<li>primary 回复 client。在任何副本中遇到的任何错误都会报告给 client。如果出现错误，写入可能在 primary 和 secondary 的任意子集上成功（如果在 primary 上失败，则不会分配序列号并转发），client 请求被认为失败，修改区域处于 inconsistent 状态。client 通过重试失败的修改来处理此类错误。它重复进行步骤 (3) 到 (7)，然后从写入开始重新尝试。</li>
</ol>
<p><img src="image-20220926105829428.png" alt="image-20220926105829428" style="zoom:80%;" /></p>
<blockquote>
<p>如果应用程序单次写入的数据量很大甚至跨越多个 chunk，client 会将其分解为多个写入操作。它们都遵循上述控制流程，但可能与来自其他 client 的并发操作交错而被覆盖。因此，共享文件域最终可能包含来自不同 client 的片段（尽管副本因各个操作在所有副本上以相同的顺序成功完成而最终一致），这使文件域处于 consistent but undefined 的状态。</p>
</blockquote>
<h4 id="数据流">数据流</h4>
<p>我们的目标是充分利用每台机器的网络带宽，避免网络瓶颈和高延迟链接，并最大限度地减少推送所有数据的延迟。</p>
<ol type="1">
<li><p>将数据流与控制流分离，以有效地使用网络。虽然控制从 client 流向 primary，然后流向所有 secondary，但数据以流水线方式沿 chunk server 链线性推送，因此，每台机器的全部出站带宽都用于尽可能快地传输数据，而不是在多个接收者之间分配。</p></li>
<li><p>为了尽可能避免网络瓶颈和高延迟链路（例如，交换机间链路通常两者兼有），每台机器将数据转发到网络拓扑中尚未收到数据的“最近”机器。</p>
<blockquote>
<p>假设 client 正在将数据推送到 chunk server S1 到 S4。它将数据发送到最近的 chunk server，比如 S1。S1 通过最接近 S1 的 S4 将其转发到最近的 chunk server S2，例如 S2。同样，S2 将其转发到 S3 或 S4，以更接近 S2 的为准，依此类推。GFS 的网络拓扑结构非常简单，可以根据 IP 地址准确估计“距离”。</p>
</blockquote></li>
<li><p>通过 TCP 连接上的数据传输流水线来最小化延迟。一旦 chunk server 接收到一些数据，它就会立即开始转发。流水线对我们特别有帮助，因为我们使用具有全双工链路的交换网络，立即发送数据不会降低接收速率。</p>
<blockquote>
<p>在没有网络拥塞的情况下，将 B 个字节传输到 R 个副本的理想经过时间是 B/T + RL，其中 T 是网络吞吐量，L 是在两台机器之间传输字节的延迟。我们的网络链接通常为 100 Mbps (T)，而 L 远低于 1 ms。因此，理想情况下，1 MB 可以在大约 80 毫秒内分配。</p>
</blockquote></li>
</ol>
<h4 id="原子性的-record-append">原子性的 record append</h4>
<p>GFS 提供了一种称为 record append 的原子性的追加操作。在传统的写入中，client 指定要写入数据的位置。对同一文件域的并发写入不可序列化：该区域最终可能包含来自多个 client 的数据片段。然而，在记录追加中，client 仅指定数据， GFS 在其选择的一组偏移处原子性地（即作为一个连续的字节序列）将其 append 到文件中至少一次，并将偏移返回给 client。</p>
<p>GFS 的分布式应用程序会大量使用 record append，可能有许多 client 同时将数据 append 到同一个文件。如果此时 client 使用传统写入的策略，将需要额外的复杂且昂贵的同步（例如通过分布式锁管理器）。</p>
<p>record append 是一种修改，故遵循之前提到的控制流程。client 将数据推送到文件最后一个 chunk 的所有副本，然后，它将请求发送到 primary。primary 检查将记录附加到当前 chunk 是否会导致其超过最大大小（64 MB）。</p>
<ol type="1">
<li>如果是这样，它将当前 chunk 填充到最大大小，告诉 secondary 也这样做，并回复 client 指示应该在下一个 chunk 上重试该操作 （记录追加被限制为最大块大小的四分之一，以将最坏情况的碎片保持在可接受的水平）；</li>
<li>如果 append 后不超过最大大小，primary 将数据追加到它的副本，并告诉 secondary 在相应偏移处写入数据，最后向 client 回复成功。</li>
</ol>
<p>如果任何副本的操作失败，client 会重试该操作。最终，同一 chunk 的副本可能包含不同的数据，可能包括全部或部分相同记录的副本。 GFS 不保证所有副本在字节上都是相同的。它只保证数据作为一个原子单元至少被写入一次，且为了报告成功的操作，数据必须在某个 chunk 的所有副本上以相同的偏移量写入。此外，所有副本至少与记录结尾一样长，因此任何未来的记录都将被分配更高的偏移或不同的 chunk（即使不同的副本后来成为 primary）。就一致性保证而言，成功的记录追加操作写入数据的区域是 defined 的，而中间区域是 undefined 的（该 chunk 在某一偏移量处并未写入，此时向 client 返回失败，client 重试该操作）。</p>
<h4 id="快照snapshot">快照(snapshot)</h4>
<p>snapshot 操作能够快速生成文件或目录树的副本，同时最大限度地减少正在进行的修改的任何中断。可以使用它来快速创建庞大数据集的分支副本，或者在尝试（未来会被提交或回滚的）更改之前检查当前状态。</p>
<p>与 AFS 一样，GFS 使用标准的<strong>写时复制技术</strong>来实现 snapshot。当 master 收到一个 snapshot 请求时，它首先撤销它要执行 snapshot 的文件中的 chunks 的所有未到期的 lease。这确保了对这些 chunks 的任何后续写入都需要先与 master 交互以找到 lease 持有者。从而 master 能首先创建 chunk 的新副本。</p>
<p>在 lease 被撤销或到期后，master 将操作记录到磁盘。然后，它通过复制源文件或目录树的元数据将此日志记录应用于其内存状态。新创建的 snapshot 文件指向与源文件相同的 chunk。</p>
<p>client 在 snapshot 操作后第一次想要写入 chunk C 时，它会向 master 发送请求以查找当前的 lease 持有者。primary 注意到 C 的引用计数大于 1。它将推迟回复 client 请求，转而选择一个新的 chunk handle C'。然后它要求每个拥有 C 的当前副本的 chunk server 创建一个名为 C' 的新 chunk。通过在与原始 chunk server 相同数据的 chunk server 上创建新 chunk，我们确保数据可以在本地复制，而不是通过网络复制（我们的磁盘大约是 100 Mb 以太网链路的三倍）。从这一点来看，请求处理与任何 chunk 的处理没有什么不同：master 授予其中一个副本对 C' 的 lease 并回复 client，client 接着正常写入 C'。</p>
<h3 id="master-操作">master 操作</h3>
<p>master 执行所有的命名空间操作。此外，它管理整个系统的 chunk 副本：如做出 chunk 副本放置决策、创建新 chunk 与其副本、协调各种系统范围的活动以保持 chunk 完全复制、平衡 chunk server 的负载、回收未使用的存储空间。</p>
<h4 id="命名空间管理和锁定">命名空间管理和锁定</h4>
<p>许多 master 操作可能需要很长时间：例如，snapshot 操作必须撤销该 snapshot 覆盖的所有 chunk 上的 lease。我们不想在其他 master 操作运行时延迟它们。因此，我们允许多个操作处于活动状态，并在命名空间的区域上使用锁以确保正确的序列化。</p>
<p>与许多传统文件系统不同，GFS 没有列出该目录中所有文件的逐目录数据结构，也不支持同一文件或目录的别名（有点像 Unix 中的硬链接或符号链接）。 GFS 在逻辑上将其命名空间表示为将完整路径名映射到 metadata 的查找表，并采用前缀压缩技术。命名空间树中的每个节点（绝对文件名或绝对目录名）都有一个关联的读写锁。</p>
<p>每个 master 操作在运行之前都会获取一组锁。通常，如果它涉及 /d1/d2/.../dn/leaf ，它将获取 leaf 路径上所有目录的读锁，以及其上的读锁或写锁（leaf 可能是文件或目录，具体取决于操作）。</p>
<blockquote>
<p>接下来说明这种锁定策略如何防止在 /home/user 被 snapshot 到 /save/user 时创建文件 /home/user/foo：snapshot 操作在 /home 和 /save 上获取读锁，并在 /home/user 和 /save/user 上获取写锁；文件创建在 /home 和 /home/user 上获得读锁，在 /home/user/foo 上获得写锁。这两个操作将被正确序列化，因为它们试图在 /home/user 上获得冲突的锁。文件创建不需要父目录上的写锁，因为没有“目录”或类似 inode 的数据结构可以防止修改，其上的读锁足以保护父目录不被删除。</p>
</blockquote>
<p>这种锁定策略的一个很好的特性是它允许在同一目录中进行并发修改。例如，可以在同一个目录中同时执行多个文件创建：每个文件都获取路径上父目录的读锁和该文件上的写锁。目录路径上的读锁足以防止目录被 delete、rename 或 snapshot；文件上的写锁对重复创建同名文件的操作进行序列化（从而避免这种操作的实现）。</p>
<p>命名空间可以有很多节点，读写锁对象被延迟分配，一旦不使用就被删除。此外，为防止死锁，锁以一定顺序获取：首先按命名空间树中的级别排序，若级别相同，则按字典序。</p>
<h4 id="副本放置">副本放置</h4>
<p>GFS 集群为多级别的高度分布，这要求分布数据具有良好的可扩展性、可靠性与可用性。副本放置策略应最大化数据可靠性和可用性，以及最大化网络带宽利用率，为做到这一点，必须跨机架分布 chunk 副本，这能确保在整个机架损坏或脱机的情况下，chunk 的某些副本仍在其它机架上存活并保持可用，同时读取 chunk 可以利用多个机架的聚合带宽。同样的，对 chunk 的写入也必须流经多个机架——这是一种 trade-off。</p>
<h4 id="创建create">创建(create)</h4>
<p>当 master 创建一个 chunk 时，会这样考虑：</p>
<ol type="1">
<li>为了均衡跨 chunk server 的磁盘利用率，希望将新副本放置在磁盘空间利用率低于平均水平的 chunk server 上；</li>
<li>希望限制每个 chunk server 上“最近”创建的副本数量，因为 chunk 是在写入需要时创建的，而在 append-once-read-many 工作负载中，其通常在完全写入后就变为只读；</li>
<li>希望将 chunk 副本分布在不同机架上。</li>
</ol>
<h4 id="再复制re-replicate">再复制(re-Replicate)</h4>
<p>当 chunk server 不可用、报告其副本可能已损坏、其中一个磁盘由于错误而变得不可用、复制目标增加时，都可能会导致可用副本的数量低于用户指定的数量，此时 master 会再复制一个 chunk。每个需要再复制的 chunk 都会根据几个因素进行优先级排序：</p>
<ol type="1">
<li>一是它离复制目标的距离有多远，比如丢失两个副本的 chunk 比只丢失一个副本的 chunk 拥有更高优先级；</li>
<li>二是 chunk 的活跃程度，我们更愿意再复制活跃文件的 chunk 而非最近被删除的文件的 chunk；</li>
<li>三是对于任何阻塞 client 进度的 chunk，其再复制优先级都会得到提升，以最大程度减少故障对应用程序的影响。</li>
</ol>
<p>在分配完优先级后，master 选择最高优先级的 chunk 并指示那些 chunk server 从有效的副本上进行复制，新副本的放置目标与创建目标相似：均衡磁盘利用率、限制单个 chunk server 上的操作以及跨机架分布副本。</p>
<h4 id="再平衡re-balance">再平衡(re-Balance)</h4>
<p>master 周期性地再平衡副本：检查当前副本分布并将其移动，以获得更好的磁盘空间和负载均衡。master 通过这一流程来逐渐填满新的 chunk server，而非用新的 chunk 和后续的写入。新副本的放置目标同上。此外，master 必须选择一些现有副本进行删除——它更偏向选择在可用空间低于平均水平的 chunk server 上的那些副本，以均衡磁盘空间利用率。</p>
<h4 id="垃圾回收garbage-collection">垃圾回收(garbage collection)</h4>
<p>文件被删除后，GFS 并<strong>不会立即回收内存</strong>，而是在文件和 chunk 级别的常规 gc 期间懒惰地回收。这样做的优点在于：</p>
<ol type="1">
<li>它在组件故障很常见的大规模分布式系统中简单可靠。chunk 的创建不一定在所有 chunk server 上成功，留下 master 不知道其存在的副本。而 gc 策略能够有效清理任何不知道是否有用的副本。</li>
<li>它将存储回收合并到 master 的常规后台活动中，如定期扫描命名空间和与 chunk server 的握手，因此它是分批完成的，能够摊销成本。而且这些活动仅在 master 空闲时进行——master 能更迅速响应需要及时关注的 client 请求。</li>
<li>存储回收的延迟提供了防止意外与不可逆删除的安全网。</li>
</ol>
<p>而其主要缺点是该延迟有时会阻碍用户在磁盘空间紧张时的使用。重复创建和删除临时文件的应用程序可能无法立即对原先空间进行重用。</p>
<p>如果删除的文件再次被显示删除，GFS 可以通过加快存储回收来解决这一问题。同时，GFS 允许用户对命名空间的不同部分应用不同的复制和回收策略。</p>
<h5 id="机制">机制</h5>
<p>应用程序删除文件后，master 会立即记录下来，但不立即回收资源，而是将其重命名为包含删除时间戳的隐藏名称。在 master 对命名空间定期扫描期间，若这些文件已存在超过一定时间，则会将其删除（在此之前其仍然可以在新的特殊名称下读取，并且可以通过将其重命名为正常名称来取消删除）。删除文件时，其内存中的 metadata 也将被删除。master 定期扫描期间，也会识别那些无法从任何文件访问的 chunk 并将其 metadata 擦除。在与 master 定期交换的 HeartBeat 消息中，每个 chunk server 报告其拥有的 chunk 的一个子集，并且 master 回复子集中所有不再存在于其 metadata 中的 chunk（根据文件到 chunk 的映射表），以便 chunk server 自由删除这些 chunk 的副本。</p>
<h4 id="旧副本检测">旧副本检测</h4>
<p>如果 chunk server 发生故障，并且在 chunk 关闭前未能及时对其进行修改，该 chunk 副本可能会变旧。master 为每个 chunk 维护一个版本号来区分是新副本还是旧副本。</p>
<p>每当 master 授予 lease 时，它会增加对应 chunk 的版本号并通知最新的副本。master 和这些副本都将最新的版本号持久化记录下来。如果一个副本不可用，则其版本号不会增加（也就是会变旧）。当 chunk server 重启并报告 master 其 chunk 子集及其版本号时，master 能够检测出旧的副本，并将更高的版本作为最新版本，这些旧的副本会在 gc 期间被删除。而当回复 client 的请求时，会将旧副本视为不存在。</p>
<p>当 master 通知 client 哪个 chunk server 拥有 lease 时，或当其只是一个 chunk server 在复制操作中从另一个 chunk server 读取该 chunk 时，会包含该 chunk 的版本号，client 或 chunk server 在执行操作时验证版本号，以便始终访问最新数据。</p>
<h3 id="容错与诊断">容错与诊断</h3>
<h4 id="高可用性">高可用性</h4>
<p>在 GFS 集群的服务器中，在任意给定时间内必然存在一些服务器不可用。以下两种策略来保证系统的高可用性。</p>
<h5 id="快速恢复">快速恢复</h5>
<p>master 和 chunk server 都会恢复其状态并在几秒钟内启动，无论它们是如何终止的。</p>
<h5 id="chunk-复制">chunk 复制</h5>
<p>每个 chunk 被复制到不同机架的多个 chunk server 上。master 根据需要复制副本，以在 chunk server 离线或通过校验和验证检测损坏的副本时保持每个 chunk 的完全复制。</p>
<h5 id="master-复制">master 复制</h5>
<p>为了可靠性，需要进行 master 状态的复制。其操作日志和 checkpoint 被复制到多台机器上，只有将其日志记录更新到本地磁盘和所有 master 副本上后，才会认为状态的修改已提交。简单起见，master 通过一个主进程负责所有修改以及后台活动，当其失败时也能立即重启。若机器或磁盘发生故障，GFS 的外部设备会在其他地方启动一个新的主进程。</p>
<p>此外，“shadow” master 提供对文件系统的只读访问，即便在 master 关闭期间。它们并非 master 的完全镜像，因为这些 shadow 的状态可能会稍微滞后于 master。事实上，client 读取的是存放在 chunk server 上的 chunk 内容，因此这一滞后并不会对结果产生多大影响。在这短时间内过时的可能是文件 metadata，如目录内容或访问控制信息。</p>
<p>为了让自己了解情况，shadow 读取操作日志的副本，并将其以与 master 完全相同的顺序执行应用。与 master 一样，它在启动时轮询 chunk server 以定位 chunk 副本并频繁与它们交换握手信息以监视其状态。shadow 对副本位置的更新仅依赖于 master 执行创建或删除副本决策所产生的结果。</p>
<h4 id="数据完整性">数据完整性</h4>
<p>每个 chunk server 使用校验和来检测存储数据的损坏与否。我们可以利用其他 chunk 副本从损坏中恢复，但不能通过与其它 chunk server 的副本进行对比来检测损坏。比如前文提到的原子 record append 并不能保证两个 chunk 副本完全相同。因此，每个 chunk server 必须通过维护校验和来独立验证自己副本的完整性。</p>
<blockquote>
<p>一个 chunk 会被分为若干 64 KB 大小的 block，每个 block 都有 32 位校验和，保存在内存中，并与日志记录一起持久化存储。</p>
</blockquote>
<p>对于读取，chunk server 会在返回数据前，验证与读取范围重叠的 block 的校验和，故不会讲损坏传播到其它机器。若一个 block 与记录的校验和不匹配，chunk server 会向请求者返回一个 error，并将不匹配的情况报告给 master。同时，请求者将从其他副本读取，而 master 从另一个副本处克隆该 block。在一个有效的新副本就位后，master 命令报告不匹配的 chunk server 删除其副本。</p>
<p>事实上，校验和几乎不会对读取性能产生影响。我们只需要读取并对少量额外数据的校验和进行验证。GFS client 通过尝试在校验和 block 边界对齐读取来进一步减少开销。并且校验和计算通常可以和 I/O 重叠。</p>
<p>对于 append，只是增量更新了最后一个 block 部分的校验和，并为新的 block 计算了新的校验和。即使最后一个 block 已损坏且无法被检测，新的校验和值也不会和存储的数据匹配，并且在下次读取时也会被检测到。</p>
<p>对于写入，如果覆盖了 chunk 的现有范围，则必须读取并验证被覆盖范围的第一个和最后一个 chunk，然后执行写入，最后计算并记录新的校验和。如果不验证被覆盖范围的第一个和最后一个 chunk，新的校验和可能会将未覆盖区域中存在的损坏给隐藏。</p>
<p>chunk server 会在空闲期间扫描和验证不活跃 chunk 的内容，一旦检测到损坏，master 可以创建新副本并删除损坏副本。</p>
<h3 id="诊断工具">诊断工具</h3>
<p>GFS 会生成诊断日志，记录重要事件以及所有 RPC 请求和恢复。这些日志可以任意删除且不会影响系统正确性，但应尽量保留。</p>
<p>RPC 日志包括请求和响应，但不包括正在读取或写入的文件数据。通过整理 RPC 日志，可以重建整个交互历史，从而进行问题诊断。日志也可以用于负载测试和性能分析。</p>
<p>由于这些日志是按顺序异步写入，因此性能影响很小。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Memcache</title>
    <url>/6-824/Memcache/</url>
    <content><![CDATA[<p>6.824 的第十一篇论文基于 <strong>Memcache</strong>——一款高性能的分布式内存对象缓存系统，以低成本提供对共享存储池的低延迟访问。Facebook 扩展了 Memcache 的架构，大大提高了性能与内存效率。</p>
<span id="more"></span>
<p>Facebook 的业务场景中决定了其工作负载以<strong>读取</strong>为主，在该情况下对数据进行缓存拥有显著优势。此外，其读取操作从多种来源（MySQL、HDFS 等）获取数据，这种异构性需要一种灵活的缓存策略，能够存储来自不同来源的数据。之所以选择 Memcache 是因为其提供的 api 简单（<code>Get, Set, Delete</code>）。</p>
<p>memcache 的相关操作如下图所示。</p>
<p><img src="image-20221109163322740.png" alt="image-20221109163322740" style="zoom:70%;" /></p>
<ul>
<li>当 Web Server 读取数据时，它首先访问 memcache，仅当未命中时才用 <code>SELECT</code> 语句访问 db，并重新插入 cache；</li>
<li>当 Web Server 写入数据时，它会用 <code>UPDATE</code> 语句更新 db，接着删除 memcache 中的旧值（下次访问该 key 时才会重新写回 memcache，保证幂等性）。这种<strong>按需填充</strong>的策略有效减轻了读取负载。此外，将 cache 层与 persist 层分开允许根据工作负载变化独立调整每个层。</li>
</ul>
<p>FB 优先考虑两个主要设计目标：</p>
<ol type="1">
<li>任何更改都必须针对用户或操作问题，很少考虑范围有限的优化；</li>
<li>将读取瞬态数据的可能性作为参数进行调整。FB 通过略微公开旧数据，以降低后端存储服务的负载。</li>
</ol>
<p>下文使用 <strong>memcached</strong> 来引用源代码或运行二进制文件，使用 <strong>memcache</strong> 来描述分布式系统。</p>
<h4 id="集群层次延迟与负载">集群层次：延迟与负载</h4>
<h5 id="降低延迟">降低延迟</h5>
<p><strong>memcached 的响应延迟</strong>是影响用户请求响应时间的关键因素。</p>
<p>尽管集群中提供了数百个 <strong>memcached server, ms</strong> 以减少负载，但 Web server 必须定期与多个 ms 通信以交换数据。这种通信模式可能会导致 <a href="https://www.mtyun.com/library/an-brief-intro-to-tcp-incast">Incast 拥塞</a>，或是任意单个 ms 成为短板。<strong>Replication</strong> 通常可以缓解短板问题，但总会导致显著的内存效率低下。</p>
<p>FB 主要通过关注在每个 Web server 上运行的 <strong>memcache client, mc</strong> 来降低延迟。mc 维护所有可用 ms 的映射，并通过辅助配置系统进行更新。</p>
<ul>
<li><p><strong>并行请求和批处理</strong>：构建 Web app 代码以最小化响应页面请求所需的网络往返次数。通过一个 DAG 表示数据之间的依赖关系。Web server 使用此 DAG 来最大化可以同时获取的数据数量。</p></li>
<li><p><strong>Client-Server 通信</strong>：ms 只与 mc 使用 <strong>UDP/TCP</strong> 进行通信。client 拥有一个称为 <strong>mcrouter</strong> 的独立代理。此代理提供了一个 ms 接口，并对网络消息进行路由。</p>
<ul>
<li>client 依靠 <strong>UDP</strong> 允许线程绕过 mcrouter 执行 <code>Get</code> 请求以减少延迟和开销，UDP 只处理错误而不进行恢复。若 <code>Get</code> 错误，client 会认为 memcache 未命中，但 Web server 将在查询数据后跳过插入，以避免增加负载。</li>
<li>由于需要确认状态更改，client 依靠 <strong>TCP</strong> 通过 mcrouter 执行 <code>Set/Delete</code> 请求以提高可靠性。</li>
</ul>
<p>下图表示通过 UDP 和通过 TCP 获取 key 的延迟。</p>
<p><img src="image-20221109205144053.png" alt="image-20221109205144053" style="zoom:67%;" /></p></li>
<li><p><strong>Incast 拥塞</strong>：client 使用<strong>滑动窗口机制</strong>来控制未完成请求的数量。当 client 收到响应才可以发送下一个请求，此滑动窗口的大小会随着请求的成功而缓慢增长。</p>
<p>下图显示了窗口大小对用户请求处于可运行状态但等待在 Web server 中进行调度的时间量的影响：窗口过小，应用将发送更多组连续的 memcache 请求，从而增加 Web 请求的持续时间；窗口过大，同时到达 memcache 请求的数量更多，导致 Incast 拥塞。</p>
<blockquote>
<p>一系列用户请求的到达呈现为<a href="https://towardsdatascience.com/the-poisson-distribution-and-poisson-process-explained-4e2cb17d459">泊松过程</a>。假设输入请求率是恒定的，则根据 <strong>Little Law</strong>: L = λW ，服务器中排队的请求数 (L)与处理请求所需的平均时间(W)成正比。</p>
</blockquote>
<p><img src="image-20221109211610473.png" alt="image-20221109211610473" style="zoom:67%;" /></p></li>
</ul>
<h5 id="降低负载">降低负载</h5>
<h6 id="lease">Lease</h6>
<p>lease 的提出是用来解决以下两个问题：</p>
<ol type="1">
<li><strong>失效集</strong>：对 memcache 的并发更新被重新排序时，会导致 memcache 中的值并不是最新值。</li>
<li><a href="https://zhuanlan.zhihu.com/p/65843741"><strong>惊群效应</strong></a>：当对一个特定的 key 进行大量的 RW 活动时，反复 write 会删除 memcache 中的值，导致许多 read 默认使用成本更高的路径——访问数据库而非 cache。</li>
</ol>
<p>当 client 遇到 cache miss 时，memcached 向 client 分配一个与 key 绑定的 lease。memcached 会检测尝试写回数据的 client 是否持有 lease 从而判断是否能够将数据写回。如果在这之前 memcached 收到对 key 的 <code>Delete</code> 操作，则 lease 失效。</p>
<p>通过定期分配 lease 来解决惊群效应——一般是每 10s——如果 client 在预计时间点之前发起请求，则会等待，而再次尝试时，数据已经存入 cache 中了，便无需访问数据库。这样可以大幅度减少 client 等待时间。</p>
<ul>
<li><strong>旧值</strong>：在某些情况下返回旧值能够进一步减少这一等待时间。有一个数据结构暂存近期被删除的值，但很快就会被刷掉。<code>Get</code> 或是返回 lease，或是返回这些被标记为过时的数据。可以继续向前推进的应用不需要等待从数据库中获取的最新值。</li>
</ul>
<h6 id="memcache-pool">Memcache Pool</h6>
<p>不同应用的工作负载在共享存储时会对彼此产生负面干扰，从而降低命中率。可以通过将集群的 ms 划分到不同的池中，具有相似工作负载的 ms 共享同一个池。下图为两个不同负载的工作集。</p>
<p><img src="image-20221112145220737.png" alt="image-20221112145220737" style="zoom: 80%;" /></p>
<h6 id="replication-with-pools">Replication with pools</h6>
<p>若池满足以下条件：</p>
<ol type="1">
<li>应用同时请求许多 key；</li>
<li>整个数据集能够放在一个或两个 ms 中；</li>
<li>请求率远高于单个 ms 可以承受的水平。</li>
</ol>
<p>则可以选择在池中复制某一类 key 来降低 ms 的延迟并提高效率。</p>
<h5 id="故障处理">故障处理</h5>
<p>无法从 memcache 中获取数据会导致后端服务负载过重，这可能会导致进一步的级联故障：</p>
<ol type="1">
<li>网络或服务器故障导致少量主机无法被访问；</li>
<li>大规模故障导致集群中大部分服务器宕机。</li>
</ol>
<p>发生小规模故障时，恢复需要一定时间，却足以导致上述级联故障。于是设置一组名为 <strong>Gutter</strong> 的机器专门来应对这种场景——接管那些故障服务器的职责。</p>
<ul>
<li>当 client 未收到请求的答复时，它认为相应 ms 故障，接着重新将请求发送至 <strong>Gutter Pool</strong>；</li>
<li>如果此请求仍未命中，client 将在查询数据库后将适当的 kv 对插入到 Gutter 机器中，这些 kv 对的有效期很短，以防止 Gutter 无效。</li>
</ul>
<h4 id="区域层次复制">区域层次：复制</h4>
<p>单纯通过增加服务器来扩展集群而不扩展系统并不能解决负载问题。需要将 web server 和 memcached server 拆分为多个<strong>前端集群</strong>(Frontend Cluster, FC)，与<strong>存储集群</strong>(Storage Cluster, SC)一起组成了一个 <strong>region</strong>。</p>
<h5 id="区域无效化">区域无效化</h5>
<p>SC 拥有数据的最新版本，FC 拥有数据复制，SC 负责发送 cache <strong>无效化</strong>(invalidation)命令来保持一致性。修改 SC 的 SQL 语句会附上需要在事务提交后无效的 memcache key。每个数据库中都有一个 <strong>mcsqueal</strong> 来检查其数据库提交的 SQL 语句，提取 <code>Delete</code> 并广播到该 region 中每个 FC 中的 ms。如下图所示。</p>
<p><img src="image-20221112163919753.png" alt="image-20221112163919753" style="zoom:67%;" /></p>
<ul>
<li><strong>减少数据包率</strong>：mcsqueal 直接与 ms 通信会浪费网络资源。通过将数据包发给 mcrouter，然后 mcrouter 将这些数据包发给 ms 是个比较好的解决方案。</li>
<li><strong>通过 web server 进行无效化</strong>：不让 Web server 直接向所有 FC 广播 invalidation 是因为
<ol type="1">
<li>Web server 在批量处理方面效率低，开销大；</li>
<li>当系统层面的 invalidation 问题（如错误路由删除和配置错误）发生时，依靠 mcsqueal 的补救措施更简单。</li>
</ol></li>
</ul>
<h5 id="区域池">区域池</h5>
<p>若每个集群都持有数据的副本，则会导致内存效率低下。可以让多个 FC 共享相同的多个 ms，称为<strong>区域池</strong>。</p>
<h5 id="冷集群预热">冷集群预热</h5>
<p>新集群加入时为空缓存的“冷集群”，大部分请求（因为 cache miss）都会指向数据库。<strong>Cold Cluster Warmup</strong> 系统允许“冷集群”中的 client 从“热集群”中获取数据，从而使得“冷集群”的 Cache 尽快填满。</p>
<p>然而当冷集群中的客户端 A 更新数据库，同时另一个客户端 B 在热集群收到 invalidation 之前从热集群中请求旧值时，会产生不一致性。memcached 选择在 <code>Delete</code> 后指定的延迟时间（默认 2s）内拒绝 <code>add</code>操作。</p>
<blockquote>
<p>当在冷集群中 cache miss 时，client 从热集群重新请求 key 并将其添加到冷集群中。<code>add</code> 失败表明数据库上有更新的数据，因此 client 将从数据库中重新请求值。</p>
</blockquote>
<h4 id="跨区域一致性">跨区域：一致性</h4>
<p>在多个地理位置部署数据中心有以下好处：</p>
<ol type="1">
<li>将网络服务器放置在更靠近最终用户的位置可以显著降低延迟；</li>
<li>地理多样性可以减轻自然灾害或大规模停电等事件的影响；</li>
<li>新位置可以提供更便宜的电力和其他经济激励措施。</li>
</ol>
<p>FB 将跨区域系统架构设计为一个 <strong>master region</strong> 管理 primary DB，其他 <strong>slave region</strong> 管理 ReadOnly 的 replica，如下图所示。</p>
<p><img src="image-20221109201537652.png" alt="image-20221109201537652" style="zoom:67%;" /></p>
<p>这一方案往往会因为 replicas 滞后于 primary 而产生不一致性问题。FB 的设计理念为：尽最大努力提供最终的一致性，但强调性能和可用性。</p>
<p><strong>从主区写入</strong>：通过 mcsqueal 发送 invalidation 的策略避免了 invalidation 在更新数据之前到达。</p>
<blockquote>
<p>考虑在 master 中的 Web server 更新完数据库，但修改尚未发送到 backup，在此之前抢先发送 invalidation 会与后续对 backup 数据的查询发生竞争，从而增加将旧数据写入 memcache 的概率。</p>
</blockquote>
<p><strong>从非主区写入</strong>：若一个用户更新了非主区域的数据，如果复制延迟过大，一旦最近的更改丢失，其下一个请求可能会出错。因此只有在复制完毕后才允许从 replica db 重新填充 memcache。</p>
<p>FB 采用 <strong>remote mark</strong> 机制来最小化读取旧数据的概率。若本地的数据被打上标记，表明该数据可能是旧的，并且查询应该被重定向到 master。当 Web server 更新 key 对应的 value 时：</p>
<ol type="1">
<li>在 region 中设置标记 <span class="math inline">\(r_k\)</span>；</li>
<li>将 k-v 写入 master，并指明 key 和 <span class="math inline">\(r_k\)</span> 无效</li>
<li>删除本地集群中的 key。</li>
</ol>
<p>在后续请求 key 时，若 cache miss 且 <span class="math inline">\(r_k\)</span> 存在，则将查询重定向到 master 或本地区域。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Spanner</title>
    <url>/6-824/Spanner/</url>
    <content><![CDATA[<p>6.824 的第八篇论文是 <strong>Spanner</strong>—— Google 的可扩展、多版本、全球分布和同步复制的数据库。它是第一个在全球范围内分发数据并支持外部一致的分布式事务的系统。</p>
<span id="more"></span>
<h4 id="简介">简介</h4>
<p>Spanner 中的数据是<strong>多时间版本化</strong>的，每个版本都会自动加上其提交时间的<strong>时间戳</strong>(timestamp)。ts 反映序列化顺序，即：如果事务 <span class="math inline">\(T_1\)</span> 在另一个事务 <span class="math inline">\(T_2\)</span> 开始之前提交，则 <span class="math inline">\(T_1\)</span> 的 commit ts 小于 <span class="math inline">\(T_2\)</span>。 这一机制归功于 <strong>TrueTime API </strong> 设计，通过使用多个现代时钟参考（GPS 和原子钟）来保持较小的不确定性。</p>
<blockquote>
<p>Spanner 是第一个在全球范围内提供此类保证的系统。</p>
</blockquote>
<p>作为一个全球分布的数据库，Spanner 不仅提供了以下特性：</p>
<ol type="1">
<li>数据的复制配置可以由应用程序动态控制；</li>
<li>应用程序可以指定哪些 data center 包含哪些数据、数据与用户之间的距离（以控制读取延迟）、副本之间的距离（以控制写入延迟）以及维护的副本数量（以控制持久性、可用性和读取性能）</li>
<li>Spanner 支持跨机器重新<strong>分片</strong>(Sharding)数据，并且能在 data center 之间动态移动数据，以平衡负载。</li>
</ol>
<p>还提供了两个在分布式数据库中难以实现的特性：</p>
<ol type="1">
<li>满足<strong>外部一致性</strong>的读取和写入；</li>
<li>利用 <strong>TrueTime</strong> 实现基于 ts 的跨数据库的全局一致读取。</li>
</ol>
<h4 id="实现">实现</h4>
<p>Spanner 部署称之为 <strong>universe</strong>，它由一系列<strong>区域</strong>(zones)组成，每个 zone 都是管理部署的单位。一个 zone 有一个 <strong>zonemaster</strong> 和若干 <strong>spanservers</strong>，前者负责将数据分配给后者，后者负责向客户提供数据。其结构如图所示：</p>
<p><img src="image-20221015173114863.png" alt="image-20221015173114863" style="zoom:80%;" /></p>
<h5 id="spanserver-软件栈结构">SpanServer 软件栈结构</h5>
<p>每个 spanserver 在底层负责若干个称为 <strong>tablet</strong> 的数据结构实例，每个 tablet 是表中的部分数据。</p>
<p>spanserver 采用 <strong>Paxos</strong> 协议来实现复制。为了提高 Paxos 算法的性能，他们并不是将整个机器作为 Paxos 的处理单位，而是将 spanserver 上的数据进行划分，并分配到不同的 Paxos Group，每次运行 Paxos 都仅由相关的 Paxos Group 参与。写操作必须发给 Leader，而读操作可以发给任意足够 up-to-date 的 replica 然后从其 tablet 中读取。</p>
<p><img src="image-20221016231043963.png" alt="image-20221016231043963" style="zoom:50%;" /></p>
<p>所有这些都在一个名为 <strong>Colossus</strong> 的分布式文件系统上。如图所示：</p>
<p><img src="image-20221016161752140.png" alt="image-20221016161752140" style="zoom:67%;" /></p>
<blockquote>
<p>当前的 Spanner 实现会对每个 Paxos 写入进行两次记录：一次在 tablet 的日志中，一次在 Paxos 日志中。</p>
</blockquote>
<p>spanserver 中会有一个 longlive 的 <strong>Leader</strong>，它拥有</p>
<ol type="1">
<li>一个<strong>锁表</strong>(lock table)来实现并发控制。锁表用于<strong>两阶段锁定</strong>(2PL)。只有需要同步的操作才会获取锁。</li>
<li>一个<strong>事务管理器</strong>(transaction manager)来支持分布式事务。只有当一个事务涉及多个 Paxos Group 时，事务管理器才参与其中，其中一个 Paxos Group 被选为<strong>协调者</strong>(coordinator)，该组的 <strong>participant Leader</strong> 将成为 <strong>coordinate Leader</strong>。每个事务管理器的状态存储在底层 Paxos Group 中（因此也会被复制）。</li>
</ol>
<h5 id="目录">目录</h5>
<p>为了进一步提高性能，将 Paxos Group 进一步划分为<strong>目录</strong>(Directory)——它是一组<strong>共享公共连续前缀</strong>的键。Directory 是数据迁移和负载均衡的基本单位，其所有数据都具有相同的复制配置。如下图所示。</p>
<blockquote>
<p>事实上，Spanner 会将一个过大的目录分片成多个<strong>片段</strong>（片段可能来自不同的 Paxos 组）。 Movedir 在组间移动片段，而不是整个目录。</p>
</blockquote>
<p><img src="image-20221016170724711.png" alt="image-20221016170724711" style="zoom:70%;" /></p>
<p><strong>Movedir</strong> 是用于在 Paxos 组之间移动目录以及向 Paxos 组添加或删除副本的后台任务。Movedir 并不作为单个事务实现，操作的时候是先将实际数据移动到指定位置，然后再用一个原子的操作更新元数据，完成整个移动过程。故 Movdir 不会阻塞当前 client 的操作。</p>
<h5 id="数据模型">数据模型</h5>
<p>Spanner 从原先 BigTable 的类关系型数据库变成了采用以下键值映射的类 KV 型数据库： <span class="math display">\[
(key:string,\quad timestamp:int64) \rightarrow string
\]</span> 同时 Spanner 向应用程序提供</p>
<ul>
<li>基于模式化半关系表的数据模型</li>
<li>查询语言</li>
<li>通用事务</li>
</ul>
<p><strong>Megastore</strong>支持模式化半关系表和同步复制的需求，它的数据模型更易于管理，而且支持跨 data center 的同步复制，Bigtable 仅支持跨 data center 的最终一致性复制。</p>
<p>Spanner 的数据模型是<strong>半关系</strong>的原因在于，每个表都需要有一组有序的 primary key。这使得 Spanner 仍然看起来像 KV 存储。</p>
<p>下图包含一个示例 Spanner 模式。客户端应用程序通过 <code>INTERLEAVE IN</code> 声明层次结构。<code>ON DELETE CASCADE</code> 表示删除目录表中的行会删除任何关联的子行。这种将表交错形成目录的设计允许客户端描述存在于多个表之间的局部关系，这能够提升分片分布式数据库的性能。</p>
<p><img src="image-20221017112002830.png" alt="image-20221017112002830" style="zoom:67%;" /></p>
<h4 id="truetime">TrueTime</h4>
<p>考虑到时间不确定性（如通信延迟），<strong>TrueTime</strong>并不表示某一特定时刻，而是将时间表示为一个具有有限时间不确定性的时间区间 <strong>TTinterval: [earliest, latest]</strong>。 TTinterval 的端点是 <strong>TTstamp</strong> 类型。 TrueTime API 包括以下方法：</p>
<ol type="1">
<li><strong>TT.now()</strong>：返回 TTinterval，并保证调用该方法的绝对时刻属于该区间；</li>
<li><strong>TT.after(t)</strong>：若时刻 <span class="math inline">\(t\)</span> 已过去，则返回 true；</li>
<li><strong>TT.before(t)</strong>：若时刻 <span class="math inline">\(t\)</span> 还未到，则返回 true。</li>
</ol>
<p>TrueTime 利用 GPS 和原子钟两种策略进行时钟参考，因为它们会以和彼此无关的方式出现故障，故其中一个方法发生故障后，可以立刻采用另一种方法。每个 data center 都有一组 <strong>time master</strong>，大多数使用 GPS，剩下的配备了原子钟。通过定期综合比较两种 master 得到一个时间点。</p>
<h4 id="并发控制">并发控制</h4>
<h5 id="timestamp-管理">timestamp 管理</h5>
<p>Spanner 支持 <strong>read-write 事务</strong>、<strong>read-only 事务</strong>和 <strong>snapshot read</strong>，单独写入为 RW 事务；非快照单独读取为 RO 事务。如下表所示：</p>
<p><img src="image-20221017132537748.png" alt="image-20221017132537748" style="zoom:67%;" /></p>
<p>RO 事务是一种具有快照隔离性能优势的事务，其以系统指定的 ts 执行，而无需锁定。</p>
<p>client 可以为 snapshot read 指定 ts，或指定时间边界并让 Spanner 选择合适的 ts。无论是 snapshot read 还是 read-only，都会在足够 up-to-date 的 replica 上直接读取。</p>
<p>无论是 RO 事务还是 snapshot read，一旦指定了 ts，就必然会 commit，除非该 ts 处的数据已被 garbage collection。当服务器发生故障时，客户端可以继续在不同服务器上通过 ts 和当前读取位置进行查询。</p>
<blockquote>
<p>RW: ts = COMMIT TIME；RO: ts = START TIME</p>
</blockquote>
<h5 id="paxos-leader-lease">Paxos Leader Lease</h5>
<p>Spanner 中 Paxos 的 <strong>lease</strong> 默认为 10 秒。如果租约到期，Leader 会请求延长 lease 投票。同时，Spanner 允许 Paxos Leader 主动退位。</p>
<p>每个 Paxos Group 中不同 Leader 的 lease 互不相交。为了保持这一 <strong>lease 不相交性</strong>，定义 <span class="math inline">\(s_{max}\)</span> 为旧 Leader 的最大 ts，新 Leader 必须等到 <span class="math inline">\(TT.after ( s_{max} ) = true\)</span> 才能开始工作。</p>
<h5 id="rw-事务">RW 事务</h5>
<p>RW 事务使用 2PL，故只能在获取所有锁之后与释放所有锁之前的任意时刻分配 ts。对于给定的写事务，Spanner 会选择 Paxos 为提交事务的那次 Paxos Write 分配的时间戳。</p>
<p>在每个 Paxos Group 内，Spanner 以单调递增的顺序为 Paxos Write 分配 ts。这一约束通过 <strong>lease 不相交性</strong>在不同 Leader 之间进行约束：Leader 只在其 lease 内分配 ts。</p>
<p>Spanner 使用 2PC 提交事务，为保证<strong>外部一致性</strong>，Spanner 作出以下约束：如果事务 <span class="math inline">\(T_2\)</span> 的 start 发生在事务 <span class="math inline">\(T_1\)</span> commit 之后，则 <span class="math inline">\(T_2\)</span> 的 commit ts 必须大于 <span class="math inline">\(T_1\)</span> 的 commit ts。并且执行事务和分配 ts 的协议遵循以下两条规则：</p>
<ul>
<li><strong>START</strong>：写事务 <span class="math inline">\(T_i\)</span> 分配的 commit ts <span class="math inline">\(s_i\)</span> 满足 <span class="math inline">\(s_i \geq TT.now().latest\)</span> 且 <span class="math inline">\(s_i &gt; t_{abs}(e^{server}_i)\)</span>；</li>
<li><strong>COMMIT WAIT</strong>：client 在 <span class="math inline">\(TT.after ( s_i ) = true\)</span> 之前无法看到 <span class="math inline">\(T_i\)</span> 提交的任何数据且 <span class="math inline">\(s_i &lt; t_{abs}(e^{commit}_i)\)</span>。</li>
</ul>
<p>证明如下：</p>
<p><img src="image-20221017142509253.png" alt="image-20221017142509253" style="zoom:80%;" /></p>
<p>其中 <span class="math inline">\(e^{start}_i\)</span> 和 <span class="math inline">\(e^{commit}_i\)</span> 为事务启动和提交事件，<span class="math inline">\(e^{server}_i\)</span> 为事务 commit 请求到达 coordinate Leader 的事件。</p>
<p>同时，为了保证任意读取都是可靠且安全的，每个 replica 都会跟踪一个称为<strong>安全时间</strong>的值 <span class="math inline">\(t_{safe}\)</span>。replica 可以满足任意 <span class="math inline">\(ts \leq t_{safe}\)</span> 的读取。</p>
<p><span class="math inline">\(t_{safe}\)</span> 定义为 <span class="math inline">\(\min (t^{Paxos}_{safe},\ t^{TM}_{safe})\)</span></p>
<p><span class="math inline">\(t^{Paxos}_{safe}\)</span> 是最新已应用的 Paxos 写入的 ts。因为 ts 单调增加并且写入是按顺序应用的，对于 Paxos 而言，不会有 ts 小于等于 <span class="math inline">\(t^{Paxos}_{safe}\)</span> 的写入。</p>
<p>如果不存在 prepared 但未 commit 的事务，则 <span class="math inline">\(t^{TM}_{safe}\)</span> 为 <span class="math inline">\(\infty\)</span>；反之，replicas 还不知道该事务是否会提交，每个 Paxos Group <span class="math inline">\(g\)</span> 的 Leader 为其分配一个 prepare ts <span class="math inline">\(s^{prepare}_{i,g}\)</span> 并确保 <span class="math inline">\(s_i \geq s^{prepare}_{i,g}\)</span>。有 <span class="math inline">\(t^{TM}_{safe} = \min_i ( s^{prepare}_{i,g} ) - 1\)</span>。</p>
<p>事务中发生的 write 会在客户端缓存直至提交，这使得事务中的 read 看不到事务 write 的影响。这种设计在 Spanner 中运行良好，因为读取返回任何数据读取的时间戳，而未提交的写入尚未分配时间戳。整个事务的具体流程如下：</p>
<ol type="1">
<li><p>client 发出 read 请求，Spanner 找到合适的 replica 并获取 read lock，然后读取最新数据。当 client 保持 open 时，它会发送 keep-alive 消息以防止 Leader 超时；</p></li>
<li><p>当 client 完成所有 read 并缓存所有 write 时，它开始 2PC；</p></li>
<li><p>client 在 Paxos Group 间选出 coordinate Group 并向其它 Group 的 Leader 发送 commit 消息；</p></li>
<li><p>participant Leader 首先获得 write lock，然后它选择一个 prepare ts，并通过 Paxos 作好 prepare 记录，之后每个 participants 将其 prepare ts 通知 coordinate；</p>
<p>coordinate Leader 也首先获取 write lock，但跳过 prepare 阶段。在收到所有其他 participant Leader 的消息后，它会为整个事务选择一个大于所有 prepare ts 的 commit ts <span class="math inline">\(s\)</span>。然后 coordinate Leader 通过 Paxos 记录进行 commit；</p></li>
<li><p>coordinate Leader 等待直到 <span class="math inline">\(TT.after(s)\)</span> 后，允许 coordinate replica 应用 commit 记录（保证 COMMIT WAIT）；</p></li>
<li><p>coordinate 将 <span class="math inline">\(s\)</span> 发送给 client 和所有其他 participant Leader，每个 participant Leader 都通过 Paxos 记录事务的结果。所有 participants 在相同的 ts 处应用该结果，然后释放锁。</p></li>
</ol>
<blockquote>
<p>read-write 事务中的 read 使用 <strong>wound-wait</strong> 来避免死锁。</p>
</blockquote>
<h5 id="ro-事务">RO 事务</h5>
<p>RO 事务分两个阶段执行：</p>
<ul>
<li>先分配一个时间戳 <span class="math inline">\(s_{read}\)</span>；</li>
<li>在 <span class="math inline">\(s_{read}\)</span> 处将事务的读取按照 snapshot read 执行。</li>
</ul>
<p>在事务开始后的任何时间进行 <span class="math inline">\(s_{read} = TT.now().latest\)</span> 的赋值，通过类似于 RW 事务中的参数来保持<strong>外部一致性</strong>。如果 <span class="math inline">\(t_{safe}\)</span> 没有充分推进，可能需要阻塞在 <span class="math inline">\(s_{read}\)</span> 处执行的读取。为了避免阻塞的发生，Spanner 应该分配能够保持外部一致性的最老的 ts。</p>
<p>整个事务的具体流程如下：</p>
<ol type="1">
<li>如果事务只涉及一个 Paxos Group，则 client 直接向该 Group 的 Leader 发出 RO 事务。将 <span class="math inline">\(LastTS()\)</span> 定义为 Paxos Group 中最后 commit 的 write 的 ts。如果没有事务 prepared，则令 <span class="math inline">\(s_{read} = LastTS()\)</span> 即可满足外部一致性：事务将看到最后一次 write 的结果；</li>
<li>反之，需要所有参与 read 的 Paxos Group 之间进行协商来决定 ts。Spanner 目前避免了一轮沟通，而是令 client 只在 <span class="math inline">\(s_{read} = TT.now().latest\)</span> 处执行 read（可能会等待 <span class="math inline">\(t_{safe}\)</span>）。事务中的所有 read 都可以发送到足够 up-to-date 的 replica。</li>
</ol>
<h4 id="总结">总结</h4>
<p>Spanner 优雅地利用了 TrueTime 实现了外部一致性以及其它强大特性，这是前所未有的创新设计。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark</title>
    <url>/6-824/SPARK/</url>
    <content><![CDATA[<p>6.824 的第十篇论文是 <strong>Spark</strong>——一个基于弹性分布式数据集(<strong>Resilient Distributed Dataset, RDD</strong>)的容错数据处理框架，能够帮助用户简单的开发快速，统一的大数据应用，对数据进行，协处理，流式处理，交互式分析等。</p>
<span id="more"></span>
<h4 id="背景">背景</h4>
<p>大多数计算框架在处理需要重复使用中间结果的问题（如迭代机器学习和图算法）时，重用数据的唯一方法是将其写入外存，这会导致大量开销，从而效率低下。然而，当前能解决该问题的专用计算框架只支持特定的计算模式，却没有为更一般的数据重用提供抽象。</p>
<p>于是 RDD 被提出。这是一种容错的分布式内存抽象，它允许用户将中间结果保存在内存中以实现高效的数据重用，同时控制其分区以优化数据放置，并支持广泛的计算模式，从而提供高性能与高兼容性。</p>
<blockquote>
<p>但 RDD 不太适合对共享状态进行异步细粒度更新的应用程序，例如 Web 应用程序的存储系统或增量 Web 爬虫。使用执行传统更新日志记录和数据检查点的系统更有效。</p>
</blockquote>
<p>与之前的系统相比，RDD 提供了一个基于<strong>粗粒度</strong>变换(<strong>transformation, Trans</strong>)的接口，将相同的变换操作应用于多个数据项。只要记录下用于构建数据集的 Trans 操作，就能在一个分区丢失时很快地恢复数据，而无需进行昂贵的复制。<strong>容错性</strong>于是得到了保证。</p>
<h4 id="rdd">RDD</h4>
<p>RDD 本质上是一个<strong>只读</strong>且<strong>分区</strong>的记录集合。Spark 将 RDD 表示为对象，使用对象的方法来操作 RDD：</p>
<ul>
<li><p><strong>Transformation/Trans</strong>：基于持久化存储中的源数据或其他 RDD 派生出新的 RDD。如 map(), filter(), join()；</p></li>
<li><p><strong>Actions/Acts</strong>：对 RDD 中的数据进行计算并将计算结果返回给上层或导出到存储系统。如 count(), collect(), save()；</p>
<p><img src="image-20221029183028035.png" alt="image-20221029183028035" style="zoom:60%;" /></p>
<blockquote>
<p>Trans 不会触发 Spark；只有在首次进行 Acts 时，Spark 才真正开始运作并调度计算任务。这是典型的<strong>惰性计算</strong>。</p>
</blockquote></li>
</ul>
<p>read-only 属性决定了 RDD 只能通过通过 Trans 派生而来。RDD 会记录足够多的 Trans 信息（比如是从哪个 RDD 派生）， 即 <strong>Lineage</strong>，以便在分区丢失时进行数据恢复，且只恢复丢失的那个分区。而如果 RDD 丢失了 Lineage 信息，它将不能被任何程序调用。下图为一个包含 3 个 Trans 的 Lineage 图：</p>
<p><img src="image-20221029164150596.png" alt="image-20221029164150596" style="zoom:80%;" /></p>
<p>用户还可以控制 RDD 的另外两个方面：</p>
<ol type="1">
<li><strong>持久性</strong>：用户可以调用 <strong>persist</strong> 方法来持久化 RDD 以重用。 Spark 默认将 RDD 持久化在内存中，但如果 RAM 不足，则会 split 到磁盘。通过修改 persist 方法中的 <strong>flag</strong>，用户还可以请求其他持久化策略。还可以在每个 RDD 上设置一个持久化优先级，以指定哪些内存中的数据应该首先 split 到磁盘。</li>
<li><strong>分区</strong>：用户可以要求基于每条记录中的 key 将 RDD 的元素跨机器分区。</li>
</ol>
<h5 id="rdd-作为分布式内存抽象的优势">RDD 作为分布式内存抽象的优势</h5>
<p><img src="image-20221029183627267.png" alt="image-20221029183627267" style="zoom:67%;" /></p>
<p>分布式共享内存(Distributed Shared Memory, DSM) 系统是一个非常通用的抽象，但是这种通用性使得在集群上难以实现高效和容错的方式。RDD 和 DSM 之间的区别在以下几点：</p>
<ol type="1">
<li>RDD 只能通过粗粒度 Trans 来创建，这限制了 RDD 只能批量执行写入，但能通过 Lineage 实现更有效的容错；而 DSM 允许对每个内存位置进行读写，但一旦数据损坏，所有数据都要重新还原或重做。</li>
<li>RDD 允许系统启动 backups 来并行执行慢节点的任务从而缓解短板；而在 DSM 中慢节点会拖累所有节点。</li>
</ol>
<p>RDD 还有两大优势：</p>
<ol type="1">
<li>在 RDD 的批量操作中，可以通过物理上更近的节点调度任务以提高性能。</li>
<li>当没有足够的内存来存储 RDD 时，溢出的分区可以存储在磁盘上，并将提供与当前数据并行系统相似的性能。</li>
</ol>
<h5 id="spark-集群">Spark 集群</h5>
<p>Spark 由 Driver 程序启动，并将任务分发至多个 Worker 节点。Driver 跟踪 RDD 的 Lineage；Worker 将 RDD 分区存储在 RAM 中。如下图所示：</p>
<p><img src="image-20221029192204791.png" alt="image-20221029192204791" style="zoom:80%;" /></p>
<h5 id="rdd-表示">RDD 表示</h5>
<p>一个 RDD 由以下部分组成：</p>
<ul>
<li>数据集的原子分区；</li>
<li>对父 RDD 的依赖；</li>
<li>基于父分区计算当前分区的 Trans 函数；</li>
<li>分区方案和数据地址相关的元数据。</li>
</ul>
<h5 id="rdd-依赖">RDD 依赖</h5>
<p>RDD 在物理形式上是分区的，其完整数据被分散在集群内若干机器的内存上。在利用 Trans 进行派生时，根据 Trans 操作的不同， 子 RDD 会与父 RDD 产生不同依赖关系：</p>
<ul>
<li><strong>Narrow Dependency</strong>：每个父分区最多生成一个子分区，如 map(), filter()；</li>
<li><strong>Wide Dependency</strong>：每个父分区能够生成多个子分区，而每个子分区可能都只依赖各个父分区中的一部分，如 groupBy(), join()。</li>
</ul>
<p><img src="image-20221029202838415.png" alt="image-20221029202838415" style="zoom:80%;" /></p>
<p>进行上述区分有以下两点好处：</p>
<ol type="1">
<li><strong>数据传输</strong>：Narrow Dependency 的每个父分区只会传入到一个子分区中，可以在一个节点内流水线式地完成转换；而 Wide Dependency 需要将父分区的数据传输到多个子分区中，往往有 shuffle 操作。</li>
<li><strong>故障恢复</strong>：Narrow Dependency 下的节点故障后的恢复效率更高，且可以在不同的节点上并行进行；而在 Wide Dependency 中，单个故障节点需要多个分区联合执行恢复，且对父分区的重新计算会产生冗余数据。</li>
</ol>
<h4 id="任务调度">任务调度</h4>
<p><img src="image-20221029235718195.png" alt="image-20221029235718195" style="zoom:80%;" /></p>
<p>每当用户在 RDD 上运行 Acts 时，调度器(<strong>Scheduler</strong>)根据 Lineage 图与该 RDD 的依赖关系，对不同 Acts 过程的执行进行阶段(<strong>stage</strong>)划分，如上图所示。stage 的<strong>划分依据</strong>即宽窄依赖：从后往前，遇到宽依赖的 Acts 便进行划分。之后，Scheduler 便生成任务(<strong>task</strong>)并将其分配给不同节点。</p>
<p>task 的分配基于<strong>数据局部性</strong>。如果 task 需要的分区存储在某个节点的内存中，则将其发送到该节点；否则，将 task 发送给 RDD 指定的 preferred 节点。对于 WD，在持有父分区的节点上保存中间产物以加速故障恢复。</p>
<p>一旦 task 失败，只要它的父 RDD 仍然可用，Spark 就会在另一个节点上重新执行该 task。反之，则根据 Lineage 图重新生成父 RDD，随后再执行任务即可。目前 Spark 还不能容忍 Scheduler 的故障，所以一旦 Scheduler 挂了，所有的工作也白费了。</p>
<h4 id="内存管理">内存管理</h4>
<p>Spark 为 RDD 持久化存储提供了三种方案：</p>
<ol type="1">
<li><strong>内存中的反序列化 Java 对象</strong>：这提供了最快的性能，因为 JVM 可以在本地访问每个 RDD 元素；</li>
<li><strong>内存中的序列化数据</strong>：这允许用户在空间有限时选择比 Java 对象图更节省内存的表示，但会降低性能；</li>
<li><strong>磁盘存储</strong>：这对于那些太大而无法保存在 RAM 中但每次使用时重新计算成本高昂的 RDD 很有用；</li>
</ol>
<p>当计算出一个新的 RDD 分区但没有足够的空间来存储它时，会使用 <strong>LRU</strong> 策略进行内存回收，以给新分区提供空间。除此之外，还可以通过设置每个 RDD 的持久性优先级提供进一步的控制。</p>
<h4 id="检查点">检查点</h4>
<p>前文提到 Lineage 可以有效进行故障恢复，但对于具有长 Lineage 链的 RDD 则容易耗费太多时间，无法体现较好性能。将一些 <strong>checkpoint</strong> 持久化到存储能很好的解决此问题。</p>
<p>一般来说，检查点对于 WD 的长 Lineage 图很有用，因为集群中的节点故障可能会导致每个父 RDD 丢失一些数据片段，需要完全重新计算。而对于对 ND 的 RDD，checkpoint 则没那么必要，如果一个节点发生故障，这些 RDD 中丢失的分区可以在其他节点上并行重新计算，而成本只是复制整个 RDD 的一小部分。</p>
<p>Spark 目前提供了一个用于检查点的 API，将决策权留给了用户，即 <strong>REPLICATE</strong> 标志。</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><span class="line">rdd.persist(<span class="type">REPLICATE</span>)</span><br></pre></td></tr></table></figure>
<p>RDD 的 read-only 性质使得它们比一般的共享内存更容易实现 checkpoint，因为一致性不是问题，RDD 可以在后台创建，而不需要程序暂停或分布式快照方案。</p>
<h4 id="总结">总结</h4>
<p>RDD 是一种分布式内存抽象，允许用户将中间结果保存在内存中以实现高效的数据重用，同时支持广泛的计算模式。</p>
<p>RDD 利用了 Lineage 大大简化了节点失效后的数据恢复过程。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>Aurora</title>
    <url>/6-824/aurora/</url>
    <content><![CDATA[<p>6.824 的第六篇论文是 <strong>Aurora</strong>——一个高性能，高可靠的关系数据库服务。在处理事务的速度上，Aurora 宣称比其他数据库快 35 倍。同时，其完全抛弃了通用存储，转而构建了自己<strong>应用定制的存储</strong>。</p>
<span id="more"></span>
<h4 id="aurora-产生背景">Aurora 产生背景</h4>
<h5 id="ec2elastic-cloud-2">EC2(Elastic Cloud 2)</h5>
<p>这是 Amazon 最早的云产品。Amazon 有装满了服务器的数据中心，并且每个服务器上都会运行一个 VMM(<strong>Virtual Machine Monitor</strong>)，以及一些 EC2 实例。每个实例在运行一个标准的操作系统的同时，出租给不同的用户。每个 EC2 的操作系统之上运行着 Web 服务或数据库等应用程序。这种方式成本低，且相对容易配置，在早期是一个成功的服务模式。</p>
<p>最早的时候，EC2 使用的都是服务器上的硬盘，每个 EC2 实例都会分到硬盘的一部分空间。</p>
<p>对于无状态的 Web 应用，如果客户数量增加了，可以通过租用更多 EC2 实例来对 Web 服务扩容，尽管服务器崩溃了，只需要在另一台服务器上启动一个新的 EC2 实例就好了。而对于数据库而言，一旦服务器崩溃了，其本地硬盘将无法访问，运行在服务器上的数据库 EC2 实例也将失效——因为数据丢失了。</p>
<p>Amazon 本身有实现块存储的服务，叫 S3。可以定期对数据库做快照，然后存到 S3 上，并基于快照来实现故障恢复。但也有可能失去两次快照之间的数据，</p>
<h5 id="ebselastic-block-store">EBS(Elastic Block Store)</h5>
<p>它表现得像个硬盘，具有容错性，且支持持久化存储的服务，其底层是一对互为副本的存储服务器。当用户要使用数据库 EC2 时，可以将一个 EBS 挂载为自己的硬盘。</p>
<p>当数据库执行写操作时，数据会通过网络传输到 EBS 服务器，之后，那一对存储服务器会使用 <strong>Chain Replication</strong> 进行数据复制。</p>
<blockquote>
<p>第一个服务器处理写，第二个服务器处理读。</p>
</blockquote>
<p>虽然 EBS 的出现能够在一定程度上避免因服务器崩溃而导致的数据丢失，但却会产生大量的网络流量，并且容错性并没有得到很好的保障——两个存储服务器会放在同个数据中心（在 paper 中称为 <strong>AZ, Available Zone</strong>）中，也就意味着一旦数据中心崩溃了，那就没辙了。</p>
<h5 id="rdsrelational-database-service">RDS(Relational Database Service)</h5>
<p>RDS 尝试将数据进行跨 AZ 复制，这样就算整个 AZ 挂了，用户还可以从另一个 AZ 中获取数据。</p>
<p>对于 RDS 而言，有且仅有一个 EC2 实例作为<strong>主数据库</strong>，这个数据库将其 data page 和 WAL log 存在 EBS，EC2 和 EBS 都在同一个 AZ <span class="math inline">\(AZ_1\)</span> 中。每次数据库执行写操作时，RDS 会自动将写操作拷贝到另一个 AZ <span class="math inline">\(AZ_2\)</span> 中的<strong>副数据库</strong> EC2 实例上，这个 EC2 的工作就是执行和主数据库相同的操作，写入成功后，会发一个 ack 给主数据库，主数据库看到了这个 ack 后才会认为真正意义上的写入成功。</p>
<p>但实际上，这样还是会通过网络传输相当大量的数据。</p>
<h4 id="aurora">Aurora</h4>
<p>在 Aurora 的架构中，会有 <span class="math inline">\(V\)</span> 个数据副本代替 EBS 的位置，分别存放在 <span class="math inline">\(z\)</span> 个不同的 AZ 中。与此同时，Aurora 通过网络传输的是 <strong>log 条目</strong>而非 data page，这也大大提高了网络性能。当然，这也就导致了 Aurora 的存储系统不再是只能理解 data 的通用存储了，变成了<strong>能够理解 log 的应用定制存储系统</strong>。</p>
<h5 id="复制与相关故障">复制与相关故障</h5>
<p>Aurora 采用<strong>基于仲裁的投票协议</strong>来保证容错，即不需要所有副本都确认了读/写操作后才能继续执行。这个协议是这样的：</p>
<ol type="1">
<li>每次读操作都需要获得 <span class="math inline">\(V_r\)</span> 个确认；</li>
<li>每次写操作都需要获得 <span class="math inline">\(V_w\)</span> 个确认；</li>
<li><span class="math inline">\(V_r + V_w &gt; V\)</span>，保证每次读都能知道最近的写入；</li>
<li><span class="math inline">\(V_w &gt; V/2\)</span>，保证每次写入必须知道最近的写入从而避免写入冲突；</li>
</ol>
<p>这样一来，Aurora 可以有更多的副本和 AZ，而不需要付出过大的性能代价——因为它无需等待所有副本，只需要等待最快的 <span class="math inline">\(V_r/V_w\)</span> 个副本就好了。这也容忍了少数副本的 crash 或是偶尔的慢响应。</p>
<p>这里又会出现一个问题，客户端读请求可能会得到 <span class="math inline">\(V_r\)</span> 个不同的结果，却并不知道哪个结果是正确的。解决这一问题的方法就是设置<strong>版本号</strong>，每次写请求都会将新的数值与一个递增的版本号绑定，于是读请求便可以从所有结果中取版本号最高的那个结果。</p>
<h5 id="容错目标">容错目标</h5>
<p>在 Aurora 中，我们希望</p>
<ul>
<li>在整个 AZ 和一个额外的副本崩溃后而不丢失数据；</li>
<li>整个 AZ 崩溃后不会影响写入数据；</li>
</ul>
<p>于是设置 <span class="math inline">\(V = 6,\ V_w = 4,\ V_r = 3,\ z = 3\)</span>，这样每个 AZ 存放 2 个副本。在这样的设置下，一个 AZ 和一个副本崩溃不会影响读性能，且任意两个副本崩溃后也能保持写入可用性。</p>
<h5 id="数据分片sharding">数据分片(Sharding)</h5>
<p>对于 Aurora 而言，每个副本都是一个计算机，其内存是有限的，且尽管我们有 6 个副本，我们并没有得到 6 倍大小的内存——每个副本上存放的数据都是一致的。对于数百 TB 甚至更多的数据，需要找一个明智的策略进行存储。</p>
<p>这一策略是：将数据库的数据，分割到多组(<strong>PG, Protection Group</strong>)存储服务器上，每一个 PG 都包含若干存储服务器作为副本，存该 data page 10GB 的数据。</p>
<blockquote>
<p>这里的 PG 是个<strong>逻辑概念</strong>。</p>
</blockquote>
<p>Sharding 后，如果要进行 log 处理，则会查看 log 所修改的数据，并找到存储该数据的 PG，并将 log 只发送给该 PG 的副本。这也就意味着，每个 PG 只存储部分 data page 和所有与这些 data page 相关的 log 条目。</p>
<p>如果某个副本挂了，希望能尽快生成新的副本。事实上，尽管每个 PG 存了某个数据库的 10GB 数据，但一个副本所拥有的存储容量可能高达 10TB，也就是说该副本可能存了成百上千个 PG 的“10GB”，一旦该副本挂了，会牵连到与之相关的所有数据库。一个简单的策略是找到另一台存储服务器，通过拷贝的形式将该副本的所有数据都通过网络传输到新的副本中，但对于 10Gb/s 的网络来说，需要的时间还是太久了。</p>
<p>Aurora 是这么做的：若某个副本保存了 <span class="math inline">\(PG_1,\ PG_2,\ \dots,\ PG_n\)</span> 的数据，则将这 <span class="math inline">\(n\)</span> 个 PG 的数据并行传输到 <span class="math inline">\(n\)</span> 个新的存储服务器上。也就是说这 <span class="math inline">\(n\)</span> 个存储服务器，每个都会加入到一个新的 PG 中。比起上面的策略，我们获得了 <span class="math inline">\(n\)</span> 倍的性能提升。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>使序列递增的最小操作次数</title>
    <url>/LeetCode/leetcode801/</url>
    <content><![CDATA[<p>链接 <a href="https://leetcode.cn/problems/minimum-swaps-to-make-sequences-increasing/submissions/">&gt;&gt;&gt; 2022.10.10 每日一题 LeetCode801(hard) &lt;&lt;&lt;</a></p>
<span id="more"></span>
<blockquote>
<p>我们有两个长度相等且不为空的整型数组 <code>nums1</code> 和 <code>nums2</code>。在一次操作中，我们可以交换 <code>nums1[i]</code> 和 <code>nums2[i]</code> 的元素。</p>
<p>例如，如果 <code>nums1 = [1,2,3,8], nums2 =[5,6,7,4]</code> ，你可以交换 <code>i = 3</code> 处的元素，得到 <code>nums1 =[1,2,3,4]</code> 和 <code>nums2 =[5,6,7,8]</code> 。 返回 使 <code>nums1</code> 和 <code>nums2</code> <strong>严格递增</strong> 所需操作的最小次数 。</p>
<p>数组 <code>arr</code> <strong>严格递增</strong> 是指 <code>arr[0] &lt; arr[1] &lt; arr[2] &lt; ... &lt; arr[arr.length - 1]</code></p>
<p><strong>注意</strong>：用例保证可以实现操作。</p>
</blockquote>
<h5 id="最初的想法">最初的想法</h5>
<p>首先，对于任意 <code>i</code>，我们有两种选择，交换 or 不交换。那么最开始，我们可以考虑定义一个数组 <code>dp[n]</code>，其中 <code>dp[i]</code> 表示前 <code>i+1</code> 个元素的子数组中<strong>使序列递增的最小操作次数</strong>。那么可以得到以下状态转移方程：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> num1[i] &lt;= nums1[i<span class="number">-1</span>] || nums2[i] &lt;= nums2[i<span class="number">-1</span>] &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>] + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但这种考虑存在一个漏洞：我们的考虑范围局限在了相邻两个元素之间的关系，却没有考虑到之前的元素。</p>
<p>比如当 <code>nums1 = [0,2,2], nums2 = [1,1,3]</code> 时，我们只需交换 <code>i = 1</code> 处的元素。而在上面的状态转移过程中，我们却得到了 <code>dp = [0, 1, 2]</code>——这显然不是我们想要的。而这一结果的成因在于，忽略了之前是否有交换。</p>
<h5 id="改进">改进</h5>
<p>于是需要将 <code>dp[n]</code> 扩展到二维数组 <code>dp[n][2]</code>，<code>dp[i][0]</code> 表示对 <code>i</code> 处<strong>不进行交换</strong>时，前 <code>i+1</code> 个元素的子数组中使序列递增的最小操作次数；<code>dp[i][1]</code> 表示<strong>进行交换</strong>时的最小操作次数。这样一来，我们就能够对之前的交换情况进行考虑了。</p>
<p>既然题目保证最终能够实现操作，那么对任意 <code>i &gt; 1</code>，必然存在以下情况：</p>
<ol type="1">
<li><p><code>nums1[i] &lt;= num1[i-1] || nums2[i] &lt;= nums2[i-1]</code></p>
<p>这种情况下，<code>i</code> 处的交换情况必须与 <code>i-1</code> 处的交换情况相反，如果 <code>i-1</code> 换了，则 <code>i</code> 处无需交换；反之同理。有： <span class="math display">\[
 \begin{align}
 dp[i][0] &amp;= dp[i-1][1] \\[2ex] dp[i][1] &amp;= dp[i-1][0] + 1
 \end{align}
 \]</span></p></li>
<li><p><code>(nums1[i] &gt; num1[i-1] &amp;&amp; nums2[i] &gt; nums2[i-1]) &amp;&amp; (nums1[i] &lt;= nums2[i-1] || nums2[i] &lt;= nums1[i-1])</code></p>
<p>这种情况下，<code>i</code> 处的交换情况必须与 <code>i-1</code> 处的交换情况保持一致，也就是要么都交换，要么都不交换，则有： <span class="math display">\[
 \begin{align}
 dp[i][0] &amp;= dp[i-1][0] \\[2ex] dp[i][1] &amp;= dp[i-1][1] + 1
 \end{align}
 \]</span></p></li>
<li><p><code>(nums1[i] &gt; num1[i-1] &amp;&amp; nums2[i] &gt; nums2[i-1]) &amp;&amp; (nums1[i] &gt; nums2[i-1] &amp;&amp; nums2[i] &gt; nums1[i-1])</code></p>
<p>这种情况下，<code>i</code> 处交不交换都无所谓，既然我们要最小操作，则有： <span class="math display">\[
 \begin{align}
 dp[i][0] &amp;= \min(dp[i-1][0], dp[i-1][1])\\[2ex] dp[i][1] &amp;= dp[i][0] + 1
 \end{align}
 \]</span></p></li>
</ol>
<p>于是代码就很清晰了</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSwap</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums1)</span><br><span class="line">    dp := <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums1[i<span class="number">-1</span>] || nums2[i] &lt;= nums2[i<span class="number">-1</span>] &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i] &lt;= nums2[i<span class="number">-1</span>] || nums2[i] &lt;= nums1[i<span class="number">-1</span>] &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i<span class="number">-1</span>][<span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = min(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">            dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(dp[n<span class="number">-1</span>][<span class="number">0</span>], dp[n<span class="number">-1</span>][<span class="number">1</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一看提交结果，看来还得优化。</p>
<blockquote>
<p>执行用时：144 ms, 在所有 Go 提交中击败了 18.18% 的用户</p>
<p>内存消耗：19.7 MB, 在所有 Go 提交中击败了 9.09% 的用户</p>
</blockquote>
<h5 id="优化">优化</h5>
<p>注意到，每个 <code>dp[i]</code> 的状态只与 <code>dp[i-1]</code> 有关，之前的信息就被淘汰了，于是可以采用<strong>滚动数组</strong>的技巧优化空间。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minSwap</span><span class="params">(nums1 []<span class="type">int</span>, nums2 []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums1)</span><br><span class="line">    a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> nums1[i] &lt;= nums1[i<span class="number">-1</span>] || nums2[i] &lt;= nums2[i<span class="number">-1</span>] &#123;</span><br><span class="line">            a, b = b, a + <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> nums1[i] &lt;= nums2[i<span class="number">-1</span>] || nums2[i] &lt;= nums1[i<span class="number">-1</span>] &#123;</span><br><span class="line">            b++</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            a = min(a, b)</span><br><span class="line">            b = a + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min(a, b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优化后，比较满意了。</p>
<blockquote>
<p>执行用时：120 ms, 在所有 Go 提交中击败了68.18%的用户</p>
<p>内存消耗：9.6 MB, 在所有 Go 提交中击败了90.91%的用户</p>
</blockquote>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>每日一题</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear-Algebra(1)</title>
    <url>/math/linear-algebra(1)/</url>
    <content><![CDATA[<p>如果本科线代能有这样的教育方式和路线，我何苦现在还要来听这门公开课(</p>
<p>记录一下听的过程中觉得有用的信息好了。</p>
<span id="more"></span>
<h4 id="从线性方程组开始">从线性方程组开始</h4>
<p>教授（下简称 GS）认为线性代数的基本用途是解<strong>线性方程组</strong>，比如有这样一个方程组： <span class="math display">\[
\begin{cases}
2x-y = 0
\\[2ex]
-x+2y=3
\end{cases}
\]</span> 我们可以从以下三个角度考虑其解法。</p>
<ol type="1">
<li><p><strong>行图像</strong>：对于每个方程，我们都可以在二维平面上画出一条直线，这些直线的交点就是我们想要的解。</p></li>
<li><p><strong>列图像</strong>：对于每个变量的参数，我们都可以把方程组写成若干向量线性组合的形式（本例中是 <span class="math inline">\(x\left[\begin{matrix}2 \\ -1\end{matrix}\right] + y\left[\begin{matrix}-1 \\ 2\end{matrix}\right] = \left[\begin{matrix}0 \\ 3\end{matrix}\right]\)</span>）。只要找到一个合适的组合，方程组得解。</p>
<blockquote>
<p>此处如果如果每次取任意的 x 与 y，则等式左侧的向量的组合能布满整个二维平面。</p>
<p>拓展到多元方程组也是同理。</p>
</blockquote></li>
</ol>
<p>我们构造一个系数矩阵 <span class="math inline">\({A} = \left[\begin{matrix}2 &amp; -1 \\ -1 &amp; 2\end{matrix}\right]\)</span>，令 <span class="math inline">\(\vec{x} = \left[\begin{matrix}x \\ y\end{matrix}\right], \vec{b} = \left[\begin{matrix}0 \\ 3\end{matrix}\right]\)</span>，然后方程组可以写成这样子： <span class="math display">\[
A\vec{x} = \vec{b}
\]</span></p>
<h5 id="是否有解">是否有解？</h5>
<p>这时要考虑一个问题：是否任意 <span class="math inline">\(\vec{b}\)</span> 都能让上面那个方程有解呢？</p>
<p>从<strong>行图像</strong>的角度来讲，如果方程组有解，则所有方程在坐标系上对应的图像（直线、平面、体积）存在交集。如果某一个 <span class="math inline">\(\vec{b}\)</span> 不能满足上面条件，则无解（反之有解）。</p>
<p>从<strong>列图像</strong>的角度来讲，如果某一个 <span class="math inline">\(\vec{b}\)</span> 不能成为 <span class="math inline">\({A}\)</span> 列向量的线性组合，则无解（反之有解）。</p>
<h5 id="如何求解">如何求解？</h5>
<p>计算机软件（以及人类）计算时最常用的方法是<strong>高斯消元法</strong>，将原方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 转换为新的方程 <span class="math inline">\({U}\vec{x}=\vec{c}\)</span>。</p>
<blockquote>
<p>其中 <span class="math inline">\({U}\)</span> 为行阶梯最简型矩阵。</p>
</blockquote>
<h5 id="消元过程">消元过程</h5>
<p>每一步消元都可以视为将原矩阵乘上一个<strong>置换矩阵</strong>。左乘置换矩阵可以完成原矩阵的行变换，右乘置换矩阵则为列变换。</p>
<h5 id="逆矩阵">逆矩阵</h5>
<p>对于消元过程，每一步都是可逆的。对于一个置换矩阵 $ E_1$，我做了其相反的操作即可得到原矩阵，若这一相反的操作用 $ E_1^{'}$ 表示，则有 $ E_1^{'} E_1 A = A$ 。</p>
<p>得到 $ E_1^{'} E_1 = {I}$，从而可以用 $ E_1^{'} = { E_1}^{-1}$ 表示逆矩阵。第一个式子代表了逆矩阵的定义与性质。同样也有 <span class="math inline">\(( E_1^{&#39;})^{-1} = { E_1}\)</span> 且 $ E_1 E_1^{'} = {I}$ 。</p>
<blockquote>
<p>其中 $ I$ 是<strong>单位矩阵</strong>（对角线元素全为 1，其它元素全为 0 的方阵）</p>
</blockquote>
<h5 id="怎么求逆矩阵">怎么求逆矩阵？</h5>
<p><strong>高斯-若尔当消元法</strong>(Gauss-Jordan Elimination)告诉我们，通过构造 <span class="math inline">\(\left[\begin{matrix}\ {A}\ |\ {I}\ \end{matrix}\right]\)</span>，再通过消元法将左侧矩阵变为单位矩阵 <span class="math inline">\({I}\)</span>，易得这一系列行变换操作对应的矩阵是 <span class="math inline">\({A}^{-1}\)</span>，相当于左乘了一个矩阵 <span class="math inline">\({A}^{-1}\)</span>，则右侧矩阵乘完后自然就变为了 <span class="math inline">\({A}^{-1}\)</span>。</p>
<h4 id="接下来引入拓展到向量空间">接下来引入拓展到向量空间</h4>
<h5 id="向量空间">向量空间</h5>
<p>一个向量空间应该满足这样一个<strong>封闭性</strong>条件：对于空间中的任意向量 <span class="math inline">\(\vec{u}, \vec{v}\)</span>，其任意线性组合 <span class="math inline">\(a\vec{u}+b\vec{v}(a, b\in R)\)</span> 必然存在于空间中。显然，所有向量空间必须包括零向量。</p>
<h5 id="子空间">子空间</h5>
<p>包含于向量空间之内的一个向量空间称为原向量空间的一个子空间。</p>
<p>以 <span class="math inline">\({R}^3\)</span> 为例（它代表具有三个实数分量的所有向量的集合），其子空间包括：</p>
<ul>
<li>其本身（三维）</li>
<li>任一过原点的平面（二维）</li>
<li>任一过原点的直线（一维）</li>
<li>零向量</li>
</ul>
<h5 id="列空间">列空间</h5>
<p>矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的所有列向量张成的空间称为其列空间，以 <span class="math inline">\(C({A})\)</span> 表示。<span class="math inline">\(C({A})\subset R^m\)</span></p>
<h5 id="零空间">零空间</h5>
<p>所有满足方程 <span class="math inline">\({A}\vec{x} = \vec{0}\)</span> 的解的集合称为矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的零空间，以 <span class="math inline">\(N({A})\)</span> 表示。<span class="math inline">\(N({A})\subset R^n\)</span></p>
<h5 id="计算零空间">计算零空间</h5>
<p>相当于求方程 <span class="math inline">\({A}\vec{x} = \vec{0}\)</span> 的所有解。通过<strong>消元法与列交换</strong>构造出新的方程 <span class="math inline">\({U}\vec{x}=\vec{0}\)</span>，其中 <span class="math inline">\({U}\)</span> 是由 <span class="math inline">\(r\)</span> 个<strong>主元列</strong>与 <span class="math inline">\(n-r\)</span> 个<strong>自由列</strong>组成的形如下式的行阶梯型矩阵： <span class="math display">\[
U =
\left[
\begin{matrix}
\quad I_{r\times r} &amp; F_{r\times n-r} \quad
\\
\quad 0 &amp; 0 \quad
\end{matrix}
\right]
\]</span></p>
<blockquote>
<p>自由列可以表示为其左侧主元列的线性组合。</p>
</blockquote>
<p>原方程变为 <span class="math inline">\({U}\)</span> 的主元行乘以 <span class="math inline">\(\vec{x}\)</span>，即 <span class="math inline">\(\left[\begin{matrix}\ {I}\ |\ {F}\ \end{matrix}\right] \left[\begin{matrix}\  \vec x_{pivot} \\ \  \vec x_{free} \ \end{matrix}\right] = 0\)</span>。如果对 <span class="math inline">\(\vec x_{free}\)</span> 中 <span class="math inline">\(n-r\)</span> 的变量自由取值，我们能得到 <span class="math inline">\(n-r\)</span> 个线性无关的特解，<span class="math inline">\(N({A})\)</span> 则是由这些特解张成的向量空间（<strong>维度</strong>为 <span class="math inline">\(n-r\)</span>）。若把这些特解作为列向量写到一个矩阵 <span class="math inline">\({N}\)</span> 中，则有 <span class="math inline">\({U}{N} = {0}\)</span>，易得： <span class="math display">\[
N =
\left[\begin{matrix}\ {-F}_{r\times n-r} \ \\ \ I_{n-r\times n-r} \ \end{matrix}\right]
\]</span> 其中 <span class="math inline">\({-F}\)</span> 对应 <span class="math inline">\(\vec{x}_{pivot}\)</span>，<span class="math inline">\({I}\)</span> 对应 <span class="math inline">\(\vec{x}_{free}\)</span></p>
<h5 id="如果方程右侧不为零向量">如果方程右侧不为零向量</h5>
<p>首先抛出结论：若 <span class="math inline">\(\vec{b} \in C({A})\)</span>，则方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 有解。</p>
<p>当方程有解时，可以先找到方程一个特解，再与 <span class="math inline">\(N({A})\)</span> 进行线性组合，即可得到最后的解。</p>
<h5 id="秩">秩</h5>
<p>矩阵的<strong>秩</strong>等于矩阵的主元数。若 <span class="math inline">\(rank({A}_{m\times n}) = r\)</span>，则必有 <span class="math inline">\(r\leq m, r\leq n\)</span> 。</p>
<ol type="1">
<li><strong>列满秩</strong>：即 <span class="math inline">\(r=n&lt;m\)</span>，每一列都是主元列，矩阵没有自由列，<span class="math inline">\(N({A})\)</span> 中只有零向量，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 要么无解，要么有唯一解。</li>
<li><strong>行满秩</strong>：即 <span class="math inline">\(r=m\leq n\)</span>，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 有无穷多解。</li>
<li><strong>方阵满秩</strong>：即 <span class="math inline">\(r=m=n\)</span>，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 总有唯一解。</li>
<li><strong>行列均不满秩</strong>：即 <span class="math inline">\(r&lt;m, r&lt;n\)</span>，方程 <span class="math inline">\({A}\vec{x} = \vec{b}\)</span> 要么无解，要么有无穷多解。</li>
</ol>
<h5 id="线性相关性">线性相关性</h5>
<p>若一组向量的非零线性组合可以得到零向量，则称这组向量<strong>线性相关</strong>；反之，则称其<strong>线性无关</strong>。</p>
<h5 id="基">基</h5>
<p>向量空间的<strong>基</strong>是一组<strong>线性无关的向量</strong>，且这些向量能够张成该向量空间。</p>
<h5 id="维数">维数</h5>
<p>空间中的每一组基都有相同的向量数，这个数值就是空间的<strong>维数</strong>，通常用 <span class="math inline">\(dim\)</span> 表示。</p>
<h5 id="基本子空间">基本子空间</h5>
<p>除了列空间和零空间，还有</p>
<ol type="1">
<li><strong>行空间</strong>：矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的所有行向量张成的空间称为其列空间，以 <span class="math inline">\(R({A})\)</span> 表示。<span class="math inline">\(R({A})\subset R^n\)</span></li>
<li><strong>左零空间</strong>：所有满足方程 <span class="math inline">\({A^T}{x} = {0}\)</span> 的解的集合称为矩阵 <span class="math inline">\({A}_{m\times n}\)</span> 的左零空间，以 <span class="math inline">\(L({A})\)</span> 表示。<span class="math inline">\(L({A})\subset R^m\)</span></li>
</ol>
<p><span class="math inline">\({A}\)</span> 的 <span class="math inline">\(r\)</span> 个主元列构成了 <span class="math inline">\(C({A})\)</span> 的一组基。</p>
<p><span class="math inline">\({A}\vec{x}=\vec{0}\)</span> 的一组特解对应于 <span class="math inline">\({A}\)</span> 的 <span class="math inline">\(n-r\)</span> 个自由列，并构成了 <span class="math inline">\(N({A})\)</span> 的一组基。</p>
<p>则得到这样一个结论： <span class="math display">\[
rank(A) = \# C_{pivot} = dim(C(A)) = r = dim(R(A))
\]</span> 同样的： <span class="math display">\[
\#C_{free} = dim(N(A)) = n - r
\\[2ex]
dim(L(A)) = m-r
\]</span> 不妨用下图来表示这一切</p>
<p><img src="image-20220929160748771.png" alt="image-20220929160748771" style="zoom:67%;" /></p>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>MIT18.06</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear-Algebra(2)</title>
    <url>/math/linear-algebra(2)/</url>
    <content><![CDATA[<p>书接上回。</p>
<span id="more"></span>
<h4 id="如何求解无解方程组">如何求解无解方程组？</h4>
<p>在这个问题之前，我先做点铺垫。</p>
<h5 id="正交向量">正交向量</h5>
<p>若两向量 <span class="math inline">\(\vec{a}, \vec{b}\)</span> 正交，则必然有 <span class="math inline">\(\vec{a}^T\vec{b} = \vec{b}^T\vec{a} = 0\)</span></p>
<h5 id="正交子空间">正交子空间</h5>
<p>若子空间 <span class="math inline">\(S\)</span> 与子空间 <span class="math inline">\(T\)</span> 正交，则 <span class="math inline">\(S\)</span> 中任意向量与 <span class="math inline">\(T\)</span> 中任意向量正交。</p>
<p>不难发现，<span class="math inline">\(R(A)\)</span> 与 <span class="math inline">\(N(A)\)</span> 是正交的，而这两个空间恰好都是 <span class="math inline">\(R^n\)</span> 的子空间，更巧的是，<strong>其维数之和为</strong> <span class="math inline">\(n\)</span>。</p>
<p>我们称这两个子空间为 <span class="math inline">\(R^n\)</span> 的<strong>正交补</strong>——它们将 <span class="math inline">\(R^n\)</span> 划分为了<strong>两个正交的子空间</strong>。</p>
<p>同样的，<span class="math inline">\(C(A)\)</span> 与 <span class="math inline">\(L(A)\)</span> 也互为正交补。</p>
<blockquote>
<p>两个互为正交补的子空间的维数之和，不能超过原空间的维数。</p>
</blockquote>
<h5 id="投影问题">投影问题</h5>
<p>这一问题的几何解释为：如何在向量 <span class="math inline">\(\vec{a}\)</span> 的方向上寻找与向量 <span class="math inline">\(\vec{b}\)</span> 距离最近的一点。假设这一点对应的向量为 <span class="math inline">\(\vec{p}\)</span>，则 <span class="math inline">\(\vec{e}=\vec{b}-\vec{p}\)</span> 就是这一近似的误差。如图所示：</p>
<p><img src="image-20220929215857174.png" alt="image-20220929215857174" style="zoom:100%;" /></p>
<p>若令 <span class="math inline">\(\vec{p} = \hat{x}\vec{a}\)</span>，因 <span class="math inline">\(\vec{e}\)</span> 与 <span class="math inline">\(\vec{a}\)</span> 正交，则有 <span class="math inline">\(\vec{a}^T(\vec{b}-\hat{x}\vec{a}) = 0\)</span>，解得 <span class="math display">\[
\hat{x} = \frac{\vec{a}^T\vec{b}}{\vec{a}^T\vec{a}}
\\[2ex]
\vec{p} = \vec{a}\frac{\vec{a}^T\vec{b}}{\vec{a}^T\vec{a}}
\]</span> 相当于把 <span class="math inline">\(\vec{b}\)</span> 以某种操作投影到了 <span class="math inline">\(\vec{p}\)</span> 上。若用<strong>投影矩阵</strong> <span class="math inline">\(P\)</span> 来描述这一操作，则有 <span class="math inline">\(\vec{p} = P\vec{b}\)</span>，得 <span class="math display">\[
P = \frac{\vec{a}\vec{a}^T}{\vec{a}^T\vec{a}}
\]</span> 这是一个<strong>对称矩阵</strong>（<span class="math inline">\(P^T=P\)</span>），而且是<strong>幂等矩阵</strong>（<span class="math inline">\(P^2 = P\)</span>）</p>
<h5 id="如果考虑该问题在高维空间的版本">如果考虑该问题在高维空间的版本</h5>
<p>有一个向量空间 <span class="math inline">\(V\)</span> 与一个不在该空间上的向量 <span class="math inline">\(\vec{b}\)</span>，如果把 <span class="math inline">\(V\)</span> 视为某一矩阵的列空间，且该空间的基为 <span class="math inline">\(\vec{a_1}, \vec{a_2},\dots, \vec{a_n}\)</span>，则该矩阵可以用 <span class="math inline">\(A = \begin{bmatrix}\vec{a_1} &amp; \vec{a_2} &amp; \cdots &amp; \vec{a_n} \end{bmatrix}\)</span> 来描述。</p>
<p>令 <span class="math inline">\(\vec{p}\)</span> 为 <span class="math inline">\(\vec{b}\)</span> 在该向量空间上的投影，则 <span class="math inline">\(\vec{p}\)</span> 可以用 <span class="math inline">\(\vec{p} = x_1\vec{a_1} + x_2\vec{a_2} + \dots + x_n\vec{a_n} = A\vec{\hat{x}}\)</span> 来表示。</p>
<p>显然误差 <span class="math inline">\(\vec{e}\)</span> 与整个向量空间正交，则有 <span class="math inline">\(\vec{a_1}^T\vec{e} = 0, \vec{a_2}^T\vec{e} = 0, \dots, \vec{a_n}^T\vec{e} = 0\)</span></p>
<p>上式可以写为 <span class="math inline">\(A^T\vec{e} = 0\)</span></p>
<p>从而得到 <span class="math display">\[
A^T(\vec{b} - A\vec{\hat{x}}) = 0 \quad \Rightarrow \quad \vec{\hat{x}} = (A^TA)^{-1}A^T\vec{b}
\]</span> 那么得到一个<strong>非常优美的结论</strong>： <span class="math display">\[
\vec{p} = A(A^TA)^{-1}A^T\vec{b}
\\[2ex]
P = A(A^TA)^{-1}A^T
\]</span> 这里的 <span class="math inline">\(P\)</span> 同样满足对称性和幂等性。</p>
<p>这里 <span class="math inline">\(\vec{p} \in C(A)\)</span>，同时惊喜的发现 <span class="math inline">\(\vec{e}\in L(A)\)</span>，说明 <span class="math inline">\(\vec{b} = \vec{p} + \vec{e}\)</span> 由两部分组成，一部分（<span class="math inline">\(\vec{p}\)</span>）投影到了 <span class="math inline">\(C(A)\)</span> 上，另一部分（<span class="math inline">\(\vec{e}\)</span>）投影到了 <span class="math inline">\(L(A)\)</span> 上。对于 <span class="math inline">\(\vec{e}\)</span>，我们发现可以通过 <span class="math inline">\(\vec{e} = \vec{b} - \vec{p} = \vec{b} - P\vec{b} = (I-P)\vec{b}\)</span> 表示，所以 <span class="math inline">\(I-P\)</span> 也是个投影矩阵，也具有和 <span class="math inline">\(P\)</span> 同样的性质。</p>
<p>当 <span class="math inline">\(A\)</span> 的列向量线性无关时，说明 <span class="math inline">\(C(A)\)</span> 就是 <span class="math inline">\(R^n\)</span>，此时任意 <span class="math inline">\(\vec{b}\in R^n\)</span> 都必然在 <span class="math inline">\(C(A)\)</span> 中，投影矩阵就是 <span class="math inline">\(I\)</span>。</p>
<p>对于 <span class="math inline">\(A^TA\)</span> 而言，其零空间与 <span class="math inline">\(A\)</span> 是一致的</p>
<ol type="1">
<li>对于 <span class="math inline">\(A^TA\vec{x}=\vec{0}\)</span>，必然满足 <span class="math inline">\(\vec{x}^TA^TA\vec{x} = (A\vec{x})^T A\vec{x} = \vec{0}\)</span>，从而 <span class="math inline">\(A\vec{x}\)</span> 与自身正交，那么 <span class="math inline">\(A\vec{x} = \vec{0}\)</span>。</li>
<li>对于 <span class="math inline">\(A\vec{x}=\vec{0}\)</span>，必然满足 <span class="math inline">\(A^TA\vec{x}=\vec{0}\)</span></li>
</ol>
<p>因此当 <span class="math inline">\(A\)</span> 的列向量线性无关时，<span class="math inline">\(A\vec{x}=\vec{0}\)</span> 只有零解，<span class="math inline">\(A^TA\vec{x}=\vec{0}\)</span> 也只有零解。且 <span class="math inline">\(A^TA\)</span> 为方阵，行列满秩，必然可逆。</p>
<h5 id="回到最开始的问题如何求解无解方程组">回到最开始的问题：如何求解无解方程组？</h5>
<p>这个问题看似很离谱，实则我们可以用一个最优解 <span class="math inline">\(\vec{\hat{x}}\)</span> 去近似。对于方程 <span class="math inline">\(A\vec{x} = \vec{b}\)</span>，如果其无解，说明 <span class="math inline">\(\vec{b}\)</span> 不在 <span class="math inline">\(A\)</span> 的列空间中。我们可以将 <span class="math inline">\(\vec{b}\)</span> 投影到 <span class="math inline">\(C(A)\)</span>，将问题转换为求解方程 <span class="math inline">\(A\vec{\hat{x}} = \vec{p}\)</span>，这个解就是我们想求的近似最优解。</p>
<p>根据上面描述的，我们能够很轻易地得到该解，即 <span class="math display">\[
\vec{\hat{x}} = (A^TA)^{-1}A^T\vec{b}
\]</span></p>
<h5 id="最小二乘法">最小二乘法</h5>
<p>应用投影矩阵求方程组最优解的方法，最常用于“最小二乘法”拟合曲线，如图：</p>
<p><img src="image-20220929223041893.png" alt="image-20220929223041893" style="zoom:80%;" /></p>
<p>已知数据点，求一直线方程，使该直线尽可能经过所有点——所有点到该直线的距离尽可能小。</p>
<p>有一个思路是：这些数据点大概率不会共线，也就是说，将这些数据点代入直线方程利用待定系数法求其参数时，组成的线性方程组大多数情况下是无解的，此时就要用到上面的“求无解方程组最优解”的思路。</p>
<p>还有一个思路是，我们希望误差 <span class="math inline">\(\vec{e}\)</span> 尽可能小，也就是 <span class="math inline">\(||\vec{e}||^2=||A\vec{\hat{x}}-\vec{b}||^2\)</span> 尽可能小。这一等式可以写成一个 <span class="math inline">\(n\)</span> 元的方程，对该方程的所有变量求偏导并令偏导数为 0，则可以得到上面那个思路一样的结果。</p>
<h5 id="再回到正交向量">再回到正交向量</h5>
<p>现在说正交向量的升级版——<strong>标准正交向量</strong>，即满足以下条件的一组向量： <span class="math display">\[
\vec{q}_i^T\vec{q}_j = \begin{cases}1 \quad i = j\\[2ex] 0 \quad i \neq j\end{cases}
\]</span></p>
<h5 id="正交矩阵">正交矩阵</h5>
若令 $Q =
<span class="math display">\[\begin{bmatrix}\vec{q}_1 &amp; \vec{q}_2 &amp; \cdots &amp; \vec{q}_n \end{bmatrix}\]</span>
<p>$，易得 <span class="math display">\[
Q^TQ = I
\]</span> 此矩阵 <span class="math inline">\(Q\)</span> 称为<strong>正交矩阵</strong>，且显然有 <span class="math inline">\(Q^T=Q^{-1}\)</span>。</p>
<p>对于正交矩阵来说，在其列空间内关于投影问题的<strong>投影矩阵</strong>也可以<strong>简化为</strong> <span class="math inline">\(P=Q(Q^TQ)^{-1}Q^T = QQ^T\)</span>。若 <span class="math inline">\(Q\)</span> 为方阵，还可以进一步得到 <span class="math inline">\(P=I\)</span>，因为此时其列空间已经张成 <span class="math inline">\(R^n\)</span>，投影操作不会对向量有任何改变。</p>
<p>对应的 <span class="math inline">\(\vec{p} = P\vec{b} = QQ^T\vec{b} = Q\vec{\hat{x}}\)</span></p>
<h5 id="施密特正交化">施密特正交化</h5>
<p>对于一组线性无关的向量 <span class="math inline">\(\vec{a}_1, \vec{a}_2,\dots,\vec{a}_n\)</span>，若其能够张成空间 <span class="math inline">\(V\)</span>，我们希望能找到该空间的<strong>正交矩阵</strong>表示——即找到一组<strong>标准正交向量</strong> <span class="math inline">\(\vec{e}_1, \vec{e}_2, \dots, \vec{e}_n\)</span>，其恰好能张成同样的空间，也就是找到该空间的一组<strong>标准正交基</strong>。</p>
<blockquote>
<p>对一个向量的<strong>标准化</strong>过程就是令其除以其模长。</p>
</blockquote>
<p>我们不妨逐一分析：</p>
<ol type="1">
<li><p>第一个向量不作变动，即 <span class="math inline">\(\displaystyle \vec{e}_1 = \frac{\vec{a}_1}{||\vec{a}_1||}\)</span></p></li>
<li><p>对于之后的所有向量 <span class="math inline">\(\vec{a}_i\)</span>，由于我们已经求得一组标准正交向量 <span class="math inline">\(\vec{e}_1, \dots, \vec{e}_{i-1}\)</span>，设求其施密特正交化后的向量为 <span class="math inline">\(\vec{e}_i\)</span>，易得 <span class="math inline">\(\vec{e}_i\)</span> 垂直于 <span class="math inline">\(\vec{e}_1, \dots, \vec{e}_{i-1}\)</span>，从而有<span class="math inline">\(\vec{e}_i\)</span> 垂直于 <span class="math inline">\(\vec{e}_1, \dots, \vec{e}_{i-1}\)</span> 张成的向量空间。此时可以把问题转换为<strong>投影问题</strong>，只不过我们这里需要求投影问题中的<strong>误差</strong>，也就是原向量 <span class="math inline">\(\vec{a}_i\)</span> 减去它在投影到所有基 <span class="math inline">\(\vec{e}_k\)</span> 上的分量 <span class="math inline">\(\vec{p}_k\)</span>： <span class="math display">\[
 \vec{e}_i = \vec{a}_i - \sum\limits_{k=1}^{i-1}\vec{p}_k
 \\[2ex]
 \vec{p}_k = \frac{\vec{e}_k^T\vec{a}_i}{\vec{e}_k^T\vec{e}_k}\vec{e}_k
 \]</span></p></li>
<li><p>最后还需要对 <span class="math inline">\(\vec{e}_i\)</span> 进行标准化。</p></li>
</ol>
<h5 id="qr分解">QR分解</h5>
<p>我们把得到的标准正交基写成矩阵的形式 <span class="math inline">\(Q = \begin{bmatrix}\vec{e}_1 &amp; \vec{e}_2 &amp; \cdots &amp; \vec{e}_n \end{bmatrix}\)</span>，若令 <span class="math inline">\(A = \begin{bmatrix}\vec{a}_1 &amp; \vec{a}_2 &amp; \cdots &amp; \vec{a}_n \end{bmatrix}\)</span>，则 <span class="math inline">\(C(Q)\)</span> 与 <span class="math inline">\(C(A)\)</span> 是同一个向量空间。</p>
<p>由于 <span class="math inline">\(Q\)</span> 的列向量是 <span class="math inline">\(C(Q)\)</span> 空间中的标准正交基，则 <span class="math inline">\(A\)</span> 的列向量必能由 <span class="math inline">\(Q\)</span> 的列向量线性表示。前文提到，列变换相当于右乘一个置换矩阵，所以我们可以通过 <span class="math inline">\(A=QR\)</span> 得到如下等式： <span class="math display">\[
\begin{bmatrix}
\vec{a}_1 &amp; \vec{a}_2 &amp; \cdots &amp; \vec{a}_n
\end{bmatrix}
=
\begin{bmatrix}
\vec{e}_1 &amp; \vec{e}_2 &amp; \cdots &amp; \vec{e}_n
\end{bmatrix}
·
\begin{bmatrix}
\vec{a}_1^T\vec{e}_1 &amp; \vec{a}_2^T\vec{e}_1 &amp; \cdots &amp; \vec{a}_n^T\vec{e}_1
\\
\vec{a}_1^T\vec{e}_2 &amp; \vec{a}_2^T\vec{e}_2 &amp; \cdots &amp; \vec{a}_n^T\vec{e}_2
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
\vec{a}_1^T\vec{e}_n &amp; \vec{a}_2^T\vec{e}_n &amp; \cdots &amp; \vec{a}_n^T\vec{e}_n
\end{bmatrix}
\]</span> 其中矩阵 <span class="math inline">\(R\)</span> 为列变换的置换矩阵。</p>
<p>根据我们求正交基的步骤，每一个 <span class="math inline">\(\vec{e}_i\)</span> 都正交于 <span class="math inline">\(\vec{a}_j\ (j &lt; i)\)</span>，因为 <span class="math inline">\(\vec{a}_j\)</span> 属于 <span class="math inline">\(\vec{e}_1, \vec{e}_2,\dots,\vec{e}_{i-1}\)</span> 张成的向量空间，而 <span class="math inline">\(\vec{e}_i\)</span> 与该向量空间正交。从而当 <span class="math inline">\(j &lt; i\)</span> 时，有 <span class="math inline">\(\vec{a}_j^T\vec{e}_i = 0\)</span>，得到 <span class="math inline">\(R\)</span> 为上三角矩阵。</p>
<p>更清楚的表示为： <span class="math display">\[
R =
\begin{bmatrix}
\vec{a}_1^T\vec{e}_1 &amp; \vec{a}_2^T\vec{e}_1 &amp; \cdots &amp; \vec{a}_{n-1}^T\vec{e}_1 &amp; \vec{a}_n^T\vec{e}_1
\\
0 &amp; \vec{a}_2^T\vec{e}_2 &amp; \cdots &amp; \vec{a}_{n-1}^T\vec{e}_2 &amp; \vec{a}_n^T\vec{e}_2
\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots
\\
0 &amp; 0 &amp; \cdots &amp;  \vec{a}_{n-1}^T\vec{e}_{n-1} &amp; \vec{a}_n^T\vec{e}_{n-1}
\\
0 &amp; 0 &amp; \cdots &amp; 0 &amp; \vec{a}_n^T\vec{e}_n
\end{bmatrix}
\]</span></p>
<h4 id="进入第二部分行列式">进入第二部分：行列式</h4>
<p>跟国内教材上来就给学生塞一堆行列式的定义与性质让你记忆和做题不一样，GS 在讲完矩阵后，把<strong>“行列式作为属于矩阵的一个特性，包含大量矩阵的信息”</strong>教授给大家，并从<strong>三个基本性质</strong>开始。</p>
<blockquote>
<p>行列式记为 <span class="math inline">\(det(A) = |A|\)</span>。矩阵必须为方阵。</p>
</blockquote>
<h5 id="行列式性质">行列式性质</h5>
<ol type="1">
<li><p><span class="math inline">\(det(I) = 1\)</span></p></li>
<li><p>交换任意两行后，<span class="math inline">\(det(A)\)</span> 取相反数。</p></li>
<li><ul>
<li>数乘： <span class="math display">\[
  \begin{vmatrix}
  ta &amp; tb
  \\
  c &amp; d
  \end{vmatrix}
  =
  t
  \begin{vmatrix}
  a &amp; b
  \\
  c &amp; d
  \end{vmatrix}
  \]</span></li>
<li>相加： <span class="math display">\[
  \begin{vmatrix}
  a+a&#39; &amp; b+b&#39;
  \\
  c &amp; d
  \end{vmatrix}
  =
  \begin{vmatrix}
  a &amp; b
  \\
  c &amp; d
  \end{vmatrix}
  +
  \begin{vmatrix}
  a&#39; &amp; b&#39;
  \\
  c &amp; d
  \end{vmatrix}
  \]</span></li>
</ul></li>
</ol>
<p>更多的性质可以从以上基本性质中推导出：</p>
<ol start="4" type="1">
<li><p>任意两行相等，行列式为 0。</p></li>
<li><p>任意一行加上/减去另一行的 <span class="math inline">\(k\)</span> 倍，行列式值不变。</p></li>
<li><p>若某一行为 0，则行列式为 0。</p></li>
<li><p>上三角/下三角行列式的值等于其主对角线所有元素的乘积。</p>
<blockquote>
<p><span class="math display">\[
\begin{vmatrix}
a &amp; b
\\
c &amp; d
\end{vmatrix}
= ad - bc
\]</span></p>
</blockquote></li>
<li><p>若 <span class="math inline">\(det(A) = 0\)</span>，则 <span class="math inline">\(A\)</span> 奇异/不可逆；反之非奇异/可逆。</p></li>
<li><p><span class="math inline">\(det(AB) = det(A)det(B)\)</span> <span class="math inline">\(det(A^{-1}) = 1/det(A)\)</span> <span class="math inline">\(det(kA) = k^ndet(A)\)</span></p></li>
<li><p><span class="math inline">\(det(A^T) = det(A)\)</span></p></li>
</ol>
<h5 id="代数余子式">代数余子式</h5>
<p>讲完性质，就来讲怎么对高阶方阵的行列式求值了。</p>
<p><span class="math inline">\(n\)</span> 阶行列式中，任意位置 <span class="math inline">\(a_{ij}\)</span> 对应的<strong>代数余子式</strong> <span class="math inline">\(C_{ij}\)</span> 等于将第 <span class="math inline">\(i\)</span> 行第 <span class="math inline">\(j\)</span> 列从行列式中移除后，剩下部分构成的 <span class="math inline">\(n-1\)</span> 阶行列式<strong>的值</strong>，且其正负性由 <span class="math inline">\((-1)^{i+j}\)</span> 表示。</p>
<p>行列式的值，等于任意一行中所有元素与其代数余子式乘积再求和，即<strong>代数余子式展开</strong>： <span class="math display">\[
det(A) = a_{i1}C_{i1} + a_{i2}C_{i2} + \dots + a_{in}C_{in} \quad (1 \leq i \leq n)
\]</span> 对列也有类似的展开方法。</p>
<blockquote>
<p>一般来说很少用这方法，以<strong>消元法化为上三角行列式</strong>为主。</p>
</blockquote>
<h5 id="逆矩阵公式">逆矩阵公式</h5>
<p>已知二阶矩阵 <span class="math inline">\(A = \begin{bmatrix}a &amp; b \\ c &amp; d\end{bmatrix}\)</span> 的行列式公式，则其逆矩阵为 <span class="math inline">\(\displaystyle A^{-1} = \frac{1}{ad-bc} \begin{bmatrix}d &amp; -b \\ -c &amp; a\end{bmatrix}\)</span></p>
<p>事实上，<strong>任意矩阵的逆</strong>都可以写为这样一个形式： <span class="math display">\[
A^{-1} = \frac{1}{det(A)}C^T
\\[2ex]
C = \begin{bmatrix}
C_{11} &amp; C_{12} &amp; \cdots &amp; C_{1n}
\\
C_{21} &amp; C_{22} &amp; \cdots &amp; C_{2n}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
C_{n1} &amp; C_{n2} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
\]</span> 其中 <span class="math inline">\(C_{ij}\)</span> 为 <span class="math inline">\(A\)</span> 中元素 <span class="math inline">\(a_{ij}\)</span> 的<strong>代数余子式</strong>。代数余子式矩阵 <span class="math inline">\(C\)</span> 的转置 <span class="math inline">\(C^T\)</span> 也称为 <span class="math inline">\(A\)</span> 的<strong>伴随矩阵</strong>。</p>
<p>对上式进行左乘 <span class="math inline">\(A\)</span>，则有 <span class="math display">\[
\frac{1}{det(A)}AC^T = \frac{1}{det(A)}\begin{bmatrix}
a_{11} &amp; a_{12} &amp; \cdots &amp; a_{1n}
\\
a_{21} &amp; a_{22} &amp; \cdots &amp; a_{2n}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
a_{n1} &amp; a_{n2} &amp; \cdots &amp; a_{nn}
\end{bmatrix}
\begin{bmatrix}
C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}
\\
C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
\]</span> 主对角线元素很好判断，就是行列式的<strong>代数余子式展开</strong>；对于其它元素，以 <span class="math inline">\(\sum\limits_{i=1}^na_{2i}C_{1i}\)</span> 为例，它可以视为 <span class="math inline">\(A\)</span> 的第一行元素全由第二行替换后的新矩阵 <span class="math inline">\(A&#39;\)</span> 按第一行代数余子式展开，根据<strong>性质 4</strong>，我们得到 <span class="math inline">\(det(A&#39;)=0\)</span>，即最终结果仅有主对角线元素全为 1，其它都是 0——单位矩阵 <span class="math inline">\(I\)</span>，恰好是 <span class="math inline">\(AA^{-1}\)</span>，故该等式是正确的。</p>
<h5 id="克拉默法则">克拉默法则</h5>
<p>对于可逆矩阵 <span class="math inline">\(A\)</span>，方程 <span class="math inline">\(A\vec{x} = \vec{b}\)</span> 必有形如下式的解：<span class="math inline">\(\vec{x} = A^{-1}\vec{b}\)</span></p>
<p>代入上面得到的逆矩阵公式，有 <span class="math display">\[
\begin{bmatrix}
x_1
\\
x_2
\\
\vdots
\\
x_n
\end{bmatrix}
= \vec{x} = \frac{1}{det(A)}C^T\vec{b} = \frac{1}{det(A)}
\begin{bmatrix}
C_{11} &amp; C_{21} &amp; \cdots &amp; C_{n1}
\\
C_{12} &amp; C_{22} &amp; \cdots &amp; C_{n2}
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
C_{1n} &amp; C_{2n} &amp; \cdots &amp; C_{nn}
\end{bmatrix}
\begin{bmatrix}
b_1
\\
b_2
\\
\vdots
\\
b_n
\end{bmatrix}
\]</span> 根据之前得到的结论，<span class="math inline">\(\sum\limits_{i=1}^nb_kC_{ik}\)</span> 可以视为将 <span class="math inline">\(A\)</span> 的第 <span class="math inline">\(k\)</span> 列用 <span class="math inline">\(\vec{b}\)</span> 替换后得到的新矩阵 <span class="math inline">\(B_k\)</span> 的行列式值，从而得到 <span class="math display">\[
x_k = \frac{det(B_k)}{det(A)}
\]</span> &gt; 评价为：<strong>没消元法好用，但确实也是一个可行的方法</strong>。</p>
<h5 id="几何度量">几何度量</h5>
<p>二阶行列式 <span class="math inline">\(|det(A)|\)</span> 等于 <span class="math inline">\(A\)</span> 行（列）向量构成的平行四边形的面积。</p>
<p>三阶行列式 <span class="math inline">\(|det(A)|\)</span> 等于 <span class="math inline">\(A\)</span> 行（列）向量构成的平行六面体的体积。</p>
<h4 id="进入下一个议题特征向量与特征值">进入下一个议题：特征向量与特征值</h4>
<p>将矩阵 <span class="math inline">\(A\)</span> 与向量 <span class="math inline">\(\vec{x}\)</span> 相乘当做是对向量的一种操作或者函数，输入 <span class="math inline">\(\vec{x}\)</span> 而输出 <span class="math inline">\(A\vec{x}\)</span> 。<strong>特征向量</strong>即在特定的向量 <span class="math inline">\(\vec{x}\)</span> 方向上输出的 <span class="math inline">\(A \vec{x}\)</span> 平行于 <span class="math inline">\(\vec{x}\)</span> ，即为： <span class="math display">\[
A\vec{x} = \lambda\vec{x}
\]</span> 其中 <span class="math inline">\(\vec{x}\)</span> 为 <span class="math inline">\(A\)</span> 的<strong>特征向量</strong>，<span class="math inline">\(\lambda\)</span> 为 <span class="math inline">\(A\)</span> 的<strong>特征值</strong>。</p>
<h5 id="如何求解特征值与特征向量">如何求解特征值与特征向量？</h5>
<p>直接上结论：<strong>求解特征值等价于求解方程</strong> <span class="math inline">\(det(A-\lambda I) = 0\)</span></p>
<p>并且有：</p>
<ol type="1">
<li><p>矩阵的<strong>迹</strong>（对角线所有元素之和）等于<strong>特征值之和</strong>。</p></li>
<li><p>对称矩阵的特征向量<strong>正交</strong>。</p>
<blockquote>
<p>设 <span class="math inline">\(\vec{x}_1, \vec{x}_2\)</span> 分别是 <span class="math inline">\(A\)</span> 对应特征值 <span class="math inline">\(\lambda_1, \lambda_2\)</span> 的特征向量，有 <span class="math display">\[
\begin{align}
A\vec{x}_1 &amp;= \lambda_1\vec{x}_1
\\[2ex]
\vec{x}_2^TA\vec{x}_1 &amp;= \lambda_1\vec{x}_2^T\vec{x}_1
\\[2ex]
(A^T\vec{x}_2)^T\vec{x}_1 &amp;= \lambda_2\vec{x}_2^T\vec{x}_1
\\[2ex]
(\lambda_1 - \lambda_2)\vec{x}_2^T\vec{x}_1 &amp;= 0
\end{align}
\]</span></p>
<p>由于 <span class="math inline">\(\lambda_1 \neq \lambda_2\)</span>，所以 <span class="math inline">\(\vec{x}_2^T\vec{x}_1 = 0\)</span>，故其正交。</p>
</blockquote></li>
</ol>
<h5 id="对角化">对角化</h5>
<p>如果矩阵 <span class="math inline">\(A\)</span> 有 <span class="math inline">\(n\)</span> 个线性无关的特征向量 <span class="math inline">\(\vec{x_i}\)</span> ，将其作为矩阵 <span class="math inline">\(S\)</span> 的列向量，则 <span class="math display">\[
AS = A
\begin{bmatrix}
\vec{x_1} &amp; \vec{x_2} &amp; \cdots &amp; \vec{x_n}
\end{bmatrix}
=
\begin{bmatrix}
\lambda_1\vec{x_1} &amp; \lambda_2\vec{x_2} &amp; \cdots &amp; \lambda_n\vec{x_n}
\end{bmatrix}
=
\begin{bmatrix}
\vec{x_1} &amp; \vec{x_2} &amp; \cdots &amp; \vec{x_n}
\end{bmatrix}
·
\begin{bmatrix}
\lambda_1 &amp; 0 &amp; \cdots &amp; 0
\\
0 &amp; \lambda_2 &amp; \cdots &amp; 0
\\
\vdots &amp; \vdots &amp; &amp; \vdots
\\
0 &amp; 0 &amp; \cdots &amp; \lambda_n
\end{bmatrix}
=
S\Lambda
\]</span> 我们得到 <span class="math inline">\(S^{-1}AS = \Lambda\)</span>，其中 <span class="math inline">\(\Lambda\)</span> 为对角矩阵，其对角线上所有元素都是 <span class="math inline">\(A\)</span> 的特征值，而且这些特征值的排布与 <span class="math inline">\(S\)</span> 中特征向量的排布是一致的。同时我们可以得到这样一个<strong>新的分解方式</strong>：<span class="math inline">\(A = S\Lambda S^{-1}\)</span>。</p>
<p>如果 <span class="math inline">\(A\vec{x} = \lambda\vec{x}\)</span>，则有 <span class="math inline">\(A^2\vec{x} = A ·\lambda\vec{x} = \lambda^2\vec{x}\)</span>，所以 <span class="math inline">\(A^2\)</span> 有着和 <span class="math inline">\(A\)</span> 同样的特征向量，且对应的特征值为 <span class="math inline">\(\lambda^2\)</span>。</p>
<p>我们甚至能进一步推测出，如果 <span class="math inline">\(A\sim\lambda\)</span>，则 <span class="math inline">\(A^k\sim\lambda^k\)</span>，且有 <span class="math inline">\(A^k = S\Lambda^k S^{-1}\)</span>。</p>
<blockquote>
<p>若 <span class="math inline">\(|\lambda| &lt; 1\)</span>，则 <span class="math inline">\(\lim\limits_{k\rightarrow\infty} A^k = O\)</span></p>
</blockquote>
<p>式子 <span class="math inline">\(S^{-1}AS = \Lambda\)</span> 被称为矩阵的<strong>对角化</strong>。矩阵能够对角化的<strong>充要条件</strong>为：<strong>矩阵有 <span class="math inline">\(n\)</span> 个线性无关的特征向量</strong>。</p>
<ul>
<li>如果矩阵没有重复特征值，则根据前文描述，矩阵的特征向量必然线性无关，故必然可对角化。</li>
<li>如果矩阵有重复特征值，则需要进一步深究——事实上，如果一个特征值重复了 <span class="math inline">\(k\)</span> 次（或称<strong>代数重度</strong>），我们希望它对应 <span class="math inline">\(k\)</span> 个线性无关的特征向量。</li>
</ul>
]]></content>
      <categories>
        <category>math</category>
      </categories>
      <tags>
        <tag>MIT18.06</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 Lab2 RAFT</title>
    <url>/6-824/raft1/</url>
    <content><![CDATA[<p>对于 Raft，官网的说法是这样的：</p>
<blockquote>
<p>Raft 是一个易于理解的共识算法。在容错性和性能方面，它相当于 Paxos。不同之处在于，它被分解成相对独立的子问题，并且清楚地解决了实际系统所需的所有主要部分。我们希望 Raft 将向更广泛的受众提供共识，并希望这些更广泛的受众将能够开发出比现在更高质量的基于共识的系统。</p>
</blockquote>
<p>之前参加了 pingcap 组织的训练营，lab2 也是 raft，但由于零基础，很快就被干碎了。故本次前来尝试教学级别的 raft code，希望6.824 善待我。</p>
<span id="more"></span>
<h4 id="part-a-raft-leader-election">PART A-Raft Leader Election</h4>
<p>关于 Raft，有一个<a href="http://thesecretlivesofdata.com/raft/#home">非常通俗易懂的Raft 可视化网站</a>，以及<a href="https://pdos.csail.mit.edu/6.824/papers/raft-extended.pdf">描述 Raft 算法的论文</a>。我只能说这个算法很复杂，很有挑战性。</p>
<p>part A 是 code 出 Raft 节点在启动后，超过一定时间间隔自动发起选举并当上领导者的过程。我把这一过程描述为以下步骤：</p>
<ol type="1">
<li><p>节点自身包含一个定时器，自动增长，在 timeout 时间间隔内满足以下条件</p>
<ul>
<li>未投票给其它节点</li>
<li>未收到当前 leader 的RPC</li>
<li>未发起选举</li>
</ul>
<p>则将自身状态变为 Candidate，CurrentTerm 加一，并请求其它各个节点（下称 Peers）给自己投票</p></li>
<li><p>Peers 收到 requestVote 消息后，对该消息进行处理，并按照一定规则判断是否能够同意其成为 leader</p></li>
<li><p>如果 Candidate 收到了超过半数的赞成票（自己也算一票），则成为当前 Term 的 leader</p></li>
</ol>
<p>至此，一个完整的选举过程就结束了。另外，节点成为 leader 后，需要定期向其它 Peers 发送不带任何 log 的特殊 AppendEntriesRPC，也就是所谓的 <strong>HeartBeat</strong>。</p>
<p>这一部分并不难，只需修改 Raft.go 即可，而解决它的关键在于 paper 中的 Figure2，为本实验提供了非常有用的结构体定义以及规则。同时，goroutines 也为我们解决某些问题提供了很重要的一个手段。</p>
<h5 id="结构体定义">结构体定义</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 每个日志条目存相应的索引、term 以及操作</span></span><br><span class="line"><span class="keyword">type</span> LogEntry <span class="keyword">struct</span> &#123;</span><br><span class="line">	Index   <span class="type">int</span></span><br><span class="line">	Term    <span class="type">int</span></span><br><span class="line">	Command <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的 RaftState 与 persister 里的不一样</span></span><br><span class="line"><span class="keyword">type</span> RaftState <span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	Follower  RaftState = <span class="string">&quot;Follower&quot;</span></span><br><span class="line">	Candidate RaftState = <span class="string">&quot;Candidate&quot;</span></span><br><span class="line">	Leader    RaftState = <span class="string">&quot;Leader&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Raft <span class="keyword">struct</span> &#123;</span><br><span class="line">	mu        sync.RWMutex</span><br><span class="line">	peers     []*labrpc.ClientEnd</span><br><span class="line">	persister *Persister</span><br><span class="line">	me        <span class="type">int</span></span><br><span class="line">	dead      <span class="type">int32</span></span><br><span class="line"></span><br><span class="line">	CurrentTerm <span class="type">int</span></span><br><span class="line">	VoteFor     <span class="type">int</span></span><br><span class="line">	Entry       []LogEntry</span><br><span class="line">	raftState   RaftState</span><br><span class="line"></span><br><span class="line">	commitIndex <span class="type">int</span></span><br><span class="line">	lastApplied <span class="type">int</span></span><br><span class="line">	nextIndex   []<span class="type">int</span></span><br><span class="line">	matchIndex  []<span class="type">int</span></span><br><span class="line"></span><br><span class="line">	applyChannel <span class="keyword">chan</span> ApplyMsg</span><br><span class="line">	applyCond    *sync.Cond</span><br><span class="line"></span><br><span class="line">	electionTimer  *time.Timer</span><br><span class="line">	heartbeatTimer *time.Timer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="timer">Timer</h5>
<p>尽管 6.824 提了一嘴不要用 go time 库里的 timer，但感觉应该是怕学生不会用用错(</p>
<p>根据算法要求，需要<strong>选举定时器</strong>和<strong>心跳定时器</strong>各一个，每个定时器到点了都要触发一次事件，并且根据节点的 raftState 不同，进行不同的重置定时器操作。</p>
<blockquote>
<p>由于 lab 要求 1s 内最多发十次心跳，所以 HeartBeatTimeOut 设置为 100ms</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> ResetTimer(isleader <span class="type">bool</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> isleader &#123;</span><br><span class="line">        rf.heartbeatTimer.Reset(rf.HeartBeatTimeOut())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rf.electionTimer.Reset(rf.ElectionTimeOut())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Ticker() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        <span class="keyword">select</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> &lt;-rf.electionTimer.C:</span><br><span class="line">            <span class="comment">// 选举投票超时，发起选举</span></span><br><span class="line">            <span class="keyword">case</span> &lt;-rf.heartbeatTimer.C:</span><br><span class="line">            <span class="comment">// 心跳超时，发送心跳</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="candidate-发送投票请求">Candidate 发送投票请求</h5>
<p>关键点在于如何应对过期的 reply。这里在每次收到 reply 时，都对整个节点上读写锁，获取当前状态是否为 Candidate 并检查 reply 的 term 是否与节点当前 term 一致。一旦有一个条件不满足，则认为该消息已过时。</p>
<blockquote>
<p>由于每个 goroutine 在对 reply 的处理是互斥的，所以这是判断消息是否过期的最有效的办法。</p>
</blockquote>
<p>若 Candidate 成功当选（破坏条件1）或收到了一个更高 term 节点的回复而更新自己的状态（破坏条件1, 2），说明这次选举已经可以结束了，再进行下去没有意义了，后续收到所有的该次选举产生的 reply 都作废。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartElection() &#123;</span><br><span class="line">    voteCnt := <span class="number">1</span>	<span class="comment">// 赞成票数</span></span><br><span class="line">    args := rf.GetRequestVoteArg()</span><br><span class="line">	<span class="keyword">for</span> i := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> i != rf.me &#123;</span><br><span class="line">            <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(peer <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">                <span class="keyword">for</span> &#123;</span><br><span class="line">                    reply := &amp;RequestVoteReply&#123;&#125;</span><br><span class="line">                    <span class="keyword">if</span> rf.peers[peer].Call(<span class="string">&quot;Raft.RequestVote&quot;</span>, args, reply) &#123;	<span class="comment">// 发送成功了</span></span><br><span class="line">                        rf.mu.Lock()</span><br><span class="line">                        <span class="keyword">if</span> rf.raftState == Candidate &amp;&amp; rf.CurrentTerm == args.Term &#123;	<span class="comment">// 处理过时 reply</span></span><br><span class="line">                            <span class="keyword">if</span> reply.Grant &#123;</span><br><span class="line">                                voteCnt++</span><br><span class="line">                                <span class="keyword">if</span> voteCnt &gt; <span class="built_in">len</span>(rf.peers)/<span class="number">2</span> &#123;</span><br><span class="line">                                    <span class="comment">// 成为 Leader</span></span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> <span class="keyword">if</span> reply.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">                                <span class="comment">// 当前 term 已过时，需要更新并转为 Follower</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        rf.mu.Unlock()</span><br><span class="line">                        <span class="keyword">return</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;(i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="对投票请求进行回复">对投票请求进行回复</h5>
<p>因为 2A 部分没有 AppendEntries，所以暂时不用考虑 paper 中各种和 Log 有关的变量。</p>
<blockquote>
<p>这里给 reply 加了个变量 Err，为了在打 log 的时候能够知道是因为什么而拒绝了该次投票，从而更快定位 bug。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> RequestVote(args *RequestVoteArgs, reply *RequestVoteReply) &#123;</span><br><span class="line">    rf.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> rf.mu.Unlock()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收到过时 rpc</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &lt; rf.CurrentTerm &#123;</span><br><span class="line">        reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">false</span>, ErrOldTerm</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 term 内已给其他节点投过票</span></span><br><span class="line">    <span class="keyword">if</span> args.Term == rf.CurrentTerm &amp;&amp; (rf.VoteFor != null &amp;&amp; rf.VoteFor != args.CandidateId) &#123;</span><br><span class="line">        reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">false</span>, ErrVoted</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前 term 已过时，需要更新并转为 Follower</span></span><br><span class="line">    <span class="keyword">if</span> args.Term &gt; rf.CurrentTerm &#123;</span><br><span class="line">        rf.VoteFor, rf.CurrentTerm = null, args.Term</span><br><span class="line">        rf.ChangeState(Follower)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LastLogTerm := rf.GetLastLog().Term</span><br><span class="line">    LastLogIndex := rf.GetLastLog().Index</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没问题了，就给它投赞成票</span></span><br><span class="line">    reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">true</span>, OK</span><br><span class="line">    rf.VoteFor = args.CandidateId</span><br><span class="line">    rf.ResetTimer(<span class="literal">false</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="成为-leader">成为 leader</h5>
<p>当选后需<strong>立即</strong>广播一次 <strong>HeartBeat</strong>，以巩固地位。</p>
<blockquote>
<p>否则，考虑这种情况：A 和 B 同时发起投票，C 因为先收到 B 的请求而给 B 投了赞成票，之后收到 A 的请求，因为已经投了票故没有投给 A，也就没有更新选举定时器。最后 A 当选了，如果不马上广播 HeartBeat 而是等心跳定时器超时，则有可能在这段时间内 C 触发了选举超时，进行新的一轮选举。<strong>而事实上我们并不需要这一次多余的选举</strong>。</p>
<p><strong>尽量避免不必要的流程</strong>。</p>
</blockquote>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> StartHeartbeat() &#123;</span><br><span class="line">    <span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> peer != rf.me &#123;</span><br><span class="line">            <span class="keyword">go</span> rf.SendHeartBeat(peer)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2A 中，<code>SendHeartBeat()</code>不需要发送多余的信息，只要告诉其它节点“我”的当前 term 即可。其它节点收到 rpc 后，根据收到的 term 进行相应操作。</p>
<h4 id="part-b-log-replication">PART B-Log Replication</h4>
<p>这一 part 要求我们实现 Log 的发送、接受与提交，选举约束与快速恢复。</p>
<h5 id="appendentry">AppendEntry</h5>
<p>上层通过调用 Start() 函数向 Leader 发送一个 command，我们需要将这一 command 以日志的形式记录下来，并告知其他 raft node。按照实验要求，我们需要立刻返回这一 command 在日志中的索引与相应 term，同时如果上层调用的结点是 Leader ，则返回 true。</p>
<p>Leader 结点还是会每隔一定时间发送 Heartbeat，但此时在每个心跳期间，我们可能是有日志要发送的。通过阅读论文发现，有这样一个变量：</p>
<ul>
<li>nextIndex[]：for each server, index of the next log entry to send to that server (initialized to leader last log index + 1)</li>
</ul>
<p>所以我们对当前是发 HB 是否要捎带日志，只需要判断 next[server] 是否 ≤ LastLogIndex 即可，且要求：</p>
<ul>
<li>If last log index ≥ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex。</li>
</ul>
<p>上面是发送侧，下面说接收侧。</p>
<p>paper 中提到了以下规则：</p>
<ol type="1">
<li>Reply false if term &lt; currentTerm (§5.1)</li>
<li>Reply false if log doesn’t contain an entry at prevLogIndex whose term matches prevLogTerm (§5.3)</li>
<li>If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it (§5.3)</li>
<li>Append any new entries not already in the log</li>
<li>If leaderCommit &gt; commitIndex, set commitIndex = min(leaderCommit, index of last new entry)</li>
</ol>
<p>逐个 adapt 到代码里即可。</p>
<p>另外，paper 中还提到了：</p>
<ul>
<li>If there exists an N such that N &gt; commitIndex, a majority of matchIndex[i] ≥ N, and log[N].term == currentTerm: set commitIndex = N (§5.3, §5.4).</li>
</ul>
<p>这条规则就是让我们更新 commitIndex 用的。在每次处理 AE 的 reply 时，都对当前其它 peers 的 matchIndex 进行遍历，找到第二大的 matchIndex 即可，该值必然满足 <strong>a majority of matchIndex[i] ≥ N</strong>。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> FindN() &#123;</span><br><span class="line">    <span class="comment">// locked</span></span><br><span class="line">    matchIndexSet := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> peer := <span class="keyword">range</span> rf.peers &#123;</span><br><span class="line">        <span class="keyword">if</span> peer != rf.me &#123;</span><br><span class="line">            matchindex, _ := rf.GetMatchNextIndex(peer)</span><br><span class="line">            matchIndexSet = <span class="built_in">append</span>(matchIndexSet, matchindex)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Ints(matchIndexSet)</span><br><span class="line">    N := matchIndexSet[<span class="built_in">len</span>(rf.peers)/<span class="number">2</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> N &gt; rf.commitIndex &amp;&amp; rf.Entry[N].Term == rf.CurrentTerm &#123;</span><br><span class="line">        rf.UpdateCommitAndApply(N)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个我一开始没搞清楚的坑在于：每次更新 Applied 不能用 Goroutine，否则会报 "out of order xxx" 的错，也就是未按序 apply。</p>
<h5 id="选举约束">选举约束</h5>
<p>这其实很好理解，Follwer 只 Grant 最后一个日志比它更 up-to-date 的 VoteRequest，也就是说要满足以下两点：</p>
<ol type="1">
<li>Candidate.LastLogTerm &gt; Follwer.LastLogTerm</li>
<li>if Candidate.LastLogTerm == Follwer.LastLogTerm, Candidate.len(Entry) &gt; Follwer.len(Entry)</li>
</ol>
<p>如果不满足，就拒绝。</p>
<p>需要加上这样一个条件：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 自己有的 LogEntry 条目更 up-to-date</span></span><br><span class="line"><span class="keyword">if</span> args.LastLogTerm &lt; LastLogTerm || (args.LastLogTerm == LastLogTerm &amp;&amp; args.LastLogIndex &lt; LastLogIndex) &#123;</span><br><span class="line">    reply.Term, reply.Grant, reply.Err = rf.CurrentTerm, <span class="literal">false</span>, ErrLogNotMatch</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="快速恢复">快速恢复</h5>
<p>Guide 上面讲的还挺清楚的，conflictIndex 是发生冲突时 <strong>Follwer 日志里的 Index</strong>，conflictTerm 就是那个索引下对应日志的 Term。</p>
<p><strong>接受侧：</strong></p>
<ul>
<li>If a follower does not have prevLogIndex in its log, it should return with <strong>conflictIndex = len(log)</strong> and <strong>conflictTerm = None</strong>.</li>
<li>If a follower does have prevLogIndex in its log, but the term does not match, it should return <strong>conflictTerm = log[prevLogIndex].Term</strong>, and then search its log for <strong>the first index whose entry has term equal to conflictTerm</strong>.</li>
</ul>
<p><strong>发送侧：</strong></p>
<ul>
<li>Upon receiving a conflict response, the leader should first search its log for conflictTerm. If it finds an entry in its log with that term, it should <strong>set nextIndex to be the one beyond the index of the last entry in that term in its log</strong>.</li>
<li>If it does not find an entry with that term, it should <strong>set nextIndex = conflictIndex</strong>.</li>
</ul>
<p>这样做有助于快速修改 next[]，而不用每次都只是减一。这里我用了 binarysearch 来找对应的 index。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> FindNextIndex(ConflictIndex, ConflictTerm <span class="type">int</span>) (next <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ConflictTerm == <span class="number">0</span> || rf.Entry[ConflictIndex].Term == ConflictTerm &#123;</span><br><span class="line">        next = ConflictIndex</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left, right := BaseIndex, rf.Entry[<span class="built_in">len</span>(rf.Entry)<span class="number">-1</span>].Index</span><br><span class="line">    <span class="keyword">for</span> left &lt; right<span class="number">-1</span> &#123;</span><br><span class="line">        mid := left + (right-left)/<span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> rf.Entry[mid-BaseIndex].Term &lt;= ConflictTerm &#123;</span><br><span class="line">            left = mid</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> rf.Entry[right-BaseIndex].Term == ConflictTerm &#123;</span><br><span class="line">        next = right + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> rf.Entry[left-BaseIndex].Term == ConflictTerm &#123;</span><br><span class="line">        next = left + <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next = ConflictIndex</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="其他">其他</h5>
<ol type="1">
<li>在生成 raft node 的时候我把一个 index:0 term:0 的日志塞到里面，这样就能让它每一个 index 都能直接对应，而不需要考虑数组从 0 开始，PrevLogTerm 也就不需要考虑 PrevLogIndex 是否大于零了。</li>
<li>AppendEntryRPC 成功和失败都返回 ConflictIndex 和 ConflictTerm，而 AE 成功时我们就认为 ConflictIndex 是 Follwer 的最后一个索引，HB 成功时则设置为 args.PrevLogIndex（这是参考了 Raft 官网的设定），就能正确更新到 next[server]</li>
</ol>
<h4 id="part-c-persistence">PART C-Persistence</h4>
<p>这块虽然标了 hard，但实际代码量可以忽略不计。总的来说要我们实现一致性，即能保证节点 crash 后能恢复到原来的状态。</p>
<p>Paper 中已经为我们标出了哪些变量（VoteFor、Term、Entry）是需要保持一致性的，所以 Persist() 和 ReadPersist() 没什么好聊的，直接 uncomment 掉，稍微改改就好了。</p>
<p>我们需要在这三个变量被修改的时候，及时调用 Persist() 函数以保存到 rf.Persist 里。</p>
<ul>
<li><strong>VoteFor</strong>：这个变量只有在两种情况下会变：
<ol type="1">
<li>收到投票申请，同意投票。 这个直接在 RequestVote 里改就好了。</li>
<li>任期改变，重置投票。 收到任一 Term 大于 CurrentTerm 的 Message 都会导致任期改变，同时也会使节点“convert to Follwer（Rules For Servers）”。</li>
</ol></li>
<li><strong>Term</strong>：同上。</li>
<li><strong>Entry</strong>：直接在 AppendEntries() 里加。</li>
</ul>
<p>由于系统的高并发性与网络的不可靠性，我们还需要在合适的位置及时上锁，尽可能保证线性一致（善用 rf.mu）。</p>
<p>以及测试中有两个是 unreliable network ，意味着会丢包，我在 log 的时候发现这会导致选举的赞成票迟迟发不到 candidate 手上（被网络丢弃了），就是出现 Term 不断增加而没有 Leader 出现。于是在 sendRequestVote 里把 Call 改成了循环发送直至返回 true。</p>
<blockquote>
<p>不需要在 SendHeartBeat 里应用这一修改，因为心跳的发送是周期性的，很有可能上一个心跳时刻由于没收到 reply 而重复发，发着发着就到下一个心跳时刻了，这是我们不能接受的。</p>
</blockquote>
<h4 id="part-d-log-compaction">PART D-Log Compaction</h4>
<p>由于日志会无限增长，如果不采取某些措施，内存则会被大大浪费。Paper 第七节提出了“日志压缩”这一机制，也就是 Leader 节点定期在 Raft 层调用 Snapshot() 将当前 Application 层的状态以快照的形式保存，并丢弃那些已经被 Applied 的日志——这些日志在之后的时间不会再被用到。如下图所示</p>
<p><img src="raf1ukdq.jpg" style="zoom:80%;" /></p>
<p>原理就如 Paper 中说的那样。 在这一 part 中我们需要做这些事情：</p>
<ol start="0" type="1">
<li>改变 Entry 的索引方式</li>
<li>实现 Snapshot() 函数</li>
<li>实现 InstallSnapshotRPC() 以及相应的 args、reply</li>
<li>实现 crash 后恢复所需的持久状态</li>
</ol>
<h5 id="索引">索引</h5>
<p>因为节点的日志里存的 Index 不一定和数组下标一一对应了，前面我将每个 rf.Entry[0] 都设为一个 {Index:0, Term: 0} 的哨兵来防止越界，在这里由于进行了日志压缩，哨兵可以改为 {Index: LastIncludedIndex, Term: LastIncludedTerm}，这样一来日志索引 index 到数组里的位置就变成了 index - rf.Entry[0].Index</p>
<p>⚠ 每个涉及到<strong>索引</strong>的地方都要进行修改</p>
<h5 id="snapshotindex-int-snapshot-byte">Snapshot(index int, snapshot []byte)</h5>
<p>这里的 index 其实就是 LastIncludedIndex，snapshot 其实就是上层告诉我们的状态，需要保存到 persist 里。 我们对 index 进行一个范围的判断，如果不越界，则进行日志的截断，并进行一个 persist.SaveSnapshot 的操作。</p>
<blockquote>
<p>因为 persist.go 里没有单独保存 snapshot 的函数，我就自己加了一个。 （根据观察，测试里好像会隐式对所有节点调用 Snapshot，当然我也不确定、、）</p>
</blockquote>
<h5 id="installsnapshotrpc">InstallSnapShotRPC</h5>
<p>args 和 reply 要的变量都直接在 6.824 lab 网页的 hint 里和 paper 里找就行。 唯一要解决的问题是发送端要怎么处理这个 RPC—— 我的处理方法是，如果某个要发送的 AppendEntries 的 PrevLogIndex 比 Leader 当前存的第一个日志的 Index 还要小，说明这个 peer 已经落后太多，Leader 没有更早的日志能发过去了，那就直接告诉它要采用这个快照，一步到位，然后更新 Leader 里这个 peer 对应的 nextIndex。 那么接收侧如果收到了这一 RPC，先按照 paper 里说的检查一下，无误后自己截断日志，并更新 lastapplied 和 commitindex（snapshot 里没有这一步）</p>
<blockquote>
<p>考虑到并发性，我选择让这一 RPC 和 AE RPC 有同等地位——每个心跳时刻只发送其中的一个，否则会出现上一个心跳时刻的 goroutine 和下一个心跳时刻的 goroutine 时间上起冲突</p>
</blockquote>
<p>BTW，2D 测试一开始会出现 <a href="https://thesquareplanet.com/blog/students-guide-to-raft/">RAFT GUIDE</a> 里最后提到的“四向死锁”这一糟糕的情况，解决方案是在建立 raft 节点时，开一个新线程让其 Apply 日志，每次 CommitIndex 更新时，都通过 raft 里的某个条件变量唤醒线程，让其工作，然后再次进入 Wait()</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(rf *Raft)</span></span> Applier() &#123;</span><br><span class="line">    <span class="keyword">for</span> !rf.killed() &#123;</span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        <span class="keyword">for</span> !(rf.lastApplied &lt; rf.commitIndex) &#123;</span><br><span class="line">            rf.applyCond.Wait()</span><br><span class="line">        &#125;</span><br><span class="line">        CommitIndex := rf.commitIndex</span><br><span class="line">        BaseIndex := rf.GetBaseLog().Index</span><br><span class="line">        Entries := <span class="built_in">make</span>([]LogEntry, rf.commitIndex-rf.lastApplied)</span><br><span class="line">        <span class="built_in">copy</span>(Entries, rf.Entry[rf.lastApplied+<span class="number">1</span>-BaseIndex:rf.commitIndex+<span class="number">1</span>-BaseIndex])</span><br><span class="line">        </span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">        <span class="keyword">for</span> _, Entry := <span class="keyword">range</span> Entries &#123;</span><br><span class="line">            rf.applyChannel &lt;- ApplyMsg&#123;</span><br><span class="line">                CommandValid: <span class="literal">true</span>,</span><br><span class="line">                Command:      Entry.Command,</span><br><span class="line">                CommandTerm:  Entry.Term,</span><br><span class="line">                CommandIndex: Entry.Index,</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        rf.mu.Lock()</span><br><span class="line">        rf.lastApplied = max(rf.lastApplied, CommitIndex)</span><br><span class="line">        rf.mu.Unlock()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>6.824 Lab3 FTkvserver</title>
    <url>/6-824/raft2/</url>
    <content><![CDATA[<p>本实验要求在每一个 raft 节点上实现一个 K/V 服务器(server)，向上接受客户端(client)的请求并返回请求结果，向下生成日志应用到 raft 节点中。</p>
<p>整个模式大概长<a href="https://pdos.csail.mit.edu/6.824/notes/raft_diagram.pdf">这样</a>。</p>
<p>主要流程是这样的：</p>
<ol type="1">
<li>client 寻找对应 raft 节点是 leader 的 server，并发起一个请求(Put/Append/Get)；</li>
<li>server 收到请求后，调用 raft 的 Start() 函数；</li>
<li>raft 节点间互相 AppendEntries 之后，将消息 apply 到 applyChannel 里；</li>
<li>server 从 applyChannel 中取出消息，之后正式将命令应用到数据库中。</li>
</ol>
<span id="more"></span>
<h4 id="part-a-keyvalue-service-without-snapshots">PART A-Key/value service without snapshots</h4>
<h5 id="发送请求">发送请求</h5>
<p>由于 Start() 函数会立即返回 isleader 信息，所以如果一个 server 节点调用了 Start() 后发现不是 leader，则返回一个 <strong>ErrWrongLeader</strong></p>
<p>当且仅当 client RPC 成功并且发送给正确的 leader 后，才算成功；否则：</p>
<ol type="1">
<li>If the Clerk sends an RPC to the wrong kvserver, or if it cannot reach the kvserver, the Clerk should re-try by sending to a different kvserver.</li>
<li>If the operation failed to commit (for example, if the leader was replaced), the server reports an error, and the Clerk retries with a different server.</li>
</ol>
<h5 id="server-向下调用">server 向下调用</h5>
<p>首先是根据 Start() 返回的 isleader 来确定是否需要返回 ErrWrongLeader 错误。若成功，则等待流程 4。</p>
<p>注意到，在等待的过程中 server 是上了锁的，那必然被阻塞，此时就需要在 startKVserver 的时候额外开启一个叫 Applier() 的 goroutine 来进行 applyChannel 的读取。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(kv *KVServer)</span></span> Applier() &#123;</span><br><span class="line">    <span class="keyword">for</span> !kv.killed() &#123;</span><br><span class="line">        msg := &lt;-kv.applyCh</span><br><span class="line">        <span class="keyword">if</span> msg.CommandValid &#123;</span><br><span class="line">            <span class="comment">// 应用操作</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> msg.SnapshotValid &#123;</span><br><span class="line">            <span class="comment">// 应用快照</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时遇到这样一个问题： 有一个网络分区 [1] | [2，3，4，5]，1 是分区前的 leader，分区后 1 仍然是 leader。第二个分区由于选主导致其 term 大于 1 的 term。 有一个 client A 一直给 [1] 发送请求，某一个请求 （requestID：x，clientID：A）发过去调用 1 的 start 并返回日志所在索引 index 后，网络恢复，[1] 收到新的 leader 消息后执行 appendEntries 并将原先 index 处的日志覆盖，更新 commitindex 后将覆盖后的日志传回 applyCh，而我采用的是 map[commandIndex] chan 的形式，由于同一索引处的日志被覆盖了，导致 server Applier 处理管道发回的错误请求，比如 get 到错误的值 or 未进行 append</p>
<p>解决方法为：在 arg 中开一个 channel，当 applier 处理完消息时通过该 channel 返回处理结果，同时判断当前 msg 中的 term 和 kv.rf.currentTerm 是否匹配，如果不匹配，说明可能被其他日志覆盖，返回一个 ErrWrongLeader 让上层重发。</p>
<blockquote>
<p>发现 6.824 labrpc 的 call 函数在传的时候会把 chan 给弄没掉。于是只能在 server 里 args.ch = make(chan int)，同时为了防止遇到的 chan 是 nil，还要加个判断当前是否为 leader，因为只有 leader 的 chan 是有效的，用 call 发给 follower 后会 arg 里的 chan 会变成 nil</p>
</blockquote>
<h5 id="应用到状态机">应用到状态机</h5>
<p>Applier() 对 applyChannel 进行一个 for 的等待，收到消息后，根据收到消息的命令类型的不同，执行不同的应用操作。</p>
<blockquote>
<p>Put(key, value) replaces the value for a particular key in the database, Append(key, arg) appends arg to key's value, and Get(key) fetches the current value for the key. A Get for a non-existent key should return an empty string. An Append to a non-existent key should act like Put.</p>
</blockquote>
<p>执行完后，返回消息到 waitchannel[index]，唤醒 server。</p>
<h5 id="other">Other</h5>
<ol type="1">
<li><p>刚开始想到和 Raft 里发送请求投票一样的手段，为每一个 server 开一个 goroutine 去发送 RPC，后来发现最后成功发送的只有一个，其它 goroutine 都是在占 cpu，遂放弃，直接用 for 循环。另外，有时候 leader 会在相当一段时间内保持不变，我们可以保存上一次发送请求成功时的 serverId，认为这是 leader，每次发请求时都可以利用这一信息，避免了不必要的 RPC，加快速度。当 RPC 失败，或发生了 ErrWrongLeader，只需要简单的令 leader 切换到下一个即可（0-&gt;1-&gt;...-&gt;n-1-&gt;0-&gt;...）</p>
<p><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(ck *Clerk)</span></span> SendRequest(args *Args) <span class="type">string</span> &#123;</span><br><span class="line">    ck.mu.Lock()</span><br><span class="line">    <span class="keyword">defer</span> ck.mu.Unlock()</span><br><span class="line">    args.RequestId, args.ClerkId = ck.RequestId, ck.ClerkId</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        reply := &amp;Reply&#123;&#125;</span><br><span class="line">        ok := ck.servers[ck.volatileLeader].Call(<span class="string">&quot;KVServer.HandleRequest&quot;</span>, args, reply)</span><br><span class="line">        <span class="keyword">if</span> ok &amp;&amp; reply.Err != ErrWrongLeader &#123;</span><br><span class="line">            ck.RequestId++</span><br><span class="line">            <span class="keyword">return</span> reply.Value</span><br><span class="line">        &#125;</span><br><span class="line">        ck.volatileLeader = (ck.volatileLeader + <span class="number">1</span>) % <span class="built_in">len</span>(ck.servers)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p></li>
<li><p>在分区测试中，有可能发生 leader 超时未 apply 的情况（即一个 leader 被分到了 minority 的网络区），此时需要在 server 等待环节加一个 &lt;-time.After() 的信号接受判断，若超时，则直接返回，并且认为超时也是一种“WrongLeader”。</p></li>
<li><p>lab3A 还要求我们不能执行同一个 client 的重复请求，那么需要在每个 server 上放一个 clientID 到其最近一次命令序号 requestID 的映射，如果 Worker 收到的这个命令序号已经被执行过了，那么就不再执行，直接返回 ErrDuplicated。Get 是否重复执行无所谓，因为它并不会对数据库产生实质性的影响，主要是防止多次 Put/Append 同一个值。</p></li>
</ol>
<p>总体代码量比 raft 少太多，但因为论文中并没有给出很详细的指示，就走了很多弯路，以至于绝大多数时间都在 debug...</p>
<h4 id="part-b-keyvalue-service-with-snapshots">PART B-Key/value service with snapshots</h4>
<p>本实验要求在 3A 的基础上加上 snapshot 功能。</p>
<blockquote>
<p>虽然标的是hard，但代码量更少了</p>
</blockquote>
<p>server 不断检测 raftStateSize，如果过大，即当 persist.RaftStateSize() &gt;= kv.maxRaftState 时，将当前 db 状态保存下来，调用 raft 层的 snapshot() 并将 db 状态传入。</p>
<p>要实现有两个函数：</p>
<ol type="1">
<li><strong>MakeSnapshot()</strong> ：当 raftStateSize 过大时保存 db 状态。</li>
<li><strong>ApplySnapshot()</strong> ：raft 层将 snapshotValid 发到 applyCh，被 server 接收到后执行的操作。</li>
</ol>
<blockquote>
<p>persist 里的 raftstate 和 index 没有直接关系，所以不能用在 snapshot 里的 index 参数。</p>
</blockquote>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>lab</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware-FT</title>
    <url>/6-824/vmware-ft/</url>
    <content><![CDATA[<p>6.824 的第二篇论文是 VMware-FaultTolerance(VMware-FT)，其描述了一个提供容错虚拟机的商业企业级系统——如果主服务器(<strong>primary</strong>)发生故障，备份服务器(<strong>backup</strong>)始终可以接管。backup 的状态必须始终保持与 primary 几乎相同，以便在其发生故障时，backup 可以立即接管，并且外部客户端看来并未发生故障且没有数据丢失。</p>
<span id="more"></span>
<h4 id="两种容错方式">两种容错方式</h4>
<h5 id="状态转移">状态转移</h5>
<p>在 backup 上复制状态的一种方法是每次同步时，primary 将其<strong>所有状态</strong>（包括 CPU、内存和 I/O 设备）<strong>变化</strong>进行完整地拷贝，并发送到 backup。但发送此状态所需的带宽会非常大。为了提升效率，可以优化为：每次同步只发送上次同步之后改变了的状态。</p>
<h5 id="操作转移">操作转移</h5>
<p>将服务器建模为<strong>确定性状态机</strong>，并实现以下两个条件：</p>
<ol type="1">
<li>从相同的初始状态开始</li>
<li>以相同的顺序执行相同的操作</li>
</ol>
<p>如果能确保以上两个条件，那么它们会一直互为副本，并且一直保持一致。由于大多数服务器或服务都有一些不确定的操作，因此必须使用额外的协调来确保 primary 和 backup 保持同步，而这一协调所需的额外信息量远远少于 primary 中正在更改的状态量。</p>
<h4 id="总结">总结</h4>
<p>操作 Log 的复制与状态机的思路给后续以启迪。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition312</title>
    <url>/LeetCode/weekCompetition312/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-312/">第 312 场周赛</a>复盘。</p>
<p><strong>排名</strong> 1273 / 6638</p>
<span id="more"></span>
<h4 id="按身高排序">1. <a href="https://leetcode.cn/problems/sort-the-people/">按身高排序</a></h4>
<blockquote>
<p>给你一个字符串数组 <code>names</code> ，和一个由 <strong>互不相同</strong> 的正整数组成的数组 <code>heights</code> 。两个数组的长度均为 n 。</p>
<p>对于每个下标 i，<code>names[i]</code> 和 <code>heights[i]</code> 表示第 i 个人的名字和身高。</p>
<p>请按身高 <strong>降序</strong> 顺序返回对应的名字数组 <code>names</code> 。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>由于人名可能有重复，故不能建 map，而是将 name 与其对应的 height 作为一个整体，然后排序。</p>
<h5 id="code">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">sortPeople</span><span class="params">(vector&lt;string&gt;&amp; names, vector&lt;<span class="type">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        vector&lt;pair&lt;string, <span class="type">int</span>&gt;&gt; temp;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; names.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            temp.<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(names[i], heights[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>(), [&amp;](<span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;a, <span class="type">const</span> pair&lt;string, <span class="type">int</span>&gt; &amp;b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a.second &gt; b.second;</span><br><span class="line">        &#125;);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;it : temp) &#123;</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(it.first);</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="按位与最大的最长子数组">2. <a href="https://leetcode.cn/problems/longest-subarray-with-maximum-bitwise-and/">按位与最大的最长子数组</a></h4>
<blockquote>
<p>给你一个长度为 n 的整数数组 <code>nums</code> 。</p>
<p>考虑 <code>nums</code> 中进行 <strong>按位与</strong>运算得到的值 <strong>最大</strong> 的 <strong>非空</strong> 子数组。</p>
<ul>
<li>换句话说，令 k 是 <code>nums</code> <strong>任意</strong> 子数组执行按位与运算所能得到的最大值。那么，只需要考虑那些执行一次按位与运算后等于 k 的子数组。</li>
</ul>
<p>返回满足要求的 <strong>最长</strong> 子数组的长度。</p>
<p>数组的按位与就是对数组中的所有数字进行按位与运算。</p>
<p><strong>子数组</strong> 是数组中的一个连续元素序列。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>首先有一个性质：<code>a AND b ≤ min(a, b)</code>，那么 AND 运算能够得到的最大值必然是整个数组的最大值。从而问题转换为，找到一个最长的连续子数组，其中所有元素都是 <code>nums[]</code> 中的最大值。</p>
<h5 id="code-1">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestSubarray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> maxm = *<span class="built_in">max_element</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == maxm) &#123;</span><br><span class="line">                <span class="type">int</span> j = i + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (nums[j] != nums[i]) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res = <span class="built_in">max</span>(res, j - i);</span><br><span class="line">                i = j<span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="找到所有好下标">3. <a href="https://leetcode.cn/problems/find-all-good-indices/">找到所有好下标</a></h4>
<blockquote>
<p>给你一个大小为 n 下标从 <strong>0</strong> 开始的整数数组 <code>nums</code> 和一个正整数 k 。</p>
<p>对于 <code>k &lt;= i &lt; n - k</code> 之间的一个下标 i ，如果它满足以下条件，我们就称它为一个 <strong>好</strong> 下标：</p>
<ul>
<li>下标 i <strong>之前</strong> 的 k 个元素是 <strong>非递增的</strong> 。</li>
<li>下标 i <strong>之后</strong> 的 k 个元素是 <strong>非递减的</strong> 。</li>
</ul>
<p>按 <strong>升序</strong> 返回所有好下标。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>定义 <code>assend[]</code> 与 <code>dessend[]</code>：如果一个数比它前面那个数大，则 <code>assend[i] = 1</code>；如果一个数比它后面那个数小，则 <code>dessend[i] = 1</code></p>
<p>问题就变为：找到一个下标，它前面 k-1 个下标的 assend 值均为 0，后面 k-1 个下标的 dessend 值也均为 0</p>
<p>用滑动窗口来维护前后 k-1 个下标的 assend/dessend 值中 1 的个数，每个迭代的过程只需判断个数是否均为 0 即可。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">goodIndices</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(nums)</span><br><span class="line">    </span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> n - k &lt;= k &#123;</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    assend := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    dessend := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> &amp;&amp; nums[i] &gt; nums[i<span class="number">-1</span>] &#123;</span><br><span class="line">            assend[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            assend[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> i &lt; n<span class="number">-1</span> &amp;&amp; nums[i] &gt; nums[i+<span class="number">1</span>] &#123;</span><br><span class="line">            dessend[i] = <span class="number">1</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dessend[i] = <span class="number">0</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    left1, right1, left2, right2 := <span class="number">1</span>, k<span class="number">-1</span>, k+<span class="number">1</span>, <span class="number">2</span>*k<span class="number">-1</span></span><br><span class="line">    cnt1, cnt2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := left1; i &lt;= right1; i++ &#123;</span><br><span class="line">        cnt1 += assend[i]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := left2; i &lt;= right2; i++ &#123;</span><br><span class="line">        cnt2 += dessend[i]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span> &#123;</span><br><span class="line">        res = <span class="built_in">append</span>(res, k)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := k+<span class="number">1</span>; i &lt; n-k; i++ &#123;</span><br><span class="line">        right1++</span><br><span class="line">        cnt1 = cnt1 + assend[right1] - assend[left1]</span><br><span class="line">        left1++</span><br><span class="line">        </span><br><span class="line">        right2++</span><br><span class="line">        cnt2 = cnt2 + dessend[right2] - dessend[left2]</span><br><span class="line">        left2++</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> cnt1 == <span class="number">0</span> &amp;&amp; cnt2 == <span class="number">0</span> &#123;</span><br><span class="line">            res = <span class="built_in">append</span>(res, i)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="好路径的数目">4. <a href="https://leetcode.cn/problems/number-of-good-paths/">好路径的数目</a></h4>
<blockquote>
<p>给你一棵 n 个节点的树（连通无向无环的图），节点编号从 0 到 n - 1 且恰好有 n - 1 条边。</p>
<p>给你一个长度为 n 下标从 <strong>0</strong> 开始的整数数组 <code>vals</code> ，分别表示每个节点的值。同时给你一个二维整数数组 <code>edges</code> ，其中 <code>edges[i] = [ai, bi]</code> 表示节点 ai 和 bi 之间有一条 <strong>无向</strong> 边。</p>
<p>一条 <strong>好路径</strong> 需要满足以下条件：</p>
<ul>
<li>开始节点和结束节点的值 <strong>相同</strong> 。</li>
<li>开始节点和结束节点中间的所有节点值都 <strong>小于等于</strong> 开始节点的值（也就是说开始节点的值应该是路径上所有节点的最大值）。</li>
</ul>
<p>请你返回不同好路径的数目。</p>
<p>注意，一条路径和它反向的路径算作 同一 路径。比方说， <code>0 -&gt; 1</code> 与 <code>1 -&gt; 0</code> 视为同一条路径。单个节点也视为一条合法路径。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>参考了 <a href="https://leetcode.cn/problems/number-of-good-paths/solution/bing-cha-ji-by-endlesscheng-tbz8/">这位大佬的解法</a>。</p>
<p>朴素的考虑是，找到连通分量中所有的最大值节点，若有 <span class="math inline">\(x\)</span> 个，则共可以生成 <span class="math inline">\(\displaystyle C(x, 2) = \frac{x(x-1)}{2}\)</span> 条好路径；之后，将这些节点删除，对剩下的所有连通分量应用上述步骤。但这种方法实现起来较为复杂。</p>
<p>不妨逆向思维，从小到大走，同时将删除操作改为合并操作。于是可以考虑用<strong>并查集</strong>来完成这一操作。</p>
<p>刚开始所有节点都是 standalone 的，我们遍历 <code>edges[]</code> 时，不断合并节点，并让较大元素作为较小元素的<strong>代表元</strong>，一旦在合并过程中发现有两个节点的代表元相等（也就意味着这两个代表元满足<strong>好路径</strong>的要求），如果用 <code>size[]</code> 表示当前节点作为代表元时，所在并查集中最大值的数量，则可以用乘法解得合并后的连通分量里的好路径数量。</p>
<p>由于我们按照节点值升序访问节点，故每次只需和比自己小的邻居合并，则可以保证对于节点 <span class="math inline">\(v\)</span> 的任意邻居，其所在并查集的最大值不会超过 <span class="math inline">\(vals[v]\)</span>，好路径的数量也就不会遗漏。合并后 <span class="math inline">\(v\)</span> 即为代表元。</p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findfather</span><span class="params">(father []<span class="type">int</span>, x <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    a, temp := x, x</span><br><span class="line">    <span class="keyword">for</span> father[x] != x &#123;</span><br><span class="line">        x = father[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> a != x &#123;</span><br><span class="line">        a = father[a]</span><br><span class="line">        father[temp] = x</span><br><span class="line">        temp = a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfGoodPaths</span><span class="params">(vals []<span class="type">int</span>, edges [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(vals)</span><br><span class="line">    res := n  <span class="comment">// 所有单节点好路径数量</span></span><br><span class="line">    father := <span class="built_in">make</span>([]<span class="type">int</span>, n)  <span class="comment">// 代表元</span></span><br><span class="line">    size := <span class="built_in">make</span>([]<span class="type">int</span>, n)    <span class="comment">// 当前节点为代表元时, 所在并查集中最大值的数量</span></span><br><span class="line">    ids := <span class="built_in">make</span>([]<span class="type">int</span>, n)     <span class="comment">// 序号, 根据 vals[id] 来排序</span></span><br><span class="line">    graph := <span class="built_in">make</span>([][]<span class="type">int</span>, n) <span class="comment">// 图</span></span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> father &#123;</span><br><span class="line">        father[i] = i</span><br><span class="line">        size[i] = <span class="number">1</span></span><br><span class="line">        ids[i] = i</span><br><span class="line">        graph[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, edge := <span class="keyword">range</span> edges &#123;</span><br><span class="line">        x, y := edge[<span class="number">0</span>], edge[<span class="number">1</span>]</span><br><span class="line">        graph[x] = <span class="built_in">append</span>(graph[x], y)</span><br><span class="line">        graph[y] = <span class="built_in">append</span>(graph[y], x)</span><br><span class="line">    &#125;</span><br><span class="line">    sort.Slice(ids, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> vals[ids[i]] &lt; vals[ids[j]]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _, id := <span class="keyword">range</span> ids &#123;</span><br><span class="line">        fx := findfather(father, id)</span><br><span class="line">        <span class="keyword">for</span> _, neighbor := <span class="keyword">range</span> graph[id] &#123;</span><br><span class="line">            fy := findfather(father, neighbor)</span><br><span class="line">            <span class="keyword">if</span> fx == fy || vals[fy] &gt; vals[id] &#123; <span class="comment">// fx == fy 则无需合并, 只考虑比自己小的邻居</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> vals[fx] == vals[fy] &#123;</span><br><span class="line">                res += size[fx] * size[fy]</span><br><span class="line">                size[fx] += size[fy]</span><br><span class="line">            &#125;</span><br><span class="line">            father[fy] = fx</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition314</title>
    <url>/LeetCode/weekCompetition314/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-314/">第 314 场周赛</a>复盘。</p>
<p><strong>排名</strong> 1130 / 4838</p>
<span id="more"></span>
<h4 id="处理用时最长的那个任务的员工">1. <a href="https://leetcode.cn/problems/the-employee-that-worked-on-the-longest-task/">处理用时最长的那个任务的员工</a></h4>
<blockquote>
<p>共有 n 位员工，每位员工都有一个从 0 到 n - 1 的唯一 id。</p>
<p>给你一个二维整数数组 <code>logs</code>，其中 <code>logs[i] = [id_i, leaveTime_i]</code>：</p>
<p><code>id_i</code> 是处理第 i 个任务的员工的 id，且 <code>leaveTime_i</code> 是员工完成第 i 个任务的时刻。所有 <code>leaveTime_i</code> 的值都是 <strong>唯一</strong> 的。</p>
<p>注意，第 i 个任务在第 i - 1 个任务结束后立即开始，且第 0 个任务从时刻 0 开始。</p>
<p>返回处理用时最长的那个任务的员工的 id。如果存在两个或多个员工同时满足，则返回几人中 <strong>最小</strong> 的 id。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>找使得 <code>log[i][1] - log[i-1][1]</code> 最大的 <code>log[i]</code>，并取其中最小的那个 <code>log[i][0]</code></p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hardestWorker</span><span class="params">(n <span class="type">int</span>, logs [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res, max := logs[<span class="number">0</span>][<span class="number">0</span>], logs[<span class="number">0</span>][<span class="number">1</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(logs); i++ &#123;</span><br><span class="line">        diff := logs[i][<span class="number">1</span>] - logs[i<span class="number">-1</span>][<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">if</span> diff &gt; max &#123;</span><br><span class="line">            max = diff</span><br><span class="line">            res = logs[i][<span class="number">0</span>]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> diff == max &amp;&amp; res &gt; logs[i][<span class="number">0</span>] &#123;</span><br><span class="line">            res = logs[i][<span class="number">0</span>]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="找出前缀异或的原始数组">2. <a href="https://leetcode.cn/problems/find-the-original-array-of-prefix-xor/">找出前缀异或的原始数组</a></h4>
<blockquote>
<p>给你一个长度为 n 的 <strong>整数</strong> 数组 <code>pref</code> 。找出并返回满足下述条件且长度为 n 的数组 <code>arr</code>：</p>
<p><code>pref[i] = arr[0] ^ arr[1] ^ ... ^ arr[i]</code></p>
<p>注意 ^ 表示 按位异或运算。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p><code>pref[i+1] = pref[i] ^ arr[i]</code>，两边同时异或 <code>pref[i]</code>，得到 <code>arr[i] = pref[i] ^ pref[i+1]</code></p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findArray</span><span class="params">(p []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(p))</span><br><span class="line">    res[<span class="number">0</span>] = p[<span class="number">0</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(p); i++ &#123;</span><br><span class="line">        res[i] = p[i] ^ p[i<span class="number">-1</span>]</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使用机器人打印字典序最小的字符串">3. <a href="https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/">使用机器人打印字典序最小的字符串</a></h4>
<blockquote>
<p>给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t。执行以下操作之一，直到 s 和 t 都变成空字符串：</p>
<p>删除字符串 s 的 <strong>第一个</strong> 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。</p>
<p>删除字符串 t 的 <strong>最后一个</strong> 字符，并将该字符给机器人。机器人将该字符写到纸上。</p>
<p>请你返回纸上能写出的字典序最小的字符串。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>题目可以转为，给定一个字符串的入栈顺序，求所有出栈顺序中字典序最小的那个。所以需要把 t 等效为栈。</p>
<p>我们需要遍历 s，同时，在任意时刻，对于 t 栈顶（尾部）的字符而言：</p>
<ol type="1">
<li><p>如果 s 中尚存的字符中没有比它更小的，则将其 append 到结果字符串的末尾（写到纸上）；</p>
<blockquote>
<p>不难证明，这样贪心的做法一定会使字典序最小。</p>
</blockquote></li>
<li><p>反之，先将其加入栈中（添加到 t 的尾部），最后一并写出。</p></li>
</ol>
<p>可以用一个数组 <code>minm[]</code> 来表示 s 的当前 index 到末尾这一子串中 ASSIC 码最小的字符，那么 (1) 中的比较就变成了 <code>t.top()</code> 与 <code>minm[i]</code> 之间的比较。</p>
<h5 id="code-2">code</h5>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// c++</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">robotWithString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">minm</span><span class="params">(n)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; t;</span><br><span class="line">        string res;</span><br><span class="line">        </span><br><span class="line">        minm[n<span class="number">-1</span>] = s[n<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = n<span class="number">-2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            minm[i] = s[i] &lt; minm[i+<span class="number">1</span>] ? s[i] : minm[i+<span class="number">1</span>];</span><br><span class="line">        &#125;        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n<span class="number">-1</span>; i++) &#123;</span><br><span class="line">            t.<span class="built_in">push</span>(s[i]);	<span class="comment">// 删除 s 的第一个字符并添加到 t 的尾部</span></span><br><span class="line">            <span class="keyword">while</span> (!t.<span class="built_in">empty</span>() &amp;&amp; t.<span class="built_in">top</span>() &lt;= minm[i+<span class="number">1</span>]) &#123;	<span class="comment">// 若后面没有比 t 尾部字符更小的，写到纸上</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(st.<span class="built_in">top</span>());</span><br><span class="line">                t.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将 t 中所有字符写到纸上</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(s[n<span class="number">-1</span>]);</span><br><span class="line">        <span class="keyword">while</span> (!t.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(t.<span class="built_in">top</span>());</span><br><span class="line">            t.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="矩阵中和能被-k-整除的路径">4. <a href="https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/">矩阵中和能被 K 整除的路径</a></h4>
<blockquote>
<p>给你一个下标从 0 开始的 m x n 整数矩阵 grid 和一个整数 k 。你从起点 (0, 0) 出发，每一步只能往 <strong>下</strong> 或者往 <strong>右</strong> ，你想要到达终点 (m - 1, n - 1) 。</p>
<p>请你返回路径和能被 k 整除的路径数目，由于答案可能很大，返回答案对 <span class="math inline">\(10^9 + 7\)</span> 取余 的结果。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p><em>知道用动态规划，但没想出来，下面参考了别人的</em></p>
<p>定义 <code>dp[i][j][v]</code> 表示从 <code>(0, 0)</code> 走到 <code>(i, j)</code>，且路径和模 k 的结果为 v 时的路径数。</p>
<p>要使得从 <code>(0, 0)</code> 处走到 <code>(i, j)</code> 且路径和模 k 的结果为 v，前一个点只能是 <code>(i-1, j)</code> 或 <code>(i, j-1)</code>，且有</p>
<ul>
<li><code>(pathsum(i-1, j) + grid[i][j]) % k = pathsum(i, j) = v</code></li>
<li><code>(pathsum(i, j-1) + grid[i][j]) % k = pathsum(i, j) = v</code></li>
</ul>
<p>那么有如下状态转移方程：<code>dp[i][j][v] = dp[i-1][j][(v - grid[i][j]) % k] + dp[i][j-1][(v - grid[i][j]) % k]</code></p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numberOfPaths</span><span class="params">(grid [][]<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mod := <span class="number">1000000007</span></span><br><span class="line">    m, n := <span class="built_in">len</span>(grid), <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">    dp := <span class="built_in">make</span>([][][]<span class="type">int</span>, m)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        dp[i] = <span class="built_in">make</span>([][]<span class="type">int</span>, n)</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            dp[i][j] = <span class="built_in">make</span>([]<span class="type">int</span>, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>] % k] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt; n; j++ &#123;</span><br><span class="line">            <span class="keyword">for</span> v := <span class="number">0</span>; v &lt; k; v++ &#123;</span><br><span class="line">                <span class="keyword">if</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j][v] += dp[i<span class="number">-1</span>][j][(v - grid[i][j] + <span class="number">100</span>*k) % k]</span><br><span class="line">                    dp[i][j][v] %= mod</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">                    dp[i][j][v] += dp[i][j<span class="number">-1</span>][(v - grid[i][j] + <span class="number">100</span>*k) % k]</span><br><span class="line">                    dp[i][j][v] %= mod</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition313</title>
    <url>/LeetCode/weekCompetition313/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-313/">第 313 场周赛</a>复盘。</p>
<p><strong>排名</strong> 106 / 5445</p>
<span id="more"></span>
<h4 id="公因子的数目">1. <a href="https://leetcode.cn/problems/number-of-common-factors/">公因子的数目</a></h4>
<blockquote>
<p>给你两个正整数 a 和 b ，返回 a 和 b 的 <strong>公</strong> 因子的数目。</p>
<p>如果 x 可以同时整除 a 和 b ，则认为 x 是 a 和 b 的一个 <strong>公因子</strong> 。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>从 1 到 gcd(a, b) 遍历即可。</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;	<span class="comment">// assert a &lt; b</span></span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> b % a == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b % a, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">commonFactors</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt := <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= gcd(a, b); i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> a % i == <span class="number">0</span> &amp;&amp; b % i == <span class="number">0</span> &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="沙漏的最大总和">2. <a href="https://leetcode.cn/problems/maximum-sum-of-an-hourglass/">沙漏的最大总和</a></h4>
<blockquote>
<p>给你一个大小为 <strong>m x n</strong> 的整数矩阵 <code>grid</code> 。</p>
<p>按以下形式将矩阵的一部分定义为一个 <strong>沙漏</strong> ：</p>
<p><img src="image-20221017190111674.png" alt="image-20221017190111674" style="zoom:50%;" /></p>
<p>返回沙漏中元素的 <strong>最大</strong> 总和。</p>
<p><strong>注意</strong>：沙漏无法旋转且必须整个包含在矩阵中。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>由于沙漏占据了 3×3 的矩阵空间，最不用思考的做法就是遍历沙漏的左上角即可。</p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSum</span><span class="params">(g [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span>    </span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(g)<span class="number">-3</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := <span class="number">0</span>; j &lt;= <span class="built_in">len</span>(g[i])<span class="number">-3</span>; j++ &#123;</span><br><span class="line">            sum := <span class="number">0</span></span><br><span class="line">            sum += g[i][j] + g[i][j+<span class="number">1</span>] + g[i][j+<span class="number">2</span>] + g[i+<span class="number">1</span>][j+<span class="number">1</span>] + g[i+<span class="number">2</span>][j] + g[i+<span class="number">2</span>][j+<span class="number">1</span>] + g[i+<span class="number">2</span>][j+<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">if</span> sum &gt; res &#123;</span><br><span class="line">                res = sum</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小-xor">3. <a href="https://leetcode.cn/problems/minimize-xor/">最小 XOR</a></h4>
<blockquote>
<p>给你两个正整数 num1 和 num2 ，找出满足下述条件的整数 x ：</p>
<ul>
<li>x 的置位数和 num2 相同，且</li>
<li>x XOR num1 的值 <strong>最小</strong></li>
</ul>
<p>注意 XOR 是按位异或运算。</p>
<p>返回整数 x 。题目保证，对于生成的测试用例， x 是 <strong>唯一确定</strong> 的。</p>
<p>整数的 <strong>置位数</strong> 是其二进制表示中 1 的数目。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>若要使两个数按位异或所得结果最小，它们二进制中 1 的位置应尽可能一致，所以找题目中的 <span class="math inline">\(x\)</span> 实际上就是<strong>安排其二进制中 ‘1’ 的位置</strong>。令 <span class="math inline">\(k(num1)\)</span> 表示 <span class="math inline">\(num1\)</span> 的置位数。则对于给定的 <span class="math inline">\(num1\)</span> 与 <span class="math inline">\(k(x) = k(num2)\)</span> ，只有以下三种情况：</p>
<ol type="1">
<li><p><span class="math inline">\(k(num1) = k(num2)\)</span>：则 <span class="math inline">\(x=num1\)</span> 时 <span class="math inline">\(x\ XOR\ num1\)</span> 最小</p></li>
<li><p><span class="math inline">\(k(num1) &lt; k(num2)\)</span>：<span class="math inline">\(k(num1)\)</span> 个 ‘1’ 与 <span class="math inline">\(num1\)</span> 中的 ‘1’ 相互抵消后，还剩下 <span class="math inline">\(k(num2) - k(num1)\)</span> 个 ‘1’ 未安排位置，这部分应尽量“靠左”，并且不与 <span class="math inline">\(num1\)</span> 中 ‘1’ 的位置冲突。</p>
<p>例如，当 <span class="math inline">\(num1=10, k(num2)=3\)</span> 时，<span class="math inline">\(num1=(1010)_2\)</span>。首先能够得到 <span class="math inline">\(x=(1\_1\_)_2\)</span>，最后一个 ‘1’ 的位置显然易见，应该放在最右边，故得到 <span class="math inline">\(x = (1011)_2\)</span></p></li>
<li><p><span class="math inline">\(k(num1) &gt; k(num2)\)</span>：<span class="math inline">\(x\)</span> 的值即保留 <span class="math inline">\(num1\)</span> 右侧 <span class="math inline">\(k(num2)\)</span> 个 ‘1’ 的结果。</p></li>
</ol>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">k</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res += num &amp; <span class="number">1</span></span><br><span class="line">        num &gt;&gt;= <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimizeXor</span><span class="params">(num1 <span class="type">int</span>, num2 <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    cnt1, cnt2, x := k(num1), k(num2), num1</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> cnt1 &gt; cnt2 &#123;</span><br><span class="line">        p := <span class="number">1</span></span><br><span class="line">        cnt1 -= cnt2    <span class="comment">// x 为 num1 去掉低 cnt1-cnt2 位 1</span></span><br><span class="line">        <span class="keyword">for</span> cnt1 &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &amp; p &gt; <span class="number">0</span> &#123;</span><br><span class="line">                x -= p</span><br><span class="line">                cnt1--</span><br><span class="line">            &#125;</span><br><span class="line">            p &lt;&lt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> cnt1 &lt; cnt2 &#123;</span><br><span class="line">        p := <span class="number">1</span></span><br><span class="line">        cnt2 -= cnt1	<span class="comment">// x 为 num1 再加上 cnt2-cnt1 位 1</span></span><br><span class="line">        <span class="keyword">for</span> cnt2 &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> x &amp; p == <span class="number">0</span> &#123;</span><br><span class="line">                x += p</span><br><span class="line">                cnt2--</span><br><span class="line">            &#125;</span><br><span class="line">            p &lt;&lt;= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对字母串可执行的最大删除数">4. <a href="https://leetcode.cn/problems/maximum-deletions-on-a-string/">对字母串可执行的最大删除数</a></h4>
<blockquote>
<p>给你一个仅由小写英文字母组成的字符串 s 。在一步操作中，你可以：</p>
<ul>
<li>删除 <strong>整个字符串</strong> s ，或者</li>
<li>对于满足 1 &lt;= i &lt;= s.length / 2 的任意 i ，如果 s 中的 <strong>前</strong> i 个字母和接下来的 i 个字母 <strong>相等</strong> ，删除 <strong>前</strong> i 个字母。</li>
</ul>
<p>例如，如果 s = "ababc" ，那么在一步操作中，你可以删除 s 的前两个字母得到 "abc" ，因为 s 的前两个字母和接下来的两个字母都等于 "ab" 。</p>
<p>返回删除 s 所需的最大操作数。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>考虑操作 2，删除前 i 个字母后还剩下长为 len(s)-i 的新字符串，我们要接着对新字符串执行同样的删除操作。这就是一个递归步骤，并且我们的递归是二叉树状的——每个 i 都需要考虑删 or 不删。</p>
<p>那么很容易想到用动态规划。定义 <code>dp[i]</code> 为删除 <code>s[i-1:]</code> 所需最大操作数，那么对于任意 <code>1 ≤ i &lt; j ≤ len(s)-1</code>，如果 <code>s[i:j] == s[j:2*j-i]</code>，则 <code>dp[i] = max(dp[i], dp[j] + 1)</code></p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteString</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    n := <span class="built_in">len</span>(s)</span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)  <span class="comment">// dp[i]: s[i:] 所需最大删除数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := n<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">        dp[i] = <span class="number">1</span></span><br><span class="line">        l := n-i</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt;= i+l/<span class="number">2</span>; j++ &#123;</span><br><span class="line">            <span class="keyword">if</span> temp[i:j] == temp[j:<span class="number">2</span>*j-i] &amp;&amp; dp[i] &lt; dp[j] + <span class="number">1</span> &#123;</span><br><span class="line">                dp[i] = dp[j] + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition315</title>
    <url>/LeetCode/weekCompetition315/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-315/">第 315 场周赛</a>复盘。</p>
<p><strong>排名</strong> 2768 / 6490</p>
<span id="more"></span>
<h4 id="与对应负数同时存在的最大正整数">1. <a href="https://leetcode.cn/problems/largest-positive-integer-that-exists-with-its-negative/">与对应负数同时存在的最大正整数</a></h4>
<blockquote>
<p>给你一个 <strong>不包含</strong> 任何零的整数数组 <code>nums</code>，找出自身与对应的负数都在数组中存在的最大正整数 k 。</p>
<p>返回正整数 k ，如果不存在这样的整数，返回 -1 。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>遍历数组，对于负数，加入 set；对于正数，判断其对应的负数是否存在于 set 中，若存在则更新最大值。</p>
<p>遍历一遍是不够的，比如遇到 <code>nums = [1, -1]</code> 的情况就挂了，所以需要遍历两遍，第一遍建 set，第二遍查询，时间复杂度 <span class="math inline">\(O(nlogn)\)</span></p>
<p>也可以先对数组进行升序排序，这样负数就集中在左侧，正数集中在右侧，只需一次遍历即可。</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findMaxK</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    res := <span class="number">-1</span></span><br><span class="line">    <span class="keyword">var</span> null <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    sort.Ints(nums)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num &lt; <span class="number">0</span> &#123;</span><br><span class="line">            mp[num] = null</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> _, ok := mp[-num]; ok &amp;&amp; num &gt; res &#123;</span><br><span class="line">            res = num</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转之后不同整数的数目">2. <a href="https://leetcode.cn/problems/count-number-of-distinct-integers-after-reverse-operations/">反转之后不同整数的数目</a></h4>
<blockquote>
<p>给你一个由 <strong>正</strong> 整数组成的数组 <code>nums</code>。</p>
<p>你必须取出数组中的每个整数，<strong>反转其中每个数位</strong>，并将反转后得到的数字添加到数组的末尾。这一操作只针对 <code>nums</code> 中原有的整数执行。</p>
<p>返回结果数组中 <strong>不同</strong> 整数的数目。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>对原始数组中每一个值，将其和其反转后的数字加入 set，最后返回 set 大小即可。</p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + (num % <span class="number">10</span>)</span><br><span class="line">        num /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDistinctIntegers</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    mp := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    <span class="keyword">var</span> null <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        mp[num] = null</span><br><span class="line">        mp[reverse(num)] = null</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">len</span>(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="反转之后的数字和">3. <a href="https://leetcode.cn/problems/sum-of-number-and-its-reverse/">反转之后的数字和</a></h4>
<blockquote>
<p>给你一个 <strong>非负</strong> 整数 <code>num</code>。如果存在某个 <strong>非负</strong> 整数 <code>k</code> 满足 <code>k + reverse(k) = num</code> ，则返回 true ；否则，返回 false 。</p>
<p><code>reverse(k)</code> 表示 <code>k</code> 反转每个数位后得到的数字。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>直接无脑枚举即可。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res = res * <span class="number">10</span> + (num % <span class="number">10</span>)</span><br><span class="line">        num /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumOfNumberAndReverse</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= num; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> i + reverse(i) == num &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="统计定界子数组的数目">4. <a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/">统计定界子数组的数目</a></h4>
<blockquote>
<p>给你一个整数数组 <code>nums</code> 和两个整数 <code>minK</code> 以及 <code>maxK</code> 。</p>
<p><code>nums</code> 的定界子数组是满足下述条件的一个子数组：</p>
<ul>
<li>子数组中的 <strong>最小值</strong> 等于 <code>minK</code> 。</li>
<li>数组中的 <strong>最大值</strong> 等于 <code>maxK</code> 。</li>
</ul>
<p>返回定界子数组的数目。</p>
<p>子数组是数组中的一个连续部分。</p>
</blockquote>
<p>参考了 <a href="https://leetcode.cn/problems/count-subarrays-with-fixed-bounds/solution/jian-ji-xie-fa-pythonjavacgo-by-endlessc-gag2/">这位大佬的解法</a>，我认为这个解法是最完美的了，这里就对该思路进行一个解释。</p>
<p>他的思路基于以下性质：</p>
<ol type="1">
<li>既然是求连续的子数组的个数，不妨对任意 <code>i</code>，考虑其作为数组右端点时能够产生的最大子数组个数；</li>
<li>如果数组某一区间及其右端点固定，则包含该区间的连续子数组个数为该区间左端点左侧的元素个数 + 1；</li>
<li>为了考虑到所有可能的情况，左端点必须尽可能靠近右端点；</li>
<li>区间内所有值必须在 <code>[minK, maxK]</code> 范围内。</li>
</ol>
<p>在 3 和 4 的约束下，左端点的坐标即 minK 和 maxK 上一次出现的坐标中的最小值。</p>
<p>再来看 2，区间不可能无限向左扩展，应该在遇到第一个不满足 <code>[minK, maxK]</code> 范围内的值时停下。</p>
<p>如果用 <code>minIndex, maxIndex, errIndex</code> 分别代表 minK、maxK 和 <strong>范围外的值</strong> 上一次出现的坐标。如果 errIndex 出现在左端点的右侧，则该区间无效，不进行考虑；反之，以 <code>i</code> 为右端点的子数组个数为 <span class="math display">\[
\min(minIndex, maxIndex) - errIndex
\]</span></p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countSubarrays</span><span class="params">(nums []<span class="type">int</span>, minK <span class="type">int</span>, maxK <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    minIndex, maxIndex, errIndex := <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>	       <span class="comment">// -1 代表未出现</span></span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> num == minK &#123;</span><br><span class="line">            minIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num == maxK &#123;</span><br><span class="line">            maxIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> num &gt; maxK || num &lt; minK &#123;</span><br><span class="line">            errIndex = i</span><br><span class="line">        &#125;</span><br><span class="line">        leftIndex := min(minIndex, maxIndex)</span><br><span class="line">        <span class="keyword">if</span> leftIndex &gt; errIndex &#123;</span><br><span class="line">            res += leftIndex - errIndex</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="type">int64</span>(res)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition316</title>
    <url>/LeetCode/weekCompetition316/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-316/">第316场周赛</a>复盘。</p>
<p><strong>排名</strong> 873 / 6387</p>
<span id="more"></span>
<h4 id="判断两个事件是否存在冲突">1. <a href="https://leetcode.cn/problems/determine-if-two-events-have-conflict/">判断两个事件是否存在冲突</a></h4>
<blockquote>
<p>给你两个字符串数组 event1 和 event2，表示发生在 <strong>同一天</strong> 的两个闭区间时间段事件，其中：</p>
<ul>
<li><p><code>event1 = [startTime1, endTime1</code>]</p></li>
<li><p><code>event2 = [startTime2, endTime2]</code></p></li>
</ul>
<p>事件的时间为有效的 24 小时制且按 <code>HH:MM</code> 格式给出。</p>
<p>当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 <strong>冲突</strong> 。</p>
<p>如果两个事件之间存在冲突，返回 true；否则，返回 false。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>用 <code>strconv.Atoi()</code> 将字符串转换为数字。</p>
<p>若 <code>endTime1 &lt; startTime2</code> 或 <code>endTime2 &lt; startTime1</code> 则认为无冲突。</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">compare</span><span class="params">(a, b <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;    <span class="comment">// a is earlier than b</span></span><br><span class="line">    h1, _ := strconv.Atoi(a[:<span class="number">2</span>])</span><br><span class="line">    m1, _ := strconv.Atoi(a[<span class="number">3</span>:])</span><br><span class="line">    h2, _ := strconv.Atoi(b[:<span class="number">2</span>])</span><br><span class="line">    m2, _ := strconv.Atoi(b[<span class="number">3</span>:])</span><br><span class="line">    <span class="keyword">if</span> h1 == h2 &#123;</span><br><span class="line">        <span class="keyword">return</span> m1 &lt; m2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h1 &lt; h2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">haveConflict</span><span class="params">(e1 []<span class="type">string</span>, e2 []<span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    start1, end1, start2, end2 := e1[<span class="number">0</span>], e1[<span class="number">1</span>], e2[<span class="number">0</span>], e2[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> !(compare(end1, start2) || compare(end2, start1))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最大公因数等于-k-的子数组数目">2. <a href="https://leetcode.cn/problems/number-of-subarrays-with-gcd-equal-to-k/">最大公因数等于 K 的子数组数目</a></h4>
<blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的子数组中元素的最大公因数等于 k 的子数组数目。</p>
<p><strong>子数组</strong> 是数组中一个连续的非空序列。</p>
<p><strong>数组的最大公因数</strong> 是能整除数组中所有元素的最大整数。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>若 <span class="math inline">\(k\)</span> 是 <span class="math inline">\(\{a_1, a_2, \dots, a_n\}\)</span> 的最大公因数，则 <span class="math inline">\(gcd(k, a_{n+1})\)</span> 是 <span class="math inline">\(\{a_1, a_2, \dots, a_n, a_{n+1}\}\)</span> 的最大公因数。</p>
<p>定义 <code>g[i][j]</code> 表示 <code>nums[i:j+1]</code> 的最大公因数，则 <code>g[i][j] = gcd(g[i][j-1], nums[j])</code></p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a % b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a%b)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarrayGCD</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    g := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> g &#123;</span><br><span class="line">        g[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">    &#125;</span><br><span class="line">    cnt := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        g[i][i] = nums[i]</span><br><span class="line">        <span class="keyword">if</span> g[i][i] == k &#123;</span><br><span class="line">            cnt++</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> j := i+<span class="number">1</span>; j &lt; <span class="built_in">len</span>(nums); j++&#123;</span><br><span class="line">            g[i][j] = gcd(g[i][j<span class="number">-1</span>], nums[j])</span><br><span class="line">            <span class="keyword">if</span> g[i][j] == k &#123;</span><br><span class="line">                cnt++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使数组相等的最小开销">3. <a href="https://leetcode.cn/problems/minimum-cost-to-make-array-equal/">使数组相等的最小开销</a></h4>
<blockquote>
<p>给你两个下标从 <strong>0</strong> 开始的数组 nums 和 cost ，分别包含 n 个 <strong>正</strong> 整数。</p>
<p>你可以执行下面操作 <strong>任意</strong> 次：</p>
<ul>
<li>将 nums 中 <strong>任意</strong> 元素增加或者减小 1</li>
</ul>
<p>对第 i 个元素执行一次操作的开销是 <code>cost[i]</code>。</p>
<p>请你返回使 nums 中所有元素 <strong>相等</strong> 的 <strong>最少</strong> 总开销。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>没做出来，看完 <a href="https://leetcode.cn/problems/minimum-cost-to-make-array-equal/solution/by-endlesscheng-i10r/">题解</a> 发现我真的蠢。。。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minCost</span><span class="params">(nums, cost []<span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">	<span class="keyword">type</span> pair <span class="keyword">struct</span>&#123; x, c <span class="type">int</span> &#125;</span><br><span class="line">	a := <span class="built_in">make</span>([]pair, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="keyword">for</span> i, x := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		a[i] = pair&#123;x, cost[i]&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	sort.Slice(a, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">        a, b := a[i], a[j];</span><br><span class="line">        <span class="keyword">return</span> a.x &lt; b.x</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">var</span> total, sumCost <span class="type">int64</span></span><br><span class="line">	<span class="keyword">for</span> _, p := <span class="keyword">range</span> a &#123;</span><br><span class="line">		total += <span class="type">int64</span>(p.c) * <span class="type">int64</span>(p.x-a[<span class="number">0</span>].x)</span><br><span class="line">		sumCost += <span class="type">int64</span>(p.c)</span><br><span class="line">	&#125;</span><br><span class="line">	ans := total</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		sumCost -= <span class="type">int64</span>(a[i<span class="number">-1</span>].c * <span class="number">2</span>)</span><br><span class="line">		total -= sumCost * <span class="type">int64</span>(a[i].x-a[i<span class="number">-1</span>].x)</span><br><span class="line">		ans = min(ans, total)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b <span class="type">int64</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="使数组相似的最少操作次数">4. <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-make-arrays-similar/">使数组相似的最少操作次数</a></h4>
<blockquote>
<p>给你两个正整数数组 nums 和 target ，两个数组长度相等。</p>
<p>在一次操作中，你可以选择两个 <strong>不同</strong> 的下标 i 和 j ，其中 <code>0 &lt;= i, j &lt; nums.length</code> ，并且令</p>
<ul>
<li><code>nums[i] = nums[i] + 2</code></li>
<li><code>nums[j] = nums[j] - 2</code></li>
</ul>
<p>如果两个数组中每个元素出现的频率相等，我们称两个数组是 <strong>相似</strong> 的。</p>
<p>请你返回将 nums 变得与 target 相似的最少操作次数。测试数据保证 nums 一定能变得与 target 相似。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>因为必然会相似，则更大的一定会通过不断 <strong>减二</strong> 得到小的数，而更小的数一定会通过不断 <strong>加二</strong> 得到大的数，而为了使总操作更小，nums 中最小的数将变成 target 中最小的数，以此类推（所以需要进行排序）。因为这两步算 <strong>同一次操作</strong>，故考虑所有的“加二”操作即可。</p>
<p>同时还要考虑奇偶，因为奇数总是变成奇数，偶数总是变成偶数。</p>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeSimilar</span><span class="params">(nums []<span class="type">int</span>, target []<span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    <span class="comment">// 考虑奇偶</span></span><br><span class="line">    n1, n2, t1, t2 := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            n1 = <span class="built_in">append</span>(n1, n)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            n2 = <span class="built_in">append</span>(n2, n)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> _, t := <span class="keyword">range</span> target &#123;</span><br><span class="line">        <span class="keyword">if</span> t % <span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">            t1 = <span class="built_in">append</span>(t1, t)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            t2 = <span class="built_in">append</span>(t2, t)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort.Ints(n1)</span><br><span class="line">    sort.Ints(n2)</span><br><span class="line">    sort.Ints(t1)</span><br><span class="line">    sort.Ints(t2)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> d1, d2 <span class="type">int64</span> = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> n1 &#123;</span><br><span class="line">        <span class="keyword">if</span> t1[i] &gt; n1[i] &#123;</span><br><span class="line">            d1 += <span class="type">int64</span>(t1[i]-n1[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> n2 &#123;</span><br><span class="line">        <span class="keyword">if</span> t2[i] &gt; n2[i] &#123;</span><br><span class="line">            d2 += <span class="type">int64</span>(t2[i] - n2[i])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (d1+d2)/<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition317</title>
    <url>/LeetCode/weekCompetition317/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-317/">第317场周赛</a>复盘。</p>
<p><strong>排名</strong> 690 / 5660</p>
<span id="more"></span>
<h4 id="可被三整除的偶数的平均值">1. <a href="https://leetcode.cn/problems/average-value-of-even-numbers-that-are-divisible-by-three/">6220. 可被三整除的偶数的平均值</a></h4>
<blockquote>
<p>给你一个由正整数组成的整数数组 nums ，返回其中可被 3 整除的所有偶数的平均值。</p>
<p>注意：n 个元素的平均值等于 n 个元素 <strong>求和</strong> 再除以 n ，结果 <strong>向下取整</strong> 到最接近的整数。</p>
</blockquote>
<h5 id="思路">思路</h5>
<p>能被 3 整除的偶数 ==&gt; 能被 6 整除。</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">averageValue</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    sum, cnt := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, n := <span class="keyword">range</span> nums &#123;</span><br><span class="line">        <span class="keyword">if</span> n % <span class="number">6</span> == <span class="number">0</span> &#123;</span><br><span class="line">            sum += n</span><br><span class="line">            cnt ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> cnt == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum/cnt</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最流行的视频创作者">2. <a href="https://leetcode.cn/problems/most-popular-video-creator/">6221. 最流行的视频创作者</a></h4>
<blockquote>
<p>给你两个字符串数组 creators 和 ids ，和一个整数数组 views ，所有数组的长度都是 n 。平台上第 i 个视频者是 <code>creator[i]</code>，视频分配的 id 是 <code>ids[i]</code>，且播放量为 <code>views[i]</code>。</p>
<p>视频创作者的 <strong>流行度</strong> 是该创作者的 <strong>所有</strong> 视频的播放量的 <strong>总和</strong> 。请找出流行度 <strong>最高</strong> 创作者以及该创作者播放量 <strong>最大</strong> 的视频的 id。</p>
<ul>
<li>如果存在多个创作者流行度都最高，则需要找出所有符合条件的创作者。</li>
<li>如果某个创作者存在多个播放量最高的视频，则只需要找出字典序最小的 id。</li>
</ul>
<p>返回一个二维字符串数组 answer，其中 <code>answer[i] = [creator_i, id_i]</code> 表示 creatori 的流行度 <strong>最高</strong> 且其最流行的视频 id 是 id_i，可以按任何顺序返回该结果。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>大模拟题，开两个 map 分别存 creators 到流行度的映射以及 creators 到其作品集的映射即可。</p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mostPopularCreator</span><span class="params">(creators []<span class="type">string</span>, ids []<span class="type">string</span>, views []<span class="type">int</span>)</span></span> [][]<span class="type">string</span> &#123;</span><br><span class="line">    <span class="keyword">type</span> info <span class="keyword">struct</span> &#123;</span><br><span class="line">        id <span class="type">string</span></span><br><span class="line">        view <span class="type">int</span></span><br><span class="line">    &#125;</span><br><span class="line">    popular := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>)     <span class="comment">// creators -&gt; 流行度</span></span><br><span class="line">    works := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>][]info)    <span class="comment">// creators -&gt; 作品集</span></span><br><span class="line">    maxm := <span class="number">0</span>                           <span class="comment">// 最大流行度</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> creators &#123;</span><br><span class="line">        popular[creators[i]] += views[i]</span><br><span class="line">        work, ok := works[creators[i]]</span><br><span class="line">        <span class="keyword">if</span> !ok &#123;</span><br><span class="line">            works[creators[i]] = []info&#123;&#123;ids[i], views[i]&#125;&#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            works[creators[i]] = <span class="built_in">append</span>(work, info&#123;ids[i], views[i]&#125;)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> popular[creators[i]] &gt; maxm &#123;</span><br><span class="line">            maxm = popular[creators[i]]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    names := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)	<span class="comment">// 所有流行度最高的创作者的名字</span></span><br><span class="line">    <span class="keyword">for</span> k, v := <span class="keyword">range</span> popular &#123;</span><br><span class="line">        <span class="keyword">if</span> v == maxm &#123;</span><br><span class="line">            names = <span class="built_in">append</span>(names, k)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res := <span class="built_in">make</span>([][]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">        wks, _ := works[name]</span><br><span class="line">        <span class="keyword">var</span> id <span class="type">string</span></span><br><span class="line">        maxview := <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> _, work := <span class="keyword">range</span> wks &#123;</span><br><span class="line">            <span class="keyword">if</span> work.view &gt; maxview &#123;</span><br><span class="line">                id = work.id</span><br><span class="line">                maxview = work.view</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> work.view == maxview &amp;&amp; work.id &lt; id &#123;</span><br><span class="line">                id = work.id</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">append</span>(res, []<span class="type">string</span>&#123;name, id&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="美丽整数的最小增量">3. <a href="https://leetcode.cn/problems/minimum-addition-to-make-integer-beautiful/">6222. 美丽整数的最小增量</a></h4>
<blockquote>
<p>给你两个正整数 n 和 target 。</p>
<p>如果某个整数每一位上的数字相加小于或等于 target ，则认为这个整数是一个 <strong>美丽整数</strong> 。</p>
<p>找出并返回满足 n + x 是 <strong>美丽整数</strong> 的最小非负整数 x 。生成的输入保证总可以使 n 变成一个美丽整数。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>定义 <code>getsum(n)</code> 表示 n 的每一位上的数字之和。若 <code>getsum(n) &lt;= target</code> 则直接返回 0 即可。</p>
<p>反之，则需要考虑一个合适的增量 x。考虑到通过增加一个数来减少 <code>getsum(n)</code> 的最朴素的办法是加了一个增量 x 后将 n 的最后 i 位变成 0，第 i+1 位由于进位加上了 1，此时 <code>getsum(n + x) = getsum(n) - getsum(n % 10^i) + 1</code>，其中 <code>getsum(n % 10^i)</code> 即 n 最后 i 位数字之和。</p>
<ol type="1">
<li>若最后 i 位全为 0，则在最后 i 位上加任何数都会导致各位和增加，因此需考虑更大的 i；</li>
<li>除此之外的所有情况都会使得 <code>getsum(n % 10^i) &gt;= 1</code>，故 <code>getsum(n + x) &lt;= getsum(n)</code>，即增加一个数 x 后 n 的各位和能够减少，此时 <code>x = 10^i - n % 10^i</code>。</li>
</ol>
<p>在这样的一个考虑下，又要 x 最小，我们只需要从 <code>i = 0</code> 开始，不断增加其值，直至找到满足要求的答案即可。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getsum</span><span class="params">(n <span class="type">int64</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">        res += <span class="type">int</span>(n % <span class="number">10</span>)</span><br><span class="line">        n /= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makeIntegerBeautiful</span><span class="params">(n <span class="type">int64</span>, target <span class="type">int</span>)</span></span> <span class="type">int64</span> &#123;</span><br><span class="line">    sum := getsum(n)</span><br><span class="line">    <span class="keyword">if</span> sum &lt;= target &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    mask := <span class="type">int64</span>(<span class="number">1</span>)    <span class="comment">// 10^i</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> sum - getsum(n % mask) + <span class="number">1</span> &lt;= target &#123;</span><br><span class="line">            <span class="keyword">return</span> mask - n % mask</span><br><span class="line">        &#125;</span><br><span class="line">        mask *= <span class="number">10</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mask - n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="移除子树后的二叉树高度">4. <a href="https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/">2458. 移除子树后的二叉树高度</a></h4>
<blockquote>
<p>给你一棵 <strong>二叉树</strong> 的根节点 root ，树中有 n 个节点。每个节点都可以被分配一个从 1 到 n 且互不相同的值。另给你一个长度为 m 的数组 queries 。</p>
<p>你必须在树上执行 m 个 <strong>独立</strong> 的查询，其中第 i 个查询你需要执行以下操作：</p>
<ul>
<li>从树中 <strong>移除</strong> 以 <code>queries[i]</code> 的值作为根节点的子树。题目所用测试用例保证 <code>queries[i]</code> 不 等于根节点的值。</li>
</ul>
<p>返回一个长度为 m 的数组 answer ，其中 <code>answer[i]</code> 是执行第 i 个查询后树的高度。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>查询之间是独立的，所以在每个查询执行后，树会回到其 <strong>初始</strong> 状态。</li>
<li>树的高度是从根到树中某个节点的 <strong>最长简单路径中的边数</strong> 。</li>
</ul>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>最开始想的是开一些数据结构存放每个节点的 父节点，左子树高度，右子树高度 以及 值对应的节点指针。对于每个 queries[i]，找到对应节点，并通知上层节点 <span class="math inline">\(f_1\)</span> 高度已改变。<span class="math inline">\(f_1\)</span> 收到消息后，会比较被删除的儿子与另一个儿子，更新当前高度后继续通知上层节点 <span class="math inline">\(f_2\)</span>。以此类推直至到达根节点。理想状态下它的时间复杂度为 <span class="math inline">\(O(q\log n)\)</span>，但极端情况下当二叉树为单链时，时间复杂度就降为 <span class="math inline">\(O(qn)\)</span>。其中 <span class="math inline">\(q\)</span> 为查询数，<span class="math inline">\(n\)</span> 为节点数。</p>
<p>于是可以想到，先遍历树，遍历的过程中存储<strong>当删除该节点为根的子树时剩余树的高度</strong>。为了保证这一信息不丢失，我们需要在调用函数时维护这一变量。那么对于任意节点 <span class="math inline">\(root\)</span>：</p>
<ul>
<li>如果删除其左子树，则剩余高度为 <span class="math inline">\(\max(depth(root)+height(right),\ restHeight)\)</span></li>
<li>如果删除其右子树，则剩余高度为 <span class="math inline">\(\max(depth(root)+height(left),\ restHeight)\)</span></li>
</ul>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">treeQueries</span><span class="params">(root *TreeNode, queries []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	height := <span class="keyword">map</span>[*TreeNode]<span class="type">int</span>&#123;&#125; <span class="comment">// 每棵子树的高度</span></span><br><span class="line">	<span class="keyword">var</span> getHeight <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">	getHeight = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		height[node] = <span class="number">1</span> + max(getHeight(node.Left), getHeight(node.Right))</span><br><span class="line">		<span class="keyword">return</span> height[node]</span><br><span class="line">	&#125;</span><br><span class="line">	getHeight(root)</span><br><span class="line"></span><br><span class="line">	res := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(height)+<span class="number">1</span>) <span class="comment">// 每个节点的答案</span></span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(*TreeNode, <span class="type">int</span>, <span class="type">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(node *TreeNode, depth, restH <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> node == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		depth++</span><br><span class="line">		res[node.Val] = restH</span><br><span class="line">		dfs(node.Left, depth, max(restH, depth+height[node.Right]))</span><br><span class="line">		dfs(node.Right, depth, max(restH, depth+height[node.Left]))</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root, <span class="number">-1</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> i, q := <span class="keyword">range</span> queries &#123;</span><br><span class="line">		queries[i] = res[q]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> queries</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123; <span class="keyword">if</span> b &gt; a &#123; <span class="keyword">return</span> b &#125;; <span class="keyword">return</span> a &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
  <entry>
    <title>Zookeeper</title>
    <url>/6-824/zookeeper/</url>
    <content><![CDATA[<p>6.824 的第四篇论文是 <strong>ZooKeeper</strong>——用于协调分布式应用程序进程，同时提供消息群发、共享寄存器和分布式锁等集中式服务。</p>
<blockquote>
<p>关于“ZooKeeper”这个项目的名字，考虑到之前内部很多项目都是使用动物的名字来命名的，Yahoo 的工程师希望给这个项目也取一个动物的名字。时任研究院的首席科学家 Raghu Ramakrishnan 开玩笑地说：“再这样下去，我们这儿就变成动物园了！”此话一出，大家纷纷表示就叫动物园管理员吧一一一因为各个以动物命名的分布式组件放在一起，Yahoo 的整个分布式系统看上去就像一个大型的动物园了，而 Zookeeper 正好要用来进行分布式环境的协调一一于是，Zookeeper 的名字也就由此诞生了。</p>
</blockquote>
<span id="more"></span>
<h5 id="协调服务">协调服务</h5>
<p>ZooKeeper 采用的协调形式有：配置、组成员、领导者选举和锁。由于实现了更强大的原语的服务可以用来实现不那么强大的原语，ZooKeeper 不再在服务端实现特定原语，而是公开一个 API，令开发者实现自己的原语，为协调提供灵活性。</p>
<p>ZooKeeper 在设计 API 时避免了阻塞原语，转而实现简单的<strong>无等待数据对象</strong>，同时也需要保证所有操作按客户端顺序 <strong>FIFO</strong> 以及<strong>可线性化的写入</strong>。</p>
<p>ZooKeeper 服务由一组使用 <strong>Replicate</strong> 的服务器组成（实际上有点像 Raft），同时利用简单的<strong>管道</strong>架构来实现高吞吐和低延迟——既能以 FIFO 顺序从单个客户端执行操作，又能使其能够异步提交操作。</p>
<p>为了保证更新操作满足<strong>线性化</strong>，ZooKeeper 采用基于领导者的原子广播协议 <strong>Zab</strong>；读取操作在本地处理，无需排序。</p>
<p>ZooKeeper 使用<strong>监视机制</strong>使客户端能够缓存数据，同时在给定数据对象更新时得到通知。</p>
<h5 id="znode">Znode</h5>
<p>ZooKeeper 向其客户端提供一组数据节点(<strong>znode</strong>)的抽象，这些节点根据分层名称空间进行组织。如下图：</p>
<p><img src="image-20221008155321613.png" alt="image-20221008155321613" style="zoom:70%;" /></p>
<p>所有 znode 都存储数据，且除了临时节点(<strong>ephemeral znode</strong>)外的所有 znode 都可以有子节点。</p>
<p>有以下两种 znode：</p>
<ol type="1">
<li><strong>Regular</strong>：显式创建和删除。</li>
<li><strong>Ephemeral</strong>：创建后，或显示删除，或在会话终止时自动删除。</li>
</ol>
<p>创建 znode 时，客户端可以设置一个 <code>SEQUENTIAL</code> 标志，这种 znode 具有全局单调增的值。</p>
<p>ZooKeeper 实现监视(<strong>watch</strong>)机制允许 client 及时接收数据更改通知，这个通知是一次性的，一旦触发或会话关闭，它们就会失效。</p>
<p><strong>数据模型</strong>：本质上是一个具有简化 api 且只有完整数据读写的文件系统，或是具有分层 key 的 key-value 表。<strong>分层命名空间</strong>对于为不同应用程序的命名空间分配子树以及分配访问权限很有用。事实上，znode 的设计并非为了一般的数据存储，而是提供一个到客户端应用程序映射的抽象，通常对应于用于协调目的的元数据，如一些可用于元数据或分布式计算中的配置信息。</p>
<p><strong>会话</strong>：client 连接到 ZooKeeper 并启动会话，用于标识 client。</p>
<h5 id="客户端-api">客户端 API</h5>
<h6 id="createpath-data-flags">create(path, data, flags)</h6>
<p>创建一个路径名为 <code>path</code> 的 znode，并将 <code>data</code> 存储在其中，返回该 znode 的名称。<code>flag</code> 代表 znode 类型。</p>
<h6 id="deletepath-version">delete(path, version)</h6>
<p>若 <code>path</code> 上的 znode 版本号等于 <code>version</code>，则将其删除。</p>
<h6 id="existspath-watch">exists(path, watch)</h6>
<p>若 <code>path</code> 上的 znode 存在，则返回 true；反之返回 false。<code>watch</code> 使得客户端在该 znode 上设置一个监视器。</p>
<h6 id="getdatapath-watch">getData(path, watch)</h6>
<p>返回 <code>path</code> 上 znode 关联的数据和元数据。若 znode 不存在，则不设置监视器。</p>
<h6 id="setdatapath-data-version">setData(path, data, version)</h6>
<p>若 <code>path</code> 上的 znode 版本号等于 <code>version</code>，则将 <code>data</code> 写入。</p>
<h6 id="getchildrenpath-watch">getChildren(path, watch)</h6>
<p>返回 <code>path</code> 上 znode 的子节点集合。</p>
<h6 id="sycnpath">sycn(path)</h6>
<p>等待所有未完成的更新，<code>path</code> 没啥用。</p>
<blockquote>
<p>以上 api 都提供了同步和异步版本，若 <code>version = -1</code>，则不进行版本检查。</p>
</blockquote>
<h5 id="zookeeper-保证">ZooKeeper 保证</h5>
<ul>
<li><p><strong>线性化写入</strong>：所有更新 ZooKeeper 状态的请求都是可序列化的，并且服从优先级。</p></li>
<li><p><strong>FIFO 客户端顺序</strong>：所有请求都按照客户端发送的顺序执行。</p></li>
</ul>
<p>要实现这两个保证，需要选出一个领导者来指挥工作进程。而当一个新的领导者接管系统时，它必须修改配置，然后通知其它进程。这样的话，需要满足以下两点：</p>
<ol type="1">
<li>领导者在修改配置时，其它进程无法使用正在被修改的配置；</li>
<li>若领导者在完全修改完配置前崩溃，则其他进程无法使用这一未完全更新的配置。</li>
</ol>
<p>ZooKeeper 使用 <strong>ready znode</strong> 来满足上述约束，其他进程仅在 ready 存在期间使用配置。领导者通过删除 ready、更新配置 znode 和创建 ready 来更改配置。若一个进程看到了 ready znode，它必能看到新领导者所做的所有配置修改；若领导者在创建 ready 前崩溃，则其他进程就知道配置尚未完全更新完毕，也不会使用该配置。</p>
<p>如果一个进程在新领导者修改配置前看到 ready，而在更改配置时读取配置，则会产生问题。为了解决这一问题，采用 <strong>watch</strong> 机制，即客户端会在读取任何新配置前收到更新通知。</p>
<blockquote>
<p>ZooKeeper 放弃了线性一致读，使得读请求能够分布在副本上，以提高性能。但由于写请求是线性化的，而且任何一个客户端的请求都会按照其指定的顺序进行，故所有写请求都是按客户端确定的顺序执行的，且每个读请求必然要在某个特定的 Log 点执行，即如果日志没有到这个点，它不会执行读请求，同时后续读请求必须在不早于当前读请求的位置进行。从而ZooKeeper 也能保证它（定义）的一致性。</p>
</blockquote>
<p>ZooKeeper 还有以下两个保证：</p>
<ul>
<li><strong>活跃性</strong>：若大多数 ZooKeeper Server 处于活跃状态，则服务可用。</li>
<li><strong>持久性</strong>：若 ZooKeeper Server 成功响应了更改请求，只要多数服务器最终能恢复，则该更改就会持续存在。</li>
</ul>
<h5 id="原语">原语</h5>
<h6 id="配置管理">配置管理</h6>
<p>配置存储在 znode <span class="math inline">\(z_c\)</span> 中，进程通过读取 <span class="math inline">\(z_c\)</span> 并通过 watch 标志来获取配置更新通知。</p>
<h6 id="会合">会合</h6>
<p>将 master 信息放在 zonode <span class="math inline">\(z_r\)</span> 中，以便 worker 寻找。</p>
<h6 id="组成员关系">组成员关系</h6>
<p>当组成员进程启动时，会在一个指定的 znode <span class="math inline">\(z_g\)</span> （用以表示组）下创建一个临时子 znode，该子 znode 存放进程信息。若进程结束，则该子 znode 自动删除。故可通过 <span class="math inline">\(z_g\)</span> 来获取该组的所有组成员信息。</p>
<h6 id="简单锁">简单锁</h6>
<ol type="1">
<li><p><strong>锁文件</strong>——最简单的实现：为了获取锁，client 会尝试创建 ephemeral znode，若成功则持有锁；若 znode 存在，则说明有其它 client 正在持有锁，设置 watch 后进入等待状态，一旦该 znode 删除，则会再次尝试获得锁。</p>
<blockquote>
<p>这个策略会受到<strong>羊群效应</strong>(Herd Effect)的影响：若有很多客户端在等待获取锁，即便只有一个客户端可以获取锁，当锁被释放时，所有客户端都会尝试获得锁，就像羊群一样阻塞着。当有 <span class="math inline">\(n\)</span> 个客户端在等待时，最坏情况下需要 <span class="math inline">\(O(n^2)\)</span> 的尝试。</p>
</blockquote></li>
<li><p><strong>无羊群效应的简单锁</strong>：所有请求锁的 client 排成一排，按请求到达的顺序<strong>链式</strong>获得锁。每个 client 按照 <code>SEQUENTIAL</code> 在 <span class="math inline">\(z_l\)</span> 下创建 ephemeral znode，并获取 <span class="math inline">\(z_l\)</span> 所有子节点的信息。当且仅当其序号为 <span class="math inline">\(z_l\)</span> 所有子节点的序号中最低时，获得锁；否则，client 会 watch 前一个 znode。释放锁时只需要删除对应 znode 即可。</p>
<p><code>Lock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = create(l + &#x27;/lock-&#x27;, EPHEMERAL | SEQUENTIAL)</span><br><span class="line">C = getChildren(l, false)</span><br><span class="line">if n is lowest znode in C, exit</span><br><span class="line">p = znode in C ordered just before n</span><br><span class="line">if exists(p, true), wait for watch event</span><br><span class="line">goto 2</span><br></pre></td></tr></table></figure></p>
<p><code>Unlock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete(n)</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>前一个 znode 消失后还需要获取 <span class="math inline">\(z_l\)</span> 所有子节点的信息，并检查自己的序号是否为最小，因为有可能只是前一个 znode 崩溃，而有更小的 znode 持有锁。</p>
<p>这样一来，每次释放锁时只会唤醒一个进程，从而将复杂度降为 <span class="math inline">\(O(n)\)</span></p>
</blockquote></li>
<li><p><strong>读写锁</strong>：写锁同上。读锁需要等待前面的写锁全部结束后才能持有。</p>
<p><code>Write Lock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = create(l + &#x27;/write-&#x27;, EPHEMERAL | SEQUENTIAL)</span><br><span class="line">C = getChildren(l, false)</span><br><span class="line">if n is lowest znode in C, exit</span><br><span class="line">p = znode in C ordered just before n</span><br><span class="line">if exists(p, true), wait for watch event</span><br><span class="line">goto 2</span><br></pre></td></tr></table></figure></p>
<p><code>Read Lock</code></p>
<p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n = create(l + &#x27;/read-&#x27;, EPHEMERAL | SEQUENTIAL)</span><br><span class="line">C = getChildren(l, false)</span><br><span class="line">if no write znodes lower than n in C, exit</span><br><span class="line">p = write znode in C ordered just before n</span><br><span class="line">if exists(p, true), wait for watch event</span><br><span class="line">goto 3</span><br></pre></td></tr></table></figure></p></li>
<li><p><strong>双屏障</strong>：使客户端能够同步计算的开始与结束。用 znode <span class="math inline">\(b\)</span> 表示 ZooKeeper 中的屏障。每个进程在准备开始时，会在 <span class="math inline">\(b\)</span> 下注册——创建一个子 znode，而在准备退出时注销——删除该子 znode。当 <span class="math inline">\(b\)</span> 的子节点数超过一定数量后，所有注册的进程都会真正开始计算，只有当 <span class="math inline">\(b\)</span> 的所有子节点都被删除时，进程才会真正退出。这两点都可通过 ready 来实现。</p></li>
</ol>
<h5 id="总结">总结</h5>
<p>ZooKeeper 是一个容错的，通用的协调服务。</p>
]]></content>
      <categories>
        <category>6.824</category>
      </categories>
      <tags>
        <tag>paperReading</tag>
      </tags>
  </entry>
  <entry>
    <title>weekCompetition319</title>
    <url>/LeetCode/weekCompetition319/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/contest/weekly-contest-319/">第319场周赛复盘</a>。</p>
<p><strong>排名</strong> 534 / 6175</p>
<span id="more"></span>
<h4 id="温度转换">1. <a href="https://leetcode.cn/problems/convert-the-temperature/">2469. 温度转换</a></h4>
<blockquote>
<p>给你一个四舍五入到两位小数的非负浮点数 celsius 来表示温度，以 <strong>摄氏度（Celsius）</strong>为单位。</p>
<p>你需要将摄氏度转换为 <strong>开氏度（Kelvin）</strong>和 <strong>华氏度（Fahrenheit）</strong>，并以数组 <code>ans = [kelvin, fahrenheit]</code> 的形式返回结果。</p>
<p>返回数组 ans 。与实际答案误差不超过 <span class="math inline">\(10^{-5}\)</span> 的会视为正确答案。</p>
<p>注意：</p>
<ul>
<li>开氏度 = 摄氏度 + 273.15</li>
<li>华氏度 = 摄氏度 * 1.80 + 32.00</li>
</ul>
</blockquote>
<h5 id="思路">思路</h5>
<p>签到题</p>
<h5 id="code">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">convertTemperature</span><span class="params">(celsius <span class="type">float64</span>)</span></span> []<span class="type">float64</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> []<span class="type">float64</span>&#123;celsius + <span class="number">273.15</span>, celsius * <span class="number">1.8</span> + <span class="number">32</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="最小公倍数为-k-的子数组数目">2. <a href="https://leetcode.cn/problems/number-of-subarrays-with-lcm-equal-to-k/">2470. 最小公倍数为 K 的子数组数目</a></h4>
<blockquote>
<p>给你一个整数数组 nums 和一个整数 k ，请你统计并返回 nums 的 <strong>子数组</strong> 中满足 元素最小公倍数为 k 的子数组数目。</p>
<p><strong>子数组</strong> 是数组中一个连续非空的元素序列。</p>
<p><strong>数组的最小公倍数</strong> 是可被所有数组元素整除的最小正整数。</p>
</blockquote>
<h5 id="思路-1">思路</h5>
<p>数据范围挺小的，直接暴力枚举即可，但也要注意剪枝。</p>
<h5 id="code-1">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcd</span><span class="params">(a, b <span class="type">int64</span>)</span></span> <span class="type">int64</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> a &lt; b &#123;</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> a % b == <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> gcd(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lcm</span><span class="params">(a, b <span class="type">int64</span>)</span></span> <span class="type">int64</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b / gcd(a, b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">subarrayLCM</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    res, i, j := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; <span class="built_in">len</span>(nums) &#123;</span><br><span class="line">        <span class="keyword">var</span> l <span class="type">int64</span> = <span class="number">1</span>;	<span class="comment">// 以 nums[i] 为起点的子数组的最小公倍数 </span></span><br><span class="line">        <span class="keyword">for</span> j = i; j &lt; <span class="built_in">len</span>(nums); j++ &#123;</span><br><span class="line">            l = lcm(<span class="type">int64</span>(nums[j]), l);</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">int64</span>(k) % l != <span class="number">0</span>) &#123;	<span class="comment">// 剪枝</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="type">int64</span>(k) == l) &#123;</span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逐层排序二叉树所需的最少操作数目">3. <a href="https://leetcode.cn/problems/minimum-number-of-operations-to-sort-a-binary-tree-by-level/">2471. 逐层排序二叉树所需的最少操作数目</a></h4>
<blockquote>
<p>给你一个 <strong>值互不相同</strong> 的二叉树的根节点 root 。</p>
<p>在一步操作中，你可以选择 <strong>同一层</strong> 上任意两个节点，交换这两个节点的值。</p>
<p>返回每一层按 <strong>严格递增顺序</strong> 排序所需的最少操作数目。</p>
<p>节点的 <strong>层数</strong> 是该节点和根节点之间的路径的边数。</p>
</blockquote>
<h5 id="思路-2">思路</h5>
<p>用二维切片记录每一层的数据 <code>level[]</code>，对当前层而言，开一个额外数组记录每个元素 <code>level[i]</code> 在排序后的最终位置 <code>pos[level[i]]</code>，不断交换 <code>level[i]</code> 与 <code>level[pos[level[i]]]</code> 即可。</p>
<h5 id="code-2">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minimumOperations</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    order := <span class="built_in">make</span>([][]*TreeNode, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    order = <span class="built_in">append</span>(order, []*TreeNode&#123;root&#125;)</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(order); i++ &#123;</span><br><span class="line">        level := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span> _, r := <span class="keyword">range</span> order[i] &#123;</span><br><span class="line">            <span class="keyword">if</span> r.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">                level = <span class="built_in">append</span>(level, r.Left)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> r.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">                level = <span class="built_in">append</span>(level, r.Right)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(level) &gt; <span class="number">0</span> &#123;</span><br><span class="line">            order = <span class="built_in">append</span>(order, level)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    res := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> _, level := <span class="keyword">range</span> order &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(level) == <span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        &#125;</span><br><span class="line">        temp := <span class="built_in">make</span>([]*TreeNode, <span class="built_in">len</span>(level))</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            temp[i] = level[i]</span><br><span class="line">        &#125;</span><br><span class="line">        sort.Slice(temp, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> temp[i].Val &lt; temp[j].Val</span><br><span class="line">        &#125;)</span><br><span class="line">        </span><br><span class="line">        pos := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">int</span>)</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> temp &#123;</span><br><span class="line">            pos[temp[i].Val] = i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="keyword">range</span> level &#123;</span><br><span class="line">            <span class="keyword">for</span> level[pos[level[i].Val]] != level[i] &#123;</span><br><span class="line">                level[i], level[pos[level[i].Val]] = level[pos[level[i].Val]], level[i]</span><br><span class="line">                res++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="不重叠回文子字符串的最大数目">4. <a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-palindrome-substrings/">2472. 不重叠回文子字符串的最大数目</a></h4>
<blockquote>
<p>给你一个字符串 s 和一个 <strong>正</strong> 整数 k 。</p>
<p>从字符串 s 中选出一组满足下述条件且 <strong>不重叠</strong> 的子字符串：</p>
<ul>
<li>每个子字符串的长度 <strong>至少</strong> 为 k 。</li>
<li>每个子字符串是一个 <strong>回文串</strong> 。</li>
</ul>
<p>返回最优方案中能选择的子字符串的 <strong>最大</strong> 数目。</p>
<p><strong>子字符串</strong> 是字符串中一个连续的字符序列。</p>
</blockquote>
<h5 id="思路-3">思路</h5>
<p>首先用一个二维数组 <code>isPalid[i][j]</code> 记录子字符串 <code>s[i] ~ s[j]</code> 是否为回文串。定义 <code>dp[i]</code> 表示字符串 <code>s[:i]</code> 中不重叠回文子字符串的最大数目。那么状态转移方程可以表示为：</p>
<ol type="1">
<li>若 <code>s[j:i] (0 &lt;= j &lt;= i-k)</code> 为回文串，则 <code>dp[i] = max(do[i], dp[j] + 1)</code>；</li>
<li>反之，<code>dp[i] = dp[i-1]</code>。</li>
</ol>
<h5 id="code-3">code</h5>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// go</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxPalindromes</span><span class="params">(s <span class="type">string</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    isPalid := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(s))</span><br><span class="line">    <span class="keyword">for</span> i := <span class="keyword">range</span> isPalid &#123;</span><br><span class="line">        isPalid[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(s))</span><br><span class="line">        isPalid[i][i] = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="built_in">len</span>(s)<span class="number">-1</span> &amp;&amp; s[i] == s[i+<span class="number">1</span>] &#123;</span><br><span class="line">            isPalid[i][i+<span class="number">1</span>] = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> l := <span class="number">3</span>; l &lt;= <span class="built_in">len</span>(s); l++ &#123;</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt;= <span class="built_in">len</span>(s) - l; i++ &#123;</span><br><span class="line">            isPalid[i][i+l<span class="number">-1</span>] = (s[i] == s[i+l<span class="number">-1</span>] &amp;&amp; isPalid[i+<span class="number">1</span>][i+l<span class="number">-2</span>])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)     <span class="comment">// dp[i]: 前 i 个字符最大的回文子字符串数</span></span><br><span class="line">    <span class="keyword">if</span> isPalid[<span class="number">0</span>][k<span class="number">-1</span>] &#123;</span><br><span class="line">        dp[k] = <span class="number">1</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">for</span> i := k + <span class="number">1</span>; i &lt;= <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">        <span class="keyword">for</span> j := i-k; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">            <span class="keyword">if</span> isPalid[j][i<span class="number">-1</span>] &#123;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + <span class="number">1</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = max(dp[i], dp[i<span class="number">-1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Println(dp)</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="built_in">len</span>(s)]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> i &gt; j &#123;</span><br><span class="line">        <span class="keyword">return</span> i</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>周赛</tag>
      </tags>
  </entry>
</search>
