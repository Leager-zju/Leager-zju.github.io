<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Effective C++ の Note, 没什么看头的地方">
    <meta name="description" content="久仰本书大名，花了若干时间入门 C++ 后，终于可以拜读一下这部经典作品。

当 C++ 律师！


#1. 视 C++ 为一个语言联邦
C++ 高效编程守则视情况而变化，取决于使用 C++ 的哪一部分。

C++ = C + Object">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Effective C++ の Note | 没什么看头的地方</title>
    <link rel="icon" type="image/png" href="/dt.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    


    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/comment_bg.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">没什么看头的地方</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/comment_bg.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">没什么看头的地方</div>
        <div class="logo-desc">
            
            【数据删除】
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Leager-zju" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Leager-zju" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Effective C++ の Note</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">这个人太懒了，都不想加标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Note/" class="post-category">
                                Note
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-03-01
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>久仰本书大名，花了若干时间入门 C++ 后，终于可以拜读一下这部经典作品。</p>
<blockquote>
<p>当 C++ 律师！</p>
</blockquote>
<span id="more"></span>
<h2 id="1-视-C-为一个语言联邦"><a class="header-anchor" href="#1-视-C-为一个语言联邦">#</a>1. 视 C++ 为一个语言联邦</h2>
<p>C++ 高效编程守则视情况而变化，取决于使用 C++ 的哪一部分。</p>
<blockquote>
<p><code>C++</code> = <code>C</code> + <code>Object-Oriented C++</code> + <code>Template C++</code> + <code>STL</code>。</p>
</blockquote>
<h2 id="2-尽量以-const-enum-inline-替换-define"><a class="header-anchor" href="#2-尽量以-const-enum-inline-替换-define">#</a>2. 尽量以 const, enum, inline 替换 #define</h2>
<p>或可以说"尽量用编译器代替预处理器"。</p>
<ol>
<li class="lvl-3">
<p>对于常量，尽量以 <code>const</code>, <code>enum</code> 替换。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">PI</span> <span class="token expression"><span class="token number">3.1415926</span></span></span>
<span class="token comment">// 改为</span>
<span class="token keyword">const</span> <span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.1415926</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果在代码出现 <code>PI</code> 的地方产生了编译错误，编译器只会看到被预处理器替换掉的文本 <code>3.1415926</code>，而察觉不到 <code>PI</code> 的存在，只会在报错信息中给出一串数字。此时很难定位到出错位置，尤其是将 <code>#define</code> 写在其它头文件中的时候——这太糟糕了！</p>
<p>最大的原因还是在于，编译器看不到 <code>PI</code>，因为已经被替换掉了，故无法在<strong>符号表</strong>中找到它。同时预处理器盲目进行文本替换还会可能导致目标代码中出现多份 <code>3.1415926</code> 这样的数字。</p>
<p>而替换为 <code>const</code> 则不会出现这一问题，编译器会将 <code>const</code> 变量加入符号表，避免了上述错误。<code>const</code> 还能进行常量指针的定义，并且 <code>const</code> 还能为一个类创建专属常量，自由控制访问级别以及静态与否。这些都是 <code>#define</code> 做不到的，毕竟 <code>#define</code> 不存在作用域这一说法，也不会进行类型检查。</p>
<blockquote>
<p>具体区别请看<a href="../../c/c-const/#%E4%B8%8E%E5%AE%8F%E5%AE%9A%E4%B9%89%E7%9A%84%E5%8C%BA%E5%88%AB"><strong>此处</strong></a>。</p>
</blockquote>
</li>
<li class="lvl-3">
<p>对于形似函数的宏，尽量以 <code>inline</code> 替换。</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">FUNC_MAX</span><span class="token expression"><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>
<span class="token comment">// 改为</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">func_max</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> a<span class="token punctuation">,</span> <span class="token keyword">const</span> T<span class="token operator">&amp;</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">f</span><span class="token punctuation">(</span>a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>用宏定义函数属于是最<strong>丑陋</strong>的行为了，因为你需要时刻关心是否正确添加括号。并且有些调用还不一定得到正确反馈，比如下面 <code>a++</code> 的调用次数取决于比较的对象：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">FUNC_MAX</span><span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// a++ 调用 2 次</span>
<span class="token function">FUNC_MAX</span><span class="token punctuation">(</span>a<span class="token operator">++</span><span class="token punctuation">,</span> b<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a++ 调用 1 次</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>而<a href="../../c/c-inline"><strong>内联函数</strong></a>则不会出现上述问题。<code>func_max()</code> 成为了真正的函数，遵循作用域和访问规则，能利用泛型的同时，增加了类型检查，同时和 <code>const</code> 一样能在类内大显身手，故更为推荐。</p>
</li>
</ol>
<p>但这并不是说预处理器就一无是处了，我们依然需要依靠 <code>#include</code> 来引入头文件，以及依赖 <code>#ifdef</code>，<code>#ifndef</code> 来控制编译。就像最开始说的那样，<strong>尽量用编译器代替预处理器</strong>。</p>
<h2 id="3-尽可能使用-const"><a class="header-anchor" href="#3-尽可能使用-const">#</a>3. 尽可能使用 const</h2>
<p>关于 <code>const</code> 具体可参考<a href="../../c/c-const"><strong>本文</strong></a>。</p>
<p><code>const</code> 更像是一种约束，只要某个变量确定性地能保持不变，我们应该尽可能加上这一约束，以取得编译器的优化。反之，则容易被玩坏，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b <span class="token operator">=</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们或许可以宽容地接受 <code>a * b = c</code> 本来是想执行比较，但因为某些原因少打了一个 <code>=</code> 这一事实。如果 <code>operator*</code> 返回值没有声明为 <code>const</code>，编译器并不会因此报错，毕竟非 const 变量允许被赋值。不考虑这一点，对函数返回值进行赋值也是个糟糕的行为——右值是不能被赋值的。即便假设编译器忽视了所有问题，程序能够成功运行下去，最终结果也可能并不如人意——该 if 子句很难保证能进去。</p>
<p>将返回值声明为 <code>const</code> 则可以预防上面一系列令人头疼的问题，我们需要做的不过是多打几个字符罢了。</p>
<p>另外，虽然对于成员函数而言，const 与 non-const 是两种重载形式，但如果仅有约束不同，也是一件不好的事。我们拿 <a href="../../c/c-mutable/#%E7%B1%BB%E4%B8%AD%E7%9A%84-mutable">C++のMutable</a> 里的 <code>TextBlock</code> 的例子来说：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">TextBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们实现了 const 与 non-const 两个重载版本，供不同常量性的对象调用。但细心的人会发现，除了是否 const 以外，其他部分几乎完全一致！这就存在一个问题：一旦往某个函数中加各种比如并发支持、完整性检查等功能，另一个函数也必须要加上同样的代码——为了保证我们希望的一致性——从而导致文件变得臃肿，反而降低可读性。尽管 ctrl cv 降低了编码难度，但总归不太方便。</p>
<p>一个<strong>明智</strong>的做法是利用 non-const 版本调用 const 版本，从而避免<strong>代码重复</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">TextBlock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">TextBlock</span><span class="token punctuation">(</span><span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">*</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

  <span class="token keyword">const</span> <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">return</span> pText<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">char</span><span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t index<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token generic-function"><span class="token function">const_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">char</span><span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token generic-function"><span class="token function">static_cast</span><span class="token generic class-name"><span class="token operator">&lt;</span><span class="token keyword">const</span> TextBlock<span class="token operator">&amp;</span><span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">[</span>position<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">char</span><span class="token operator">*</span> pText<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 non-const 版本中将 <code>*this</code> 转型为 const，便能调用 const 函数，最后通过 <code>const_cast</code> 移除常量性。代码瞬间精简不少！尽管，使用 cast 是一个糟糕的想法，但在这里，很安全。</p>
<p>而另一种做法，即通过 const 函数调用 non-const 函数，则是一种错误行为，为了不冒 const 风险，不建议采取这种做法。</p>
<h2 id="4-确定对象被使用前已先被初始化"><a class="header-anchor" href="#4-确定对象被使用前已先被初始化">#</a>4. 确定对象被使用前已先被初始化</h2>
<p>C++ 并不能保证变量在所有语境下声明时都能得到初始化，但能保证读取未初始化的值会导致 <strong>UB</strong>。</p>
<p>与其记忆哪些语境下会初始化，哪些语境下不会，不如选择<strong>永远在使用对象前将其初始化</strong>。</p>
<p>对于内置类型，我们应当手动初始化；而对于非内置类型，则需要用到构造函数，并保证初始化每一个成员变量，此时只有两种方式：要么赋值，要么初始化列表。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 赋值</span>
<span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string <span class="token operator">&amp;</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    myName <span class="token operator">=</span> name<span class="token punctuation">;</span>
    myAddress <span class="token operator">=</span> address<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string myName<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string myAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 初始化列表</span>
<span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Entry</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> name<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>string <span class="token keyword">const</span><span class="token operator">&amp;</span> address<span class="token punctuation">)</span>
  <span class="token operator">:</span><span class="token function">myName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span>
   <span class="token function">myAddress</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string myName<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string myAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>第二个版本比第一个版本效率更高</strong>。事实上，类成员变量的初始化行为发生在构造函数之前（见<a href="../../c/c-oop/#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><strong>构造顺序</strong></a>），所以对于大多数类型而言，赋值行为会先调用默认构造函数，然后再使用赋值运算符，这样就导致默认构造函数的操作被浪费，增加无意义的开销并不是一件好事。并且如果某个变量的默认构造函数被<strong>弃置</strong>，编译器还会报错。</p>
<p>而使用初始化列表的方式，则只会影响这些成员变量调用构造函数的版本，相当于是拿着指定的实参去调用构造函数，不用担心顺序问题（但最好还是按照成员变量列出顺序来）。此时只需调用一次构造，比起赋值的方法高效许多。对于内置类型，两种方式开销一样，但为了一致性还是通过初始化列表来初始化。</p>
<p>最后需要关心的事就是<strong>定义于不同编译单元内的 non-local static 变量</strong>了，即定义在作用域外的其它文件的静态变量。因为 C++ 对于这类变量的初始化顺序并未明确定义，甚至根本无解。所以我们在使用一个 <code>extern</code> 标识的变量时，它极有可能未被初始化！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Tool.h</span>
<span class="token keyword">class</span> <span class="token class-name">Tool</span> <span class="token punctuation">{</span>
 <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Human.h</span>
<span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
 <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">extern</span> Tool theTool<span class="token punctuation">;</span>

Human <span class="token function">Jack</span><span class="token punctuation">(</span>theTool<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 如果 theTool 未被初始化，则该语句的实现效果将是非确定性的。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>一个<strong>好的设计</strong>是将 static 变量移到成员函数中，该函数返回一个该变量的引用，用户通过调用该函数来获取变量的访问权，而非直接使用——这就是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/zh-hans/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F"><strong>单例模式</strong></a>的常用实现手法。</p>
<p>为什么说它好？因为函数内部的 static 变量会在调用函数首次遇到定义式时进行初始化，且仅初始化这一次。所以只要调用该函数，便能保证变量必然被初始化。furthermore，如果不调用函数，则变量永远不会被初始化，构造和析构的开销也降低了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// Tool.h</span>
<span class="token keyword">class</span> <span class="token class-name">Tool</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// Human.h</span>
<span class="token keyword">class</span> <span class="token class-name">Human</span> <span class="token punctuation">{</span>
 <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Tool<span class="token operator">&amp;</span> <span class="token function">getTool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> Tool globalTool<span class="token punctuation">;</span>
  <span class="token keyword">return</span> globalTool<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Human <span class="token function">Jack</span><span class="token punctuation">(</span><span class="token function">getTool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 保证得到初始化</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="5-了解-C-默默编写并调用哪些函数"><a class="header-anchor" href="#5-了解-C-默默编写并调用哪些函数">#</a>5. 了解 C++ 默默编写并调用哪些函数</h2>
<p><a href="../../c/c-oop/#%E8%A3%85"><strong>见此处</strong></a></p>
<blockquote>
<p>C++11 引入移动语义之后，对于一个<strong>空类</strong>，编译器将为其默认生成以下 6 种特殊成员函数，且访问级别默认为 <code>public</code>（见下文）：<strong>默认构造函数</strong>、<strong>析构函数</strong>、<strong>拷贝构造函数</strong>、<strong>拷贝赋值运算符</strong>、<strong>移动构造函数</strong>、<strong>移动赋值运算符</strong>。</p>
</blockquote>
<h2 id="6-若不想使用编译器自动生成的函数，就该明确拒绝"><a class="header-anchor" href="#6-若不想使用编译器自动生成的函数，就该明确拒绝">#</a>6. 若不想使用编译器自动生成的函数，就该明确拒绝</h2>
<p>通常来说，如果不希望使用某函数，则不声明即可。但上面那点提到，尽管你可能没声明，但一旦尝试调用，编译器就会自动帮你声明。</p>
<p>所以希望完全阻止这种调用行为，可以加上 <a href="../../c/c-defaultanddelete/#delete"><code>delete</code> 说明符</a>。</p>
<blockquote>
<p>与 <code>default</code> 相对，后面加上 <code>= delete</code> 的函数会被视为<strong>弃置</strong>(deleted)，在编译器眼中这个函数<strong>禁止被定义</strong>，对该函数的调用会导致编译错误，继而从根本上解决了这个问题。</p>
</blockquote>
<h2 id="7-为多态基类声明-virtual-析构函数"><a class="header-anchor" href="#7-为多态基类声明-virtual-析构函数">#</a>7. 为多态基类声明 virtual 析构函数</h2>
<p>见<a href="../../c/c-oop/#%E6%B3%A8%E6%84%8F"><strong>此处</strong></a>第 5 条。</p>
<blockquote>
<p>当可能用到基类指针/引用绑定派生类时，基类的析构函数必须为虚函数。这是因为当出现 <code>Base* ptr = new Derived</code> 这样的代码时，虽然 <code>ptr</code> 是 <code>Base</code> 类的指针，但我们实际上还分配了一个 <code>Derived</code> 类的空间，如果析构函数非虚，则只会执行 <code>Base</code> 类的析构函数，而属于 <code>Derived</code> 的那一部分并没有被析构。为了程序安全运行，我们应该要调用派生类的析构函数，也就是通过将基类析构函数设为虚函数来实现；</p>
</blockquote>
<h2 id="8-别让异常逃离析构函数"><a class="header-anchor" href="#8-别让异常逃离析构函数">#</a>8. 别让异常逃离析构函数</h2>
<p>C++ 虽然并不禁止析构函数吐出异常，但<strong>不建议</strong>。考虑这种情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 存在抛出异常的可能 */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>vector<span class="token operator">&lt;</span>Widget<span class="token operator">&gt;</span> widgets<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在 <code>widgets</code> 销毁时，会调用每一个 <code>Widget</code> 对象的析构函数，一旦某个对象析构时抛出异常，并且没有得到正确处理，整个程序可能因此发生一些 UB。</p>
<p>析构函数必须对此异常进行处理，以防止它逃逸到外层，造成不必要的危害。此时有两种做法：</p>
<ol>
<li class="lvl-3">
<p>直接终止</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment">/* 调用某些可能抛出异常的函数 */</span> <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 记录调用失败 */</span>
      std<span class="token double-colon punctuation">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>吞下异常</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token operator">~</span><span class="token function">Widget</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span> <span class="token comment">/* 调用某些可能抛出异常的函数 */</span> <span class="token punctuation">}</span>
    <span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* 记录调用失败 */</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
</ol>
<p>两种做法均能阻止异常的逃逸，这是好的。另外，如果客户需要对某个函数运行期间抛出的异常做出响应，那么类应该提供一个普通函数（而不是在析构函数中）执行该响应。</p>
<h2 id="9-绝不在构造和析构过程中调用-virtual-函数"><a class="header-anchor" href="#9-绝不在构造和析构过程中调用-virtual-函数">#</a>9. 绝不在构造和析构过程中调用 virtual 函数</h2>
<p>假设有一个 transaction 类体系，用于模拟股市的买卖等操作，每次创建一个交易对象时，都会根据交易类型进行一次适当的记录。比如下面这个看起来挺好的做法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 创建一份因类型不同而不同的交易日志</span>
  <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Transaction</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">SellTransaction</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Transaction</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

BuyTransation buyTxn<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>创建 <code>buyTxn</code> 时，根据<a href="../../c/c-oop/#%E6%B4%BE%E7%94%9F%E7%B1%BB%E6%9E%84%E9%80%A0%E9%A1%BA%E5%BA%8F"><strong>构造顺序</strong></a>，其基类的构造一定会更早被调用，然后才是派生类的专属部分。而其基类的构造函数中出现了一个纯虚函数 <code>logTxn()</code>，这是万恶之源！</p>
<p>我们本意是希望通过该虚函数完成派生类版本的构造，但事实上，构造 <code>BuyTransaction</code> 对象时，优先构造的是对象中的基类部分，也就是 <code>Transaction</code> 部分，此时调用的 <code>logTxn()</code> 尽管为虚，但其无法表现出多态性质，相当于将其视为了 non-virtual，执行的还是 <code>Transaction</code> 版本的函数，并不会下降到派生类 <code>BuyTransaction</code>。毕竟，此时派生类专属部分尚未得到初始化，如果派生类版本的 <code>logTxn()</code> 将用到其成员变量，那将成为"<strong>通往彻夜调试的直达车票</strong>"——C++ 不允许你使用对象内部尚未初始化的部分。</p>
<p>还有一个更根本的原因是，在基类部分构造期间，对象类型会被视为基类而非派生类，请看：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">B</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">D</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token keyword">typeid</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"cons\n"</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  D d<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 1Bcons</span>
<span class="token comment">// 1Dcons</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>所以就算能实现多态，也不会使用派生类的版本——那不就相当于没有多态么(笑</p>
<p>更何况，基类 <code>logTxn()</code> 还是 pure virtual，压根无法调用，故本条款也是为了防止这种情况发生。</p>
<p>上面说的所有原因也同样适用于析构函数。</p>
<p>如果非要实现"<strong>根据不同类型使用不同构造函数</strong>"，一个好的做法是，将基类的 <code>logTxn()</code> 设为 non-virtual，然后要求为该函数传入必要的信息，如:</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Transaction</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token keyword">const</span> TransactionInfo<span class="token operator">&amp;</span> info<span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">logTxn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">static</span> TransactionInfo <span class="token function">createInfo</span><span class="token punctuation">(</span> <span class="token comment">/* params */</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">BuyTransaction</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Transaction</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">BuyTransaction</span><span class="token punctuation">(</span> <span class="token comment">/* params */</span><span class="token punctuation">)</span>
    <span class="token operator">:</span><span class="token function">Transaction</span><span class="token punctuation">(</span><span class="token function">createInfo</span><span class="token punctuation">(</span> <span class="token comment">/* params */</span> <span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就由<strong>令派生类将必要的信息向上传递</strong>代替了<strong>使用虚函数向下调用</strong>。</p>
<h2 id="10-令-operator-返回一个-reference-to-this"><a class="header-anchor" href="#10-令-operator-返回一个-reference-to-this">#</a>10. 令 operator= 返回一个 reference to *this</h2>
<p>关于赋值，可以写为如下形式：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span>
a <span class="token operator">=</span> b <span class="token operator">=</span> c <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">;</span>
<span class="token comment">// 由于赋值遵循右结合律，故被解析为</span>
a <span class="token operator">=</span> <span class="token punctuation">(</span>b <span class="token operator">=</span> <span class="token punctuation">(</span>c <span class="token operator">=</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>为了实现<strong>连锁赋值</strong>，<code>operator=</code> 必须返回一个自身的引用。这同样适用于 <code>+=</code>、<code>-=</code>、<code>后++</code> 等运算符。</p>
<h2 id="11-在-operator-中处理-自我赋值"><a class="header-anchor" href="#11-在-operator-中处理-自我赋值">#</a>11. 在 operator= 中处理"自我赋值"</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object ob<span class="token punctuation">;</span>
ob <span class="token operator">=</span> ob<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>是的这很蠢，但为了演示，没办法（摊手）。当然这种写法是被允许的，只不过自我赋值增加了无意义的开销——这还算能接受，但如果类的赋值运算符写成这样，那就要当心点了：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果 <code>rhs == *this</code> 会发生什么？<code>this-&gt;name</code> 与 <code>rhs.name</code> 实际上就是同一个指针，指向同一块内存。那么此时 <code>name</code> 首先被 delete，然后再通过 <code>operator*</code> 获取 <code>name</code> 指向的字符串……接下来懂的都懂了吧~</p>
<p>为了避免这种危害，<strong>传统做法</strong>是在最开始执行<strong>证同测试</strong>，实现<strong>自我赋值安全性</strong>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> <span class="token operator">&amp;</span>rhs<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span> <span class="token comment">// 比较地址比比较对象本身更好</span>

  <span class="token keyword">delete</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但该做法无法保证<strong>异常安全性</strong>，也就是说，如果 <code>new</code> 操作中出现异常（内存不够 or 构造函数异常），最后还是会得到一份<strong>不安全</strong>的反馈——<code>name</code> 可能因此被永久 delete，既无法删除，也无法读取。看 solution！</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> tmp <span class="token operator">=</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span>name<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token operator">-&gt;</span>name <span class="token operator">=</span> <span class="token keyword">new</span> std<span class="token double-colon punctuation">::</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token operator">*</span>rhs<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">delete</span> tmp<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>即便 <code>new</code> 或构造函数出现异常，<code>name</code> 也不会因此被贸然 delete——该做法保证了先分配再释放。同样的，这也解决了最开始<strong>自我赋值安全性</strong>的问题。</p>
<p>上一方案的替代做法是 <strong>copy and swap</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 交换 *this 和 rhs 的数据 */</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Object <span class="token function">tmp</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>tmp<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>或者直接这样写：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Object</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Object<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* 交换 *this 和 rhs 的数据 */</span> <span class="token punctuation">}</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">*</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token operator">&amp;</span> opeartor<span class="token operator">=</span><span class="token punctuation">(</span>Object rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>当然可以在这些方案的最开始加上证同测试，但需要在自我赋值开销与目标代码、CPU 控制流之间做出 trade-off。</p>
</blockquote>
<h2 id="12-复制对象时勿忘其每个成分"><a class="header-anchor" href="#12-复制对象时勿忘其每个成分">#</a>12. 复制对象时勿忘其每个成分</h2>
<p>本来编译器会为你默认生成一个完美的拷贝构造/拷贝赋值，但不一定是你想要的，所以此时你进行了一些自定义。</p>
<p>结果后面类加入了新的成员变量，你就需要时刻警醒自己：别忘了修改自定义的拷贝构造与拷贝赋值。否则就会出现违背<a href="#4.-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>条款 4</strong></a> 的结果。</p>
<p>当然这还好说，但一旦出现继承，另一个噩梦又来了……</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string name<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Customer</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> priority<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面看起来没啥问题，但实际上，<code>PriorityCustomer</code> 类对象进行拷贝时，仅仅对派生类部分的变量进行了拷贝，而忽略了基类部分的 <code>std::string name</code>。这是致命的！此时 <code>name</code> 会用默认的方式进行构造，那么得到的新 <code>PriorityCustomer</code> 对象就变成无名氏了~</p>
<blockquote>
<p>因为如果让编译器来干，它会毫不犹豫地将基类部分也一并拷贝，怎么到你这就拉垮了？尽管如此，编译器不会给你报错，哎就是玩，毕竟这也不是啥大问题嘛，万一你真的不想拷贝呢~</p>
</blockquote>
<p>所以通过拷贝的方式进行构造时，一定不要忘了调用所有基类的适当的拷贝函数，拷贝赋值也是同理的。就像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">PriorityCustomer</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Customer</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">PriorityCustomer</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
    <span class="token operator">:</span><span class="token function">Customer</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">,</span>
     <span class="token function">priority</span><span class="token punctuation">(</span>rhs<span class="token punctuation">.</span>priority<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  PriorityCustomer<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> PriorityCustomer<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Customer<span class="token punctuation">.</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
    priority <span class="token operator">=</span> rhs<span class="token punctuation">.</span>priority<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> priority<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后要注意的是，如果拷贝构造与拷贝赋值出现了重复部分，可以将这些重复的部分写入新的函数(eg.<code>init()</code>)，然后让它俩一起调用，从而消除冗余。而不是让一个拷贝调用另一个拷贝——<a href="../../c/c-oop/#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6">构造跟赋值不能混为一谈</a>！</p>
<h2 id="13-以对象管理资源"><a class="header-anchor" href="#13-以对象管理资源">#</a>13. 以对象管理资源</h2>
<p>关于本条款，可以阅读 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34660259"><strong>RAII</strong></a> 与<a href="../../c/c-smartptr"><strong>智能指针</strong></a> 相关内容。</p>
<blockquote>
<p>构造时获取资源，析构时释放资源。</p>
</blockquote>
<h2 id="14-在资源管理类中小心-coping-行为"><a class="header-anchor" href="#14-在资源管理类中小心-coping-行为">#</a>14. 在资源管理类中小心 coping 行为</h2>
<p>资源管理类的核心是 RAII 技术，而智能指针则将其表现在了 heap-based 资源上。但并非所有资源都是 heap-based，一个很常见的例子就是<strong>互斥锁</strong>，获取资源相当于进行 <code>lock()</code>，而释放资源则相当于 <code>unlock()</code>。我们希望利用 RAII 来管理这种资源，则可以很容易写出以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Lock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">Lock</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">*</span> pm_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">pm</span><span class="token punctuation">(</span>pm_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    pm<span class="token operator">-&gt;</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
  <span class="token operator">~</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    pm<span class="token operator">-&gt;</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">*</span> pm<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">*</span> m<span class="token punctuation">;</span>
<span class="token punctuation">{</span>
  Lock <span class="token function">lock1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 锁定互斥体</span>
  <span class="token comment">/* 访问临界区 */</span>
<span class="token punctuation">}</span> <span class="token comment">// 作用域末尾，通过析构函数释放互斥体</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但如果 <code>Lock</code> 对象被拷贝，会发生什么事？（不言而喻了）</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Lock <span class="token function">lock2</span><span class="token punctuation">(</span>lock1<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>大部分情况下，我们有以下做法：</p>
<p>第一，<strong>禁止拷贝</strong>，即设为 <code>=delete</code>，正如<a href="#6.-%E8%8B%A5%E4%B8%8D%E6%83%B3%E4%BD%BF%E7%94%A8%E7%BC%96%E8%AF%91%E5%99%A8%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%8C%E5%B0%B1%E8%AF%A5%E6%98%8E%E7%A1%AE%E6%8B%92%E7%BB%9D"><strong>条款 6</strong></a> 所说的那样；</p>
<p>第二，<strong>引用计数法</strong>，正如 <a href="../../c/c-smartptr/#std::shared_ptr"><strong>shared_ptr</strong></a> 做的那样，直到该资源的最后一个使用者被销毁后才释放；</p>
<p>第三，<strong>拷贝底部资源</strong>，注意这里的拷贝是指深拷贝，即不仅仅拷贝指针，同时拷贝一份指针指向的内存；</p>
<p>第四，<strong>转移底部资源所有权</strong>，即实现<a href="../../c/c-value/#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89"><strong>移动语义</strong></a>；</p>
<h2 id="15-在资源管理类中提供对原始资源的访问"><a class="header-anchor" href="#15-在资源管理类中提供对原始资源的访问">#</a>15. 在资源管理类中提供对原始资源的访问</h2>
<p>或通过 api 来提供对原始资源的显式访问，或通过在类内自定义类型转换提供隐式访问。一般而言显示访问比较安全，而隐式访问比较方便，需要根据实际应用场景作出 trade-off。</p>
<h2 id="16-成对使用-new-和-delete-时采取相同形式"><a class="header-anchor" href="#16-成对使用-new-和-delete-时采取相同形式">#</a>16. 成对使用 new 和 delete 时采取相同形式</h2>
<p>游戏规则很简单：如果你调用 new 时使用 <code>[]</code>，你必须在对应调用 delete 时也使用 <code>[]</code>。如果你调用 new 时没有使用 <code>[]</code>，那么也不该在对应调用 delete 时使用 <code>[]</code>。</p>
<h2 id="17-以独立语句将-newed-对象置入智能指针"><a class="header-anchor" href="#17-以独立语句将-newed-对象置入智能指针">#</a>17. 以独立语句将 newed 对象置入智能指针</h2>
<p>考虑这样一个函数 <code>foo()</code>：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> pInt<span class="token punctuation">,</span> <span class="token keyword">int</span> someint<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span>

<span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">new</span> Object<span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ERROR！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>像这样调用是不行的，因为 <code>shared_ptr</code> 尽管有形参为裸指针的构造函数，但却是声明为 <code>explicit</code>，没法如此隐式转换，也就无法通过编译。或许我们可以如此做来通过编译：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token function">foo</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span><span class="token keyword">new</span> Object<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>但不同编译器做出的反应也不一样，或许存在某个编译器给出了以下指令执行顺序：</p>
<ol>
<li class="lvl-3">
<p>new Object；</p>
</li>
<li class="lvl-3">
<p>bar()；</p>
</li>
<li class="lvl-3">
<p>shared_ptr 构造函数；</p>
</li>
</ol>
<p>设想一下，如果 <code>bar()</code> 抛出一个异常，导致程序终止，会发生什么？new 出来的 <code>Object</code> 指针将无家可归，它并没有被 shared_ptr 保有，而我们依赖后者来防止资源泄漏，但很遗憾，资源泄漏发生了。解决方案很简单，就像条款说的，<strong>以独立语句将 newed 对象置入智能指针</strong>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> <span class="token function">pObj</span><span class="token punctuation">(</span><span class="token keyword">new</span> Object<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">(</span>pObj<span class="token punctuation">,</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// perfect! 绝不会引发泄漏</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<h2 id="18-让接口容易被正确使用，不易被误用"><a class="header-anchor" href="#18-让接口容易被正确使用，不易被误用">#</a>18. 让接口容易被正确使用，不易被误用</h2>
<p>促进正确使用很简单，只需要满足 api 的一致性，以及与内置类型的行为兼容即可。</p>
<p>但误用却时有发生。任何一个 api 如果要求客户必须记得做某些事，就是有着"不正确使用"的倾向，因为客户可能会忘记。比如<a target="_blank" rel="noopener" href="https://refactoringguru.cn/design-patterns/factory-method"><strong>工厂函数</strong></a>如果在内部 new 了一个指针并将其返回，则客户很容易忘记 delete，或是 delete 多次。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Object<span class="token operator">*</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>或许你会想到将该指针托付给一个智能指针，比如 <code>std::shared_ptr&lt;Object&gt; pObj(factory());</code>，但客户也很可能会忘记使用智能指针。事实上，一个好的设计是令该 api 返回一个智能指针，即</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Object<span class="token operator">&gt;</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这便消除了上面这些问题发生的可能性。</p>
<h2 id="19-设计-class-犹如设计-type"><a class="header-anchor" href="#19-设计-class-犹如设计-type">#</a>19. 设计 class 犹如设计 type</h2>
<p>C++ 就像其他 OOP 语言一样，当我们定义一个新 class，也就定义了一个新 type。身为 C++ 程序员，我们并不只是 class 设计者，还是 type 设计者，重载(overloading)函数和操作符、控制内存的分配和归还、定义对象的初始化和终结……全都由我们负责。因此我们应该带着和"语言设计者当初设计语言内置类型时"一样的谨慎来研讨 class 的设计。</p>
<p>为了搞清"<strong>如何设计高效的类</strong>"这一问题，我们必须想明白以下几件事：</p>
<ol>
<li class="lvl-3">
<p><strong>新 type 的对象应该如何创建和销毁？</strong>——好好设计构造、析构函数以及 <code>new</code>，<code>delete</code> 运算符；</p>
</li>
<li class="lvl-3">
<p><strong>对象的初始化与对象的赋值有什么区别？</strong>——别混淆初始化与赋值，它们对应了两个不同的函数调用；</p>
</li>
<li class="lvl-3">
<p><strong>新 type 对象如果被值传递，意味着什么？</strong>——这由拷贝构造函数决定；</p>
</li>
<li class="lvl-3">
<p><strong>什么是新 type 的"合法值"？</strong>——对类成员变量而言，只有某些数值组成的集合是有效的，而这也决定了类的约束条件，以及需要在成员函数中做的错误检查工作；</p>
</li>
<li class="lvl-3">
<p><strong>新 type 需要配合某个继承图系吗？</strong>——如果该类继承自其他类，那么其设计就受到其他类 virtual 与 non-virtual 函数等的影响。如果允许该类派生其他类，那么需要关注析构函数是否为虚；</p>
</li>
<li class="lvl-3">
<p><strong>新 tyoe 需要什么样的转换？</strong>——好好设计自定义转换函数，并且思考构造函数需不需要 <code>explicit</code>；</p>
</li>
<li class="lvl-3">
<p><strong>什么样的操作符和函数对此新 type 而言是合理的？</strong>——这决定了该类所相关的函数设计；</p>
</li>
<li class="lvl-3">
<p><strong>什么样的标准函数应当被驳回？</strong>——好好思考哪些该 <code>=delete</code>；</p>
</li>
<li class="lvl-3">
<p><strong>谁该取用新 type 的成员？</strong>——好好思考访问级别、友元以及是否让该类对象成为其他类的成员变量相关问题；</p>
</li>
<li class="lvl-4">
<p><strong>什么是新 type 的未声明接口？</strong>——它对效率、异常安全性以及资源运用提供何种保证？</p>
</li>
<li class="lvl-4">
<p><strong>新 type 有多么一般化？</strong>——实现一般化的最好做法是定义一个类模板；</p>
</li>
<li class="lvl-4">
<p><strong>真的需要新 type 吗？</strong>——如果只是为了给基类添加新功能而定义派生类，那不如直接加点成员函数或模板；</p>
</li>
</ol>
<h2 id="20-宁以引用传递代替值传递"><a class="header-anchor" href="#20-宁以引用传递代替值传递">#</a>20. 宁以引用传递代替值传递</h2>
<p>说白了就是降低因<strong>构造/析构</strong>新的局部对象带来的额外开销，毕竟传引用的开销可以忽略不计，也没有生成新对象。</p>
<blockquote>
<p>至于引用是否需要加 <code>const</code>，则需要根据具体应用场景灵活变化。</p>
</blockquote>
<p>还有一个隐性好处是，可以通过将派生类传递给基类引用来实现多态——如果是值传递，那么就容易造成<strong>对象切割</strong>。</p>
<p>最后要注意的是，C++ 里的引用常以指针的形式实现，意味着引用传递实际上传的是指针，那么对于内置类型、迭代器和函数对象而言，值传递的效率往往比引用传递的高——引用传递则还多了一步地址寻址的操作。</p>
<h2 id="21-必须返回对象时，别妄想返回其-reference"><a class="header-anchor" href="#21-必须返回对象时，别妄想返回其-reference">#</a>21. 必须返回对象时，别妄想返回其 reference</h2>
<p>尽管我们了解了引用传递的优势，但也不能一味追求引用传递，尤其是传递一些 reference 指向实际不存在的对象，这可不是件好事。</p>
<p>以<a href="#3-%E5%B0%BD%E5%8F%AF%E8%83%BD%E4%BD%BF%E7%94%A8-const"><strong>条款 3</strong></a> 中 <code>Rational</code> 类为例，它内含一个函数用于计算两个有理数的乘积。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">int</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
           <span class="token keyword">int</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> n<span class="token punctuation">,</span> d<span class="token punctuation">;</span> <span class="token comment">// 分子和分母</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>虽然返回值是以值传递，但这点开销是值得且必要的。如果我们试图通过引用传递来逃避这一开销，那必然要有一个已经存在的 <code>Rational</code> 对象来给引用绑定，这是引用的刚需。事实上这并不合理，如果我们有以下代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rational <span class="token function">a</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational <span class="token function">b</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational c <span class="token operator">=</span> a <span class="token operator">*</span> b<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>此时希望在运算之前就存在一个表示 <code>3/10</code> 的 <code>Rational</code> 对象是不现实的。如果 <code>operator*</code> 要返回一个 reference 指向该数值，它必须自己创建该对象，在 stack 上或 heap 上。</p>
<p>在 stack 上创建的对象会因为函数的退出而消亡，显然是无法作为引用返回值的。任何调用者甚至只是对此函数的返回值做任何一点点运用，都将立刻坠入"无定义行为"的恶地。事情的真相是，任何函数如果返回一个 reference 指向某个局部变量，都将一败涂地（指针亦是如此）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// on-the-stack</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Rational <span class="token function">result</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 糟糕的代码！</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么在 heap 上创建呢？只会更糟！还带来了一个额外的问题——如何 delete？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// on-the-heap</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Rational <span class="token operator">*</span>result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 更糟糕的代码！</span>
  <span class="token keyword">return</span> <span class="token operator">*</span>result<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>尽管你可能非常小心谨慎，但还是无法在以下代码中幸存：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rational w<span class="token punctuation">,</span> x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">;</span>
w <span class="token operator">=</span> x <span class="token operator">*</span> y <span class="token operator">*</span> z<span class="token punctuation">;</span> <span class="token comment">// 等价于 operator*(operator*(x, y), z);</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>此时同一个语句调用了两次 <code>operator*</code>，也就调用了两次 new，便需要两次 delete。但遗憾的是，我们没有合理的方法进行 delete 调用，因为我们没有合理的方法取得返回值背后隐藏的那个指针，从而导致了内存泄漏。</p>
<p>或许会想到返回 <code>static</code> 变量来避免上述情况，我只能说没有任何区别，就像下面这串代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// static</span>
<span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> Rational result<span class="token punctuation">;</span>
  result <span class="token operator">=</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

Rational a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">,</span> d<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span>c <span class="token operator">*</span> d<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>a * b</code> 与 <code>c * d</code> 返回了同一个 <code>static</code> 变量的引用，表达式难道不是永远返回 <code>true</code>？</p>
<p>至于其它一些想法，梅耶懒得一一驳斥了，他的想法很简单：对于一个"必须返回新对象"的函数，就让那个函数返回一个新对象呗！就像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">inline</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                                 <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span>n <span class="token operator">*</span> rhs<span class="token punctuation">.</span>n<span class="token punctuation">,</span> lhs<span class="token punctuation">.</span>d <span class="token operator">*</span> rhs<span class="token punctuation">.</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们已经探讨过，在 on-the-stack，on-the-heap，static 这些思路中，都难免存在构造/析构一个新的对象带来的开销，既然逃不过，那不如选择最稳妥的做法，更何况这只不过是一个非常小的代价罢了。</p>
<h2 id="22-将成员变量声明为-private"><a class="header-anchor" href="#22-将成员变量声明为-private">#</a>22. 将成员变量声明为 private</h2>
<p>就<strong>语法一致性</strong>而言，如果 public 下全是成员函数，客户就无需思考某个成员后面是否需要加圆括号。</p>
<p>另外，使用函数可以对成员变量的处理有着更精确的<strong>访问控制</strong>。如果将成员变量设为 public，那么可以很轻易地直接读写，而通过函数，则可以人为控制读写权限，就像下面这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">AccessLevels</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> <span class="token function">getReadOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readOnly<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">setReadWrite</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> readWrite <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">int</span> <span class="token function">getReadWrite</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> readWrite<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">setWriteOnly</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span> writeOnly <span class="token operator">=</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> noAccess<span class="token punctuation">;</span>   <span class="token comment">// 无访问操作</span>
  <span class="token keyword">int</span> readOnly<span class="token punctuation">;</span>   <span class="token comment">// 只读</span>
  <span class="token keyword">int</span> readWrite<span class="token punctuation">;</span>  <span class="token comment">// 可读写</span>
  <span class="token keyword">int</span> WriteOnly<span class="token punctuation">;</span>  <span class="token comment">// 只写</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>最后，考虑整个类的<strong>封装性</strong>，将成员变量隐藏在函数接口的背后，可以为"所有可能的实现"提供弹性，并且可以确保类的约束条件总是会获得维护，因为只有成员函数可以影响它们。</p>
<h2 id="23-宁以-non-member、non-friend-替换-member-函数"><a class="header-anchor" href="#23-宁以-non-member、non-friend-替换-member-函数">#</a>23. 宁以 non-member、non-friend 替换 member 函数</h2>
<p>考虑一个网页浏览器的例子，它拥有清理缓存、清理访问历史，以及清理所有 cookies 的功能</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">clearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">clearCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可能很多人会想要添加一个这样的功能：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">WebBrowser</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">clearEverything</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 调用 clearCache, clearHistory, clearCookies</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当然，这一功能也可以通过一个 non-member 函数调用适当的成员函数实现：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">clearBrowser</span><span class="token punctuation">(</span>WebBrowser<span class="token operator">&amp;</span> wb<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  wb<span class="token punctuation">.</span><span class="token function">clearCache</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  wb<span class="token punctuation">.</span><span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  wb<span class="token punctuation">.</span><span class="token function">clearCookies</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>好的设计中，如果能够实现相同功能，那么会优先考虑 non-member 函数。为什么？</p>
<p>首先，non-member non-friend 函数能够提供<strong>更大的封装性</strong>。前一条款曾说过，成员变量应该是 private，否则将有无限的函数可以访问它们，它们也就毫无封装性。而一个 non-member non-friend 函数并不会增加"能够访问类内 private 成分"的函数数量。</p>
<p>其次，non-member 函数也可以是其他类的成员函数。比较自然的做法是让它俩处于同一命名空间。不仅如此，我们还应意识到，命名空间不像 classes，前者可以跨越多个源码文件，而后者不行。将所有像 <code>clearBrowser()</code> 的这些 <strong>utility 函数</strong>放在多个头文件内但隶属同一个命名空间，意味客户可以轻松扩展这一组 utility 函数，<strong>增加包裹弹性</strong>，<strong>降低编译耦合度</strong>。他们需要做的就是添加更多 non-member non-friend 函数到此命名空间内，这允许客户只对他们所用的那一小部分系统形成编译耦合——毕竟如果我们想要用 <code>&lt;vector&gt;</code> 相关 utility 函数，无需 <code>#include&lt;memory&gt;</code>。</p>
<h2 id="24-若所有参数皆需类型转换，请为此采用-non-member-函数"><a class="header-anchor" href="#24-若所有参数皆需类型转换，请为此采用-non-member-函数">#</a>24. 若所有参数皆需类型转换，请为此采用 non-member 函数</h2>
<p><a href="#21-%E5%BF%85%E9%A1%BB%E8%BF%94%E5%9B%9E%E5%AF%B9%E8%B1%A1%E6%97%B6%E5%88%AB%E5%A6%84%E6%83%B3%E8%BF%94%E5%9B%9E%E5%85%B6-reference"><strong>条款 21</strong></a> 中的 <code>Rational</code> 类对象的构造函数并没有声明为 <code>explicit</code>，也就意味着允许隐式的转换。梅耶在导读中已经提过"令 class 支持隐式转换是一种糟糕的行为"，但有例外。<code>Rational</code> 中便是梅耶刻意为之，那么为什么？</p>
<p>注意到，类中进行乘积的函数被设为 non-member 函数。当然也可以写成成员函数，比如这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>但这样写却忽略了一种混合式乘法场景：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Rational <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational result<span class="token punctuation">;</span>
result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>  <span class="token comment">// OK! oneHalf.operator* (Rational(2));</span>
result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> oneHalf<span class="token punctuation">;</span>  <span class="token comment">// ERROR! int 并没有运算符 operator* (Rational) 的实现</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>result = oneHalf * 2</code> 这一语句能编译通过的原因便是 <code>Rational</code> 类支持来自 <code>int</code> 的隐式转换。如果声明为了 <code>explicit</code>，那同样编译不过。此时我们最开始提出的那个问题已经得到了回答。</p>
<p>而即便构造函数为 non-explicit，<code>result = 2 * oneHalf</code> 这句依然无法编译通过，本质原因在于我们实现的是 <code>Rational::operator* (const Rational&amp;)</code>，而运算符左侧为 <code>int</code> 型，该类型并不支持 <code>int::operator* (const Rational&amp;)</code> 这样的运算。</p>
<p>定理为，<strong>只有当参数被列于参数列表时，该参数才是隐式类型转换的合格参与者，而 this 不是</strong>。一个好的设计应当满足所有的应用场景，为了解决这一问题，我们要做的便是像条款 21 中的那样，将 <code>operator*</code> 定义为 non-member，并（可以）令其为 <code>friend</code>——以便访问 lhs, rhs 的 private 变量。</p>
<p>这样一来，<code>result = 2 * oneHalf</code> 便可以被编译器视为 <code>result = operator*(Rational(2), oneHalf)</code>。编译通过！</p>
<h2 id="25-考虑写出一个不抛出异常的-swap-函数"><a class="header-anchor" href="#25-考虑写出一个不抛出异常的-swap-函数">#</a>25. 考虑写出一个不抛出异常的 swap 函数</h2>
<p>当 <code>std::swap</code> 的缺省实现版，或对其全特化无法满足需求（无法访问 private 成员）时，考虑添加一个 <code>swap</code> 成员函数，并确保其不抛出异常。为了方便，可以在同一个命名空间中提供一个 non-member non-std <code>swap</code> 来调用前者。调用成员函数 <code>swap</code> 时，应针对 <code>std::swap</code> 使用 <code>using</code> 声明，然后不带任何作用域运算符 <code>::</code> 地来为具体的成员变量调用 <code>swap</code>。就像这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">namespace</span> WidgetStuff <span class="token punctuation">{</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
  <span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
   <span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">using</span> std<span class="token double-colon punctuation">::</span>swap<span class="token punctuation">;</span>      <span class="token comment">// 令 std::swap 在此函数内可用</span>
      <span class="token function">swap</span><span class="token punctuation">(</span>impl<span class="token punctuation">,</span> rhs<span class="token punctuation">.</span>impl<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 为 impl 调用最佳版本，而不是憨憨地 std::swap(impl, rhs.impl);</span>
    <span class="token punctuation">}</span>

   <span class="token keyword">private</span><span class="token operator">:</span>
    <span class="token comment">/* 可能有许多数据 */</span>
    WidgetImpl<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">*</span> impl<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
  <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span>Widget<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> Widget<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    lhs<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span>rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">//namespace WidgetStuff</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>千万不要试图通过偏特化 <code>std::swap</code> 的方式来实现目标，因为 C++ 禁止对函数模板进行偏特化。或许可以通过添加重载版本来逃避，但尽量不要忘 <code>std</code> 里添加新东西。</p>
<h2 id="26-尽可能延后变量定义式的出现时间"><a class="header-anchor" href="#26-尽可能延后变量定义式的出现时间">#</a>26. 尽可能延后变量定义式的出现时间</h2>
<p>这一条款的提出是源于这样一个场景：如果某个变量定义后，在其真正使用之前，同个作用域内抛出了异常，那么该变量的定义将白白浪费了一次构造与一次析构的开销。</p>
<p>当然，基于<a href="#4-%E7%A1%AE%E5%AE%9A%E5%AF%B9%E8%B1%A1%E8%A2%AB%E4%BD%BF%E7%94%A8%E5%89%8D%E5%B7%B2%E5%85%88%E8%A2%AB%E5%88%9D%E5%A7%8B%E5%8C%96"><strong>条款 4</strong></a> 的讨论，我们也不容易写出先定义，然后使用到的时候再赋值这种行为，这比直接在构造时指定初值效率低太多了。所以，不应该只延后变量的定义，而是直到非用该变量不可的前一刻为止，甚至是尝试延后这份定义知道能给它初值实参为止，这不仅能避免构造/析构不必要的对象，还可以避免无意义的默认构造行为。更深一层说，以"具有明显意义的处置"进行初始化还可以附带说明变量的目的。</p>
<p>那么，在循环中，我们可能容易产生疑虑：如果变量只在循环内使用，那么是定义在循环外，然后每次循环迭代时赋值，还是定义在循环内，每次循环构造一个新的 on-the-stack 变量？</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 方法 A：循环外定义</span>
Widget w<span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  w <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 方法 B：循环内定义</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  Widget w <span class="token operator">=</span> <span class="token comment">/* ... */</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>方法 A 的开销为：1 次构造 + 1 次析构 + n 次赋值；</p>
<p>方法 B 的开销为：n 次构造 + n 次析构；</p>
<p>所以，如果赋值的开销比一组构造/析构的开销小，那么自然选择方法 A；反之，选择方法 B。但方法 A 造成名称 w 的作用域比方法 B 更大，有时会对程序的可理解性和易维护性造成冲突，这也是需要考虑在内的因素。</p>
<h2 id="27-尽量少做转型动作"><a class="header-anchor" href="#27-尽量少做转型动作">#</a>27. 尽量少做转型动作</h2>
<p>文章 <a href="../../c/c-cast"><strong>C++ の Cast</strong></a> 中已经介绍过 C++ 中类型转换的内容。尽量避免转型，特别是在注重效率的代码中避免 <code>dynamic_cast</code>。如果非要转型，也尽可能使用 C+±style 转型。</p>
<h2 id="28-避免返回-handles-指向对象内部成分"><a class="header-anchor" href="#28-避免返回-handles-指向对象内部成分">#</a>28. 避免返回 handles 指向对象内部成分</h2>
<p>通常我们认为，对象的"内部"就是指它的成员变量，但其实 non-public 成员函数也是对象"内部"的一部分，因此也应该留心不要返回它们的 handles，这意味你绝对不该令成员函数返回一个指针/引用指向"访问级别较低"的成员函数。如果你那么做，后者的实际访问级别就会提高如同访问级别较高者，因为客户可以取得一个指针指向那个"访问级别较低"的函数，然后通过那个指针调用它。这无形中相当于将 private 变量变成了 public，就跟之前提到的那样，这降低了封装性。</p>
<p>此外，handles 也可能出现<strong>悬空</strong>的情况，即获取一个对象内部变量的指针/引用后，该对象在真正使用之前销毁，那么该指针/引用实际上指向了一个未知的变量，这极为糟糕。毕竟，handles 并不能延长变量的生命周期。这和 <a href="../../c/c-function/#%E6%82%AC%E5%9E%82%E5%BC%95%E7%94%A8"><strong>lambda 表达式</strong></a>中提到的有异曲同工之妙。</p>
<h2 id="29-为-异常安全-而努力是值得的"><a class="header-anchor" href="#29-为-异常安全-而努力是值得的">#</a>29. 为"异常安全"而努力是值得的</h2>
<p>关于异常可见<a href="../../c/c-exception"><strong>此文</strong></a>。</p>
<p><strong>异常安全函数</strong>提供以下三个保证之一：</p>
<ol>
<li class="lvl-3">
<p><strong>基本承诺</strong>：如果异常被抛出，程序内的任何事物仍然保持在有效状态下，没有任何对象或数据结构因此被破坏，所有对象都处于内部前后一致的状态；</p>
</li>
<li class="lvl-3">
<p><strong>强烈保证</strong>：如果异常被抛出，程序状态不变。即要么成功，要么回滚；</p>
</li>
<li class="lvl-3">
<p><strong>不抛保证</strong>：承诺绝不抛出异常，因为它们总能完成原先承诺的功能；</p>
</li>
</ol>
<h2 id="30-透彻了解-inlining-的里里外外"><a class="header-anchor" href="#30-透彻了解-inlining-的里里外外">#</a>30. 透彻了解 inlining 的里里外外</h2>
<p>关于 inline，请看<a href="../../c/c-inline"><strong>此文</strong></a>。</p>
<blockquote>
<p>inline 函数背后的整体观念是，将"对此函数的每一个调用"都以函数本体替换之。优点是能够免除函数调用成本，比宏多了类型检查，以及其他编译器优化。缺点是增加了目标码大小，导致程序体积太大，可能导致额外的换页行为，降低 cache 命中率，以及隐性的其他效率降低。</p>
</blockquote>
<h2 id="31-将文件之间的编译耦合度降至最低"><a class="header-anchor" href="#31-将文件之间的编译耦合度降至最低">#</a>31. 将文件之间的编译耦合度降至最低</h2>
<p>我们不希望仅仅修改某个头文件后，重新 make 项目还要花大量时间将所有文件重新编译链接一遍。问题出在 C++ 并没有把接口从实现很好地分离。类的定义式不仅有各种 api，还有各种数据的实现条目。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string theName<span class="token punctuation">;</span>
  Date theBirthdate<span class="token punctuation">;</span>
  Address theAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>如果没有取得合适的定义式，则编译失败。事实上，文件的最开始总会有下面这样的语句。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"date.h"</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"address.h"</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>这便是一种编译耦合关系。一旦上述任何一个头文件被改变，那么所有 include 该头文件，包括含有/使用 <code>Person</code> 类的文件就得重新编译，这很容易造成级联依存关系。</p>
<p>好的设计是<strong>前置声明</strong>，并将所有实现条目由指向其实现类的指针代替，即 <strong>pimpl</strong>(pointer to implementation)，这样也方便令编译器计算出所需分配空间的大小。如果仅修改了前者，则编译器很难在不了解定义式的前提下知道一个 Data，一个 Address 应该分配的空间是多少。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;memory&gt;</span></span>

<span class="token keyword">class</span> <span class="token class-name">PersonImpl</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Data</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Address</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>PersonImpl<span class="token operator">&gt;</span> pImpl<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>此时，<code>Person</code> 便真正做到了<strong>接口与实现分离</strong>，将编译耦合度降至了最低——它只需要将实现的内容交付给 <code>PersonImpl</code> 类，而用户只需要 <code>#include "Person.h"</code> 即可，无需在意 impl 里是怎么做的。当然，改变 <code>"date.h"</code> 这些头文件也仅仅影响 <code>PersonImpl</code> 类罢了——关键在于，以<strong>声明依存性</strong>替换<strong>定义依存性</strong>，这正是本质所在。下面还有一些其它重要的策略：</p>
<ol>
<li class="lvl-3">
<p>如果可以，尽量用对象引用/对象指针代替对象；</p>
</li>
<li class="lvl-3">
<p>如果可以，尽量用类声明式代替类定义式；</p>
</li>
<li class="lvl-3">
<p>为声明式和定义式提供不同的头文件；</p>
</li>
</ol>
<p>像 <code>Person</code> 这样使用 pimpl 的类一般称为 <strong>handle class</strong>，它必须要通过调用 pImpl 的成员函数来真正做点事情。当然，在调用 <code>pImpl-&gt;</code> 函数时，必须先引入 <code>"PersonImpl.h"</code>（定义式），否则无法调用其成员函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">"PersonImpl.h"</span></span>

<span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span>
  <span class="token operator">:</span> <span class="token function">pImpl</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">PersonImpl</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>string <span class="token class-name">Person</span><span class="token double-colon punctuation">::</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> pImpl<span class="token operator">-&gt;</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>另一个策略是，令 <code>Person</code> 成为<strong>抽象基类</strong>（即<strong>接口类</strong>），它仅需描述派生类的接口，而将具体实现交给派生类去完成，因此其不带成员变量，也没有构造函数，只有一个虚析构函数，以及一组纯虚函数。此时，某些函数的参数就得用 <code>Person*</code> 或 <code>Person&amp;</code> 来撰写。就像 handle class 一样，除非接口被改写，否则无需重新编译。</p>
<p>在这种接口类中，往往有一个静态的<strong>工厂函数</strong>来创建新对象。尽管接口类不存在构造函数，无法实例化，但它完全可以通过实例化派生类来达成目的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span>
                                        <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">RealPerson</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span> <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span> <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">theName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">theBirthdate</span><span class="token punctuation">(</span>birthday<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">theAddress</span><span class="token punctuation">(</span>addr<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">RealPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">birthdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>string <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>string theName<span class="token punctuation">;</span>
  Date theBirthdate<span class="token punctuation">;</span>
  Address theAddress<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

std<span class="token double-colon punctuation">::</span>shared_ptr<span class="token operator">&lt;</span>Person<span class="token operator">&gt;</span> <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>string<span class="token operator">&amp;</span> name<span class="token punctuation">,</span>
                               <span class="token keyword">const</span> Date<span class="token operator">&amp;</span> birthday<span class="token punctuation">,</span>
                               <span class="token keyword">const</span> Address<span class="token operator">&amp;</span> addr<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
  <span class="token keyword">return</span> std<span class="token double-colon punctuation">::</span><span class="token generic-function"><span class="token function">shared_ptr</span><span class="token generic class-name"><span class="token operator">&lt;</span>RealPerson<span class="token operator">&gt;</span></span></span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token function">RealPerson</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> birthday<span class="token punctuation">,</span> addr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现实中，<code>create</code> 会根据实现代码创建不同类型的派生类，取决于额外参数值、环境变量等。</p>
<p>上面两种策略，handle class 也好，接口类也好，也是会为了降低耦合度而付出少许代价的。</p>
<p>对前者而言，成员函数必须通过 pimpl 获取数据，这会为每一次访问添加一层间接性，并且每一个对象所需内存增加了一个指针大小，这在 64 位机器上为 8B。最后， pimpl 的初始化必须经历动态内存分配带来的困扰——<code>new</code> 的开销，以及 <code>bad_alloc</code> 的可能性。</p>
<p>至于后者，由于每个函数都是虚函数，所以每次函数调用都会在运行时带来查找虚表的开销，当然，所有派生类也增加了（至少）一个 vptr 的大小。</p>
<p>我们进行效率分析时必须进行代价分析，但这些代价，之于降低耦合度带来的好处，则可以忽略不计了。</p>
<h2 id="32-确定你的-public-继承塑模出-is-a（是一种）关系"><a class="header-anchor" href="#32-确定你的-public-继承塑模出-is-a（是一种）关系">#</a>32. 确定你的 public 继承塑模出 is-a（是一种）关系</h2>
<p>如果令 <code>class Derived</code> 以 public 继承自 <code>class Base</code>，这就是告诉编译器与读者，每个 Derived 对象同时也是一个 Base 对象，Derived 是 Base 的特殊化，而 Base 是 Derived 的一般化，Base 能派上用场的地方，Derived 一定也可以。因为<strong>每个 Derived 都 is-a（是一种） Base 对象</strong>，而反之不成立。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Person</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>把 Student 和 Person 分别代入上面的 Derived 和 Base，则很轻易地就能得到符合直觉的结论——每个 Student 都是 Person，而反之不一定。于是，综上所述，C++ 中，任何函数如果希望获得一个 <code>Person*</code> / <code>Person&amp;</code> 实参，也愿意接受一个 <code>Student*</code> / <code>Student&amp;</code> 对象。</p>
<p>当然，上述结论，<strong>仅仅</strong>针对 <strong>public 继承</strong>时成立。</p>
<blockquote>
<p>尽管如此，直觉往往会误导我们的设计——企鹅属于鸟类，但企鹅不会飞；正方形属于矩形，但矩形可以仅仅修改长或宽中的其中一个变量，正方形仅有<strong>边长</strong>这一个属性……许多继承可能接近事实真相，也可能不。我们要做的就是尽可能实现 <strong>is-a</strong> 这一特质。</p>
</blockquote>
<h2 id="33-避免遮掩继承而来的名称"><a class="header-anchor" href="#33-避免遮掩继承而来的名称">#</a>33. 避免遮掩继承而来的名称</h2>
<p>众所周知，当编译器遇到某个名称时，它会从内向外逐个作用域去查找是否有匹配的"东西"，因为内层作用域的名称会<strong>遮掩</strong>外层作用域的名称。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">double</span> x<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cin <span class="token operator">&gt;&gt;</span> x<span class="token punctuation">;</span> <span class="token comment">// 用的是 double x</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>在继承中亦是如此。当在派生类成员函数内指涉某个基类成员时，编译器很容易能找到，因为派生类继承了基类的所有东西，就好像派生类的作用域嵌套在基类作用域内一样。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>

 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token class-name">Derived</span><span class="token double-colon punctuation">::</span><span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>就像上面这串代码中，编译器看到 <code>Derived</code> 调用 <code>mf2()</code>，首先在 <code>Derived</code> 里找，然后去其所有基类中找，本例中为 <code>Base</code>。很幸运，找到了，如果没找到，还会继续向外到内含 <code>Base</code> 的那个命名空间，最后往 global 去找。</p>
<p>上面只是提供了一个简单的例子，下面这个才是我们真正想讨论的：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">int</span> x<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这很难不能称为一种💩的代码，但无关紧要，之前提到的<strong>名称遮掩规则</strong>并没有改变。因此 <code>Base::mf1(int)</code> 与 <code>Base::mf3(double)</code> 都被 <code>Derived::mf1()</code> 与 <code>Derived::mf3()</code> 掩盖了。换个角度来讲，<code>mf1(int)</code> 与 <code>mf3(double)</code> 并没有得到继承。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>

d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf1()</span>
d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! Derived::mf1() 遮掩了 Base::mf1(int)</span>
d<span class="token punctuation">.</span><span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Base::mf2()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf3()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! Derived::mf3() 遮掩了 Base::mf3(double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>不幸的是，我们通常会想继承重载函数，但上面这种继承又不继承的写法实际上是在破坏 is-a 关系。可以通过 using 声明达成目标。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>mf1<span class="token punctuation">;</span> <span class="token comment">// 让 Base 内名为 mf1 和 mf3 的所有东西</span>
  <span class="token keyword">using</span> Base<span class="token double-colon punctuation">::</span>mf3<span class="token punctuation">;</span> <span class="token comment">// 在 Derived 作用域内都可见，且 public</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在，继承机制正常运转。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">Derived d<span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>

d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf1()</span>
d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 调用 Base::mf1(int)</span>
d<span class="token punctuation">.</span><span class="token function">mf2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Base::mf2()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Derived::mf3()</span>
d<span class="token punctuation">.</span><span class="token function">mf3</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 调用 Base::mf3(double)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>可问题又产生了——我们只希望继承 <code>mf1()</code> 的无参版本！这在 public 继承下没有意义，因为破坏了 is-a 关系，但在 private 继承下值得讨论。既然 using 声明并不能满足要求，那我们干脆实现一个<strong>转发函数</strong>好了。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token class-name">Base</span><span class="token double-colon punctuation">::</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">mf3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">mf4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Derived d<span class="token punctuation">;</span>
<span class="token keyword">int</span> x<span class="token punctuation">;</span>

d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// OK! 调用 Base::mf1()</span>
d<span class="token punctuation">.</span><span class="token function">mf1</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// ERROR! Base::mf1(int) 被掩盖</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="34-区分接口继承和实现继承"><a class="header-anchor" href="#34-区分接口继承和实现继承">#</a>34. 区分接口继承和实现继承</h2>
<p>public 继承实际上由两部分组成：<strong>函数接口继承</strong>与<strong>函数实现继承</strong>。</p>
<p>基于 is-a，函数接口总是会被继承，毕竟如果某个函数可用于基类，那么必然可用于派生类。</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>声明一个 pure virtual 函数的目的是为了让派生类<strong>只</strong>继承<strong>接口</strong>；</p>
<blockquote>
<p>你必须 override，否则无法实例化，但我不干涉你怎么实现它。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>声明一个 impure virtual 函数的目的是为了让派生类继承<strong>接口和缺省实现</strong>；</p>
<blockquote>
<p>如果你不想或忘了 override，可以使用基类提供的缺省版本。</p>
</blockquote>
</li>
<li class="lvl-2">
<p>声明一个 non-virtual 函数的目的是为了让派生类继承<strong>接口和强制性实现</strong>；</p>
<blockquote>
<p>non-virtual 函数意味着不变性凌驾于特异性，所以其绝不该在派生类中被 override。</p>
</blockquote>
</li>
</ul>
<p>这三个函数之间的差异，使得我们需要精确指定希望派生类继承的东西：只继承接口，继承接口和缺省实现，还是继承接口和强制性实现。必须谨慎选择。或许能够避免犯下以下两个错误：</p>
<ol>
<li class="lvl-3">
<p>将所有函数声明为 non-virtual。这使得派生类没有空间进行特化工作；</p>
</li>
<li class="lvl-3">
<p>将所有函数声明为 virtual。但某些函数并不该在派生类中被 override，对这部分函数最好的做法是声明为 non-virtual；</p>
</li>
</ol>
<h2 id="35-考虑-virtual-函数以外的其他选择"><a class="header-anchor" href="#35-考虑-virtual-函数以外的其他选择">#</a>35. 考虑 virtual 函数以外的其他选择</h2>
<p>假设你正在写一个暴力砍杀类型的游戏，你打算为游戏内的人物设计一个继承体系，人物会因被伤害或其他因素而扣血。你因此决定提供一个成员函数 <code>healthValue()</code>，它会返回一个整数，表示人物的血量。由于不同的人物可能以不同的方式计算他们的血量，将 <code>healthValue()</code> 声明为 virtual 似乎是再明白不过的做法。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面想讨论一些其它代替方案。</p>
<ol>
<li class="lvl-3">
<p>通过 <strong>NVI</strong>(Non-Virtual Interface) 手法实现 <strong>Template Method 设计模式</strong>。该模式主张令 virtual 函数称为 private，然后通过一个称为 <strong>wrapper</strong> 的 public non-virtual 函数来调用它。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span>
    <span class="token comment">/* 事前准备 */</span>
    <span class="token keyword">int</span> retVal <span class="token operator">=</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 事后工作 */</span>
    <span class="token keyword">return</span> retValue<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">virtual</span> <span class="token keyword">int</span> <span class="token function">doHealthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span> <span class="token comment">// 允许 override</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>NVI 手法的一个优点在于，它确保在一个 virtual 函数调用前后完成一些工作。虽然它涉及在派生类中对 virtual 函数进行 override，但这仅仅影响"如何"被完成，而基类中的 wrapper 则决定了"何时"被完成。</p>
</li>
<li class="lvl-3">
<p>通过函数指针实现 <strong>Strategy 设计模式</strong>。该方案主张"人物血量计算与人物类型无关"，而是在构造函数中接受一个函数指针指向一个"血量计算"函数，通过调用该函数实现效果：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">defaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalFunc hcf <span class="token operator">=</span> defaultHealthCalc<span class="token punctuation">)</span>
   <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  HealthCalFunc healthFunc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这使得同一人物类型下不同实体也可以拥有不同"血量计算"函数，并且某人物的计算函数可以在运行时期变化，比如可以通过提供一个 <code>setHealthCalculator</code> 来替换"血量计算"函数。但缺点在于，如果"血量计算"所需信息为 non-public，那就比较危险，或许可能要适当降低封装性，比如提供一些 public 访问接口或将函数设为 friend。其优点是否足以弥补缺点，这是需要进行仔细考虑的。</p>
</li>
<li class="lvl-3">
<p>通过 <code>std::function</code> 实现 <strong>Strategy 设计模式</strong>。上面的函数指针本质上是一个<strong>可调用对象</strong>。C++11 已经将所有的可调用对象进行了统一，推出了新特性 <code>std::function</code>（见<a href="../../c/c-function">此文</a>），那用此新特性进行替换，提高了更多的实现弹性，不是吗？只要函数签名与需求端兼容，那么就是可行的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">GameCharacter</span><span class="token punctuation">;</span>
<span class="token keyword">int</span> <span class="token function">defaultHealthCalc</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span> gc<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">GameCharacter</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> HealthCalcFunc <span class="token operator">=</span> std<span class="token double-colon punctuation">::</span>function<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter <span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token operator">&gt;</span><span class="token punctuation">;</span>
  <span class="token keyword">explicit</span> <span class="token function">GameCharacter</span><span class="token punctuation">(</span>HealthCalFunc hcf <span class="token operator">=</span> defaultHealthCalc<span class="token punctuation">)</span>
   <span class="token operator">:</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span>hcf<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">int</span> <span class="token function">healthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">healthFunc</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  HealthCalFunc healthFunc<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>那么，接下来表演个戏法：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 函数</span>
<span class="token keyword">short</span> <span class="token function">calcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 仿函数</span>
<span class="token keyword">struct</span> <span class="token class-name">HealthCalculator</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> <span class="token keyword">operator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 成员函数</span>
<span class="token keyword">class</span> <span class="token class-name">GameLevel</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">float</span> <span class="token function">calcHealth</span><span class="token punctuation">(</span><span class="token keyword">const</span> GameCharacter<span class="token operator">&amp;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">// 两个人物类型</span>
<span class="token keyword">class</span> <span class="token class-name">EvilBadGuy</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">GameCharacter</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">EyeCandyCharacter</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">GameCharacter</span></span> <span class="token punctuation">{</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

GameLevel currentLevel<span class="token punctuation">;</span>

EvilBadGuy <span class="token function">ebg1</span><span class="token punctuation">(</span>calcHealth<span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token comment">// 1. 使用函数计算</span>

EyeCandyCharacter <span class="token function">ecc1</span><span class="token punctuation">(</span><span class="token function">HealthCalculator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 2. 使用仿函数计算</span>

EvilBadguy <span class="token function">ebg2</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>GameLevel<span class="token double-colon punctuation">::</span>health<span class="token punctuation">,</span>      <span class="token comment">// 3. 使用某个类的成员函数计算</span>
                          currentLevel<span class="token punctuation">,</span>
                          std<span class="token double-colon punctuation">::</span>placeholder<span class="token double-colon punctuation">::</span>_1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>传统 <strong>Strategy 设计模式</strong>。它会将函数做成一个分离的继承体系中的 virtual 成员函数。构造函数接受一个 <code>HealthCalcFunc</code> 类指针，通过传入不同派生类地址实现效果。</p>
</li>
</ol>
<h2 id="36-绝不-override-继承来的-non-virtual-函数"><a class="header-anchor" href="#36-绝不-override-继承来的-non-virtual-函数">#</a>36. 绝不 override 继承来的 non-virtual 函数</h2>
<p>记住就行了。</p>
<h2 id="37-绝不重新定义继承来缺省参数值"><a class="header-anchor" href="#37-绝不重新定义继承来缺省参数值">#</a>37. 绝不重新定义继承来缺省参数值</h2>
<p>基于上条，这里就只考虑带缺省参数的 virtual 函数。这种情况下，本条款成立的理由就非常直接而明确了：virtual 函数为动态绑定，而缺省参数值却是静态绑定。那么在用基类指针指向派生类时，指针的静态类型必然为基类，则就会出现"调用一个定义于派生类的虚函数，却使用了基类指定的缺省参数值"这一情况。这也就直接宣告派生类对缺省值的重新定义无效化了。</p>
<h2 id="38-通过复合塑模出-has-a-或-根据某物实现出"><a class="header-anchor" href="#38-通过复合塑模出-has-a-或-根据某物实现出">#</a>38. 通过复合塑模出 has-a 或"根据某物实现出"</h2>
<p>当某种类型的对象内含另一种类型的对象，这就是复合关系。如同 public 含有 is-a 意义一样，复合关系也有着 has-a（有一个）或"根据某物实现出"的意义。就比如想实现一个 set 数据结构，复用 <code>std::set</code> 是最方便的，但是其为了提高时间效率，提高了空间开销，每个元素额外有三个指针的空间占用。加一条限制：我们希望空间比时间重要。那么复用 <code>std::set</code> 就并不可取。于是在万千种替代方法中，随机挑选了一个用 <code>std::list</code> 实现，决定复用它。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Set</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> std<span class="token double-colon punctuation">::</span><span class="token class-name">list</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>看起来很美好，但实际上这违背了 is-a 准则。<code>std::list</code> 允许重复元素，而我们想实现的 set 不允许，该冲突决定了这一设计是糟糕的——public 继承并不适合这种情况。正确的做法是，令 <code>std::list</code> 作为我们 <code>Set</code> 类的底层数据结构，用于存放数据，即根据 <code>std::list</code> 实现出，就像这样：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Set</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">bool</span> <span class="token function">member</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">insert</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> item<span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>size_t <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>list<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span> rep<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="39-明智而审慎地使用-private-继承"><a class="header-anchor" href="#39-明智而审慎地使用-private-继承">#</a>39. 明智而审慎地使用 private 继承</h2>
<p>public 继承可以实现 is-a 语义，这是前文讨论过的。那么 private 继承呢？首先要明确几点规则，如果一个类之间的继承关系为 private，那么：</p>
<ol>
<li class="lvl-3">
<p>编译器不会将一个派生类对象转换为基类对象，也就是无法用基类指针/引用去指向；</p>
</li>
<li class="lvl-3">
<p>基类的所有成员在派生类中均变为 private，纵使在基类中原本是 public 或 protected；</p>
</li>
<li class="lvl-3">
<p>意味着"根据某物实现出"——使用 private 继承的用意是为了采用某些基类特性，而不是因为基类和派生类存在任何观念上的关系（如 is-a），这纯粹是一种实现技术；</p>
</li>
</ol>
<p>第三个事实令人感到不安，因为复合关系也能实现这一层语义。如果非得选一个，还是<strong>复合关系更胜一筹</strong>，因为复合更容易理解，只有必要时采用 private 继承。何为必要？即需要访问基类 protected 成员，或需要 override virtual 函数时。</p>
<h2 id="40-明智而审慎地使用多重继承"><a class="header-anchor" href="#40-明智而审慎地使用多重继承">#</a>40. 明智而审慎地使用多重继承</h2>
<p>关于多继承的事，请看<a href="../../c/c-oop/#%E7%BB%A7%E6%89%BF"><strong>此文</strong></a>。</p>
<p>多重继承容易引发歧义，且带来了虚继承的需求。虚继承还会带来一系列成本，除非虚基类不带任何数据。</p>
<p>但多重继承也不是一无是处，在 public 继承某个接口类，并且 private 继承某个协助类时才发挥出正当用途。</p>
<h2 id="41-了解隐式接口和编译期多态"><a class="header-anchor" href="#41-了解隐式接口和编译期多态">#</a>41. 了解隐式接口和编译期多态</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 隐式接口</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">doProcessing</span><span class="token punctuation">(</span>T<span class="token operator">&amp;</span> w<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>w<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">&amp;&amp;</span> w <span class="token operator">!=</span> someNastyWidget<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    T <span class="token function">temp</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span><span class="token function">normalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    temp<span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>w 必须支持在 <strong>template</strong> 中指定需要 w 进行执行的操作，这里是 <code>size()</code>，<code>operator!=()</code>，<code>normalize()</code> 和 <code>swap()</code>，还有一个拷贝构造函数。如果某个类型 <code>T</code> 不支持这些功能，那么编译失败。这些就是所谓的<strong>隐式接口</strong>。</p>
<p>而一旦支持了，就会根据 <code>T</code> 的不同，调用不同类型的这些函数。这种实例化在编译期决定，就是所谓的<strong>编译期多态</strong>。</p>
<p>而对于 <strong>class</strong> 而言，接口都是<strong>显式</strong>的，以函数签名为中心，通过 virtual 函数实现<strong>运行时多态</strong>。</p>
<h2 id="42-了解-typename-的双重意义"><a class="header-anchor" href="#42-了解-typename-的双重意义">#</a>42. 了解 typename 的双重意义</h2>
<p>在 template 中，<code>typename</code> 和 <code>class</code> 具有同样的含义。就比如下面这两种声明方式，其实是没有区别的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>然而在这两者并不总是等价，有时候我们不得不用 <code>typename</code>。比如下面一个函数模板，接受一个 STL 容器作为模板参数，该容器内持有的对象可被赋值为 int，函数功能是打印容器内的第二个元素。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    C<span class="token double-colon punctuation">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token operator">++</span>iter<span class="token punctuation">;</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token operator">*</span>iter<span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> value<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>变量 <code>iter</code> 的的类型为 <code>const_iterator</code>，具体是什么取决于传入的模板参数 <code>C</code>。这种依赖于某个模板参数的名称称为<strong>从属名称</strong>，像 <code>C::const_iterator</code> 这种存在嵌套关系的又进一步被称为<strong>嵌套从属名称</strong>，同理还有 <code>std::vector&lt;C&gt;</code> 这样的。而 <code>int</code> 则为<strong>非从属名称</strong>。</p>
<p>如果传入的参数恰好是内含该类型迭代器的 STL 容器，那万事大吉，函数正常运转。但如果 <code>const_iterator</code> 是类型 <code>C</code> 的一个成员变量呢？编译器此时就会解析错误，毕竟不能把一个变量作为类型吧。事实上，在知道 <code>C</code> 是什么之前，没有任何方法知道 <code>C::const_iterator</code> 是什么东西，C++ 提供了一个规则来消除歧义：如果解析器在模板中遇到一个嵌套从属名称，除非我们明确指出这是一个类型，否则编译器就会默认它不是。也就是说，上面那份代码中的第四行，<code>C::const_iterator</code> 被认为是"非类型"。</p>
<p>此时我们发现应该明确指出这是一个类型，做法很简单，只要在前面加上一个关键字 <code>typename</code> 即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">C</span><span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">print2nd</span><span class="token punctuation">(</span><span class="token keyword">const</span> C<span class="token operator">&amp;</span> container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">typename</span> <span class="token class-name">C</span><span class="token double-colon punctuation">::</span>const_iterator <span class="token function">iter</span><span class="token punctuation">(</span>container<span class="token punctuation">.</span><span class="token function">begin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>然而这个做法也有例外，即，<code>typename</code> 不可以出现在基类继承列表中的嵌套从属名称前，也不可以在成员初始化列表中作为基类的修饰符，比如：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token class-name">Nested</span></span> <span class="token punctuation">{</span>         <span class="token comment">// 继承列表，不允许 typename</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">DErived</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">Nested</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 初始化列表，不允许 typename</span>
    <span class="token keyword">typename</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>Nested temp<span class="token punctuation">;</span>              <span class="token comment">// 允许，且必须</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="43-学习处理模板化基类内的名称"><a class="header-anchor" href="#43-学习处理模板化基类内的名称">#</a>43. 学习处理模板化基类内的名称</h2>
<p>如果一个派生类模板继承自基类模板，并且派生类试图调用基类中的函数，那么极有可能无法通过编译：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// ERROR!</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这是因为，在 Template C++ 中，任何一个模板均存在被<strong>特化</strong>的可能性，而那个特化版本可能并不提供和一般性 template 相同的接口。也就是说我们可以实现一个 <code>Base&lt;int&gt;</code>，它不包含 <code>foo()</code> 这个函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Derived<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> d<span class="token punctuation">;</span>
d<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment">// ERROR! Base&lt;int&gt; 不存在函数 foo()</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>考虑到这种可能性，编译器在遭遇派生类模板定义式时，就不知道它继承自怎样的基类，既然如此，也就无法知道这个类里拥有怎样的成员，具体点说，无法知道这个类是否拥有函数 <code>foo()</code>。因此它往往拒绝在模板化基类内寻找继承来的名称。</p>
<p>幸运的是，我们有三种办法使得派生类模板能成功调用基类模板。</p>
<ol>
<li class="lvl-3">
<p>在基类函数前加 <code>this-&gt;</code></p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 假设 foo() 被继承</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>使用 using 声明，将基类名称引入派生类中</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> Base<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>foo<span class="token punctuation">;</span>   <span class="token comment">// 告诉编译器假设 foo() 位于 Base 内</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 假设 foo() 被继承</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p>显式指明被调用函数的作用域</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Derived</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">/* ... */</span>
    <span class="token class-name">Base</span><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// OK! 假设 foo() 被继承</span>
    <span class="token comment">/* ... */</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这种做法最糟糕，因为一旦 <code>foo()</code> 是个 virtual 函数，那么就完全无法实现多态了。</p>
</li>
</ol>
<p>上述做法仅仅是提供一个假设，而一旦实例化了一个 <code>Derived&lt;int&gt;</code> 对象，那么一切依然照旧——无法通过编译。</p>
<h2 id="44-将与参数无关的代码抽离-template"><a class="header-anchor" href="#44-将与参数无关的代码抽离-template">#</a>44. 将与参数无关的代码抽离 template</h2>
<p>template 是节省时间和避免代码重复的奇技淫巧。但如果不小心，使用 template 也可能会导致代码膨胀，即实例化时，产生多个类和多个函数，造成重复的二进制代码。所以任何 template 代码都不该与某个造成膨胀的参数产生耦合关系。</p>
<p>因<strong>非类型模板参数</strong>而造成的代码膨胀，往往可以通过函数参数或类成员变量替换的方式来<strong>消除</strong>，但会因此将编译期行为迁移到运行期。</p>
<p>因<strong>类型参数</strong>造成的代码膨胀，可以让带有完全相同二进制表述的实例类型共享实现码来<strong>降低</strong>。</p>
<p>比如希望实现某个矩阵，并支持求逆运算：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t n<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  T data<span class="token punctuation">[</span>n<span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

SquareMatrix<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token operator">&gt;</span> m1<span class="token punctuation">;</span>
SquareMatrix<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token operator">&gt;</span> m2<span class="token punctuation">;</span>

m1<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
m2<span class="token punctuation">.</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两份实例化了的对象，产生了两份除了常量 5 和 10 不同，其它完全相同的函数。这就是一个典型的代码膨胀例子。为了消除这一膨胀行为，进行如下修改：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SquareMatrixBase</span> <span class="token punctuation">{</span>
 <span class="token keyword">protected</span><span class="token operator">:</span>
  <span class="token function">SquareMatrixBase</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t n<span class="token punctuation">,</span> T<span class="token operator">*</span> pMem<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">size</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">pData</span><span class="token punctuation">(</span>pMem<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">void</span> <span class="token function">setDataPtr</span><span class="token punctuation">(</span>T<span class="token operator">*</span> ptr<span class="token punctuation">)</span> <span class="token punctuation">{</span> pData <span class="token operator">=</span> ptr<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size matrixSize<span class="token punctuation">)</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">;</span>
  T<span class="token operator">*</span> pData<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>size_t n<span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SquareMatrix</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">private</span> <span class="token class-name">SquareMatrixBase</span><span class="token operator">&lt;</span><span class="token class-name">T</span><span class="token operator">&gt;</span></span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> SquareMatrixBase<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token double-colon punctuation">::</span>invert<span class="token punctuation">;</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">SquareMatrix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token generic-function"><span class="token function">SquareMatrixBase</span><span class="token generic class-name"><span class="token operator">&lt;</span>T<span class="token operator">&gt;</span></span></span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">void</span> <span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token operator">-&gt;</span><span class="token function">invert</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  T data<span class="token punctuation">[</span>n<span class="token operator">*</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>基类 <code>SquareMatrixBase</code> 中放置了一个带参数的 <code>invert()</code>，不同的是它只对矩阵元素对象的<strong>类型</strong>进行参数化，而不对矩阵的尺寸参数化，因此对于某给定类型，所有矩阵共享唯一一个 <code>SquareMatrixBase</code> 类，也因此共享唯一一个 <code>invert()</code>。</p>
<h2 id="45-运用成员函数模板接受所有兼容类型"><a class="header-anchor" href="#45-运用成员函数模板接受所有兼容类型">#</a>45. 运用成员函数模板接受所有兼容类型</h2>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">SmartPtr</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">U</span><span class="token operator">&gt;</span>
  <span class="token function">SmartPtr</span><span class="token punctuation">(</span><span class="token keyword">const</span> SmartPtr<span class="token operator">&lt;</span>U<span class="token operator">&gt;</span><span class="token operator">&amp;</span> other<span class="token punctuation">)</span>      <span class="token comment">// 未声明为 explicit 是刻意的，因为原始指针间的转换是隐式转换</span>
    <span class="token operator">:</span> <span class="token function">heldPtr</span><span class="token punctuation">(</span>other<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>  <span class="token comment">// 无需写出转型动作，即支持 Smart&lt;Base&gt; pBase = &amp;d; 这样的写法</span>
                                          <span class="token comment">// 仅当存在隐式转换 U-&gt;T 时编译才通过</span>
  T<span class="token operator">*</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> heldPtr<span class="token punctuation">;</span> <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  T<span class="token operator">*</span> heldPtr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>SmartPtr&lt;Base&gt;</code> 与 <code>SmartPtr&lt;Derived&gt;</code> 是两种完全不同的类型，无法通过后者对前者进行拷贝构造/赋值，尽管相应的裸指针是拥有这种转换能力的。通过定义<strong>构造函数模板</strong>，上述转型得以实现。这种构造函数又称<strong>泛化拷贝构造函数</strong>。而这种函数的出现并不会替代正常拷贝构造函数的地位，如果没有声明，编译器依然会默认生成一个 <code>SmartPtr(const SmartPtr&amp;)</code> 来，所以为了面面俱到，必须同时声明泛化版本的和"正常"版本的拷贝构造函数。相同规则也适用于<strong>赋值</strong>。</p>
<h2 id="46-需要类型转换时请为模板定义非成员函数"><a class="header-anchor" href="#46-需要类型转换时请为模板定义非成员函数">#</a>46. 需要类型转换时请为模板定义非成员函数</h2>
<p><a href="#24-%E8%8B%A5%E6%89%80%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%86%E9%9C%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E8%AF%B7%E4%B8%BA%E6%AD%A4%E9%87%87%E7%94%A8-non-member-%E5%87%BD%E6%95%B0"><strong>条款 24</strong></a> 讨论过为什么惟有 non-member 函数才有能力"在所有实参身上实施院式类型转换"，该条款并以 <code>Rational</code> 类的 <code>operator*()</code> 函数为例。本条款将对该例子进行扩充——模板化。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
  <span class="token keyword">const</span> T <span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> T <span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>

Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// ERROR! 无法通过 2 来生成一个 Rational&lt;int&gt; 对象</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>推导 <code>oneHalf</code> 并不困难，然而，编译器并没有如此强大的能力，仅根据 <code>2</code> 来进行模板实参推导，因为规则是<strong>绝不</strong>将通过构造函数而发生的隐式类型转换纳入考虑。这样的转换在函数调用过程中确实被使用了，但在能够调用一个函数之前，首先必须知道那个函数存在，而为此又必须先为相关的函数模板推导出参数类型，然后才能将适当的函数实例化。</p>
<p>而只需要在类模板中用 <code>friend</code> 指涉某个特定函数（即 <code>operator*</code>）即可应对挑战。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token function">Rational</span><span class="token punctuation">(</span><span class="token keyword">const</span> T<span class="token operator">&amp;</span> numerator <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span>
           <span class="token keyword">const</span> T<span class="token operator">&amp;</span> denominator <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* ... */</span> <span class="token punctuation">}</span>
  <span class="token keyword">const</span> T <span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> T <span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span><span class="token punctuation">;</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                                   <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> Rational<span class="token operator">&lt;</span>T<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
<span class="token punctuation">{</span><span class="token comment">/* ... */</span><span class="token punctuation">}</span>

Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">oneHalf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Rational<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> result <span class="token operator">=</span> oneHalf <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span> <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>现在对 <code>operator*</code> 的混合式调用可以通过编译了，因为当对象 <code>oneHalf</code> 被声明为一个 <code>Rational&lt;int&gt;</code> 时，相应的类被实例化，同时友元函数 <code>operator*(const Rational&lt;int&gt;, const Rational&lt;int&gt;)</code> 也就被自动声明出来。后者身为一个函数而非函数模板，因此编译器可在调用它时使用隐式转换函数，而这便是混合式调用之所以成功的原因。但这个函数虽然声明于类内，却并没有被定义——既然我们声明了一个函数，那就有责任定义这个函数！最简单可行的办法就是将函数定义式直接写到类内，并令其调用一个辅助函数：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span> <span class="token keyword">class</span> <span class="token class-name">Rational</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token function">doMultiply</span><span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span> <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token function">Rational</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">numerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
                  lhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> rhs<span class="token punctuation">.</span><span class="token function">denominator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">T</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">Rational</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token comment">/* ... */</span>
  <span class="token keyword">friend</span> <span class="token keyword">const</span> Rational <span class="token keyword">operator</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> lhs<span class="token punctuation">,</span>
                                   <span class="token keyword">const</span> Rational<span class="token operator">&amp;</span> rhs<span class="token punctuation">)</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">doMutiply</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">/* ... */</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="47-请使用-traits-classes-表现类型信息"><a class="header-anchor" href="#47-请使用-traits-classes-表现类型信息">#</a>47. 请使用 traits classes 表现类型信息</h2>
<p>STL 里使用 <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_15730877/article/details/117482541"><strong>iterator_traits</strong></a> 来表达迭代器的信息，包含迭代器类型所属(iterator_category)，所指对象类型(value_type)，迭代器间距离(difference_type)，所指内容指针(pointer)，所指内容引用(reference)。根据这些信息，就能为算法提供深度优化。这些信息在编译期可用，通过 template 和特化完成实现，并有可能在编译期对类型执行 if-else 测试。</p>
<h2 id="48-认识模板元编程"><a class="header-anchor" href="#48-认识模板元编程">#</a>48. 认识模板元编程</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/137853957"><strong>模板元编程</strong></a>的优点在于，其执行于编译期，故可以在编译期侦测出一些原本运行时才能找出的错误，并且降低了运行时长、可执行文件大小与内存需求，但劣势很明显，编译时期变长了许多。</p>
<h2 id="49-了解-new-handler-的行为"><a class="header-anchor" href="#49-了解-new-handler-的行为">#</a>49. 了解 new-handler 的行为</h2>
<p>当 <code>operator new</code> 抛出异常以反映一个未获满足的内存需求之前，它会先调用一个错误处理函数，即 <code>new-handler</code>，定义为一个 <code>void(*)()</code> 类型的函数指针。我们可以通过 <code>set_new_handler()</code> 函数来自定义这个处理函数。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 已声明于 &lt;new&gt; 中的代码</span>
<span class="token keyword">namespace</span> std <span class="token punctuation">{</span>
  <span class="token keyword">using</span> new_handler <span class="token operator">=</span> <span class="token keyword">void</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// main.cpp</span>
<span class="token comment">/* ... */</span>
<span class="token keyword">void</span> <span class="token function">outOfMem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>cerr <span class="token operator">&lt;&lt;</span> <span class="token string">"无法分配足够内存\n"</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>outOfMem<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> <span class="token operator">*</span>pBigDataArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">100000000L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>当 <code>operator new</code> 无法分配足够内存空间时，它会反复调用 <code>new-handler</code> 函数（尽管在上面代码中调用第一次就会先输出一段信息，然后 <code>abort()</code> 终止），直到找到足够内存。因此，一个设计良好的 new-handler 函数必须做以下事情：</p>
<ol>
<li class="lvl-3">
<p><strong>让更多内存可被使用</strong>。一个做法是，程序一开始就分配一大块内存，当 <code>new-handler</code> 第一次被调用时，将那块内存还给程序；</p>
</li>
<li class="lvl-3">
<p><strong>安装另一个 <code>new-handler</code></strong>。使用其它能取得更多可用内存的 <code>new-handler</code> 通过 <code>set_new_handler()</code> 代替现有的，或者修改自身行为，比如通过修改一些 <code>static</code> / <code>global</code> 数据来影响行为；</p>
</li>
<li class="lvl-3">
<p><strong>卸载 <code>new-handler</code></strong>。一旦上面的策略不可行，则需要将 <code>nullptr</code> 传给 <code>set_new_handler()</code>，此时 <code>operator new</code> 会在内存分配失败时抛出异常；</p>
</li>
<li class="lvl-3">
<p><strong>抛出 <code>bad_alloc</code> 或其派生类的异常</strong>；</p>
</li>
<li class="lvl-3">
<p><strong>不返回</strong>。通常调用 <code>std::abort()</code> 或 <code>std::exit()</code>；</p>
</li>
</ol>
<p>有时候我们希望根据分配对象的类型不同而调用不同的 <code>new_handler</code>，只需要令每个类提供一个 <code>set_new_handler()</code> 和 <code>operator new</code> 即可。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Widget</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler <span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
 <span class="token keyword">private</span><span class="token operator">:</span>
  <span class="token keyword">static</span> std<span class="token double-colon punctuation">::</span>new_handler curHandler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>new_handler Widget<span class="token double-colon punctuation">::</span>curHandler <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
<span class="token comment">// 存储后返回原来的 new-handler，与  std::set_new_handler 做法无异。仅改变局部 new-handler</span>
std<span class="token double-colon punctuation">::</span>new_handler <span class="token class-name">Widget</span><span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler p<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>new_handler oldHandler <span class="token operator">=</span> curHandler<span class="token punctuation">;</span>
  curHandler <span class="token operator">=</span> p<span class="token punctuation">;</span>
  <span class="token keyword">return</span> oldHandler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>其中，<code>Widget::operator new</code> 做了以下事情：</p>
<ol>
<li class="lvl-3">
<p>调用 <code>std::set_new_handler()</code>，告知 <code>Widget</code> 的错误处理函数，从而将 <code>Widget</code> 的 <code>new-handler</code> 安装为全局 <code>new-handler</code>；</p>
</li>
<li class="lvl-3">
<p>调用全局 <code>operator new</code></p>
<ul class="lvl-2">
<li class="lvl-5">
<p>如果分配失败，调用 <code>Widget</code> 的 <code>new-handler</code>。如果全局 <code>operator new</code> 最终无法分配足够内存，会抛出 <code>std::bad_alloc</code> 异常。此时 <code>Widget</code> 的 <code>operator new</code> 必须恢复原本的全局 <code>new-handler</code>，再传播该异常；</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">NewHandlerHolder</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">explicit</span> <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>new_handler nh<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">handler</span><span class="token punctuation">(</span>nh<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 取得原先 new-handler</span>
  <span class="token operator">~</span><span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>handler<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>         <span class="token comment">// 释放当前</span>

  <span class="token function">NewHandlerHolder</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewHandlerHolder<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  NewHandlerHolder<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> NewHandlerHolder<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  std<span class="token double-colon punctuation">::</span>new_handler handler<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>这样就使得 <code>Widget::operator new</code> 的实现非常简单：</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> Widget<span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  NewHandlerHolder <span class="token function">h</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">set_new_handler</span><span class="token punctuation">(</span>currentHandler<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token double-colon punctuation">::</span><span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li class="lvl-5">
<p>反之，<code>Widger::operator new</code> 返回一个指向分配所得的指针。<code>Widget::~Widget()</code> 会自动将全局 <code>new-handler</code> 恢复。</p>
</li>
</ul>
</li>
</ol>
<h2 id="50-了解-new-和-delete-的合理替换时机"><a class="header-anchor" href="#50-了解-new-和-delete-的合理替换时机">#</a>50. 了解 new 和 delete 的合理替换时机</h2>
<p>为何要替换呢？总的来说有以下理由：</p>
<ol>
<li class="lvl-3">
<p>检测运行时错误；</p>
</li>
<li class="lvl-3">
<p>强化效能；</p>
</li>
<li class="lvl-3">
<p>收集使用上的统计数据；</p>
</li>
<li class="lvl-3">
<p>增加分配和释放的速度；</p>
</li>
<li class="lvl-3">
<p>降低缺省内存管理器带来的额外空间开销；</p>
</li>
<li class="lvl-3">
<p>弥补缺省分配器中的非最佳齐位；</p>
</li>
<li class="lvl-3">
<p>将相关对象成簇集中；</p>
</li>
<li class="lvl-3">
<p>获得非传统的行为；</p>
</li>
</ol>
<h2 id="51-编写-new-和-delete-时需固守常规"><a class="header-anchor" href="#51-编写-new-和-delete-时需固守常规">#</a>51. 编写 new 和 delete 时需固守常规</h2>
<p><code>operator new</code> 应该内含一个无限循环，在其中尝试分配内存，若无法满足，则调用 <code>new-handler</code>。它需要有能力处理 0 bytes 的分配申请。类中的重载版本还应该处理比正确大小更大的错误申请。</p>
<p><code>operator delete</code> 应该不处理任何 <code>nullptr</code> 的释放申请。同样的，类中的重载版本还应该处理比正确大小更大的错误申请。</p>
<h2 id="52-写了-placement-new-也要写-placement-delete"><a class="header-anchor" href="#52-写了-placement-new-也要写-placement-delete">#</a>52. 写了 placement new 也要写 placement delete</h2>
<p>如果一个 placement new 没有 placement delete，那么当 new 的内存分配动作需要取消并恢复原状时就没有任何 delete 会被调用。因此，为了消除这种内存泄漏，有必要在写了 placement new 的同时声明一个 placement delete。</p>
<p>btw，如<a href="#33-%E9%81%BF%E5%85%8D%E9%81%AE%E6%8E%A9%E7%BB%A7%E6%89%BF%E8%80%8C%E6%9D%A5%E7%9A%84%E5%90%8D%E7%A7%B0"><strong>条款 33</strong></a> 讨论的那样，我们必须小心让 <code>operator new</code> 掩盖外层作用域的其它版本。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">class</span> <span class="token class-name">Base</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span>ostream<span class="token operator">&amp;</span> logstram<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 掩盖 global operator new</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">Derived</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">Base</span></span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">static</span> <span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t size<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 掩盖 Base::operator new</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

Base<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> Base<span class="token punctuation">;</span>                   <span class="token comment">// ERROR! normal operator new 被掩盖</span>
Base<span class="token operator">*</span> pb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">Base</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>cerr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// OK!</span>
Derived<span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>clog<span class="token punctuation">)</span> Derived<span class="token punctuation">;</span> <span class="token comment">// ERROR! Base::operator new 被掩盖</span>
Derived<span class="token operator">*</span> pd <span class="token operator">=</span> <span class="token keyword">new</span> Derived<span class="token punctuation">;</span>             <span class="token comment">// OK!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决方案为：对于撰写内存分配函数，需要在缺省情况下，在全局作用域内提供以下所有形式的 <code>operator new</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// normal new</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">void</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>                  <span class="token comment">// placement new</span>
<span class="token keyword">void</span><span class="token operator">*</span> <span class="token keyword">operator</span> <span class="token keyword">new</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>size_t<span class="token punctuation">,</span> <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>nothrow_t<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>  <span class="token comment">// nothrow new</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>如果在类内声明任何 <code>operator new</code>，它会遮掩上述这些标准形式。除非你就是要阻止用户使用这些形式，否则请确保它们在你所生成的任何自定义 <code>operator new</code> 可用。对于每一个可用的 <code>operator new</code>，也请确定提供对应的 <code>operator delete</code>。如果希望这些函数有着平常的行为，只要令自定义重载版本调用全局版本即可。</p>
<p>一个简单做法是，建立一个基类，内含所有调用全局版本的 new 和 delete。凡是想以自定义形式扩充的用户，可利用继承机制与 <code>using</code> 声明取得标准形式。</p>
<h2 id="53-不要轻忽编译器的警告"><a class="header-anchor" href="#53-不要轻忽编译器的警告">#</a>53. 不要轻忽编译器的警告</h2>
<p>一旦从某个特定编译器的警告信息中获得经验，你将学会了解，不同的信息意味什么——那往往和它们"看起来"的意义十分不同！尽管一般认为，写出一个在最高警告级别下也无任何警告信息的程序最是理想，然而一旦有了上述的经验和对警告信息的深刻理解，你倒是可以选择忽略某些警告信息。不管怎样说，在你打发某个警告信息之前，请确定你了解它意图说出的精确意义。这很重要。</p>
<p>记住，警告信息天生和编译器相依，不同的编译器有不同的警告标准。所以，草率编程然后倚赖编译器为你指出错误，并不可取。</p>
<h2 id="54-让自己熟悉包括-TR1-在内的标准程序库"><a class="header-anchor" href="#54-让自己熟悉包括-TR1-在内的标准程序库">#</a>54. 让自己熟悉包括 TR1 在内的标准程序库</h2>
<p>所有功能都被 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/11"><strong>C++11</strong></a> 囊括。</p>
<h2 id="55-让自己熟悉-Boost"><a class="header-anchor" href="#55-让自己熟悉-Boost">#</a>55. 让自己熟悉 Boost</h2>
<p>大部分都被 <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/11"><strong>C++11</strong></a> 囊括。</p>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">这个人太懒了，都不想加标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/c/c-mutable/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="C++ の 可变说明符(Mutable)">
                        
                        <span class="card-title">C++ の 可变说明符(Mutable)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            mutable 意为可变的，可以在非引用非常量非静态数据成员的声明中出现，允许被常量类对象修改。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-03-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/c/c-exception/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="C++ の 异常处理(Exception)">
                        
                        <span class="card-title">C++ の 异常处理(Exception)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            异常，在操作系统中指的是指令内部出现的"内中断"，如除数为零，地址越界等。这些情况在程序中也时有发生，C++ 为了应对偶发的程序异常事件，引入了异常处理机制。其基于三个关键字：try，throw 与 catch。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-03-01
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h1, h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Leager</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "8";
                        var startDate = "1";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Leager-zju" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1004729740@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1004729740" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1004729740" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "http://Leager-zju.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <script type="text/javascript">
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                document.title = '你会有一天后悔';
            } else {
                document.title = '欢迎来到 G8 北海道 洞爷湖 高峰会 博物馆';
            }
        });
    </script>

</body>

</html>
