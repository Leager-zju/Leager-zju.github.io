<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="现代图形学入门（GAMES101）の 笔记, 没什么看头的地方">
    <meta name="description" content="&amp;gt;&amp;gt;&amp;gt;课程主页传送门&amp;lt;&amp;lt;&amp;lt;

变换(Transformation)
变换分为两种：Modeling（平移、旋转、缩放等）和 Viewing（3D 投影到
2D）
模型变换(Modeling)
先讨论二维的">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>现代图形学入门（GAMES101）の 笔记 | 没什么看头的地方</title>
    <link rel="icon" type="image/png" href="/dt.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/comment_bg.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">没什么看头的地方</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/comment_bg.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">没什么看头的地方</div>
        <div class="logo-desc">
            
            【数据删除】
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Leager-zju" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Leager-zju" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">现代图形学入门（GAMES101）の 笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">这个人太懒了，都不想加标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Note/" class="post-category">
                                Note
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2024-03-31
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p><a target="_blank" rel="noopener" href="https://sites.cs.ucsb.edu/~lingqi/teaching/games101.html">&gt;&gt;&gt;课程主页传送门&lt;&lt;&lt;</a></p>
<span id="more"></span>
<h2 id="变换transformation">变换(Transformation)</h2>
<p>变换分为两种：Modeling（平移、旋转、缩放等）和 Viewing（3D 投影到
2D）</p>
<h3 id="模型变换modeling">模型变换(Modeling)</h3>
<p>先讨论二维的情况。</p>
<blockquote>
<p>在二维平面图上，所有的 modeling 都是基于原点 <span class="math inline">\((0, 0)\)</span> 的。</p>
</blockquote>
<h4 id="缩放scale">缩放(Scale)</h4>
<p>对于原图像上任意一个点 <span class="math inline">\((x,
y)\)</span>，其缩放后的坐标为 <span class="math inline">\((x',
y') = (s_x·x, s_y·y)\)</span>。其中 <span class="math inline">\(s_x,
s_y\)</span> 分别表示 <span class="math inline">\(\mathbf{x},
\mathbf{y}\)</span> 方向上的缩放倍率。</p>
<p>用线性代数的方式表示就是：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'
\end{matrix}\right)
=
\left(\begin{matrix}
s_x &amp; 0\\
0 &amp; s_y
\end{matrix}\right)
\left(\begin{matrix}
x\\ y
\end{matrix}\right)
\]</span></p>
<h4 id="镜像reflection">镜像(Reflection)</h4>
<p>考虑下面这张图</p>
<p><img src="reflection.png" style="zoom:50%"></p>
<p>我们也可以得到下面这样一个线性表达式：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'
\end{matrix}\right)
=
\left(\begin{matrix}
-1 &amp; 0\\
0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\\ y
\end{matrix}\right)
\]</span></p>
<h4 id="旋转rotate">旋转(Rotate)</h4>
<p>考虑下面这张图：</p>
<p><img src="rotate.png" style="zoom:70%"></p>
<p>我们可以采用特值法，<span class="math inline">\((1,
0)\rightarrow(\cos{\alpha}, \sin{\alpha})\quad(0,
1)\rightarrow(-\sin{\alpha}, \cos{\alpha})\)</span>，代入 <span class="math inline">\(\mathbf{a'}=\mathbf{M}\mathbf{a}\)</span>
求解，从而得到：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'
\end{matrix}\right)
=
\left(\begin{matrix}
\cos{\alpha} &amp; -\sin{\alpha}\\
\sin{\alpha} &amp; \cos{\alpha}
\end{matrix}\right)
\left(\begin{matrix}
x\\ y
\end{matrix}\right)
\]</span></p>
<blockquote>
<p>这里如果改变旋转方向，从逆时针改为顺时针，那么矩阵 <span class="math inline">\(\mathbf{M}\)</span> 应该代入 <span class="math inline">\(-\alpha\)</span>，得到</p>
<p><span class="math display">\[
\mathbf{M(-\alpha)} =
\left(\begin{matrix}
\cos{\alpha} &amp; \sin{\alpha}\\
-\sin{\alpha} &amp; \cos{\alpha}
\end{matrix}\right) = \mathbf{M}(\alpha)^T
\]</span></p>
<p>事实上改变方向，角度不变的两个旋转应该互为逆操作，所以也有 <span class="math inline">\(\mathbf{M(-\alpha)} =
\mathbf{M(\alpha)}^{-1}\)</span></p>
<p>易得，<strong>旋转矩阵是一个正交矩阵</strong>。</p>
</blockquote>
<h4 id="切变shear">切变(Shear)</h4>
<p>考虑下面这张图：</p>
<p><img src="shear.png" style="zoom:70%"></p>
<p>坐标在 <span class="math inline">\(\mathbf{x}\)</span>
方向上的偏移量与其纵坐标的大小有关，并且呈线性关系，同时纵坐标又不会发生偏移，那么很容易能够得到下面这个关系：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'
\end{matrix}\right)
=
\left(\begin{matrix}
1 &amp; a\\
0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\\ y
\end{matrix}\right)
\]</span></p>
<h4 id="齐次坐标与平移translation">齐次坐标与平移(Translation)</h4>
<p>上面这些都属于线性变换，都可以通过 <span class="math inline">\(\mathbf{a} = \mathbf{M}\mathbf{a}\)</span>
的方式来表示，但这并不适用于「平移」操作，比如下面这张图：</p>
<p><img src="translation.png" style="zoom:50%"></p>
<p>我们之前讨论的变换，不难发现图像在变换前后，<span class="math inline">\((0, 0)\)</span>
处的点是不动的，但平移不然。我们似乎不能通过 <span class="math inline">\(\mathbf{a} = \mathbf{M}\mathbf{a}\)</span> 使得
<span class="math inline">\((x', y') = (x+t_x,
y+t_y)\)</span>。换句话说，平移并非线性变换，其需要的「变换」应当为</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'
\end{matrix}\right)
=
\left(\begin{matrix}
a &amp; b\\
c &amp; d
\end{matrix}\right)
\left(\begin{matrix}
x\\ y
\end{matrix}\right)
+
\left(\begin{matrix}
t_x\\ t_y
\end{matrix}\right)
\tag{1}
\]</span></p>
<p>于是科学家引入了「齐次坐标」，对于二维的点/向量，为其增加第三个坐标
<span class="math inline">\(w\)</span>。当 <span class="math inline">\(w=1\)</span> 时，表示点；<span class="math inline">\(w=0\)</span> 时，表示向量。</p>
<p>那么对于图像上任意一个点，对其进行平移操作，相当于做了下面这样的变换：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'\\ w'
\end{matrix}\right)
=
\left(\begin{matrix}
1 &amp; 0 &amp; t_x\\
0 &amp; 1 &amp; t_y\\
0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\\ y\\ 1
\end{matrix}\right)
=
\left(\begin{matrix}
x+t_x\\ y+t_y\\ 1
\end{matrix}\right)
\]</span></p>
<p>得到的结果依然是一个「点」的形式。而对于向量而言，因为 <span class="math inline">\(w=0\)</span>，那么有</p>
<ul>
<li>vector ± vector = vector</li>
<li>point - point = vector</li>
<li>point + vector = point</li>
</ul>
<p>从而能够满足向量的平移不变性。</p>
<blockquote>
<p>那么 point + point 呢？我们定义当 <span class="math inline">\(w\neq0\)</span> 时，<span class="math inline">\(\left(\begin{matrix}x\\ y\\
w\end{matrix}\right)\)</span> 等同于点 <span class="math inline">\(\left(\begin{matrix}x/w\\ y/w\\
1\end{matrix}\right)\)</span>。易得<strong>两点相加得到该两点所成线段的中点</strong>。</p>
</blockquote>
<h4 id="仿射变换affine">仿射变换(Affine)</h4>
<p>根据齐次坐标，我们能够把式(1)改写为：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'\\ 1
\end{matrix}\right)
=
\left(\begin{matrix}
a &amp; b &amp; t_x\\
c &amp; d &amp; t_y\\
0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\\ y\\ 1
\end{matrix}\right)
=
\left(\begin{matrix}
ax+by+t_x\\ cx+dy+t_y\\ 1
\end{matrix}\right)
\]</span></p>
<p>即线性变换+平移。这样就用一个形式统一了所有的变换。</p>
<ul>
<li><strong>缩放</strong>: <span class="math inline">\(\mathbf{S}(s_x,
s_y) = \left(\begin{matrix}s_x &amp; 0 &amp; 0\\ 0 &amp; s_y &amp; 0\\0
&amp; 0 &amp; 1\end{matrix}\right)\)</span></li>
<li><strong>旋转</strong>: <span class="math inline">\(\mathbf{R}(\alpha) =
\left(\begin{matrix}\cos{\alpha} &amp; -\sin{\alpha} &amp; 0\\
\sin{\alpha} &amp; \cos{\alpha} &amp; 0\\0 &amp; 0 &amp;
1\end{matrix}\right)\)</span></li>
<li><strong>平移</strong>: <span class="math inline">\(\mathbf{T}(t_x,
t_y) = \left(\begin{matrix}1 &amp; 0 &amp; t_x\\ 0 &amp; 1 &amp; t_y\\0
&amp; 0 &amp; 1\end{matrix}\right)\)</span></li>
</ul>
<h4 id="逆变换inverse">逆变换(Inverse)</h4>
<p>相当于左乘一个逆矩阵。</p>
<p><img src="inverse.png" style="zoom:80%"></p>
<h4 id="对变换进行压缩composing-transforms">对变换进行压缩(Composing
Transforms)</h4>
<p>根据上面的结论，<strong>左乘</strong>一个仿射矩阵相当于进行相应的变换。我们知道矩阵是有结合律的，一系列变换相当于不断左乘对应的矩阵，那么左侧所有矩阵的乘积就是这一系列变换的总和。</p>
<p><img src="compose.png" style="zoom:60%"></p>
<p>再考虑下面两种情况：</p>
<ol type="1">
<li>先平移后旋转；</li>
<li>先旋转后平移；</li>
</ol>
<p>两者得到的结果并不一样。这是<strong>矩阵不满足交换律</strong>导致的，即
<span class="math inline">\(\mathbf{R}(\alpha)·\mathbf{T}(t_x, t_y) \neq
\mathbf{T}(t_x, t_y)·\mathbf{R}(\alpha)\)</span></p>
<p>如果希望图像围绕一个特定的点 <span class="math inline">\((x_0,
y_0)\)</span>
进行旋转，那么可以先平移至与原点对齐，旋转后再回到原来的位置，即</p>
<p><img src="trt.png" style="zoom:60%"></p>
<h4 id="推广到三维空间">推广到三维空间</h4>
<p>也是一样的，都需要进行一个坐标的拓展。对于三维坐标系而言，其仿射变换长下面这样：</p>
<p><span class="math display">\[
\left(\begin{matrix}
x'\\ y'\\ w'\\ 1
\end{matrix}\right)
=
\left(\begin{matrix}
a &amp; b &amp; c &amp; t_x\\
d &amp; e &amp; f &amp; t_y\\
g &amp; h &amp; i &amp; t_z\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
x\\ y\\ z\\ 1
\end{matrix}\right)
\]</span></p>
<ul>
<li><p><strong>缩放</strong>: <span class="math inline">\(\mathbf{S}(s_x, s_y, s_z) =
\left(\begin{matrix}s_x &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; s_y &amp; 0
&amp; 0\\ 0 &amp; 0 &amp; s_z &amp; 0\\ 0 &amp; 0 &amp; 0 &amp;
1\end{matrix}\right)\)</span></p></li>
<li><p><strong>旋转</strong>（往轴负方向看逆时针）:</p>
<ul>
<li>绕 <span class="math inline">\(x\)</span> 轴：<span class="math inline">\(\mathbf{R_x}(\alpha) = \left(\begin{matrix}1 &amp;
0 &amp; 0 &amp; 0\\ 0 &amp; \cos{\alpha} &amp; -\sin{\alpha} &amp; 0\\ 0
&amp; \sin{\alpha} &amp; \cos{\alpha} &amp; 0\\ 0 &amp; 0 &amp; 0 &amp;
1\end{matrix}\right)\)</span></li>
<li>绕 <span class="math inline">\(y\)</span> 轴：<span class="math inline">\(\mathbf{R_y}(\alpha) =
\left(\begin{matrix}\cos{\alpha} &amp; 0 &amp; \sin{\alpha} &amp; 0\\ 0
&amp; 1 &amp; 0 &amp; 0\\ -\sin{\alpha} &amp; 0 &amp; \cos{\alpha} &amp;
0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\)</span></li>
<li>绕 <span class="math inline">\(z\)</span> 轴：<span class="math inline">\(\mathbf{R_z}(\alpha) =
\left(\begin{matrix}\cos{\alpha} &amp; -\sin{\alpha} &amp; 0 &amp; 0\\
\sin{\alpha} &amp; \cos{\alpha} &amp; 0 &amp; 0\\ 0 &amp; 0 &amp; 1
&amp; 0\\ 0 &amp; 0 &amp; 0 &amp; 1\end{matrix}\right)\)</span></li>
</ul></li>
<li><p><strong>平移</strong>: <span class="math inline">\(\mathbf{T}(t_x, t_y, t_z) = \left(\begin{matrix}1
&amp; 0 &amp; 0 &amp; t_x\\ 0 &amp; 1 &amp; 0 &amp; t_y\\ 0 &amp; 0
&amp; 1 &amp; t_z\\ 0 &amp; 0 &amp; 0 &amp;
1\end{matrix}\right)\)</span></p></li>
</ul>
<p>三维空间的旋转比较特殊，因为需要考虑绕某个轴旋转（二维旋转可以视为有一条虚拟的
<span class="math inline">\(z\)</span>
轴，方向垂直纸面向外，所有的旋转都是绕该轴进行的）。</p>
<blockquote>
<p>有的科学家用飞机来模拟三维空间的旋转，并为其进行命名：<strong>roll</strong>，<strong>pitch</strong>，<strong>yaw</strong>。</p>
<p><img src="eularangles.png" style="zoom:60%"></p>
</blockquote>
<h4 id="罗德里格斯旋转公式rodrigues-rotation-formula">罗德里格斯旋转公式(Rodrigues'
Rotation Formula)</h4>
<p>参考<a href="../basicmathingame/#罗德里格斯旋转公式rodrigues-rotation-formula">罗德里格斯旋转公式</a>。</p>
<h3 id="观测变换view">观测变换(View)</h3>
<h4 id="相机的放置">相机的放置</h4>
<p>要做观测变换，首先要解决「<strong>如何放置相机</strong>」这一问题。一般由以下三个属性在空间中唯一确定一个相机：</p>
<ol type="1">
<li><strong>位置</strong>(position)：<span class="math inline">\(\mathbf{e}\)</span>；</li>
<li><strong>朝向</strong>(gaze direction)：<span class="math inline">\(\hat{g}\)</span>；</li>
<li><strong>上方</strong>(up direction)：<span class="math inline">\(\hat{t}\)</span>；</li>
</ol>
<p>另外还有一个关键属性：<strong>相对不变</strong>。即如果相机和所有的物体保持同样的移动，那么得到的观测（照片）永远一致。常用的做法是将相机变换到下面这样的初始状态，其它物体也做同样的变换。</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{e} &amp;= (0, 0, 0)\\
\hat{g} &amp;= -\mathbf{z}\\
\hat{t} &amp;= \mathbf{y}
\end{aligned}
\]</span></p>
<blockquote>
<p>把人头当作相机，观测结果就是我们日常画的<strong>二维坐标系</strong>。上面这个是约定俗成的，能够使观测变容易。</p>
</blockquote>
<h4 id="相机变换">相机变换</h4>
<p>为了让任意位置的相机都能达到初始状态，需要进行一定的变换（称之为
<span class="math inline">\(\mathbf{M}_{view}\)</span>）</p>
<ol type="1">
<li>将 <span class="math inline">\(\mathbf{e}\)</span> 移至原点；</li>
<li>将 <span class="math inline">\(\hat{g}\)</span> 旋转至 <span class="math inline">\(-\mathbf{z} = (0, 0, -1, 0)\)</span>；</li>
<li>将 <span class="math inline">\(\hat{t}\)</span> 旋转至 <span class="math inline">\(\mathbf{y} = (0, 1, 0, 0)\)</span>；</li>
<li>将 <span class="math inline">\(\hat{g}\times\hat{t}\)</span> 旋转至
<span class="math inline">\(\mathbf{x} = (1, 0, 0, 0)\)</span>；</li>
</ol>
<p>不难得到 <span class="math inline">\(\mathbf{M}_{view} =
\mathbf{R}_{view}\mathbf{T}_{view}\)</span>（先平移后旋转）。</p>
<p>其中</p>
<p><span class="math display">\[
\mathbf{T}_{view} =
\left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -x_e\\
0 &amp; 1 &amp; 0 &amp; -y_e\\
0 &amp; 0 &amp; 1 &amp; -z_e\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\]</span></p>
<p>那么旋转矩阵要如何表示呢？发现正着来不太好写，那不如倒着来，先考虑逆操作，即
<span class="math inline">\(\mathbf{x}\rightarrow\hat{g}\times\hat{t},\quad
\mathbf{y}\rightarrow\hat{t},\quad
\mathbf{z}\rightarrow-\hat{g}\)</span>，分别代入特殊值可以得到</p>
<p><span class="math display">\[
\mathbf{R}_{view}^{-1} =
\left(\begin{matrix}
x_{\hat{g}\times\hat{t}} &amp; x_{\hat{t}} &amp; x_{-\hat{g}} &amp; 0\\
y_{\hat{g}\times\hat{t}} &amp; y_{\hat{t}} &amp; y_{-\hat{g}} &amp; 0\\
z_{\hat{g}\times\hat{t}} &amp; z_{\hat{t}} &amp; z_{-\hat{g}} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\]</span></p>
<blockquote>
<p>矩阵分别乘 <span class="math inline">\(\mathbf{x}, \mathbf{y},
\mathbf{z}\)</span> 能得到 <span class="math inline">\(\hat{g}\times\hat{t},\hat{t},-\hat{g}\)</span></p>
</blockquote>
<p>之前我们讨论过，二维旋转矩阵是<strong>正交矩阵</strong>，其实这一性质对三维同样成立，所以有</p>
<p><span class="math display">\[
\mathbf{R}_{view} =
(\mathbf{R}_{view}^{-1})^T =
\left(\begin{matrix}
x_{\hat{g}\times\hat{t}} &amp; y_{\hat{g}\times\hat{t}} &amp;
z_{\hat{g}\times\hat{t}} &amp; 0\\
x_{\hat{t}} &amp; y_{\hat{t}} &amp; z_{\hat{t}} &amp; 0\\
x_{-\hat{g}} &amp; y_{-\hat{g}} &amp; z_{-\hat{g}} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\]</span></p>
<h3 id="投影变换projection">投影变换(Projection)</h3>
<p><img src="projections.png" style="zoom:80%"></p>
<blockquote>
<p>透视投影会形成视角锥，正交投影假设相机置于无穷远处。</p>
</blockquote>
<h4 id="正交投影orthographic-projection">正交投影(Orthographic
projection)</h4>
<p>在计算机图形学中，为了节省计算资源，会定义一个<strong>可视空间</strong>，只有可视空间内的物体才需要进行绘制。正交投影定义的可视空间是一个<strong>盒状可视空间</strong>，本质上是三维物体的外切立方体，其长宽高分别由区间
<span class="math inline">\([f, n], [l, r], [b, t]\)</span> 确定。</p>
<p>所谓正交投影，其实就是已知该可视空间内的任意点，将其垂直投影到 <span class="math inline">\(xOy\)</span>
平面并求解对应点的坐标。一种朴素的思路是直接舍弃 <span class="math inline">\(z\)</span>
坐标，但这样做在有前后遮挡的情况下会出现错误的绘制结果。</p>
<p><img src="orth.png" style="zoom:50%"></p>
<p>现代化做法是像上图这样。首先将可视空间平移至以原点为空间中心，再对长宽高进行归一化。</p>
<p>不难得到两步操作之和的变换矩阵为</p>
<p><span class="math display">\[
\mathbf{M}_{ortho} =
\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0\\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; 0\\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(\begin{matrix}
1 &amp; 0 &amp; 0 &amp; -\frac{r+l}{2}\\
0 &amp; 1 &amp; 0 &amp; -\frac{t+b}{2}\\
0 &amp; 0 &amp; 1 &amp; -\frac{n+f}{2}\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
=
\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l}\\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b}\\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; -\frac{n+f}{n-f}\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\]</span></p>
<blockquote>
<p>归一化是因为，现实情况几乎所有的图形系统都把坐标系的空间范围限定在
<span class="math inline">\((-1,1)\)</span>
范围内，这么做是为了方便移植，使坐标系独立于各种尺寸的图形设备。</p>
</blockquote>
<blockquote>
<p>我们这里是<strong>右手系</strong>，所以有反直觉的 <span class="math inline">\(n&gt;f\)</span>，有的引擎采用左手系（相机看向
<span class="math inline">\(\mathbf{z}\)</span> 正向），从而 <span class="math inline">\(f&gt;n\)</span>，更加符合直觉。</p>
</blockquote>
<h4 id="透视投影perspective-projection">透视投影(Perspective
projection)</h4>
<p>透视投影符合我们日常视角，即<strong>近大远小</strong>，且平行线不再平行，视觉效果看会收束到一个点。</p>
<p>闫神提供的解法是，将相机视锥形成的四棱台<strong>压缩(squish)</strong>成盒状，再应用正交投影即可。</p>
<p><img src="squish.png" style="zoom:80%"></p>
<details>
<summary>
👈推导过程自行点击查看
</summary>
<blockquote>
<p>对于视锥范围内的任意一点 <span class="math inline">\(A(x, y,
z)\)</span>，从原点作一条直线经过该点的直线（即视线），与近裁切面相交于点
<span class="math inline">\(A'(x', y',
z'=n)\)</span>。基于正交投影的性质，我们希望点 <span class="math inline">\(A\)</span> 在经过 squish 后的点 <span class="math inline">\(B\)</span> 满足 <span class="math inline">\(x_B=x', y_B=y'\)</span>。</p>
<p><img src="similarTriangle.png" style="zoom:60%"></p>
<p>根据相似三角形，不难得到</p>
<p><span class="math display">\[
\begin{aligned}
x'&amp;=\frac{n}{z}x\\[2em]
y'&amp;=\frac{n}{z}y
\end{aligned}
\]</span></p>
<p>在齐次坐标下，我们得到这样一个变换关系：</p>
<p><span class="math display">\[
\mathbf{M}_{squish}
\left(
\begin{matrix}
x \\ y \\ z \\ 1
\end{matrix}
\right)
=
\left(
\begin{matrix}
nx/z \\ ny/z \\ ? \\ 1
\end{matrix}
\right)
\overset{\times z}{\Longleftrightarrow}
\left(
\begin{matrix}
nx \\ ny \\ ? \\ z
\end{matrix}
\right)
\]</span></p>
<p>从而有</p>
<p><span class="math display">\[
\mathbf{M}_{squish}
=
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
? &amp; ? &amp; ? &amp; ?\\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
\overset{不妨设为}{==}
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
A &amp; B &amp; C &amp; D\\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
\]</span></p>
<p>接下来就是求 squish 矩阵的第三行元素。由于在 squish
前后，近裁切面和远裁切面上的所有点保持不变，所以我们可以代入两个特殊点进行求解，一个是近裁切面上的点
<span class="math inline">\((x, y, n)\)</span>，一个是远裁切面上的点
<span class="math inline">\((x, y, f)\)</span>，从而得到</p>
<p><span class="math display">\[
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
A &amp; B &amp; C &amp; D\\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
\left(
\begin{matrix}
x \\ y \\ n \\ 1
\end{matrix}
\right)
=
\left(
\begin{matrix}
nx \\ ny \\ Ax+By+Cn+D \\ n
\end{matrix}
\right)
=
\left(
\begin{matrix}
nx \\ ny \\ n^2 \\ n
\end{matrix}
\right)
\Leftrightarrow
\left(
\begin{matrix}
x \\ y \\ n \\ 1
\end{matrix}
\right)
\]</span></p>
<p>得到 <span class="math inline">\(Cn+D = n^2\)</span>，同理 <span class="math inline">\(Cf+D = f^2\)</span>，最终解得</p>
<p><span class="math display">\[
A=B=0,\ C=n+f,\ D=-nf
\]</span></p>
<p>即</p>
<p><span class="math display">\[
\mathbf{M}_{squish}
=
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
0 &amp; 0 &amp; n+f &amp; -nf\\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right)
\]</span></p>
</blockquote>
</details>
<p>最终得到透视投影变换矩阵为</p>
<p><span class="math display">\[
\mathbf{M}_{persp} = \mathbf{M}_{ortho}\mathbf{M}_{squish}
=
\left(\begin{matrix}
\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\frac{r+l}{r-l}\\
0 &amp; \frac{2}{t-b} &amp; 0 &amp; -\frac{t+b}{t-b}\\
0 &amp; 0 &amp; \frac{2}{n-f} &amp; -\frac{n+f}{n-f}\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}\right)
\left(
\begin{matrix}
n &amp; 0 &amp; 0 &amp; 0\\
0 &amp; n &amp; 0 &amp; 0\\
0 &amp; 0 &amp; n+f &amp; -nf\\
0 &amp; 0 &amp; 1 &amp; 0
\end{matrix}
\right) \\
\]</span></p>
<blockquote>
<p>❗提问：视锥内任意一点 <span class="math inline">\(x, y, z\)</span>
在 squish 后是靠近 <span class="math inline">\(xOy\)</span>
平面还是远离？</p>
<p>不妨代入式子求解，计算得到新的点为 <span class="math inline">\((nx/z,
ny/z, n+f-nf/z)\)</span>，我们只需要判断 <span class="math inline">\(n+f-nf/z\)</span> 和 <span class="math inline">\(z\)</span> 的大小关系即可。</p>
<p>令 <span class="math inline">\(f(z) = n+f-nf/z-z = -[z^2-(n+f)z+nf]/z
= -[(z-n)(z-f)]/z\)</span></p>
<p>当 <span class="math inline">\(f \leq z \leq n &lt; 0\)</span>
时，<span class="math inline">\(f(z) &lt;= 0\)</span> 恒成立，即 <span class="math inline">\(n+f-nf/z \leq
z\)</span>，表示<strong>远离</strong>。结论呼之欲出。</p>
</blockquote>
<p>在上面我们定义了远近裁切面，并对其作了相应映射操作。但还有一个问题我们没有解决，那就是<strong>如何定义近裁切面的大小</strong>。</p>
<p>近裁切面其实就是相机的<strong>视口(View
Port)</strong>，可以用两个参数：<strong>视角(fovY, Field of
View)</strong>和<strong>宽高比(Aspect Ratio)</strong>来定义。</p>
<p><img src="viewport.png" style="zoom:80%"></p>
<p><img src="lrbt.png" style="zoom:80%"></p>
<p>当近裁切面在 <span class="math inline">\(\mathbf{z}\)</span>
轴上的坐标 <span class="math inline">\(n\)</span> 确定后，我们就能得到
squish
后的盒状可视空间的上下左右裁切面坐标值，从而正确应用正交投影的平移/缩放。</p>
<p><span class="math display">\[
\begin{aligned}
t &amp;= |n|\tan{\frac{(fovY)}{2}} \\
b &amp;= -t \\[1.5em]
r &amp;= t·(aspect) \\
l &amp;= -r
\end{aligned}
\]</span></p>
<h2 id="光栅化rasterization">光栅化(Rasterization)</h2>
<h3 id="屏幕映射">屏幕映射</h3>
<p><strong>屏幕</strong>其实就是一个二维数组，数组的每一个元素是一个<strong>像素(Pixel,
Picture Element)</strong>，可以用坐标 <span class="math inline">\((x,
y)\)</span> 表示，其像素中心坐标实际上是 <span class="math inline">\((x+0.5, y+0.5)\)</span>。</p>
<p>对于一个分辨率为 width*height 的屏幕而言，其屏幕空间大小就是
width*height，对应了 width*height 大小的二维像素数组。</p>
<p><img src="pixels.png" style="zoom:80%"></p>
<p>我们经过正交/透视投影变换后得到了一个归一化的立方体盒状可视空间（<span class="math inline">\([-1,1]^3\)</span>），需要将其 <span class="math inline">\(xOy\)</span> 平面上的点映射到屏幕空间（<span class="math inline">\([0, width]*[0,
height]\)</span>）中。这一步很简单，缩放+平移即可，对应的变换矩阵为。</p>
<p><span class="math display">\[
\mathbf{M}_{viewport}
\left(
\begin{matrix}
\frac{width}{2} &amp; 0 &amp; 0 &amp; \frac{width}{2}\\
0 &amp; \frac{height}{2} &amp; 0 &amp; \frac{height}{2}\\
0 &amp; 0 &amp; 1 &amp; 0\\
0 &amp; 0 &amp; 0 &amp; 1
\end{matrix}
\right) \\
\]</span></p>
<p>万事俱备，我们只差将其变成真正的<strong>图</strong>，也就是说，要将视口中的多边形打散成像素，得到每个像素的值，真正将其画在屏幕上，这就是光栅化。</p>
<h3 id="光栅化">光栅化</h3>
<p>大部分物体都会采用三角形来组合成对应的多边形，这是因为三角形：</p>
<ol type="1">
<li>是最基础的多边形，任意多边形都可以拆分为若干三角形；</li>
<li>能够唯一确定一个平面；</li>
<li>有明确的内外之分，不存在凹三角形和凸三角形，所以<strong>给定一个点可以唯一确定在三角形内部还是外部</strong>；</li>
<li><strong>缺点</strong>在于无法完美还原曲线；</li>
</ol>
<p><img src="dolphinTriangle.png" style="zoom:70%"></p>
<p>下面就以三角形为例，讲述光栅化的过程。</p>
<p>🙋‍♂️
先进行一个提问：<strong>已知屏幕空间内三个点的坐标值，如何根据这三个点构成的三角形，为像素数组赋合理的值呢？</strong></p>
<h4 id="采样sampling">采样(Sampling)</h4>
<p>采样其实就是一个<strong>离散化</strong>的过程。比如下图，采样的思路是：如果一个像素的像素中心落在三角形的内部，那么就为这个像素赋予相应的值（三角形
RGB）。</p>
<p><img src="sample.png" style="zoom:70%"></p>
<blockquote>
<p>判断一个点 <span class="math inline">\(O\)</span> 是否落在三角形
<span class="math inline">\(P_0P_1P_2\)</span>
内很简单，只需要<strong>三次叉乘</strong>，如果 <span class="math inline">\(\mathbf{OP_0}\times\mathbf{P_0P_1},
\mathbf{OP_1}\times\mathbf{P_1P_2},
\mathbf{OP_2}\times\mathbf{P_2P_0}\)</span>
同号，则认为在内部，反之在外部。</p>
</blockquote>
<blockquote>
<p>实际上去遍历屏幕上的所有像素是没必要的，像上图左边的白色区域是肯定不会碰到三角形的，三角形肯定不会填充到这些像素上，只要考虑蓝色区域即可。蓝色区域就叫三角形的<strong>轴对齐包围盒</strong>，简称
<strong>AABB(Axis-aligned bounding box)</strong>。</p>
</blockquote>
<h4 id="反走样antialiasing">反走样(Antialiasing)</h4>
<p>由于一个像素实际上会被填充为一个正方形，大部分情况下，采样的结果并不能完美地还原一个图形，反而容易产生<strong>锯齿(Jaggies)</strong>，比如下图。</p>
<p><img src="jaggies.png" style="zoom:70%"></p>
<p>锯齿是<strong>走样(Aliasing)问题</strong>的其中一种表现形式，此外还有摩尔纹（空间采样）、车轮错觉（时间采样）等。本质原因都是：<u>信号（函数）变化太快，以至于采样速度跟不上</u>。</p>
<p><strong>反走样(Antialiasing)</strong>就是为了解决这一问题所提出的。以三角形锯齿问题为例，我们可以先将其<strong>模糊处理(Blurring)</strong>，或者说<strong>滤波(Pre-Filtering)</strong>，再对模糊结果进行采样，这样就会有一些边界被采样成粉红色，而不是说只要像素中心不落在三角形内部就被采样成白色。</p>
<p><img src="blur.png" style="zoom:70%"></p>
<p>❗
注意<strong>顺序不能颠倒</strong>，这涉及到一些<strong>频域(frequency
domain)</strong>相关的知识。可以明确的一点是：<u>采用同样的间隔进行采样，频率越高采样越不准确，所以更高频率的函数需要更密集的采样点</u>。比如下面，用相同的手段分别对黑色和蓝色的曲线进行采样，得到的结果是一样的，也就无法对其进行区分，从而导致走样。</p>
<p><img src="diff.png" style="zoom:50%"></p>
<p>而模糊处理其实就是<strong>低通滤波</strong>，将高频信息滤掉，只通过低频分量，这样再做采样操作，就不容易在频域上发生混叠。</p>
<p><img src="filter.png" style="zoom:50%"></p>
<p>最简单的操作就是，根据三角形在一个像素区域中的覆盖面积来决定采样结果。</p>
<p><img src="sample2.png" style="zoom:50%"></p>
<p>那如何计算三角形覆盖的区域呢？有一种近似方法叫
<strong>MSAA(MultiSampling Anti-Aliasing)</strong>：对于任何一个像素
<span class="math inline">\(P\)</span>，考虑其被划分成 <span class="math inline">\(n\)</span> 个小的像素 <span class="math inline">\(p_i\)</span>，求 <span class="math inline">\(P\)</span> 被三角形覆盖的面积，实际上就是求有多少
<span class="math inline">\(p_i\)</span> 落在三角形内部，最后对结果除以
<span class="math inline">\(n\)</span>，这就得到了一个近似的结果。比如下图，将像素划分为
4 个小像素。</p>
<p><img src="22supersample.png" style="zoom:50%">
<img src="afterss.png" style="zoom:50%">
<img src="result.png" style="zoom:50%"></p>
<blockquote>
<p>虽然效果不错，但实际上增加了 <span class="math inline">\(n\)</span>
倍的开销。实际上从工业的角度，人们并不是把一个像素规则的划分为 <span class="math inline">\(n\)</span>
个点，而是会用更加有效的图案去分布这些点，邻近的点还会被相邻的像素所复用，以减少开销。</p>
<p>还有一些重要的反走样方法，如 <strong>FXAA(Fast Approximate
AA)</strong>、<strong>TAA(Temporal AA)</strong>。</p>
</blockquote>
<p>这部分内容并没有「变换」那样涉及到大量公式，都是一些理论上的知识点，所以相对来说篇幅不是那么大。</p>
<h2 id="着色shading">着色(Shading)</h2>
<p>在本课程中，着色的定义为：「对不同物体应用不同材质的过程」。</p>
<h3 id="可见性visibility">可见性(Visibility)</h3>
<p>在屏幕映射这一部分中，我们说到将直接将多边形 <span class="math inline">\(xOy\)</span>
平面上的点映射到屏幕空间，但并没有考虑 <span class="math inline">\(\mathbf{z}\)</span>
轴方向上会出现的<strong>遮挡(Occlusion)</strong>问题。</p>
<h4 id="画家算法">画家算法(👎)</h4>
<p>这是人们最开始想到的一种朴素的做法：维护一个<strong>帧缓存(Frame
Buffer)</strong>
存放屏幕空间的临时像素值，不断用更近的点覆盖原有的像素值，就像油画家的做法一样，最后将得到的
Frame Buffer 写入屏幕空间对应的像素数组，得到结果图像。</p>
<p>这种做法需要将所有的三角形进行排序（多边形拆成若干三角形），需要
<span class="math inline">\(O(n\log{n})\)</span>
的时间复杂度。<strong>缺点</strong>在于，一旦出现<strong>循环覆盖</strong>的情况，画家算法就失效了，比如下图，无法判断哪个三角形更近。</p>
<p><img src="painter.png" style="zoom:50%"></p>
<h4 id="z-buffer">Z-Buffer(👍)</h4>
<p>Z-Buffer
是经过实践检验的优秀算法。它的基本思路是这样的：在维护<strong>帧缓存(Frame
Buffer)</strong>的同时，额外维护一个<strong>深度缓存(Depth Buffer,
Z-Buffer)</strong>。我们需要遍历可视空间内的所有三角形，对其进行采样，并保留被采样点的完整坐标信息。对于一个三角形的所有采样点，如果发现某个点
<span class="math inline">\((x, y, z)\)</span> 对应的深度 <span class="math inline">\(|z|\)</span> 超过 <span class="math inline">\(\text{Z-Buffer}(x,
y)\)</span>，那么就将其舍弃，反之用该点信息更新两个
Buffer。虽然牺牲了一部分空间，却换来了<strong>速度</strong>（线性时间复杂度，无需关心顺序）与<strong>鲁棒性</strong>（解决了循环覆盖问题）。</p>
<blockquote>
<p>同时，还可以根据像素深度进行额外的处理，如着色深浅。</p>
</blockquote>
<details>
<summary>
🤳伪代码
</summary>
<pre class="line-numbers language-pseudocode" data-language="pseudocode"><code class="language-pseudocode">for each triangle T
    for each sample(x, y, z) in T
        if (z &lt; ZBuffer[x, y])
            FrameBuffer[x, y] = RGB
            ZBuffer = z<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</details>
<h3 id="blinn-phong-模型shading-is-local">Blinn-Phong 模型——Shading is
Local</h3>
<p>Blinn-Phong Model
是一个简单的着色模型，它计算<u>从点光源射出，在物体表面的一个点（即<strong>着色点(Shading
Point)</strong>）上反射向相机的光</u>。</p>
<blockquote>
<p>它将着色完全理想化，而不考虑物理真实性，因而没有太大的现实借鉴意义。</p>
</blockquote>
<p>这里认为在一个局部比较小的范围内，着色点永远是一个平面。那么关于光的反射，需要定义以下内容：</p>
<ol type="1">
<li>平面法线 <span class="math inline">\(\mathbf{n}\)</span>；</li>
<li>观测方向 <span class="math inline">\(\mathbf{v}\)</span>；</li>
<li>光照方向 <span class="math inline">\(\mathbf{l}\)</span>；</li>
<li>物体表面属性（如下面要提到的漫反射系数）；</li>
</ol>
<p><img src="shadingpoint.png" style="zoom:50%"></p>
<blockquote>
<p><strong>Shading is
Local</strong>，这句话的意思是，着色只会考虑这个着色点，以及光照和观测方向，不考虑其他物体的存在，所以没有阴影。</p>
</blockquote>
<h4 id="漫反射diffuse-reflection">漫反射(Diffuse Reflection)</h4>
<p>对于<strong>漫反射(Diffuse
Reflection)</strong>而言，光在着色点<strong>均匀</strong>地向四面八方反射，故此时观测结果与观测方向无关。</p>
<p>另外我们发现，当着色点平面法线方向和光线的夹角变化时，得到的观测结果明暗程度也会发生变化。根据光的波粒二象性，<u>光是具有能量的</u>，所以当
<span class="math inline">\(\theta(\mathbf{n}, \mathbf{l})\)</span>
变化时，着色点在单位面积收到的<strong>能量值</strong>（光强度）也会有所变化。具体而言，光强度与
<span class="math inline">\(\cos{\theta}=\mathbf{n}·\mathbf{l}\)</span>
呈正相关。<u>我们判断物体的明暗程度，本质上就是判断该物体表面能接收到多少能量</u>。</p>
<p><img src="nl.png" style="zoom:50%"></p>
<p>除了角度以外，点光源与着色点的<strong>距离</strong>也是决定光强度的一个重要因素。根据能量守恒定律，假设光的传播不会发生能量损耗，则以点光源为中心，半径
1 个单位长度的球体表面和半径 r
个单位长度的球体表面，两者所具有的能量应该是相等的。假设前者的光强度为
<span class="math inline">\(I\)</span>，那么后者的光强度应该为</p>
<p><span class="math display">\[
I' = \frac{4\pi}{4\pi r^2} I = \frac{I}{r^2}
\]</span></p>
<p>基于以上讨论，Blinn-Phong 模型给出如下的漫反射公式：</p>
<p><span class="math display">\[
L_d = k_d·\frac{I}{r^2}·\max{(0, \mathbf{n}·\mathbf{l})}
\]</span></p>
<p>其中</p>
<ul>
<li><p><span class="math inline">\(L_d\)</span> 为漫反射光强；</p></li>
<li><p><span class="math inline">\(k_d\)</span>
为<strong>漫反射系数</strong>，表示这个点对光的吸收率；</p>
<blockquote>
<p>对于一个点，它之所以会有颜色，是因为这个点会吸收一部分的颜色（能量），将那部分不吸收的能量进行反射。那不同的物体表面材质不同，因而有不同的<strong>吸收率</strong>，就会产生不同的反射光。当这个系数为
1 时，表示这个点完全不吸收能量；为 0
就表示所有能量都被吸收了。如果把这个系数表示为一个三通道的 RGB
颜色向量，那就可以在着色点上定义一个颜色了。</p>
<p>控制变量法得到的结果大概是下面这样</p>
<p><img src="diffuseresult.png" style="zoom:50%"></p>
</blockquote></li>
</ul>
<h4 id="高光specular">高光(Specular)</h4>
<p>当观测方向和光反射方向一致（或者说接近）时，能观测到高光。</p>
<blockquote>
<p>这里不考虑漫反射，只谈<strong>镜面反射</strong>。</p>
</blockquote>
<p>那么如何定义「接近」呢？假设反射光方向为 <span class="math inline">\(\mathbf{R}\)</span>，则 <span class="math inline">\(\theta{\mathbf{R},\mathbf{v}}\)</span>
越小，表示越接近。但是 <span class="math inline">\(\mathbf{R}\)</span>
比较难求，Blinn-Phong 模型改为求解<strong>半程向量</strong> <span class="math inline">\(\mathbf{h}\)</span> 与法线 <span class="math inline">\(\mathbf{n}\)</span> 之间的夹角 <span class="math inline">\(\alpha\)</span>。所谓半程向量，其实就是 <span class="math inline">\(\mathbf{v}\)</span> 与 <span class="math inline">\(\mathbf{l}\)</span> 的角平分线，有 <span class="math inline">\(\displaystyle
\mathbf{h}=\frac{\mathbf{v}+\mathbf{l}}{||\mathbf{v}+\mathbf{l}||}\)</span>
。</p>
<p><img src="specular.png" style="zoom:50%"></p>
<p>基于以上讨论，Blinn-Phong 模型给出如下的高光项公式：</p>
<p><span class="math display">\[
L_s = k_s\frac{I}{r^2}\max{(0, \mathbf{n}·\mathbf{h})}^p
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(L_s\)</span> 为高光项光强；</li>
<li><span class="math inline">\(k_d\)</span>
为<strong>高光项系数</strong>，决定观测到的高光明暗程度；</li>
</ul>
<blockquote>
<p>🙋‍♂️ 之所以有一个指数 <span class="math inline">\(p\)</span>，是因为需要对「接近程度」设置一个阈值，当
<span class="math inline">\(p=1\)</span> 时，即便 <span class="math inline">\(\mathbf{h}\)</span> 与 <span class="math inline">\(\mathbf{n}\)</span> 夹角达到了
45°，此时我们认为已经是相当偏离了，但余弦值为 <span class="math inline">\(\sqrt{2}/2\approx
0.7\)</span>，还是能观测到比较明显的高光，这完全不符合我们的预期吧！</p>
<p>所以需要加入指数 <span class="math inline">\(p\)</span>
进行控制，使得夹角增大时，<span class="math inline">\((\cos{\alpha})^p\)</span>
能够快速衰减，比如下图</p>
<p><img src="cosinePower.png" style="zoom:50%"></p>
<p>控制变量法得到的结果大概是下面这样（加入漫反射项）：</p>
<p><img src="specularresult.png" style="zoom:50%"></p>
</blockquote>
<h4 id="环境光照ambient">环境光照(Ambient)</h4>
<p>虽然有些点因为遮挡等因素，不会接收点光源的直射光，但是存在来自四面八方的、反射自其它物体表面的光，这就是<strong>环境光(Ambient)</strong>。</p>
<p><img src="ambient.png" style="zoom:50%"></p>
<p>Blinn-Phong 模型给出的环境光项公式很简单：</p>
<p><span class="math display">\[
L_a = k_aI_a
\]</span></p>
<p>其中</p>
<ul>
<li><span class="math inline">\(L_a\)</span> 为环境光强；</li>
<li><span class="math inline">\(k_a\)</span>
为<strong>环境光系数</strong>；</li>
<li><span class="math inline">\(I_a\)</span>
为光强，且假设任何一个点接收到来自环境的光强永远都是相同的；</li>
</ul>
<p>不难发现，该模型的环境光强和 <span class="math inline">\(\mathbf{l},
\mathbf{n}, \mathbf{v}\)</span>
无关，是一个<strong>常数</strong>，保证了没有一个地方完全是黑的。事实上不是这么一回事，正如我之前说的，Blinn-Phong
只是一个简单的模型，如果要对环境光做精确求值，需要运用到<strong>全局光照</strong>的知识。</p>
<h4 id="总结">总结</h4>
<p>Blinn-Phong 模型下，我们最终能观测到的光强是以上三大项之和，即</p>
<p><span class="math display">\[
L = L_a+L_d+L_s = k_aI_a + k_d\frac{I}{r^2}\max{(0,
\mathbf{n},\mathbf{l})}+k_s\frac{I}{r^2}\max{(0,
\mathbf{n}·\mathbf{h})}^p
\]</span></p>
<p>下面是一个简单的示例</p>
<p><img src="blinnphongresult.png" style="zoom:50%"></p>
<p>❗ 再次强调，<strong>Blinn-Phong
只是一个简单的模型，不具备物理真实性，没有太大的现实借鉴意义</strong>。</p>
<h3 id="着色频率shading-frequency">着色频率(Shading Frequency)</h3>
<p>选择着色频率，本质上是「如何选择着色点」的问题。下面的讨论中，我们认为物体表面由若干三角形的平面组成。</p>
<p><img src="shadingFreq.png" style="zoom:50%"></p>
<h4 id="flat-shading">Flat Shading</h4>
<p>将着色应用到整个三角形上。对于一个三角形，我们只需对任意两条边作叉乘，即可求得法线，最后对三角形内部所有点作同样的着色处理。缺点是不够平滑。</p>
<h4 id="gouraud-shading">Gouraud Shading</h4>
<p>将着色应用到顶点上。对于物体表面任意一个顶点，其相邻的所有三角形为
<span class="math inline">\(T_1, T_2, \dots\)</span>，这些三角形面积为
<span class="math inline">\(S_1, S_2, \dots\)</span>，法线为 <span class="math inline">\(\mathbf{n}_1, \mathbf{n}_2,
\dots\)</span>，那么此顶点为着色点对应的法线为</p>
<p><span class="math display">\[
\mathbf{n} = \frac{S_1\mathbf{n}_1 + S_2\mathbf{n}_2 + \dots}{S_1 + S_2
+ \dots}
\]</span></p>
<blockquote>
<p>本质上是对所有法线作一个<strong>加权平均</strong>，权值为其面积，故面积越大的三角形，影响/贡献越大。</p>
</blockquote>
<p>对于一个三角形，其三个顶点的着色已知，那么三角形内部应用<strong>插值</strong>即可。缺点是一旦某个三角形过大，着色效果就会不明显。</p>
<h4 id="phong-shading">Phong Shading</h4>
<p>将着色应用到像素上。首先对于三角形的每个顶点求出各自的法线，在三角形内部每一个像素上都<strong>插值</strong>出一个法线方向，对每一个像素进行一次着色，就会得到一个相对比较好的效果。</p>
<blockquote>
<p>🤔 注意和 Blinn-Phong 区分。虽然都是同一个人发明的。</p>
</blockquote>
<h4 id="总结-1">总结</h4>
<p>根据一开始放的图，在顶点数较少，即模型比较简单时，Phong
的效果无疑是最好的，但也要一定的开销。而当顶点数增大，模型逐渐复杂时，即便用相对简单的
Flat Shading
也能得到一个比较好的效果，因为此时一个平面的大小可能已经接近像素大小了。</p>
<h3 id="实时渲染管线real-time-rendering-pipeline">实时渲染管线(Real-time
Rendering PipeLine)</h3>
<p><img src="gpipe.png" style="zoom:50%"></p>
<ol type="1">
<li>输入空间中的若干点；</li>
<li>将这些点投影到屏幕上，定义连接关系，生成相应三角形；</li>
<li>光栅化，形成不同的离散的<strong>片元(fragment)</strong>；</li>
<li>考虑可见性与着色频率，将不同的片元进行着色；</li>
<li>输出到显示器；</li>
</ol>
<p>以上就是从三维场景到最后渲染出二维图片的基本操作，这些都是已经在 GPU
里写好了的。</p>
<blockquote>
<p>🙋‍♂️
提问：<strong>为什么在管线中是先把三维空间中的点投影到屏幕上去，然后再把它连成三角形呢？</strong></p>
<p>定义空间物体时，首先定义顶点，再进行若干次定义由哪三个顶点构成小平面，这两步是将<strong>直接定义所有的三角形</strong>进行拆分，本质上是一样的，且三维空间投影到二维屏幕时，点与点之间的连接关系是不变的，所以我们只要对顶点进行操作就行。</p>
</blockquote>
<h3 id="纹理映射texture-mapping">纹理映射(Texture Mapping)</h3>
<p>纹理映射解决了这样一个问题：<strong>给定三角形，我们希望观察到的结果为，三角形内部填充了某一张图片</strong>。</p>
<p>前面提到，对于一个表面，我们能够观察到不同颜色以及不同明暗程度，实际上是这个物体表面的属性发挥了作用——吸收一部分光，反射剩下的部分。我们能够看到物体表面仿佛填充了一张图片，本质上是<strong>这个物体表面的不同点具有不同的属性</strong>，这才是决定了不同观测结果的重要因素。</p>
<p>所以纹理映射的根本作用，就是<strong>定义物体表面属性</strong>。</p>
<p>那么如何定义呢？对于任意一个三维物体，其表面都可以通过某种方式转变成大小为
<span class="math inline">\(1\times 1\)</span>
的二维图像，那么只要我们得到任意一张图，就可以通过逆操作将其「贴」到三维物体上，这就是赋予纹理的过程。只要将三维物体表面的所有三角形平面，都在这个二维图像找到一一对应关系，那么我们就可以把「定义三维物体表面属性」简化为「定义二维图像表面属性」了。</p>
<p><img src="texturemap.png" style="zoom:50%"></p>
<p>假设这种映射关系已经找到了。不难发现，任意一个三角形的顶点，在二维纹理图像
<span class="math inline">\(\mathbf{uv}\)</span>
上都有对应的坐标，所以顶点处的纹理很好计算。那如何计算三角形内部任何一个点的纹理坐标呢？这就又涉及到<strong>插值</strong>了，即让纹理在三角形内部作平滑过渡。</p>
<blockquote>
<p>同时我们希望对于多个相邻物体赋予同一纹理时（比如草坪，以一个平方为单位赋予纹理），我们希望两块纹理之间能够<strong>无缝衔接</strong>（这种纹理称为
<strong>tilable texture</strong>）。这就需要一个好的纹理设计，通常使用
<strong>wang tiled</strong> 算法。</p>
</blockquote>
<h3 id="插值interpolation">插值(Interpolation)</h3>
<p>之前我们提到过很多次「插值」的概念，在这里对其进行比较详细的阐述。插值的意义在于，如果已知三角形的三个顶点的值，那么通过插值的方法可以得到三角形内任何一点的值，并且任意两点之间的值是平滑过渡的。下面主要了解一种名为「重心坐标」的插值方法。</p>
<h4 id="重心坐标barycentric-coordinates">重心坐标(Barycentric
Coordinates)</h4>
<p>根据高中知识，对于二维平面上的三角形而言，其<strong>重心</strong>定义为三条中线的交点。重心有一些重要的性质，比如与三角形顶点的连线将三角形面积三等分，平面直角坐标系中重心的坐标等于顶点坐标的算术平均等。第二条性质用数学的方法可以表示为</p>
<p><span class="math display">\[
P_{x,y} = \frac{1}{3}A_{x,y}+\frac{1}{3}B_{x,y}+\frac{1}{3}C_{x,y}
\]</span></p>
<p>其中 <span class="math inline">\(P\)</span> 为 <span class="math inline">\(\triangle{ABC}\)</span> 的重心。</p>
<p>再次根据高中知识，线段 <span class="math inline">\(AB\)</span>
上的一点 <span class="math inline">\(Q\)</span> 的坐标可以表示为 <span class="math inline">\(Q_{x,y}=\alpha
A_{x,y}+(1-\alpha)B_{x,y}\)</span>。</p>
<p>那么对于 <span class="math inline">\(\triangle{ABC}\)</span>
而言，我们完全可以认为其内部一点是 <span class="math inline">\(AB\)</span> 上某一点和 <span class="math inline">\(C\)</span>
所成线段上的点，是否也可以利用上面这个性质呢？答案是：<strong>可以</strong>！</p>
<p>事实上三角形内部任何一点 <span class="math inline">\(Q\)</span>
的坐标都可以表示成 <span class="math inline">\(Q_{x,y} = \alpha
A_{x,y}+\beta B_{x,y}+\gamma C_{x,y}\)</span> 的形式，其中 <span class="math inline">\(\alpha+\beta+\gamma=1\)</span>。只不过重心是 <span class="math inline">\(\alpha=\beta=\gamma=1/3\)</span>
时的特殊情况。</p>
<details>
<summary>
简单的推导
</summary>
<p>取 <span class="math inline">\(\triangle{ABC}\)</span> 内部任意一点
<span class="math inline">\(P\)</span>，连接 <span class="math inline">\(CP\)</span> 并延长交 <span class="math inline">\(AB\)</span> 于点 <span class="math inline">\(Q\)</span>。易得 <span class="math inline">\(Q_{x,y} = \lambda A_{x,y} + (1-\lambda)
B_{x,y}\)</span>，那么有</p>
<p><span class="math display">\[
\begin{aligned}
P_{x,y}
&amp;= \gamma C_{x,y} + (1-\gamma) P_{x,y} \\
&amp;= \gamma C_{x,y} + (1-\gamma)\lambda A_{x,y} +
(1-\gamma)(1-\lambda) B_{x,y}
\end{aligned}
\]</span></p>
<p>此时令 <span class="math inline">\(\alpha=(1-\gamma)\lambda,
\beta=(1-\gamma)(1-\lambda)\)</span> 即得结果，并且不难发现 <span class="math inline">\(\alpha+\beta = 1-\gamma\)</span></p>
</details>
<p>我们称 <span class="math inline">\((\alpha,\beta,\gamma)\)</span>
为<strong>重心坐标</strong>（注意区别于<em>重心的坐标</em>）。</p>
<p>现在问题来了，对于三角形内一个点，怎么求对应的重心坐标呢？答案如下图所示，证明就不证了。</p>
<p><img src="bc.png" style="zoom:50%"></p>
<p>现在我们可以利用这三个系数进行插值了。已知三个顶点的「值」 <span class="math inline">\(V_A, V_B,
V_C\)</span>，利用重心坐标，内部任意一点的「值」为</p>
<p><span class="math display">\[
V = \alpha V_A + \beta V_B + \gamma V_C
\]</span></p>
<blockquote>
<p>这里的「值」既可以是 Phong Shading 的法线，也可以是纹理值。</p>
<p>要注意的是，三维空间的点 <span class="math inline">\(P\)</span>
投影到二维屏幕上成为 <span class="math inline">\(P'\)</span>
后，<span class="math inline">\((\alpha,\beta,\gamma)_P\neq
(\alpha,\beta,\gamma)_{P'}\)</span>。所以想要对三维空间的属性进行插值，就必须先在三维空间内做，再对应到二维结果上去。</p>
</blockquote>
<h4 id="纹理映射中的应用">纹理映射中的应用</h4>
<p>现在我们可以计算三角形内部任一点的纹理坐标 <span class="math inline">\(\mathbf{u}\mathbf{v}\)</span>
了，具体做法是：在三维空间中，先求出重心坐标 <span class="math inline">\((\alpha,\beta,\gamma)\)</span>，再利用三个顶点的纹理坐标进行插值计算
<span class="math inline">\(\mathbf{u}\mathbf{v} =
\alpha(\mathbf{u}\mathbf{v}_A)+\beta(\mathbf{u}\mathbf{v}_B)+\gamma(\mathbf{u}\mathbf{v}_C)\)</span>。得到结果后，就可以直接去二维纹理图上找到对应的纹理值，应用即可。</p>
<h4 id="双线性插值bilinear-interpolation">双线性插值(Bilinear
Interpolation)</h4>
<p>对于一个给定的纹理，其上的<strong>纹理元素(Texel, Texture
Element)</strong>数量是固定的。在纹理比较<strong>小</strong>的情况下，比如我们要将一张
512*512 的纹理应用到整个 4k 屏幕上，就必然导致屏幕的多个像素，对同一个
Texel
进行采样。有的像素点可能对应的纹理坐标没有落到纹理中心，比如下面这样</p>
<p><img src="texelsample.png" style="zoom:50%"></p>
<p>一种简单的方法是<strong>就近法(Nearest)</strong>，就是找最近的那个
Texel，那么会使得多个像素赋予同一个纹理值，最后得到的结果就会呈现颗粒状，两个像素之间有明显的界限，如下面最左边那张图。</p>
<p><img src="nearest.png" style="zoom:50%"></p>
<p>我们发现中间的 Bilinear 方法效果更好，那么它为什么会这么好呢？是因为
Bilinear 不是找最近的一个，而是根据最近的四个 Texel
的纹理值作两次线性插值，就会得到一个比较好的效果，同时开销也不会非常大。</p>
<p><img src="bilinear.png" style="zoom:50%"></p>
<p>而最右侧的 Bicubic
是找最近的十六个点，效果当然会更好，但同样开销也更大了。</p>
<h4 id="mipmap-与三线性插值trilinear-interpolation">mipmap
与三线性插值(Trilinear Interpolation)</h4>
<p>上面讨论了纹理过小的情况，还算比较简单。那么纹理如果过大呢？比如在一个屏幕内有一个视角很大、场景层次很丰富的世界场景，远山所占的屏幕内容很小，但是纹理贴图却很大，此时会转变为同一个像素点对多个
Texel
进行采样。根据之前的讨论，这时数据频率远大于采样频率，就会导致图像失真，出现摩尔纹等现象。</p>
<p><img src="texelbig.png" style="zoom:60%"></p>
<p>我们可以用 MSAA
的方法，在一个像素点内用更多的采样点，取平均值就好了，效果当然会不错，但是开销也会非常大。有没有一种更好的方法，即我们能不能在采样前预先计算好平均值，这样就不需要在采样的时候作重复计算呢？<strong>Mipmap(Multum
in parvo map)</strong> 来了。</p>
<p>Mipmap
的原理很简单，对于一个纹理图，不断将其分辨率缩放一半，每缩放一次，将结果作为更高的
level。<span class="math inline">\(i\)</span> 层对应大小为 <span class="math inline">\(2^i\)</span>
的纹理区域。之后只需要求出采样的纹理面积/边长，在相应 level
的纹理图中根据 <span class="math inline">\(\mathbf{u}\mathbf{v}\)</span>
取值就行。</p>
<p><img src="mipmap.png" style="zoom:60%"></p>
<p>对于屏幕上的一个像素点 <span class="math inline">\(P\)</span>，我们可以找其相邻的四个像素点，将这五个点分别在纹理空间中找到对应的纹理坐标，然后求中心点
<span class="math inline">\(P_{tex}\)</span> 到另外四个点距离的最大值
<span class="math inline">\(L\)</span>，就可以近似认为该像素点所采样的纹理区域是一个边长为
<span class="math inline">\(L\)</span>
的正方形。说明该像素点对应的纹理值要去 <span class="math inline">\(\log_2{L}\)</span> 层取。</p>
<p><img src="computemipmap.png" style="zoom:60%"></p>
<p>这里的 <span class="math inline">\(\log_2{L}\)</span>
如果是一个浮点数，就不能直接使用了，我们总不能去 1.7
层找吧！如果进行四舍五入那就又陷入就近法的误区了。参考之前的做法，我们可以找到
<span class="math inline">\(D=\lfloor\log_2{L}\rfloor\)</span> 层和
<span class="math inline">\(D+1=\lceil\log_2{L}\rceil\)</span> 层的
bilinear 结果，然后再次进行线性插值。实际上就是
<strong>trilinear</strong> 了。</p>
<p><img src="trilinear.png" style="zoom:60%"></p>
<p>三线性 + mipmap
虽然能处理一些小像素采样大纹理的问题，但仅能对正方形进行近似，如果一个像素点采样的纹理区域是不规则图形，比如比较斜的平行四边形，此时用正方形对其进行近似就会出现
<strong>OverBlur</strong> 的问题。</p>
<p><img src="irregular.png" style="zoom:60%"></p>
<blockquote>
<p>有一些替代方案，比如<strong>各向异性过滤(Anisotropic
Filtering)</strong>可以用矩形进行近似，但并没有解决上面提到的问题。</p>
<p><strong>EWA filtering</strong>
可以将不规则形状拆分为若干圆形，每次查询其中一个圆，分多次查询来近似。虽然能够比较好的进行近似，但「多次查询」已经暴露了其开销过大的缺陷。</p>
</blockquote>
<h3 id="纹理的其他应用">纹理的其他应用</h3>
<p>对于现代 GPU
而言，所谓纹理，其实就是一块内存(memory)，并且可以对其进行范围查询/过滤(range
query/filtering)，所以纹理其实是一个比较广义的概念，并不局限于「图片」，可以表示非常多的东西。</p>
<h4 id="环境贴图environment-mapping">环境贴图(Environment Mapping)</h4>
<p>我们可以用纹理来描述环境光，再去渲染物体，这样就代替了点光源。此时我们可以假设环境光都是来自<strong>无穷远处</strong>，光强和距离无关，只记录方向信息，也就是说只要方向相同，环境光强就是一致的。比如下图，左图描述了在房间里从四面八方看到的光，用左图去渲染一个茶壶（右图），我们就能观察到茶壶被环境光所照亮，并反射来自四面八方的光。</p>
<p><img src="cup.png" style="zoom:60%"></p>
<blockquote>
<p>这是一个经典模型，名为<strong>犹他茶壶(Ultra teapot)</strong></p>
</blockquote>
<p>那么如何描述呢？</p>
<p>第一种做法是存储在<strong>球面</strong>上，但因为不是一个均匀的描述，会在靠近极点的地方出现扭曲。</p>
<p><img src="sphericalmap.png" style="zoom:60%"></p>
<p>第二种做法是，假设上面的球有一个立方体状的包围盒，那原来记录在球面上的环境光信息，会沿着与球心的延长线打在盒面上，而不会有差异。也就是可以将环境光信息存储在<strong>立方体表面</strong>上，这样展开就会得到下图：</p>
<p><img src="cubemap.png" style="zoom:60%"></p>
<h4 id="凹凸贴图bump-mapping">凹凸贴图(Bump Mapping)</h4>
<p>纹理甚至可以定义物体表面某个点的「相对高度」，也就是在原来物体基础上定义凸起和凹陷的程度。这样就可以在<strong>不修改几何模型</strong>的前提下影响物体表面的着色。如下图，定义了相对高度后，求得的法线就会随之发生变化，那
Shading 的结果就会发生变化，就会看到不同的明暗对比。</p>
<p><img src="orange.png" style="zoom:60%"></p>
<blockquote>
<p>如果想表示球上凹凸不平的复杂几何，那就要用更多的三角形了。</p>
</blockquote>
<p>法线的求法也很简单，只需要在纹理空间中求出该点在 <span class="math inline">\(\mathbf{u}, \mathbf{v}\)</span>
两个方向上的梯度，那就得到了切线，通过切线就能简单地得到法线了。</p>
<h4 id="位移贴图displacement-mapping">位移贴图(Displacement
mapping)</h4>
<p>凹凸贴图本质上没有改变物体几何，而是用了视错觉原理，欺骗人的眼球，给人一种凹凸不平的错觉。</p>
<p><img src="displacementmap.png" style="zoom:60%"></p>
<p>而<strong>位移贴图</strong>实际上会修改物体几何，即改变了三角形顶点的位置。但如果一个三角形比较大，就无法改变三角形内部还有一些需要改变的位置。也就是说三角形要足够细，细到三角形顶点之间的间隔要比纹理定义的频率还要高，使得模型能够跟得上所定义的纹理的变化速度。</p>
<p>有一种解决方案是，开始先用比较粗糙（三角形少）的模型，在应用位移贴图的过程中检测一下是否应该把三角形变得更细，如果需要，就将三角形拆开成很多小三角形，再继续做位移贴图。</p>
<h4 id="三维纹理">三维纹理</h4>
<p>事实上纹理没必要限制在二维，也可以是三维的。像下图，如果将这个球砍一半，我们希望可以看到它内部的情况，也就是说需要定义空间中任意一个点的纹理值。而实际上没有真的生成纹理的图，而是定义了一个定义在三维空间中的噪声的函数，所以在空间中任何一个点，它都有一个解析式可以算出来噪声的值。像这里是<strong>柏林噪声(Perlin
noise)</strong></p>
<p><img src="3dtexture.png" style="zoom:60%"></p>
<h2 id="几何geometry">几何(Geometry)</h2>
<h3 id="隐式表示implicit">隐式表示(Implicit)</h3>
<p>隐式表示方法不会指明具体的点在哪，而是给出这些点满足的关系。</p>
<h4 id="代数曲面algebraic-surfaces">代数曲面(Algebraic Surfaces)</h4>
<p>根据单位球面满足关系 <span class="math inline">\(x^2+y^2+z^2=1\)</span>，不妨进行推广，任意物体表面都可以由这样一个数学公式进行表达：</p>
<p><span class="math display">\[
f(x,y,z)=0
\]</span></p>
<p>已知任意一个 <span class="math inline">\(x,y,z\)</span>，我们可以计算
<span class="math inline">\(f(x,y,z)\)</span>，进而判断 <span class="math inline">\((x,y,z)\)</span>
在物体内部（&lt;0）、表面上（=0）还是在物体外部（&gt;0）。</p>
<h4 id="构造实体几何csg-constructive-solid-geometry">构造实体几何(CSG,
Constructive Solid Geometry)</h4>
<p>通过对基本几何的基本布尔运算（并集、交集、差集），来定义新的几何。</p>
<p><img src="csg.png" style="zoom:60%"></p>
<h4 id="符号距离函数signed-distance-functions">符号距离函数(Signed
Distance Functions)</h4>
<p>对于任何一个几何，都不直接描述它的表面，而是描述任何一个点到这个表面的最近距离，这就是<strong>符号距离函数</strong>（结果为正则认为在物体表面的外面，负的则在物体内部）。</p>
<p>计算出两个物体的符号距离函数 <span class="math inline">\(SDF_1,
SDF_2\)</span> 后，就可以将两者做一个 blending，得到一个新的符号距离函数
<span class="math inline">\(SDF\)</span>，然后再恢复成原来的物体（所有满足
<span class="math inline">\(SDF(x,y,z) = 0\)</span>
的点构成的集合就是物体的表面），就可以得到如下的变换。</p>
<p><img src="disfunc.png" style="zoom:60%"></p>
<h4 id="水平集level-set-methods">水平集(Level Set Methods)</h4>
<p>这个方法的思路和距离函数其实完全一样，仅仅是函数的表述是写在格子上的，函数在不同的格子上有不同的值，只需要找出格子中值为
0
的点（可以通过双线性插值计算），就可以将函数试图描述的物体表面提取出来。</p>
<blockquote>
<p>这和地理上的等高线的概念是一致的。</p>
</blockquote>
<h4 id="分形fractals">分形(Fractals)</h4>
<p>分形是自相似的意思，也就是说自己的一个部分和它的整体长得非常像，和计算机科学中说的<strong>递归</strong>是一个道理。下图是一种叫
Romanesco 的西兰花。</p>
<p><img src="fractals.png" style="zoom:60%"></p>
<blockquote>
<p>这种类型的几何对于渲染和描述来说都是巨大的挑战，渲染时会引起强烈的走样</p>
</blockquote>
<h4 id="总结-2">总结</h4>
<p>隐式表示表述起来相对容易，同时支持点与物体表面位置关系的查询，且有利于求解光线与表面的交集。</p>
<p>缺点在于，很难描述复杂的几何结构。</p>
<h3 id="显示表示explicit">显示表示(Explicit)</h3>
<p>显示表示则是直接给出点的位置。</p>
<h4 id="参数映射parameter-mapping">参数映射(Parameter Mapping)</h4>
<p>比如定义了一个坐标系 <span class="math inline">\(\mathbf{u},
\mathbf{v}\)</span>，对于给定的任意点 <span class="math inline">\((u,v)\)</span>，都会映射到空间中的点 <span class="math inline">\((x,y,z)\)</span> 中，这样只需要遍历一遍 <span class="math inline">\((u,v)\)</span>，就可以得到所有的 <span class="math inline">\((x,y,z)\)</span>。</p>
<p><img src="explicit.png" style="zoom:60%"></p>
<h4 id="点云point-cloud">点云(Point Cloud)</h4>
<p>我们不考虑物体是一个表面，而是由海量点组成。只要点足够密集，那么点与点之间的缝隙就可以忽略不计，理论上可以表示任何类型的几何体。</p>
<p>而如果点云密度很低，就很难绘制成物理实体，所以除了最原始扫描出来的数据，人们很少用点云。</p>
<h4 id="多边形面polygon-mesh">多边形面(Polygon Mesh)</h4>
<p>这是用的最广泛的，也是之前一直在聊的，就是将物体表面视为由若干三角形组成。这就会涉及到一个问题，就是三角形之间的<strong>连接关系</strong>，这是点云不会遇到的。</p>
<p>有一种特殊文件格式，<strong>The Wavefront Object File(.obj)
Format</strong>，对于该格式的文件，一个文件存储一个物体或场景，把空间中的一堆顶点、法线和纹理坐标分开来表示，然后在一块把他们组织起来形成模型。如下图，描述的是一个立方体。</p>
<p><img src="obj.png" style="zoom:60%"></p>
<ul>
<li><code>v</code>：描述顶点信息；</li>
<li><code>vt</code>：描述纹理坐标；</li>
<li><code>vn</code>：描述每个面的法线方向；</li>
<li><code>f</code>：描述哪三个点构成三角形，格式为
<code>三角形顶点/纹理坐标/法线坐标</code>；</li>
</ul>
<h4 id="贝塞尔曲线bézier-curve">贝塞尔曲线(Bézier Curve)</h4>
<p>贝塞尔曲线由一系列控制点 <span class="math inline">\(\mathbf{b}_0,
\mathbf{b}_1, \dots, \mathbf{b}_n\)</span>
定义。具体而言，我们需要将控制点顺序连接（这样会有 <span class="math inline">\(n-1\)</span> 条边），在每条边上我们找到 <span class="math inline">\(t\)</span> 分点，得到一组新的点 <span class="math inline">\(\mathbf{b}^1_0, \mathbf{b}^1_1, \dots,
\mathbf{b}^1_{n-1}\)</span>。重复上述过程，直至生成唯一一个点 <span class="math inline">\(\mathbf{b}^n_0\)</span>。当 <span class="math inline">\(t\in[0,1]\)</span>
时，这个点就表示了贝塞尔曲线的运动轨迹。</p>
<p><img src="bezier.png" style="zoom:60%"></p>
<p>我们可以利用 <span class="math inline">\(\mathbf{b}^n_i =
(1-t)\mathbf{b}^{n-1}_i + t\mathbf{b}^{n-1}_{i+1}\)</span>
这一性质作金字塔式计算，不难得到这样一个结论</p>
<p><span class="math display">\[
\mathbf{b}^n(t) = \mathbf{b}^n_0(t) =
\sum\limits_{i=0}^n\mathbf{b}_iB^n_i(t)
\]</span></p>
<p>其中 <span class="math inline">\(B^n_i(t)=\left(\begin{matrix}n\\
i\end{matrix}\right)t^i(1-t)^{n-i}\)</span>，即二项分布多项式（<strong>伯恩斯坦多项式</strong>）。</p>
<p>贝塞尔曲线具备以下<strong>性质</strong>：</p>
<ol type="1">
<li>过起点 <span class="math inline">\(\mathbf{b}_0\)</span>（t=0）和终点 <span class="math inline">\(\mathbf{b}_n\)</span>（t=1）；</li>
<li>在 <span class="math inline">\(n=4\)</span>
时，曲线在起点和终点的切线满足：<span class="math inline">\(\mathbf{b}'(0)=3(\mathbf{b}_1-\mathbf{b}_0),\mathbf{b}'(1)=3(\mathbf{b}_3-\mathbf{b}_2)\)</span>；</li>
<li><strong>仿射相似性</strong>：对原始控制点作仿射变换后得到新控制点，再构造贝塞尔曲线
<span class="math inline">\(bc'\)</span>，和直接对原始贝塞尔曲线
<span class="math inline">\(bc\)</span>
作仿射变换所得到的结果是一样的。<u>投影变换不行</u>；</li>
<li><strong>凸包性质</strong>：贝塞尔曲线一定在所有控制点形成的凸包（能够包围一系列给定的几何形体的<strong>最小的凸多边形</strong>）内。如果所有控制点共线，那么对应的贝塞尔曲线是起点与终点形成的线段；</li>
</ol>
<p>🤷‍♂️
当控制点数量过多时，得到的贝塞尔曲线并不一定是我们想要的，甚至很难控制。</p>
<p><img src="highorderbc.png" style="zoom:60%"></p>
<p>此时可以若干个控制点为一组分别绘制贝塞尔曲线，再首尾相连即可。一般取
4 个为一组，也就是 <strong>Piecewise cubic
Bézier</strong>。这形成一种最简单的连续，是几何上的连续，一般称为 <span class="math inline">\(C^0\)</span> 连续。</p>
<p><img src="c0pbc.png" style="zoom:60%"></p>
<p>但为了使结果平滑过渡，我们需要利用<strong>性质
2</strong>，令分段点的左右切线相等。此时有三点共线，且分段点（中间的点）为线段中点，如下图所示。此时就称为
<span class="math inline">\(C^1\)</span> 连续。</p>
<p><img src="c1pbc.png" style="zoom:60%"></p>
<blockquote>
<p><span class="math inline">\(C^2\)</span>
连续则要保证二阶导连续，更高阶的连续性同理。</p>
</blockquote>
<h4 id="贝塞尔曲面bézier-surfaces">贝塞尔曲面(Bézier Surfaces)</h4>
<p>贝塞尔曲面其实就是通过贝塞尔曲线得到的。对于一个用 4*4
个点控制的贝塞尔曲面而言，可以将其 4 个控制点为一组分为 4 组。</p>
<p><img src="bs1.png"></p>
<p>每一组控制点得到一条横向的贝塞尔曲线 <span class="math inline">\(bc_i\)</span>，当 <span class="math inline">\(t\)</span> 相同时，四条曲线上的点 <span class="math inline">\(bc_i(t)\)</span>
四点共面，我们认为这四个点可以作为新的控制点，并绘制出一条纵向的贝塞尔曲线。</p>
<p><img src="bs2.png"></p>
<p>当 <span class="math inline">\(t\in[0,1]\)</span>
时，横向贝塞尔曲线的这四个点会逐渐扫过空间，那么这四个点控制的贝塞尔曲线在扫的过程中也就形成了最终我们想要的贝塞尔曲面。</p>
<p><img src="bs3.png" style="zoom:60%"></p>
<p>要找到贝塞尔曲面上任何一个点，根据上面的过程，需要两个不同的参数，在水平方向上找一个参数
<span class="math inline">\(t\)</span>，找到 4 个点后，这 4
个点要连成一条曲线，还需要一个参数 <span class="math inline">\(t\)</span>。所以需要用二维参数来控制，那不如管它叫
<span class="math inline">\(\mathbf{u}\mathbf{v}\)</span> 好了🤣。</p>
<h3 id="网格细分mesh-subdivision">网格细分(Mesh Subdivision)</h3>
<p>我们可以通过增加三角形的数量，使要表示的曲面更加光滑，看上去就像增大了图像的分辨率，可以看到更多细节的东西。</p>
<p><img src="meshsub.png" style="zoom:60%"></p>
<h4 id="loop-细分">loop 细分</h4>
<blockquote>
<p>loop 是人名，不是「循环」的意思。</p>
</blockquote>
<p>取三角形三条边的中点，依次相连，可以将三角形一分为四。接下来就可以通过调整顶点位置来修改三角形的位置。这里特殊的一点是，新顶点和旧顶点需要采用不同的规则。</p>
<p>对于<strong>新</strong>的顶点 <span class="math inline">\(P\)</span>，只要其所在边 <span class="math inline">\(AB\)</span> 不是物体边界，那么必定被两个三角形
<span class="math inline">\(\triangle{ABC}, \triangle{ABD}\)</span>
共享。此时需要将 <span class="math inline">\(P\)</span> 更新至 <span class="math inline">\(\displaystyle
\frac{3}{8}(A+B)+\frac{1}{8}(C+D)\)</span>，从而使得表面更加平滑。</p>
<p><img src="newvtx.png" style="zoom:60%"></p>
<p>对于<strong>旧</strong>的顶点 <span class="math inline">\(Q\)</span>，取其度 <span class="math inline">\(n\)</span> 以及一个相关的数 <span class="math inline">\(u\)</span>，对其自身与邻接点（旧）做一个加权平均，这样既能在度较低时尽可能保留本身的位置信息，也允许在度较大时完全由其它点来决定。</p>
<p><img src="oldvtx.png" style="zoom:60%"></p>
<h4 id="catmull-clark-subdivision">Catmull-Clark Subdivision</h4>
<p>loop
细分仅在三角形网格中适用，而如果存在一些网格面是四边形（对应一般的情况），就需要用到
Catmull-Clark 细分了。</p>
<blockquote>
<p>图灵奖得主提的算法。</p>
</blockquote>
<p>首先定义度不为 4 的点为<strong>奇异点</strong>，四边形平面为
<strong>quad face</strong>，其它为 <strong>non-quad face</strong>。</p>
<p>第一步进行细分，具体操作为：取 <strong>non-quad face</strong>
上的<strong>重心</strong>，与其每条边的中点进行连接。在此操作后，就不存在
<strong>non-quad face</strong> 点了，只是会引入等量的奇异点。</p>
<p><img src="ccs.png" style="zoom:60%"></p>
<p>第二步进行调整，依然是有不同规则，如下图。</p>
<p><img src="fyi.png" style="zoom:60%"></p>
<h3 id="网格简化mesh-simplification">网格简化(Mesh Simplification)</h3>
<p>游戏为提高性能，不希望顶点太多，顶点多了，顶点的变换、着色等要花更多的时间；并且如果某个物体距离很远，就不需要用很多三角形去把一些细节的东西建模出来。</p>
<p>总而言之，当我们不需要这么复杂的网格的时候，就可以减少网格数量，去掉一些边和三角形。</p>
<blockquote>
<p>但仍然要维持它们之间的相互关系，这就需要一定的方法。</p>
</blockquote>
<p><img src="meshsimp.png" style="zoom:60%"></p>
<h4 id="边坍缩edge-collapsing">边坍缩(Edge Collapsing)</h4>
<p>找一条边，将这条边两端的点缩到一起，这条边就不存在了。</p>
<p><img src="ec.png" style="zoom:60%"></p>
<p>怎么找边也是有讲究的。我们希望找到的这条边尽可能「<strong>不重要</strong>」，也就是将其坍缩后对物体的影响尽可能小。那么如何衡量所谓的「影响」呢，就要使用到<strong>二次度量误差(Quadric
Error Metrics)</strong>了。</p>
<p>令某条边坍缩后形成的新点 <span class="math inline">\(P\)</span>，那么
<span class="math inline">\(P\)</span>
到原本受影响面的距离平方和就是要求的二次度量误差。</p>
<p><img src="eq.png" style="zoom:60%"></p>
<p>我们不妨假设每条边坍缩后，将新点进行移动，总能移动到一个最优的位置，使得二次度量误差最小，那么可以将最小的二次度量误差值作为该边的<strong>坍缩分数</strong>（该值越大，就表示这条边坍缩后对物体的影响越大）。</p>
<p>在统计所有边的坍缩分数后，我们可以不断取坍缩分数最低的边进行坍缩，之后更新所有相关的边（或者说发生变化的边），重复上述步骤直至不再需要进行简化。</p>
<blockquote>
<p>这种方式是一个典型的贪心算法，通过不断对局部做最优解的方式试图找到一个全局的最优解。虽然不能保证有全局最优性质，但是结果不错。可以利用<strong>优先队列/堆</strong>来实现，能保证既快速取到最小值，又能动态的以最小的代价去更新其他的受影响的元素。</p>
</blockquote>
<h3 id="网格正则化mesh-regularization">网格正则化(Mesh
Regularization)</h3>
<p>如果三角形有大有小有细长，会对渲染造成不便，通常对于这种情况，会对模型做正则化，即让这些面变得更像正三角形。</p>
<p><img src="meshsreg.png" style="zoom:60%"></p>
<h2 id="光线追踪ray-tracing">光线追踪(Ray Tracing)</h2>
<p>光栅化本质上是一种快速，近似的渲染方法，质量相对较低，仅能处理局部着色点，并不能很好地处理全局效果，如<strong>软阴影(Soft
Shadow)</strong>、<strong>光泽反射(Glosyy
Reflection)</strong>、<strong>间接光照(Indirect
Illumination)</strong>等。通常用于<strong>实时</strong>的应用，如每秒生成超过
30 帧的图。</p>
<p>而<strong>光线追踪</strong>渲染准确，质量高，完全符合物理规律，能给大家带来最真实的渲染结果，缺点是非常慢。更多被用于做<strong>离线</strong>的应用，如电影生成。</p>
<h3 id="shadow-mapping">Shadow Mapping</h3>
<blockquote>
<p>在「着色」部分，我们谈到「Shading is
Local」，也就是没有考虑阴影，接下去就把这缺失但重要的部分给补上。</p>
</blockquote>
<p>我们先考虑点光源下如何生成阴影。如果将一个点和点光源相连，与其它物体产生交点，那说明该点被遮挡，在我们的视角里这个点会被打上阴影；如果这个点我们压根看不到，也就不用谈阴影的事了。</p>
<p>所以这里有一个很简单的思路：<strong>对于原始相机处所有可见的点，我们可以在点光源
<span class="math inline">\(L\)</span> 处对其进行观测，如果其在 <span class="math inline">\(L\)</span>
处不可见，说明光线没法到达这个点，那也就是在阴影里；反之正常着色</strong>。</p>
<p>判断一个点是否「能被光源相机看到」，可以直接在位置 <span class="math inline">\(L\)</span>
做一遍光栅化，就生成了所有光源会看到的点的深度信息。接着在原始位置再做一次光栅化，匹配可视点在
<span class="math inline">\(L\)</span>
处的深度，如果不一致，说明在阴影中，如下图红线；反之，可以被正常着色，如下图蓝线。</p>
<p><img src="shadowmapping.png" style="zoom:60%"></p>
<p>这种做法在判断「深度一致」方面存在<strong>浮点精度</strong>问题，毕竟判断两个浮点数相等是做不到的，虽然人们也引入了
<span class="math inline">\(a&gt;b+\text{bias}\)</span>
的方式，但不能从根本上解决问题。</p>
<p>同时，在点光源处做光栅化也会涉及到<strong>分辨率</strong>的问题。如果分辨率很低，但渲染整个场景的分辨率又很高，那就容易产生走样（场景多个点对应到同一个像素）；但分辨率太大的话开销就会大。</p>
<p>我们在对某个点进行判断时，仅仅是「非此即彼」的形式，要么在阴影中，要么不在阴影中，所以
Shadow Mapping 只能做<strong>硬阴影(Hard
Mapping)</strong>：阴影的边缘非常锐利。比如下面这样。</p>
<p><img src="hardshadow.png" style="zoom:60%"></p>
<p>与此相对的还有一个<strong>软阴影(Soft
Mapping)</strong>，它俩本质区别在于光源大小不同。如果光源非常大，那就会在物体背后形成「半影区」，此时就产生了软阴影：可以观察到阴影在逐渐过渡，越靠近物体根部越「硬」（本影区），反之越「虚」（半影区）。比如下面这样。</p>
<p><img src="softshadow.png" style="zoom:60%"></p>
<h3 id="基础光追算法">基础光追算法</h3>
<p>光线具有以下基本物理性质：</p>
<ol type="1">
<li>直线传播；</li>
<li>两条光线不会发生碰撞；</li>
<li>光路可逆；</li>
</ol>
<blockquote>
<p>早期有人认为人眼观察到物体这一现象，是因为眼睛会发出感知光线打到世界中，当光线被物体挡住时就看到了东西。</p>
</blockquote>
<p>上面这一说法，在现在看来显然是错误的认知，但可以为光追原理带来一点感性上的参考。实际上，光线追踪是<u>从相机/人眼出发，往世界中投射光线，然后不断弹射直到光源上的过程</u>。</p>
<h4 id="光线投射ray-casting与针孔相机模型pinhole-camera-model">光线投射(Ray
Casting)与针孔相机模型(Pinhole Camera Model)</h4>
<p>假设我们在往虚拟的世界中看，面前放了一个成像平面，成像平面上有很多像素的小格子。对于每个像素，可以从摄像机连一条线穿过这个像素，相当于打出去一根光线，这个光线会打到场景中的某个位置。</p>
<blockquote>
<p>事实上，这根光线会和很多物体相交，而物体之间会有遮挡关系，人眼看到的肯定是最近的，所以永远考虑这根光线和场景中的物体最近的交点。</p>
</blockquote>
<p>判断这个点是否在阴影里（与光源的连线(Shadow
Rays)是否会被阻挡），如果它不在阴影里，根据光路可逆性质，这就形成了一条有效的光路。最后通过计算这条光路的能量，进行相应的着色操作。</p>
<p><img src="pcm1.png" style="zoom:60%"></p>
<p><img src="pcm2.png" style="zoom:60%"></p>
<h4 id="递归算法whitted-style">递归算法(Whitted-Style)</h4>
<p>通过上面的方法可以得到和光栅化近似的结果，可这种方法狭隘地认为光线只反射一次——光线其实可以反射/折射很多次。对于更复杂的情况，可以用下面的算法实现。</p>
<p>Whitted-Style
的核心思想在于：<u>光线可以在空间中无限传播，只要你正确的算出来反射方向和折射方向</u>。</p>
<blockquote>
<p>如果一个点满足折射条件，那么光线投射到这点上就会发生折射，比如下面的球体（可以认为是一个玻璃球）。</p>
</blockquote>
<p><img src="ws.png" style="zoom:60%"></p>
<p>由于光线发生多次弹射，上图中的 4
个弹射点都需要计算一次着色值，并且该光线对应的像素值为空间中所有弹射点的着色值之和（需要考虑能量损失）。</p>
<h3 id="光线和物体表面交点ray-surface-intersection求解">光线和物体表面交点(Ray-Surface
Intersection)求解</h3>
<blockquote>
<p><strong>奇-偶规则(Odd-Even Rule)</strong>：从任意位置 <span class="math inline">\(p\)</span>
作一条射线，若与该射线相交的多边形边的数目为奇数，则 <span class="math inline">\(p\)</span> 是多边形内部点，否则是外部点。</p>
</blockquote>
<p>数学意义上讲，光线其实就是一条<strong>射线</strong>，有起点和单位方向向量，表示为
<span class="math inline">\(\mathbf{r}(t)=\mathbf{o}+t\mathbf{d}\)</span>。</p>
<p>其中</p>
<ul>
<li><span class="math inline">\(\mathbf{o}\)</span>：起点位置；</li>
<li><span class="math inline">\(t\)</span>：<strong>非负数</strong>，决定光线终点位置；</li>
<li><span class="math inline">\(\mathbf{d}\)</span>：方向向量；</li>
</ul>
<h4 id="隐式物体表面">隐式物体表面</h4>
<p>对于隐式物体表面 <span class="math inline">\(f(x, y,
z)=0\)</span>，欲求光线与其交点，其实就是求解方程</p>
<p><span class="math display">\[
f(\mathbf{o}+t\mathbf{d})=0
\]</span></p>
<p>解出 <span class="math inline">\(t\)</span> 后代入 <span class="math inline">\(\mathbf{r}(t)\)</span>
即可求出交点位置，并根据解的数量判断与物体的位置关系。</p>
<h4 id="显式物体表面">显式物体表面</h4>
<p>对于显式物体表面，要分情况讨论。</p>
<p>对于单个三角形而言，交点只有 0 个或 1
个。对于一个三角形而言，我们可以快速求出其<strong>法线</strong> <span class="math inline">\(\mathbf{N}\)</span>，假设交点为 <span class="math inline">\(\mathbf{p}=\mathbf{o}+t\mathbf{d}\)</span>，可以找到三角形所在平面上另一个确定的点
<span class="math inline">\(\mathbf{p'}\)</span>，必然满足 <span class="math inline">\((\mathbf{p}-\mathbf{p'})\mathbf{N}=0\)</span>。解得
<span class="math inline">\(\mathbf{p}\)</span>
后，可以用<strong>重心坐标</strong>判断是否在三角形内部。</p>
<blockquote>
<p>我们发现，光线与平面的交点 <span class="math inline">\(\mathbf{p}\)</span> 必然满足 <span class="math inline">\(\mathbf{p} =
b_1\mathbf{A}+b_2\mathbf{B}+(1-b_1-b_2)\mathbf{C}\)</span>，那么求解下面这个方程，就能把
<span class="math inline">\(t\)</span> 和重心坐标一起求出来，这就是
<strong>Möller–Trumbore 算法</strong>。</p>
<p><span class="math display">\[
\mathbf{o}+t\mathbf{d} =
b_1\mathbf{A}+b_2\mathbf{B}+(1-b_1-b_2)\mathbf{C}
\]</span></p>
<p>我们将上式进行一定改动，得到</p>
<p><span class="math display">\[
-t\mathbf{d} + b_1(\mathbf{A}-\mathbf{C}) + b_2(\mathbf{B}-\mathbf{C}) =
\mathbf{o} - \mathbf{C}
\]</span></p>
<p>不难发现这是一个关于 <span class="math inline">\(t, b_1, b_2\)</span>
的三元一次方程组，如果令</p>
<p><span class="math display">\[
\begin{aligned}
\mathbf{X} &amp;= -\mathbf{d}\\ \mathbf{Y} &amp;=
\mathbf{A}-\mathbf{C}\\ \mathbf{Z} &amp;= \mathbf{B}-\mathbf{C}\\
\mathbf{W} &amp;= \mathbf{o}-\mathbf{C}
\end{aligned}
\]</span></p>
<p>那么上式可以写作 <span class="math inline">\([\mathbf{X}, \mathbf{Y},
\mathbf{Z}]·[t, b_1, b_2]^T = \mathbf{W}\)</span>。</p>
<p>根据克莱姆法则，我们能够得到</p>
<p><span class="math display">\[
t = \det([\mathbf{W}, \mathbf{Y}, \mathbf{Z}])/\det([\mathbf{X},
\mathbf{Y}, \mathbf{Z}])
\]</span></p>
<p>又因为 <span class="math inline">\(\det(\mathbf{a}, \mathbf{b},
\mathbf{c}) = \mathbf{a}·(\mathbf{b}\times\mathbf{c})\)</span>，则 <span class="math inline">\(t\)</span> 易求，同理 <span class="math inline">\(b_1, b_2\)</span> 易求。</p>
</blockquote>
<p>对于若干个三角形构成的物体而言，如果一个个三角形去遍历判断，那就太慢了。现代化做法是用<strong>轴对齐包围盒(AABB)</strong>包裹该物体，如果一道光线连
AABB 都不会产生交点，那必然不会和物体产生交点。</p>
<p>考虑<strong>二维空间</strong>，所谓 AABB，实际上就是 2 对分别与 <span class="math inline">\(\mathbf{x},\mathbf{y}\)</span>
轴垂直的平面形成的交集。所以判断光线能否与 AABB
产生交点，可以先令其所在直线与每一对平面作交点，此时每一对平面会生成两个交点，这样就形成了一条线段。如果
2 条线段之间在 <span class="math inline">\(t\geq0\)</span>
时存在交集，则说明光线与 AABB 相交。</p>
<p><img src="riaabb.png" style="zoom:60%"></p>
<blockquote>
<p>使用 AABB 而不是任意平面是因为方便计算。</p>
</blockquote>
<p>那光线与 AABB
相交后，我们该如何判断光线与其内部的物体是否有交集呢？</p>
<h4 id="空间均匀切割uniform-spatial-partitions">空间均匀切割(Uniform
Spatial Partitions)</h4>
<p>该方法指的是将给定 AABB 划分为若干小的
AABB，并且将那些与物体表面相交的小 AABB
打上标记。在光线传播过程中，如果与某个打上标记的小 AABB
有交点，则认为可能与物体表面相交，需要进一步判断。</p>
<p><img src="usp.png" style="zoom:60%"></p>
<p>缺点是对于那些特别稀疏的场景而言，仍然需要较多的划分，并且需要找到一个划分疏密程度的平衡点。</p>
<h4 id="空间划分spatial-partitions">空间划分(Spatial Partitions)</h4>
<p>对于一个物体比较稀少的空间，我们希望减少划分；而如果物体比较密集，我们希望能尽可能细致地划分。</p>
<p>之前常用的划分方式有八叉树(Oct-Tree)、KD-Tree、BSP-Tree。如果一条光线与某个
AABB 有交点，那么认为它可能与该 AABB
的所有划分结果有交点，需要在一个树状结构中进行递归判断。</p>
<blockquote>
<p>我们知道，光线与包围盒空间求交点是非常迅速的，但是与物体表面求交点相对而言更加困难，所以我们应当尽可能减少「与物体表面求交」这一操作。</p>
<p>前两者都有两个共同的问题，第一个是<strong>物体可能存在于多个子空间中</strong>，比如一条光线可能经过多个子空间，而这些子空间都与同一个物体相交，那就需要对该物体进行多次交点求解。第二个是<strong>很难判定
AABB 是否和物体存在交集</strong>。</p>
<p>而后者则没有划分为轴平行包围盒，不便于计算。</p>
</blockquote>
<p><img src="sp.png" style="zoom:60%"></p>
<h4 id="物体划分object-partitions与-bounding-volume-hierarchybvh">物体划分(Object
Partitions)与 Bounding Volume Hierarchy(BVH)</h4>
<p>BVH
这种加速结构目前得到了非常广泛的应用，其本质思想在于：<u>对物体进行划分</u>。我们可以以一个大的
AABB 为起点，将其中的物体划分为两部分，分别计算这两部分的 AABB。如果某个
AABB 中的物体数量低于一定数量，那就停止；反之，继续以该 AABB
为起点进行递归的划分。</p>
<p><img src="bvh.png" style="zoom:60%"></p>
<p>这就解决了上面空间划分的两个问题。因为一旦确定了划分方式，其实就相当于确定了
BVH 的树状结构。在 BVH 中，一个叶子节点对应了一个
AABB，并且一个物体只会存在于一个叶子节点中，相当于确定了这个 AABB
与哪些物体存在交集。</p>
<blockquote>
<p>尽管这种方式会使得 AABB 之间存在交集，但这点开销 who cares？</p>
</blockquote>
<p>唯一需要考量的是<strong>如何划分物体</strong>。一个可取的思路是：<u>取中间的物体进行划分</u>，即找若干个数的中位数，可以用<strong>快速选择算法</strong>在
<span class="math inline">\(O(n)\)</span> 内完成。</p>
<blockquote>
<p>❗ 需要注意的是，无论是 BVH
还是空间划分，都是在做光线追踪之前的预处理操作，有了这个树状结构就可以在真正做光追时进行加速。如果场景是动态的、物体移动了、或者加了新物体，要重新去计算一个新的加速结构。</p>
</blockquote>
<p>BVH 的求解伪代码如下：</p>
<p><img src="bvhcode.png" style="zoom:60%"></p>
<h3 id="辐射度量学radiometry">辐射度量学(Radiometry)</h3>
<p>辐射度量学是一种方法，能定义一系列的属性和单位去描述光照。之前在
Blinn-Phong
模型中，我们有定义「光强」这么一个概念，但并没有明确给出其物理意义，这就是辐射度量学要说明的。接下来聊聊光照相关的两个基本属性。</p>
<ul>
<li><strong>辐射能量(Radiant Energy)</strong>：符号 <span class="math inline">\(Q\)</span>。单位<strong>焦耳</strong>(<span class="math inline">\(\text{J}\)</span>)；</li>
<li><strong>辐射通量(Radiant Flux)</strong>：定义为单位时间产生的能量
<span class="math inline">\(\displaystyle\Phi=\frac{dQ}{dt}\)</span>，常称<strong>功率</strong>。单位<strong>瓦特</strong>(<span class="math inline">\(\text{W}\)</span>)/<strong>流明</strong>(<span class="math inline">\(\text{lm}\)</span>)。也可定义为单位时间内通过某一平面的光子数量/光源的亮度；</li>
</ul>
<p>有了以上两个基本属性以后，就能对其进行拓展了。</p>
<h4 id="辐射强度intensity">辐射强度(Intensity)</h4>
<p>定义为<strong>点光源在单位立体角的辐射通量(Power Per Unit Solid
Angle)</strong>。</p>
<p>即 <span class="math inline">\(\displaystyle
I(\omega)=\frac{\text{d}\Phi}{\text{d}\omega}\)</span>，单位 <span class="math inline">\(\displaystyle
\frac{\text{W}}{\text{sr}}=\frac{\text{lm}}{\text{sr}}=\text{cd}/\text{candela}\)</span>。</p>
<p>那么什么是立体角呢？数学中的<strong>角(Angle)</strong>通常用弧度表示，对应一段圆的弧长，此时弧度为
<span class="math inline">\(\displaystyle\theta=\frac{l}{r}\)</span>。</p>
<p><img src="angle.png" style="zoom:60%"></p>
<p>而立体角则是会形成一个锥体，对应球体的表面，此时立体角度为 <span class="math inline">\(\displaystyle\Omega=\frac{A}{r^2}\)</span>。</p>
<p><img src="solidangle.png" style="zoom:60%"></p>
<blockquote>
<p>整个球的立体角为 <span class="math inline">\(4\pi r^2/r^2 =
4\pi\)</span></p>
</blockquote>
<p>有了这一概念，那么单位立体角的计算，就可以通过计算球表面单位面积来求解。如果我们引入了球体的
<span class="math inline">\(\theta,\phi\)</span>
表示，那么这就很简单了，如下图。</p>
<p><img src="da.png" style="zoom:60%"></p>
<blockquote>
<p>可以认为单位面积是一块矩形区域，其长为 <span class="math inline">\(d\theta\)</span> 对应的弧长，宽为 <span class="math inline">\(d\phi\)</span> 在半径为 <span class="math inline">\(r\sin\theta\)</span> 的圆中对应的弧长。</p>
<p>此时整个球的立体角也可以用下式进行计算</p>
<p><span class="math display">\[
\Omega=\displaystyle\int_{S^2}d\omega=\int_0^{2\pi}\int_0^\pi\sin\theta
d\theta d\phi = 4\pi
\]</span></p>
</blockquote>
<p>我们只需要确定某个光照方向 <span class="math inline">\(\omega\)</span> ，就可以用 <span class="math inline">\(\theta,\phi\)</span>
定义其位置，进而计算出对应的单位立体角。所以 intensity
也可以理解为<strong>光源在任意方向上的亮度</strong>。</p>
<p>假设光线从点光源处均匀辐射，那么任一方向上的 intensity
都是相同的，如果我们又预先知道了这个点光源的
flux（对应整个球面），就可以用以下式子计算出 intensity：</p>
<p><span class="math display">\[
\Phi = \int_{S^2}Id\omega = 4\pi I \longrightarrow I = \frac{\Phi}{4\pi}
\]</span></p>
<h4 id="辐射照度irradiance">辐射照度(Irradiance)</h4>
<p>定义为<strong>单位面积上的辐射通量(Power Per Unit
Area)</strong>。</p>
<p>即 <span class="math inline">\(\displaystyle
E(\mathbf{x})=\frac{\text{d}\Phi(\mathbf{x})}{\text{d}A}\)</span>，单位
<span class="math inline">\(\displaystyle\frac{\text{W}}{\text{m}^2}=\frac{\text{lm}}{\text{m}^2}=\text{lux}\)</span>。</p>
<blockquote>
<p>注意计算时必须用 Power 垂直于 Unit Area
的分量，就是前面「漫反射」提到的，需要与平面法线作夹角并乘上 <span class="math inline">\(\cos{\theta}\)</span>。也可以用太阳直射角与季节的关系来理解——夏季太阳几乎垂直入射到北半球，所以接收到能量就多，就会更热。</p>
</blockquote>
<p>之前我们聊 Blinn-Phong
模型的漫反射项时，提到「能量损耗」这么一个概念。基于上面提到的两个光照属性，我们发现对于一个点光源而言，随着半径的增大，intensity
其实是不会发生变化的，因为立体角是不变的。但是对于任意半径的球面而言，它们的
power 也是不变的，其实是 irradiance 发生了衰减。</p>
<p><img src="irradiancefalloff.png" style="zoom:60%"></p>
<h4 id="辐射亮度radiance">辐射亮度(Radiance)</h4>
<p>定义为<strong>投射到单位面积上的单位立体角上的辐射通量(Power Per Unit
Solid Angle, Per Projected Unit Area)</strong>。</p>
<p>即 <span class="math inline">\(\displaystyle\text{L}(\mathbf{p},
\omega)=\frac{\text{d}^2\Phi(\mathbf{p},
\omega)}{\text{d}\omega\text{d}A\cos\theta}\)</span>，单位 <span class="math inline">\(\displaystyle\frac{\text{W}}{\text{sr}\
\text{m}^2}=\frac{\text{lm}}{\text{sr}\
\text{m}^2}=\frac{\text{cd}}{\text{m}^2}=\text{nit}\)</span>。</p>
<p>这个概念可以和 intensity 和 irradiance
联系起来，既可以认为是投射到单位面积上的
intensity，也可以认为是某个点从单位立体角上接收到的 irradiance。</p>
<p>通常我们采用后者，也就是像下图这样，既然 irradiance 考虑的是点 <span class="math inline">\(\mathbf{p}\)</span> 从四面八方接收到的 power，那
radiance 就是只考虑其中的某个方向。</p>
<p><img src="radiance.png" style="zoom:60%"></p>
<h4 id="双向反射分布函数brdf-bidirectional-reflectance-distribution-function">双向反射分布函数(BRDF,
Bidirectional Reflectance Distribution Function)</h4>
<p>当光线打到某个点上时，会根据该点的属性，可能会吸收一部分能量，再形成特定的反射结果：如果这个点具有漫反射特性，那么会向四面八方均匀反射；如果这个点是镜面，那就会往法线的对称方向集中反射……如果能确定入射方向，那就需要某种数学方法来准确描述反射结果，这就是
BRDF 干的事情。</p>
<p>BRDF 定义了 irradiance
从某个单位立体角方向入射到单位面积上后，以怎样的结果向反射的立体角方向进行反射。</p>
<p><img src="brdf.png" style="zoom:60%"></p>
<p>也就是说 BRDF
将一个入射方向与一个反射方向建立了映射。如果我们对所有的入射方向都应用一遍反射方向
<span class="math inline">\(\omega_r\)</span> 的
BRDF，那是不是就能得出一个正确的反射结果了呢？是的没错，正是下式：</p>
<p><span class="math display">\[
L_r(\mathbf{p}, \omega_r) = \int_{\Omega^+}f_r(\mathbf{p},
\omega_i\rightarrow\omega_r)L_i(\mathbf{p},\omega_i)\cos\theta_i
\text{d}\omega_i
\]</span></p>
<p>上面这个方程称为<strong>反射方程(Reflection Equation)</strong>。</p>
<blockquote>
<p>从概念上来讲，反射方程考虑了任意入射方向的光照对反射方向的贡献，并将其累加。</p>
</blockquote>
<p>如果在此基础上考虑到物体本身会发光的情况，那就得到了<strong>渲染方程(Rendering
Equation)</strong>，如下式：</p>
<p><span class="math display">\[
L_r(\mathbf{p}, \omega_r) = L_e(\mathbf{p}, \omega_r)
+
\int_{\Omega^+}f_r(\mathbf{p},
\omega_i\rightarrow\omega_r)L_i(\mathbf{p},\omega_i)\cos\theta_i
\text{d}\omega_i
\]</span></p>
<blockquote>
<p>当然还要考虑「入射光不仅仅来自光源，也会来自其它物体表面的反射光」这么一种情况，那就是一个<strong>递归</strong>的解法了，即在点
<span class="math inline">\(\mathbf{p}\)</span>
处放置一个虚拟相机，观察其它物体表面的 <span class="math inline">\(L_r\)</span>。这是光线弹射一次的做法，那么弹射两次、三次、……做法也是类似的。</p>
</blockquote>
<h3 id="路径追踪path-tracing">路径追踪(Path Tracing)</h3>
<h4 id="蒙特卡洛积分monte-carlo-integration">蒙特卡洛积分(Monte Carlo
Integration)</h4>
<p>回顾一下微积分中的<strong>黎曼积分</strong>，它的基本思路是将函数图像分解为若干个矩形，求解该函数的定积分实际上就是求这些矩形的面积之和。</p>
<p>蒙特卡洛积分也参考了这一思路，但它的核心思路是<strong>随机采样</strong>。也就是说，对于积分域
<span class="math inline">\([a,b]\)</span>，我们认为变量 <span class="math inline">\(x\)</span> 在区间内满足一定概率分布 <span class="math inline">\(X_i\sim
p(x)\)</span>，我们只要不断地进行随机采样，求得采样值对应的函数值（可以认为是一个矩形面积值），那么定积分的结果可以认为是这些函数值的<strong>平均</strong>。用式子
<span class="math inline">\(\displaystyle
F_N=\frac{1}{N}\sum\limits_{i=1}^N\frac{f(X_i)}{p(X_i)}\)</span>
表示。其中 <span class="math inline">\(N\)</span> 为采样次数。</p>
<p><img src="mtkl.png" style="zoom:60%"></p>
<blockquote>
<p>对于一个在积分域服从均匀分布的变量来说，<span class="math inline">\(\displaystyle
p(X_i)=\frac{1}{b-a}\)</span>，那么定积分的结果就是 <span class="math inline">\(\displaystyle\frac{b-a}{N}\sum\limits_{i=1}^Nf(X_i)\)</span></p>
</blockquote>
<h4 id="用蒙特卡洛积分求解路径追踪">用蒙特卡洛积分求解路径追踪</h4>
<p>利用所学知识，我们就可以对渲染方程作特殊处理了。取点 <span class="math inline">\(\mathbf{p}\)</span>
所有单位入射方向（半球）构成向量集合，表示采样域。对该集合进行 <span class="math inline">\(N\)</span>
次随机采样，得到一个概率分布，代入蒙特卡洛积分求解即可。</p>
<p>此时可以认为光线在所有方向上都是等概率的，即入射方向/立体角满足均匀分布，则有
<span class="math inline">\(p(\omega_i) =
1/2\pi\)</span>（半球的立体角为 <span class="math inline">\(2\pi\)</span>）。如果我们额外考虑某一束入射光是来自光源还是其它物体表面
<span class="math inline">\(\mathbf{q}\)</span>
的反射光，就可以得到下面这个式子</p>
<p><span class="math display">\[
L_r(\mathbf{p},\omega_r)\approx
\begin{cases}
  \displaystyle\frac{1}{N}\sum\limits_{i=1}^N
\frac{f_r(\mathbf{p},\omega_i\rightarrow\omega_r)L_i(\mathbf{p},
\omega_i)\cos\theta_i}{p(\omega_i)} \qquad 点光源直射
  \\[2em]
  \displaystyle\frac{1}{N}\sum\limits_{i=1}^N
\frac{f_r(\mathbf{p},\omega_i\rightarrow\omega_r)L_r(\mathbf{q},
-\omega_i)\cos\theta_i}{p(\omega_i)} \quad\ 来自其它物体的反射
\end{cases}
\]</span></p>
<p>进而可以用以下伪代码来描述</p>
<p><img src="globalillumination.png" style="zoom:60%"></p>
<h4 id="优化1解决指数爆炸">优化1：解决指数爆炸</h4>
<p>这种做法存在一个问题，那就是当 <span class="math inline">\(N\)</span>
比较大的时候，如果只考虑光源直射，那就只需要作 N
次采样即可，为线性时间复杂度；但是如果考虑其它物体的反射，进行递归计算时，对应的时间复杂度就高达
<span class="math inline">\(O(N^{光线总反射次数})\)</span>。这显然是不可取的。</p>
<p><img src="ptp1.png" style="zoom:60%"></p>
<p>如果设置 <span class="math inline">\(N=1\)</span>，就叫<strong>路径追踪</strong>，可以解决上面的问题，只不过噪声大了点。但事实上我们要得到的是一整个像素的
radiance，而这个像素会对应多条 path，只要对这些 path
求平均就可以了。</p>
<p><img src="paths.png" style="zoom:60%"></p>
<p>我们可以在像素内均匀地取 <span class="math inline">\(N\)</span>
个不同的点，对于每个点，发射一条光线到场景中（区别于上面那个 <span class="math inline">\(N\)</span>），如果与物体产生交点，那就计算相应的着色。</p>
<p><img src="rg.png" style="zoom:60%"></p>
<p>这样就把路径追踪和着色联系在了一起。</p>
<blockquote>
<p>如果 <span class="math inline">\(N&gt;1\)</span>，就是<strong>分布式光线追踪</strong>，会出现指数爆炸。</p>
</blockquote>
<h4 id="优化2确定递归终点">优化2：确定递归终点</h4>
<p>完了吗？没有，还有一个问题，那就是如何确定递归终点。</p>
<p>这里可以使用<strong>俄罗斯轮盘赌(Russian
Roulette)</strong>的方式，即我们可以设置某个概率 <span class="math inline">\(P\)</span>，在采样反射光时，以概率 <span class="math inline">\(P\)</span> 进行采样，概率 <span class="math inline">\(1-P\)</span> 什么也不干，此时我们收集到的
<code>shade()</code> 结果需要除以 <span class="math inline">\(P\)</span>，使得期望不变。这样一来，上面
<code>shade()</code> 函数的伪代码就需要修正为下面这样。</p>
<p><img src="shaderr.png" style="zoom:60%"></p>
<h4 id="优化3在光源上采样">优化3：在光源上采样</h4>
<p>遗憾的是，上面的解法仍然存在问题，因为我们是在半球上随机取一个入射方向进行采样，运气成分就很大，可能没法取到一个恰好从光源入射的方向。此时就需要转换思路，可以在光源上采样。</p>
<p>但毕竟我们是把着色点为球心的单位球面作为积分域，如果要在光源上采样，那就需要把
<span class="math inline">\(\text{d}\omega\)</span> 转换成光源上的 <span class="math inline">\(\text{d}A\)</span>，再进行积分。</p>
<p>这很简单，因为采样光的方向相同，那么对应的单位立体角也是相同的，所以
<span class="math inline">\(\mathbf{x}'\)</span> 处的 intensity
和单位半球面上的 intensity 是相等的。考虑 <span class="math inline">\(\text{d}A\)</span> 的法线方向 <span class="math inline">\(\mathbf{n}'\)</span>，我们可以得到</p>
<p><span class="math display">\[
\text{d}\omega·{||\mathbf{x}'-\mathbf{x}||^2}=\text{d}A\cos\theta'
\Longrightarrow
\text{d}\omega=\frac{\text{d}A\cos\theta'}{||\mathbf{x}'-\mathbf{x}||^2}
\]</span></p>
<p><img src="samplethelight.png" style="zoom:60%"></p>
<p>这就把之前的所有知识都给串起来了。有了这一结论，渲染方程又可以进一步改为</p>
<p><span class="math display">\[
L_r(\mathbf{p}, \omega_r) = L_e(\mathbf{p}, \omega_r)
+
\int_{A}f_r(\mathbf{p},
\omega_i\rightarrow\omega_r)L_i(\mathbf{p},\omega_i)\frac{\cos\theta\cos\theta'}{||\mathbf{x}'-\mathbf{x}||^2}
\text{d}A
\]</span></p>
<p>此时点光源直射的情况就不需要用 RR
来处理递归终点了，因为我们只需要一次采样就够了。考虑到着色点与点光源直接可能存在其它物体遮挡，伪代码可以进一步优化为下面这样：</p>
<pre class="line-numbers language-python" data-language="python"><code class="language-python">shade<span class="token punctuation">(</span>p<span class="token punctuation">,</span> wo<span class="token punctuation">)</span>
  <span class="token comment">## Contribution from the light source.</span>
  Uniformly sample the light at x’ <span class="token punctuation">(</span>pdf_light <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> A<span class="token punctuation">)</span>
  Shoot a ray <span class="token keyword">from</span> p to x’
  If the ray <span class="token keyword">is</span> <span class="token keyword">not</span> blocked <span class="token keyword">in</span> the middle
    L_dir <span class="token operator">=</span> L_i <span class="token operator">*</span> f_r <span class="token operator">*</span> cos θ <span class="token operator">*</span> cos θ’ <span class="token operator">/</span> <span class="token operator">|</span>x’ <span class="token operator">-</span> p<span class="token operator">|</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">/</span> pdf_light

  <span class="token comment">## Contribution from other reflectors.</span>
  L_indir <span class="token operator">=</span> <span class="token number">0.0</span>
  Test Russian Roulette <span class="token keyword">with</span> probability P_RR
  Uniformly sample the hemisphere toward wi <span class="token punctuation">(</span>pdf_hemi <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> 2pi<span class="token punctuation">)</span>
  Trace a ray r<span class="token punctuation">(</span>p<span class="token punctuation">,</span> wi<span class="token punctuation">)</span>
  If ray r hit a non<span class="token operator">-</span>emitting <span class="token builtin">object</span> at q
    L_indir <span class="token operator">=</span> shade<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token operator">-</span>wi<span class="token punctuation">)</span> <span class="token operator">*</span> f_r <span class="token operator">*</span> cos θ <span class="token operator">/</span> pdf_hemi <span class="token operator">/</span> P_RR
  Return L_dir <span class="token operator">+</span> L_indir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>GAMES101 的难度在此已经到达峰值了，接下去就简单很多。</p>
</blockquote>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">这个人太懒了，都不想加标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/lab/games101lab/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="现代图形学入门（GAMES101）の 作业记录">
                        
                        <span class="card-title">现代图形学入门（GAMES101）の 作业记录</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            &gt;&gt;&gt; Github
传送门&lt;&lt;&lt;
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2024-04-19
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Lab/" class="post-category">
                                    Lab
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/computer-network/tcpthings/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="TCP Things">
                        
                        <span class="card-title">TCP Things</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            聊聊传输控制协议(TCP, Transmission Control
Protocol)。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2024-03-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Computer-Network/" class="post-category">
                                    Computer Network
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Leager</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "8";
                        var startDate = "1";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Leager-zju" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1004729740@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1004729740" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1004729740" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "http://Leager-zju.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <script type="text/javascript">
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                document.title = '你会有一天后悔';
            } else {
                document.title = '欢迎来到 G8 北海道 洞爷湖 高峰会 博物馆';
            }
        });
    </script>

</body>

</html>
