<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="C++11 の 并发支持(Concurrency), 没什么看头的地方">
    <meta name="description" content="C++11 新增了官方并发支持库，使得我们能够更好地在系统间移植程序，之前的 Boost 库等也就随之成为历史了。

#并发与并行
多线程的世界中，常常会涉及这俩重要概念。
从定义的角度来说，在操作系统中，并发是指一个时间段中有几个程序都处">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>C++11 の 并发支持(Concurrency) | 没什么看头的地方</title>
    <link rel="icon" type="image/png" href="/dt.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    


    <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css">

    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/comment_bg.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">没什么看头的地方</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/comment_bg.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">没什么看头的地方</div>
        <div class="logo-desc">
            
            【数据删除】
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/Leager-zju" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/Leager-zju" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">C++11 の 并发支持(Concurrency)</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                          <div class="article-tag">
                            <span class="chip bg-color">这个人太懒了，都不想加标签</span>
                          </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/C/" class="post-category">
                                C++
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2023-01-29
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        
        <!-- 是否加载使用自带的 prismjs. -->
        <link rel="stylesheet" href="/libs/prism/prism.min.css">
        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>C++11 新增了官方<strong>并发支持库</strong>，使得我们能够更好地在系统间移植程序，之前的 Boost 库等也就随之成为历史了。</p>
<span id="more"></span>
<h2 id="%E5%B9%B6%E5%8F%91%E4%B8%8E%E5%B9%B6%E8%A1%8C" tabindex="-1"><a class="header-anchor" href="#并发与并行">#</a>并发与并行</h2>
<p>多线程的世界中，常常会涉及这俩重要概念。</p>
<p>从定义的角度来说，在操作系统中，<strong>并发</strong>是指一个时间段中有几个程序都处于已启动运行到运行完毕之间，且这几个程序都是在同一个处理机上运行，但任一个时刻点上只有一个程序在处理机上运行；而<strong>并行</strong>指的是一组程序按独立异步的速度执行，无论从微观还是宏观，程序都是一起执行的。 （抄自百科）</p>
<p>用自己的语言描述：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p>只会先把饭吃完，再把菜吃完，这叫<strong>单线程</strong>行为；</p>
</li>
<li class="lvl-2">
<p>先扒拉几口饭，再夹点菜，再吃饭，以这一时间段为单位，两个行为看似一起进行，但任意时刻却又不同时发生，存在资源（嘴巴）的调度，这叫<strong>并发</strong>；</p>
</li>
<li class="lvl-2">
<p>嘴巴里既嚼饭又嚼菜的，即同时吃饭吃菜，有能力同时处理多件事，这叫<strong>并行</strong>；</p>
</li>
</ul>
<p>综上所述，<strong>并发</strong>与<strong>并行</strong>的最主要区别，就在于各个线程是否能够"同时"进行。</p>
<h2 id="%E5%B9%B6%E5%8F%91%E6%94%AF%E6%8C%81%E5%BA%93" tabindex="-1"><a class="header-anchor" href="#并发支持库">#</a>并发支持库</h2>
<p>并发支持库与 boost 很像，主要包含以下 5 个头文件。</p>
<h3 id="%3C-thread-%3E" tabindex="-1"><a class="header-anchor" href="#thread">#</a>&lt; thread &gt;</h3>
<blockquote>
<p>此头文件中定义了 <code>std::thread</code> 以及访问当前执行线程的函数 <code>std::this_thread</code></p>
</blockquote>
<h4 id="std%3A%3Athread" tabindex="-1"><a class="header-anchor" href="#std-thread">#</a>std::thread</h4>
<p>该类管理<strong>单个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Thread_(computing)">执行线程</a></strong>，并对外提供 api。</p>
<p>首先讲下<strong>初始化方式</strong>。由于每个线程都是一个独立的执行单位，故不存在两个同样的执行线程，那么<strong>拷贝构造</strong>与<strong>拷贝赋值</strong>因此被<strong>弃置</strong>(<code>delete</code>)。除此之外，其初始化方式共有四种重载形式：</p>
<table>
<thead>
<tr>
<th style="text-align:center">重载形式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>thread() noexcept</code></td>
<td style="text-align:center"><strong>默认构造函数</strong>。构造<strong>不</strong>关联执行线程的新 thread 对象。</td>
</tr>
<tr>
<td style="text-align:center"><code>thread( thread&amp;&amp; other ) noexcept</code></td>
<td style="text-align:center"><strong>移动构造函数</strong>。将 <code>other</code> 所关联的执行线程的资源转移，此后 <code>other</code> <strong>不</strong>关联任何执行线程。</td>
</tr>
<tr>
<td style="text-align:center"><code>thread&amp; operator=( thread&amp;&amp; other ) noexcept</code></td>
<td style="text-align:center"><strong>移动赋值运算符</strong>。若当前对象此时拥有关联的运行中线程（即 <code>joinable() == true</code> ），则调用 <code>std::terminate()</code>。</td>
</tr>
<tr>
<td style="text-align:center"><code>template&lt; class Func, class... Args &gt; explicit thread( Func&amp;&amp; f, Args&amp;&amp;... args )</code></td>
<td style="text-align:center"><strong>初始化构造函数</strong>。thread 创建并关联一个新的执行线程，开始执行可调用对象 <code>f</code>，相应参数也一并给出。</td>
</tr>
</tbody>
</table>
<p>接下来是其<strong>成员函数</strong>：</p>
<ol>
<li class="lvl-3">
<p><code>get_id()</code>：任何关联执行线程的 thread 对象均有一个唯一标识线程的对象 <code>id</code>。若当前对象存在关联的执行线程，则返回其 <code>id</code>；反之，输出 “<strong>thread::id of a non-executing thread</strong>”；</p>
</li>
<li class="lvl-3">
<p><code>join()</code>：阻塞当前线程直至 thread 对象关联的线程运行完毕。当前线程的 <code>id</code> 不能与 thread 的 <code>id</code> 相同，否则出现死锁（自己等自己）。并且，thread 自身不进行同步。同时从多个线程在同一 thread 对象上调用 <code>join()</code> 构成数据竞争，导致 <strong>UB</strong>；</p>
</li>
<li class="lvl-3">
<p><code>joinable()</code>：判断当前 thread 是否可以 join，即是否关联<strong>活跃</strong>的执行线程。简单来说，就是<strong>是否正在执行</strong>。结束执行但未 join 的 thread 也视为 <strong>joinable</strong>。由默认构造函数生成的 thread 对象 <code>joinable() == false</code>；</p>
</li>
<li class="lvl-3">
<p><code>detach()</code>：从 thread 对象分离执行线程，允许其独立执行。线程结束后，才释放资源。分离后，thread 也就不再关联任何执行对象了，既无法 <code>get_id()</code>，也无法 <code>join()</code>；</p>
<blockquote>
<p>考虑这样一种情况：</p>
<p>若 thread 关联的线程执行周期比 thread 对象生命周期还长，则当 thread 周期结束后调用析构函数删除资源时，如果没有调用 <code>join()</code> 或 <code>detach()</code>，此时线程仍在运行，则会出大问题。</p>
<p>所以要么用 <code>join()</code> 来阻塞当前线程防止过早结束，要么用 <code>detach()</code> 进行线程与 thread 对象的分离。</p>
<p>当然，也可以进一步封装 thread，在析构函数中调用 <code>join()</code> / <code>detach()</code> 操作，就不会出现上述情况了。</p>
</blockquote>
</li>
<li class="lvl-3">
<p><code>native_handler()</code>：返回实现线程句柄，实现实时调度。</p>
</li>
<li class="lvl-3">
<p><code>[static] hardware_concurrency()</code>：静态方法，返回实现支持的并发线程数。</p>
</li>
</ol>
<p>下面用具体代码进行演示。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>thread</span></div><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Thread "</span> <span class="token operator">&lt;&lt;</span> n <span class="token operator">&lt;&lt;</span> <span class="token string">" executing\n"</span><span class="token punctuation">;</span>
  this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  thread t1<span class="token punctuation">;</span>
  thread <span class="token function">t2</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  thread <span class="token function">t3</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  thread <span class="token function">t4</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>t3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  cout <span class="token operator">&lt;&lt;</span> boolalpha
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t1 id: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t1<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t2 id: "</span> <span class="token operator">&lt;&lt;</span> t2<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t2<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t3 id: "</span> <span class="token operator">&lt;&lt;</span> t3<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t3<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span>
       <span class="token operator">&lt;&lt;</span> <span class="token string">"t4 id: "</span> <span class="token operator">&lt;&lt;</span> t4<span class="token punctuation">.</span><span class="token function">get_id</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">", joinable: "</span> <span class="token operator">&lt;&lt;</span> t4<span class="token punctuation">.</span><span class="token function">joinable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token string">"\n"</span><span class="token punctuation">;</span>

  t2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  t4<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">/*
 * output:
 * Thread 3 executing
 * Thread 2 executing
 * t1 id: thread::id of a non-executing thread, joinable: false
 * t2 id: 2, joinable: true
 * t3 id: thread::id of a non-executing thread, joinable: false
 * t4 id: 3, joinable: true
 */</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std%3A%3Athis_thread" tabindex="-1"><a class="header-anchor" href="#std-this-thread">#</a>std::this_thread</h4>
<p>这实际上是 <code>std</code> 下的一个命名空间，用来表示当前线程。</p>
<p>该命名空间下有以下常用成员函数：</p>
<ol>
<li class="lvl-3">
<p><code>get_id()</code>：获取当前线程 <code>id</code>；</p>
</li>
<li class="lvl-3">
<p><code>yield()</code>：让出 CPU 资源；</p>
</li>
<li class="lvl-3">
<p><code>sleep_for()</code>：当前线程主动睡眠指定时间后醒来。<strong>函数原型</strong>为</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Period</span> <span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sleep_for</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> time<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
<li class="lvl-3">
<p><code>sleep_until()</code>：当前线程主动睡眠，直至指定时刻。<strong>函数原型</strong>为</p>
 <pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">typename</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Duration</span> <span class="token operator">&gt;</span>
<span class="token keyword">inline</span> <span class="token keyword">void</span> <span class="token function">sleep_until</span><span class="token punctuation">(</span><span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> time<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
</li>
</ol>
<h3 id="%3C-mutex-%3E" tabindex="-1"><a class="header-anchor" href="#mutex">#</a>&lt; mutex &gt;</h3>
<blockquote>
<p>此头文件中定义了各种互斥锁如 <code>std::mutex</code>，<code>std::lock_guard</code>，<code>std::unique_lock</code> 等</p>
</blockquote>
<h4 id="std%3A%3Amutex" tabindex="-1"><a class="header-anchor" href="#std-mutex">#</a>std::mutex</h4>
<p>mutex，全称 <strong>mutual exclusion</strong>(互斥体)，用于保护共享数据的<strong>互斥</strong>访问，也就是常说的<strong>锁</strong>。mutex 相当于一种独占性的资源，仅有 <code>lock</code> / <code>try_lock</code>（获取该资源）与 <code>unlock</code>（释放该资源）两种操作，其余各种锁都是围绕 mutex 进行封装与变形，故这些锁的<strong>拷贝构造函数</strong>与<strong>拷贝赋值运算符</strong>被<strong>弃置</strong>。其<strong>主要特性</strong>如下：</p>
<ul class="lvl-0">
<li class="lvl-2">
<p><strong>调用方</strong>线程从它成功调用 <code>lock</code> / <code>try_lock</code> 开始，到它调用 unlock 为止占有 mutex；</p>
</li>
<li class="lvl-2">
<p>任一其它线程占有 mutex 时，当前线程若试图通过 <code>lock</code> / <code>try_lock</code> 要求获得 mutex 的所有权，则阻塞，直至<strong>占有方</strong>通过 <code>unlock</code> 释放 mutex；</p>
</li>
<li class="lvl-2">
<p>调用方线程在 <code>lock</code> / <code>try_lock</code> 前必须不占有 mutex，否则为 <strong>UB</strong>；</p>
</li>
</ul>
<p>就<strong>初始化方式</strong>而言，直接通过<strong>默认构造函数</strong>进行创建互斥锁对象，创建后锁处于<strong>未锁定</strong>状态。</p>
<p>mutex 类是所有锁的基础，其<strong>成员函数</strong>只有三个，都是基于之前讨论的特性：</p>
<ol>
<li class="lvl-3">
<p><code>lock()</code>：尝试锁定 mutex；</p>
</li>
<li class="lvl-3">
<p><code>try_lock()</code>：尝试锁定 mutex，成功获得锁时返回 <code>true</code> ，否则返回 <code>false</code>；</p>
</li>
<li class="lvl-3">
<p><code>unlock()</code>：释放 mutex；</p>
</li>
</ol>
<h4 id="std%3A%3Atimed_mutex" tabindex="-1"><a class="header-anchor" href="#std-timed-mutex">#</a>std::timed_mutex</h4>
<p>在 mutex 基础上，timedMutex 添加了<strong>超时语义</strong>，相关成员函数为：</p>
<ol>
<li class="lvl-3">
<p><code>try_lock_for( time )</code>：尝试获取锁，若一段时间 time 后超时未获得锁则放弃；</p>
</li>
<li class="lvl-3">
<p><code>try_lock_until( time )</code>：尝试获取锁，若指定时刻 time 后超时未获得锁则放弃；</p>
</li>
</ol>
<p>以上两个函数都会在成功时返回 <code>true</code>，失败时返回 <code>false</code>。</p>
<h4 id="std%3A%3Arecursively_mutex" tabindex="-1"><a class="header-anchor" href="#std-recursively-mutex">#</a>std::recursively_mutex</h4>
<p>以上两种锁都无法重复获取，即已占有 mutex 的线程继续 <code>lock</code> / <code>try_lock</code> 会发生 UB。在 mutex 基础上，recursivelyMutex 添加了<strong>递归语义</strong>，即允许线程多次上锁，并在释放相等次数的锁后结束（好比左右括号匹配）。其成员函数与 mutex 一致。</p>
<h4 id="std%3A%3Arecursively_timed_mutex" tabindex="-1"><a class="header-anchor" href="#std-recursively-timed-mutex">#</a>std::recursively_timed_mutex</h4>
<p><strong>省流</strong>：recursivelyMutex + timedMutex</p>
<h4 id="std%3A%3Alock()-%26-std%3A%3Atry_lock()" tabindex="-1"><a class="header-anchor" href="#std-lock-std-try-lock">#</a>std::lock() &amp; std::try_lock()</h4>
<p>除了各个锁类以外，&lt;mutex&gt; 头文件下还定义了两个全局函数 <code>std::lock()</code> 与 <code>std::try_lock()</code>，提供了通用的<strong>一次性加多个锁</strong>的方法。<strong>函数原型</strong>如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Lockable1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lockable2</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LockableN <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">lock</span><span class="token punctuation">(</span> Lockable1<span class="token operator">&amp;</span> lock1<span class="token punctuation">,</span> Lockable2<span class="token operator">&amp;</span> lock2<span class="token punctuation">,</span> LockableN<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lockn <span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Lockable1</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Lockable2</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> LockableN <span class="token operator">&gt;</span>
<span class="token keyword">int</span> <span class="token function">try_lock</span><span class="token punctuation">(</span> Lockable1<span class="token operator">&amp;</span> lock1<span class="token punctuation">,</span> Lockable2<span class="token operator">&amp;</span> lock2<span class="token punctuation">,</span> LockableN<span class="token operator">&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> lockn <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>std::lock()</code> 为阻塞式加锁，<code>std::try_lock()</code> 为异步式加锁，它俩其实是去调用每种 lockable 对象，即 mutex 自身的方法，然后加锁，并且不会因为不同线程上锁顺序不同而死锁，这是因为一旦上锁失败，则不再推进，而对所有已上锁的 mutex 调用 <code>unlock()</code>，然后再次重复尝试，直至所有 mutex 都已上锁。</p>
<h4 id="std%3A%3Alock_guard" tabindex="-1"><a class="header-anchor" href="#std-lock-guard">#</a>std::lock_guard</h4>
<p>对于不加超时语义的 mutex 而言，需要程序员主动上锁解锁，但如果某线程在 unlock 之前就因为抛出异常而被迫终止，那么其持有的 mutex 就永远无法释放，所有等待该资源的线程也就陷入了无尽的阻塞中，这显然是不可用的。并且这样的手动释放要求我们在所有执行体的出口都要解锁，也增加了不必要的代码量。</p>
<p><code>lock_guard</code> 应用了 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/34660259">RAII 技术</a>，其将 mutex 进一步封装，并在构造/析构函数中进行资源的分配/释放，这样就不会出现上述问题——因为一旦线程退出，其所有资源都会被释放，那么必然会调用析构函数，进行解锁，防止线程由于编码失误导致一直持有锁。</p>
<blockquote>
<p>这样一来，就不能用同一个 mutex 对象来初始化两个不同的 lock_guard 对象了，否则会出现<strong>死锁</strong>，下面几个锁也是如此。</p>
</blockquote>
<p>其类定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Mutex</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">lock_guard</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> mutex_type <span class="token operator">=</span> Mutex<span class="token punctuation">;</span>

  <span class="token keyword">explicit</span> <span class="token function">lock_guard</span><span class="token punctuation">(</span>mutex_type<span class="token operator">&amp;</span> m<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span> m_<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token function">lock_guard</span><span class="token punctuation">(</span>mutex_type<span class="token operator">&amp;</span> m<span class="token punctuation">,</span> adopt_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 线程拥有锁时调用此构造函数</span>

  <span class="token operator">~</span><span class="token function">lock_guard</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> m_<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>

  <span class="token function">lock_guard</span><span class="token punctuation">(</span><span class="token keyword">const</span> lock_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  lock_guard<span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> lock_guard<span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  mutex_type<span class="token operator">&amp;</span>  m_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>两种构造函数区别在于：第一种在构造时上锁；而第二种重载形式形参中的 <code>adopt_lock_t</code> 为空结构体类型，表示<strong>构造模式</strong>，即<strong>假设调用方线程已拥有 mutex 的所有权</strong>，以此种方式进行构造时不会上锁。<code>std</code> 命名空间下已为我们实现了名为 <code>adopt_lock</code> 的全局变量，故可以用以下方式进行初始化：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>mutex a<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>lock_guard <span class="token function">b</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token comment">// 构造后 a 上锁</span>

a<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment">// 这句没有就报错</span>
std<span class="token double-colon punctuation">::</span>lock_guard <span class="token function">c</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> adopt_lock<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 告知 a 已上锁，此时用这种初始化方式</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>下面还会讲另外两种上锁模式，也是同理的。</p>
<h4 id="std%3A%3Aunique_lock" tabindex="-1"><a class="header-anchor" href="#std-unique-lock">#</a>std::unique_lock</h4>
<p>顾名思义，unique_lock 是独占性的，故不存在两个 unique_lock 对应同一个 mutex 对象，故<strong>移动构造函数</strong>与<strong>移动赋值运算符</strong>得到了实现，方便转移资源。</p>
<p>类定义如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Mutex</span><span class="token operator">&gt;</span>
<span class="token keyword">class</span> <span class="token class-name">unique_lock</span> <span class="token punctuation">{</span>
 <span class="token keyword">public</span><span class="token operator">:</span>
  <span class="token keyword">using</span> mutex_type <span class="token operator">=</span> Mutex<span class="token punctuation">;</span>

  <span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span><span class="token keyword">nullptr</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">explicit</span> <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    own_ <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 支持三种上锁模式</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> defer_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> try_to_lock_t<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>m_<span class="token operator">-&gt;</span><span class="token function">try_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> adopt_lock_t<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token comment">// 超时语义</span>
  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Duration</span><span class="token operator">&gt;</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> <span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>time<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>m_<span class="token operator">-&gt;</span><span class="token function">try_lock_until</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">template</span> <span class="token operator">&lt;</span><span class="token keyword">typename</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">typename</span> <span class="token class-name">Period</span><span class="token operator">&gt;</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>mutex_type <span class="token operator">&amp;</span>m_<span class="token punctuation">,</span> <span class="token keyword">const</span> chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span> <span class="token operator">&amp;</span>time<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">__addressof</span><span class="token punctuation">(</span>m_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>m_<span class="token operator">-&gt;</span><span class="token function">try_lock_for</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token operator">~</span><span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>own_<span class="token punctuation">)</span>
      <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 拷贝被弃置</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_lock <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>
  unique_lock <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">const</span> unique_lock <span class="token operator">&amp;</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">delete</span><span class="token punctuation">;</span>

  <span class="token comment">// 移动被实现</span>
  <span class="token function">unique_lock</span><span class="token punctuation">(</span>unique_lock <span class="token operator">&amp;&amp;</span>u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token operator">:</span> <span class="token function">m_</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>m_<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">own_</span><span class="token punctuation">(</span>u<span class="token punctuation">.</span>own_<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    u<span class="token punctuation">.</span>m_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    u<span class="token punctuation">.</span>own_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  unique_lock <span class="token operator">&amp;</span><span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span>unique_lock <span class="token operator">&amp;&amp;</span>u<span class="token punctuation">)</span> <span class="token keyword">noexcept</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>own_<span class="token punctuation">)</span>
      <span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unique_lock</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    u<span class="token punctuation">.</span>m_ <span class="token operator">=</span> <span class="token keyword">nullptr</span><span class="token punctuation">;</span>
    u<span class="token punctuation">.</span>own_ <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token operator">*</span><span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

 <span class="token keyword">private</span><span class="token operator">:</span>
  mutex_type <span class="token operator">*</span>m_<span class="token punctuation">;</span>
  <span class="token keyword">bool</span> own_<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>unique_lock 在 lock_guard 基础上添加了超时语义，并且支持另外两种<strong>上锁模式</strong>：</p>
<ol>
<li class="lvl-3">
<p><code>defer_lock_t</code>：不上锁；</p>
</li>
<li class="lvl-3">
<p><code>try_lock_t</code>：尝试上锁，而不阻塞；</p>
</li>
</ol>
<p>除此以外，<code>unique_lock</code> 还提供了 <code>lock()</code>，<code>unlock()</code>，<code>try_lock()</code>，<code>try_lock_for()</code>，<code>try_lock_until()</code> 这几个 api，并能通过调用 <code>release()</code> 解绑所拥有的锁对象。</p>
<p>为了支持上述功能，类中新添加了变量 <code>own_</code> 来判断当前是否持有锁，并且 mutex 对象改为了指针类型，以便判断当前是否存在绑定的 mutex。</p>
<blockquote>
<p>lock_gurad 相比于 unique_lock 更轻量，但因为 unique_lock 类可以手动解锁，所以<strong>条件变量</strong>都搭配 unique_lock 一起使用，因为条件变量在 wait 时需要有手动解锁的能力。</p>
</blockquote>
<h4 id="std%3A%3Acall_once()" tabindex="-1"><a class="header-anchor" href="#std-call-once">#</a>std::call_once()</h4>
<p>此函数保证某一函数在多线程环境中只调用一次，它需要配合 <code>std::once_flag</code> 使用。<strong>函数原型</strong>为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Callable</span><span class="token punctuation">,</span> <span class="token keyword">class</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Args <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">call_once</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>once_flag<span class="token operator">&amp;</span> flag<span class="token punctuation">,</span> Callable<span class="token operator">&amp;&amp;</span> f<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>若 <code>flag == true</code>，则直接返回；反之，利用 <code>std::forward</code> 调用 <code>f</code>，且仅当正常返回时将 <code>flag</code> 由 <code>false</code> 改为 <code>true</code>。具体代码如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

once_flag flag<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">call_once</span><span class="token punctuation">(</span>flag<span class="token punctuation">,</span> <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token string">" call\n"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  thread threads<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    threads<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">thread</span><span class="token punctuation">(</span>func<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">auto</span><span class="token operator">&amp;</span> t <span class="token operator">:</span> threads<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// output: 0 call</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="%3C-atomic-%3E" tabindex="-1"><a class="header-anchor" href="#atomic">#</a>&lt; atomic &gt;</h3>
<blockquote>
<p>此头文件中定义了原子变量 <code>std::atomic&lt;T&gt;</code>，以及其各种特化 <code>std::atomic_int</code>，<code>std::atomic_bool</code> 等</p>
</blockquote>
<h4 id="std%3A%3Aatomic" tabindex="-1"><a class="header-anchor" href="#std-atomic">#</a>std::atomic</h4>
<p>考虑这样一个情况：存在一整型变量 <code>x = 0</code>，现在有两个线程 A, B 分别对其执行加 1 与 减 1 的操作，这些操作可以归结为两步原子操作：</p>
<ol>
<li class="lvl-3">
<p>读取变量值；</p>
</li>
<li class="lvl-3">
<p>加/减该值，赋值给原变量；</p>
</li>
</ol>
<p>如果不加以限制，可能会出现 <strong>Write-After-Read</strong>, <strong>Write-After-Write</strong> 的情况，+则 x 最终的结果可能是 -1, 0, 1 这三种，这取决于线程每一步原子操作之间的执行顺序。</p>
<p>我们希望最终结果是<strong>确定性</strong>的，就需要严格控制线程同步，一个很好的考虑是使用前面提到的 mutex，代码可以写为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">lock_guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  x<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span><span class="token function">lock_guard</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  x<span class="token operator">--</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>而如果使用<strong>原子变量</strong>，则代码可以简化为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>atomic<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> <span class="token function">x</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// or std::atomic_int x(0)</span>
<span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
<p>事实上，原子变量能帮助我们自动控制线程之间的同步，保证加/减等操作的原子性——若一个线程写入原子对象，同时另一线程从它读取，则行为良好定义。</p>
<h3 id="%3C-condition_variable-%3E" tabindex="-1"><a class="header-anchor" href="#condition-variable">#</a>&lt; condition_variable &gt;</h3>
<h4 id="std%3A%3Acondition_variable" tabindex="-1"><a class="header-anchor" href="#std-condition-variable">#</a>std::condition_variable</h4>
<p><code>condition_variable</code> 是利用线程间共享的<strong>全局变量</strong>进行<strong>同步</strong>的一种机制，能用于阻塞一个或多个线程（或称使其等待(<strong>wait</strong>)），直至另一线程通知(<strong>notify</strong>)条件变量将等待的线程唤醒。相当于操作系统里的 <strong>P/V</strong> 操作。</p>
<blockquote>
<p>下面就用 P/V 代称 wait/notify。</p>
</blockquote>
<p>即使共享变量是原子的，也必须互斥地修改它，故尝试进行 P/V 的线程必须在持有锁时进行 P/V，这里的锁必须采用 <code>unique_lock</code>，因为需要 RAII 以及手动 lock/unlock。具体用法大致如下：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>

<span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">/*
   * predicate 为布尔类型表达式
   * 若 predicate == true，则 do something
   * 反之，进入休眠状态，直至被唤醒后检查到 predicate == true
   */</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>predicate<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 必须在持有锁的情况下调用 wait，会被其它线程通过 notify 唤醒</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// do something</span>

  cond<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>与互斥方式相比，条件变量的 P 操作以<strong>非竞争方式</strong>争夺资源，会进入一个等待队列，这样一来 CPU 的时间片就得到了充分利用，而不是耗费在无意义的等待上锁上。</p>
<p>接下来谈谈其<strong>成员函数</strong>。</p>
<p>首先是 <strong>wait</strong> 系列：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 1. wait</span>
<span class="token comment">// 原子地进行 unlock ，阻塞当前线程，并将它添加到等待队列。唤醒后，进行 lock 且 wait 退出。</span>
<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于 while(!pred()) { wait(lock); }，这里 pred 是一个返回 bool 值的可调用对象</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Predicate</span> <span class="token operator">&gt;</span>
<span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span> Predicate pred <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 2. wait_until</span>
<span class="token comment">// 等待至时刻 timeout_time 后若还未被唤醒，则强制唤醒</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span> <span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>cv_status <span class="token function">wait_until</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
                           <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timeout_time <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 等价于:</span>
<span class="token comment">// while (!pred()) {</span>
<span class="token comment">//   if (wait_until(lock, timeout_time) == std::cv_status::timeout) {</span>
<span class="token comment">//     return pred();</span>
<span class="token comment">//   }</span>
<span class="token comment">// }</span>
<span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Clock</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Duration</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Pred</span> <span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">wait_until</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
                 <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>time_point<span class="token operator">&lt;</span>Clock<span class="token punctuation">,</span> Duration<span class="token operator">&gt;</span><span class="token operator">&amp;</span> timeout_time<span class="token punctuation">,</span>
                 Pred pred <span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment">// 3. wait_for</span>
<span class="token comment">// 等待 rel_time 后若还未被唤醒，则强制唤醒</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span> <span class="token operator">&gt;</span>
std<span class="token double-colon punctuation">::</span>cv_status <span class="token function">wait_for</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
                         <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rel_time<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 等价于</span>
<span class="token comment">// return wait_until(lock,</span>
<span class="token comment">//                   std::chrono::steady_clock::now() + rel_time,</span>
<span class="token comment">//                   std::move(pred));</span>
<span class="token keyword">template</span><span class="token operator">&lt;</span> <span class="token keyword">class</span> <span class="token class-name">Rep</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Period</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token class-name">Predicate</span> <span class="token operator">&gt;</span>
<span class="token keyword">bool</span> <span class="token function">wait_for</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span><span class="token operator">&amp;</span> lock<span class="token punctuation">,</span>
               <span class="token keyword">const</span> std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span>duration<span class="token operator">&lt;</span>Rep<span class="token punctuation">,</span> Period<span class="token operator">&gt;</span><span class="token operator">&amp;</span> rel_time<span class="token punctuation">,</span>
               Predicate pred<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<blockquote>
<p>其中 <code>cv_status</code> 是一个枚举型变量，描述定时等待是否因时限返回。其只包含两个枚举值：</p>
<ol>
<li class="lvl-3"><code>no_timeout</code>：表示条件变量因 <code>notify_all</code> 、 <code>notify_one</code> 或虚假地被唤醒；</li>
<li class="lvl-3"><code>timeout</code>：表示条件变量因时限耗尽被唤醒；</li>
</ol>
</blockquote>
<p>接下来是 <strong>notify</strong> 系列：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// 唤醒等待队列中的某一线程，一般只有两个线程的时候才会用 notify_one，因为非此即彼。</span>
<span class="token keyword">void</span> <span class="token function">notify_one</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span>

<span class="token comment">// 唤醒等待队列中的所有线程</span>
<span class="token keyword">void</span> <span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">noexcept</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std%3A%3Acondition_variable_any" tabindex="-1"><a class="header-anchor" href="#std-condition-variable-any">#</a>std::condition_variable_any</h4>
<p>与 <code>condition_variable</code> 相比，<code>condition_variable_any</code> 是 <code>condition_variable</code> 的泛化，其支持任一 Lockable 的锁，不一定非要用 <code>unique_lock</code>。除此以外与 <code>condition_variable</code> 几乎完全一致，就不聊了。</p>
<h4 id="std%3A%3Anotify_all_at_thread_exit()" tabindex="-1"><a class="header-anchor" href="#std-notify-all-at-thread-exit">#</a>std::notify_all_at_thread_exit()</h4>
<p>在此线程完全结束时调用 <code>notify_all()</code>。函数原型为：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">notify_all_at_thread_exit</span><span class="token punctuation">(</span> std<span class="token double-colon punctuation">::</span>condition_variable<span class="token operator">&amp;</span> cond<span class="token punctuation">,</span>
                                std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> lk <span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>需要注意的是，调用该函数之前，必须首先用与 cond 绑定的相同 mutex 来创建 unique_lock 对象，并且传参时需要用 <code>move()</code> 将先前获得的锁 <code>lk</code> 的所有权转移到内部存储。</p>
<h4 id="%E5%94%A4%E9%86%92%E4%B8%A2%E5%A4%B1" tabindex="-1"><a class="header-anchor" href="#唤醒丢失">#</a>唤醒丢失</h4>
<p>上面讲条件变量用法时，我提到"<strong>尝试进行 P/V 的线程必须在持有锁时进行 P/V</strong>"，那么如果不上锁就 wait/notify 会怎样呢？不加锁便进行wait 操作的行为我们已经说过是 UB，而不加锁便进行 notify 的行为会导致<strong>唤醒丢失</strong>，且看：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case1 唤醒丢失</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread1 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread2 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>我们希望的是：thread1 首先上锁，然后 wait（此时会隐式地解锁），然后 thread2 上锁，修改 flag，唤醒 thread1，然后两个线程分别打印一条消息出来。</p>
<p>但线程是异步推进的，极有可能由于 thread2 未进行 <code>m</code> 的上锁操作，故其执行体不会被阻塞，从而出现 thread1 上锁，thread2 notify，thread1 再 wait 的执行顺序，显然会导致 thread1 无限阻塞。这便是<strong>不加锁导致唤醒丢失</strong>的经典案例。</p>
<p>为了解决这一问题，我们需要在 notify 前上锁，这样保证了在 thread1 的上锁与 wait 之间不会发生 notify 行为——thread2 会因竞争锁资源而被阻塞。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// OK</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
<span class="token keyword">bool</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread1 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread2 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面这种情况中，我们只考虑了 notify 是否会发生在上锁与 wait 之间，但 notify 也有可能发生在上锁之前，这也可能导致唤醒丢失。考虑下面这种情况：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case2 唤醒丢失</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread1</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread1 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

std<span class="token double-colon punctuation">::</span>thread <span class="token function">thread2</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"thread2 over\n"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

thread1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
thread2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>thread2 先上锁然后 notify_all（此时会隐式地解锁），再是 thread1 上锁并进行 wait。由于没有其它线程执行唤醒的工作，thread1 将永远 wait 下去——thread2 的 notify 实际上丢失了！这便是<strong>不加条件导致唤醒丢失</strong>的经典案例。</p>
<p>为了解决这一问题，我们应当加上某些限制，使得 notify 确定性地位于 wait 之后。于是需要套上一层条件判断的语句（如 <code>while</code>），检测当前是否应当 wait，套上 <code>while</code> 后，即便 thread2 首先执行，但由于 thread2 中修改了 predicate，thread1 也就能够很快检测到，能够跳过 wait 阶段。当然也可以不用 <code>while</code>，而是写成下面这种样子，这两者是等价的。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> flag<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<h4 id="%E8%99%9A%E5%81%87%E5%94%A4%E9%86%92" tabindex="-1"><a class="header-anchor" href="#虚假唤醒">#</a>虚假唤醒</h4>
<p>当上面的条件判断语句由 <code>while</code> 改为 <code>if</code> 时，便存在<strong>虚假唤醒</strong>的情况。</p>
<blockquote>
<p>当一个线程从等待一个已发出信号的条件变量中醒来，却发现它正在等待的条件不满足时，就会发生<strong>虚假唤醒</strong>。之所以称为虚假，是因为该线程似乎无缘无故地被唤醒了。但是虚假唤醒不会无缘无故地发生：它们通常会发生，因为在条件变量发出信号和等待线程最终运行之间，另一个线程运行并改变了条件。（抄自<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Spurious_wakeup">百科</a>）</p>
</blockquote>
<p>用一个例子来说明：在<strong>生产者消费者</strong>问题中，生产者每生产出一个产品，就通知所有消费者；当所有消费者被唤醒时，它们对产品的获取顺序为竞争关系，此时第一个赢得竞争的消费者取走了产品，而之后的消费者会发现并没有任何产品存在，又此时已经退出了 wait 阶段，也就继续推进下去直至消亡，最后就导致只有一个消费者进行了消费。比如下面这段代码：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token comment">// case3 虚假唤醒</span>
std<span class="token double-colon punctuation">::</span>mutex m<span class="token punctuation">;</span>
std<span class="token double-colon punctuation">::</span>condition_variable cond<span class="token punctuation">;</span>
<span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">// 产品</span>

<span class="token keyword">void</span> <span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    cond<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">void</span> <span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>unique_lock<span class="token operator">&lt;</span>std<span class="token double-colon punctuation">::</span>mutex<span class="token operator">&gt;</span> <span class="token function">lock</span><span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span>
  cnt<span class="token operator">++</span><span class="token punctuation">;</span>
  cond<span class="token punctuation">.</span><span class="token function">notify_all</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>解决办法就是<strong>将 wait 放到条件判断循环中</strong>，即类似于上一节中第二段代码。</p>
<h3 id="%3C-future-%3E" tabindex="-1"><a class="header-anchor" href="#future">#</a>&lt; future &gt;</h3>
<h4 id="std%3A%3Afuture" tabindex="-1"><a class="header-anchor" href="#std-future">#</a>std::future</h4>
<p><code>std::future</code> 类型变量可以用于保存某个异步任务的结果（<strong>共享变量</strong>），并且内含一个状态(state)来表示该任务是否完成(ready)。因此可以把它当成一种简单的线程间同步的手段。通常由某个 “Provider” 创建，并在未来的某个线程中设置共享变量的值（future 因此得名），另外一个线程中与该共享变量相关联的 <code>std::future</code> 对象调用 <code>get()</code> 获取该值。</p>
<p>如果共享变量中 <code>state != ready</code>，则对 <code>std::future::get()</code> 的调用会阻塞，直到 Provider 设置了共享变量的值（然后 <code>state == ready</code>），这才返回异步任务的值或异常（如果发生了异常）。</p>
<h4 id="std%3A%3Apromise" tabindex="-1"><a class="header-anchor" href="#std-promise">#</a>std::promise</h4>
<p><code>std::promise&lt;T&gt;</code> 属于 Provider。它关联了一个 <code>std::future&lt;T&gt;</code> 对象，并可以通过 <code>get_future()</code> 返回该对象。同样的，它也可以通过 <code>set_value(T)</code> 进行共享变量的赋值，从而唤醒另一个调用了 <code>std::future::get()</code> 的线程（如果有）。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;functional&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">void</span> <span class="token function">print_int</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span><span class="token operator">&amp;</span> fut<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">int</span> x <span class="token operator">=</span> fut<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment">// 1. 阻塞</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"value: "</span> <span class="token operator">&lt;&lt;</span> x <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>  <span class="token comment">// 3. 打印 value: 10.</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>promise<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> prom<span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> fut <span class="token operator">=</span> prom<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>thread <span class="token function">t</span><span class="token punctuation">(</span>print_int<span class="token punctuation">,</span> std<span class="token double-colon punctuation">::</span><span class="token function">ref</span><span class="token punctuation">(</span>fut<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  prom<span class="token punctuation">.</span><span class="token function">set_value</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 2. 线程 t 结束对 fut.get() 的阻塞</span>
  t<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// value: 10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="std%3A%3Apackaged_task" tabindex="-1"><a class="header-anchor" href="#std-packaged-task">#</a>std::packaged_task</h4>
<p><code>std::packaged_task&lt;T(Args...)&gt;</code> 也是 Provider。它除了关联一个 <code>std::future&lt;T&gt;</code> 对象，还包装了一个类型为 <code>T(Args...)</code> 的<strong>可调用对象</strong>。packaged_task 实现了 <code>operator()</code>（因而可以作为 <code>std::thread</code> 的初始化参数），调用一个 packaged_task 相当于调用内含的可调用对象，并将返回值或异常存在关联的 future 里。</p>
<p>当线程 a 用一个 <code>std::packaged_task</code> 初始化新线程 b 时，a 可以调用 <code>std::packaged_task::get_future()</code> 返回一个 future 对象，并调用 <code>get()</code> 阻塞直至 b 执行完返回。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;chrono&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;future&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;thread&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">int</span> from<span class="token punctuation">,</span> <span class="token keyword">int</span> to<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> from<span class="token punctuation">;</span> i <span class="token operator">!=</span> to<span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> i <span class="token operator">&lt;&lt;</span> <span class="token char">'\n'</span><span class="token punctuation">;</span>
    std<span class="token double-colon punctuation">::</span>this_thread<span class="token double-colon punctuation">::</span><span class="token function">sleep_for</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span>chrono<span class="token double-colon punctuation">::</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"Finished!\n"</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> from <span class="token operator">-</span> to<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// contruct a packaged_task</span>
  std<span class="token double-colon punctuation">::</span>future<span class="token operator">&lt;</span><span class="token keyword">int</span><span class="token operator">&gt;</span> ret <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// get its future</span>

  std<span class="token double-colon punctuation">::</span>thread <span class="token function">th</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">int</span> value <span class="token operator">=</span> ret<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// wait until count() is done</span>

  std<span class="token double-colon punctuation">::</span>cout <span class="token operator">&lt;&lt;</span> <span class="token string">"The countdown lasted for "</span> <span class="token operator">&lt;&lt;</span> value <span class="token operator">&lt;&lt;</span> <span class="token string">" seconds.\n"</span><span class="token punctuation">;</span>

  th<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// output:</span>
<span class="token comment">// 10</span>
<span class="token comment">// 9</span>
<span class="token comment">// 8</span>
<span class="token comment">// 7</span>
<span class="token comment">// 6</span>
<span class="token comment">// 5</span>
<span class="token comment">// 4</span>
<span class="token comment">// 3</span>
<span class="token comment">// 2</span>
<span class="token comment">// 1</span>
<span class="token comment">// Finished!</span>
<span class="token comment">// The countdown lasted for 10 seconds.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="pthread(posix-thread)" tabindex="-1"><a class="header-anchor" href="#pthread-POSIX-thread">#</a>pthread(POSIX thread)</h2>
<p>pthread 是一个在类 UNIX 系统下广泛使用的并发包，Linux 系统下在 glibc 库里实现。</p>
<h3 id="pthread_mutex_t" tabindex="-1"><a class="header-anchor" href="#pthread-mutex-t">#</a>pthread_mutex_t</h3>
<p>这是 pthread 中对于锁的数据结构定义，如下所示：</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">typedef</span> <span class="token keyword">union</span>
<span class="token punctuation">{</span>
  <span class="token keyword">struct</span> <span class="token class-name">__pthread_mutex_s</span>
  <span class="token punctuation">{</span>
    <span class="token keyword">int</span> __lock<span class="token punctuation">;</span>             <span class="token comment">// 锁状态。0: 未占用；1: 占用</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __count<span class="token punctuation">;</span>   <span class="token comment">// 为可重入锁所使用，表示持有锁的次数</span>
    <span class="token keyword">int</span> __owner<span class="token punctuation">;</span>            <span class="token comment">// 持有锁的 thread id</span>
    <span class="token keyword">unsigned</span> <span class="token keyword">int</span> __nusers<span class="token punctuation">;</span>
    <span class="token comment">/* KIND must stay at this position in the structure to maintain binary compatibility. */</span>
    <span class="token keyword">int</span> __kind<span class="token punctuation">;</span>             <span class="token comment">// 锁类型。</span>
                            <span class="token comment">// PTHREAD_MUTEX_TIMED_NP:      普通锁(默认值)</span>
                            <span class="token comment">// PTHREAD_MUTEX_RECURSIVE_NP:  可重入锁</span>
                            <span class="token comment">// PTHREAD_MUTEX_ADAPTIVE_NP:   自适应锁</span>
                            <span class="token comment">// PTHREAD_MUTEX_ERRORCHECK_NP: 检错锁</span>
    <span class="token keyword">int</span> __spins<span class="token punctuation">;</span>            <span class="token comment">// 当前已自旋次数，用于计算自适应锁单次最大自旋次数</span>
    __pthread_list_t __list<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> __data<span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span> pthread_mutex_t<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="pthread_mutex_lock(mutex)" tabindex="-1"><a class="header-anchor" href="#pthread-mutex-lock-mutex">#</a>pthread_mutex_lock(mutex)</h3>
<p>这是提供给用户的加锁函数，内部会判断锁的类型，并执行不同的上锁策略。</p>
<h4 id="%E6%99%AE%E9%80%9A%E9%94%81" tabindex="-1"><a class="header-anchor" href="#普通锁">#</a>普通锁</h4>
<p>对于<strong>普通锁</strong>，直接进行加锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_likely</span> <span class="token punctuation">(</span>type <span class="token operator">==</span> PTHREAD_MUTEX_TIMED_NP<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 普通锁 */</span>
  simple<span class="token operator">:</span>
    <span class="token function">LLL_MUTEX_LOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">assert</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81" tabindex="-1"><a class="header-anchor" href="#可重入锁">#</a>可重入锁</h4>
<p>对于<strong>可重入锁</strong>，如果同一线程加锁，则直接增加计数器；否则，像普通锁一样加锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">PTHREAD_MUTEX_TYPE</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">==</span> PTHREAD_MUTEX_RECURSIVE_NP<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 可重入锁 */</span>
  pid_t id <span class="token operator">=</span> <span class="token function">THREAD_GETMEM</span> <span class="token punctuation">(</span>THREAD_SELF<span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__count <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token comment">/* 意思是当前计数器达到了 unsigned int 的上界 */</span>
      <span class="token keyword">return</span> EAGAIN<span class="token punctuation">;</span>

    <span class="token operator">++</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__count<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span>
  <span class="token punctuation">}</span>

  <span class="token function">LLL_MUTEX_LOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="%E8%87%AA%E9%80%82%E5%BA%94%E9%94%81" tabindex="-1"><a class="header-anchor" href="#自适应锁">#</a>自适应锁</h4>
<p>对于<strong>自适应锁</strong>，则是首先进行一定次数的「自旋」，如果达到次数上限后依然没有获得锁，则像普通锁一样加锁。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_expect</span> <span class="token punctuation">(</span><span class="token function">PTHREAD_MUTEX_TYPE</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">==</span> PTHREAD_MUTEX_ADAPTIVE_NP<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 自适应锁 */</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> __is_smp<span class="token punctuation">)</span>
    <span class="token comment">/* 如果不是 SMP 系统，则跳过自旋，直接像普通锁一样加锁 */</span>
    <span class="token keyword">goto</span> simple<span class="token punctuation">;</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">LLL_MUTEX_TRYLOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">int</span> max_cnt <span class="token operator">=</span> <span class="token function">MIN</span> <span class="token punctuation">(</span>MAX_ADAPTIVE_COUNT<span class="token punctuation">,</span> mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__spins <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">do</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>cnt<span class="token operator">++</span> <span class="token operator">&gt;=</span> max_cnt<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">LLL_MUTEX_LOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      <span class="token function">atomic_spin_nop</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">LLL_MUTEX_TRYLOCK</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">/* 如果这次自旋次数少，说明竞争不激烈，之后可以减少最大自旋次数；反之需要更多次的竞争 */</span>
    mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__spins <span class="token operator">+=</span> <span class="token punctuation">(</span>cnt <span class="token operator">-</span> mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__spins<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">8</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="%E6%A3%80%E9%94%99%E9%94%81" tabindex="-1"><a class="header-anchor" href="#检错锁">#</a>检错锁</h4>
<p>对于<strong>检错锁</strong>，则首先检查是否为同一线程重复上锁，是一种简单的避免死锁的逻辑。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">else</span> <span class="token punctuation">{</span>
  <span class="token comment">/* 检错锁 */</span>
  pid_t id <span class="token operator">=</span> <span class="token function">THREAD_GETMEM</span> <span class="token punctuation">(</span>THREAD_SELF<span class="token punctuation">,</span> tid<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">assert</span> <span class="token punctuation">(</span><span class="token function">PTHREAD_MUTEX_TYPE</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span> <span class="token operator">==</span> PTHREAD_MUTEX_ERRORCHECK_NP<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>mutex<span class="token operator">-&gt;</span>__data<span class="token punctuation">.</span>__owner <span class="token operator">==</span> id<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> EDEADLK<span class="token punctuation">;</span>

  <span class="token keyword">goto</span> simple<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="lll_mutex_lock(mutex)" tabindex="-1"><a class="header-anchor" href="#LLL-MUTEX-LOCK-mutex">#</a>LLL_MUTEX_LOCK(mutex)</h3>
<p>这其实是一个宏，将其展开后我们可以得到 <code>__lll_lock(&amp;((mutex)-&gt;__data.__lock), PTHREAD_MUTEX_PSHARED (mutex))</code>。所以其实是走了 <code>__lll_lock()</code> 宏，第二个参数用于获取当前锁是否为共享锁（读锁）。</p>
<p>来看看上锁的策略吧！简单来说就是先尝试用 CAS 获取锁，如果获取失败（被占用）就执行 <code>__lll_lock_wait*()</code> 挂起等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__lll_lock</span><span class="token expression"><span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>                                      </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                                                               </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                                   </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span>__futex <span class="token operator">=</span> <span class="token punctuation">(</span>futex<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span>__glibc_unlikely                                               </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token punctuation">(</span><span class="token function">atomic_compare_and_exchange_bool_acq</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        </span><span class="token punctuation">\</span>
       <span class="token expression"><span class="token punctuation">{</span>                                                                </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__builtin_constant_p</span> <span class="token punctuation">(</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token operator">==</span> LLL_PRIVATE<span class="token punctuation">)</span></span><span class="token punctuation">\</span>
           <span class="token expression"><span class="token function">__lll_lock_wait_private</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">)</span><span class="token punctuation">;</span>                           </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token keyword">else</span>                                                           </span><span class="token punctuation">\</span>
           <span class="token expression"><span class="token function">__lll_lock_wait</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          </span><span class="token punctuation">\</span>
       <span class="token expression"><span class="token punctuation">}</span>                                                                </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>发现这里有个 <code>futex</code>，对此，源码里面的注释是这样的：</p>
<p>「If FUTEX is 0 (not acquired), set to 1 (acquired with no waiters) and return.</p>
<p>Otherwise, ensure that it is &gt;1 (acquired, possibly with waiters) and then block until we acquire the lock, at which point FUTEX will still be &gt; 1.</p>
<p>The lock is always acquired on return.」</p>
<blockquote>
<p>这里是直接把 <code>pthread_mutex_t</code> 里的 <code>__lock</code> 拿来当 futex 使了。</p>
</blockquote>
<h4 id="__lll_lock_wait()" tabindex="-1"><a class="header-anchor" href="#lll-lock-wait">#</a>__lll_lock_wait()</h4>
<p><code>*futex</code> 为 2 表示 “acquired, possibly with waiters”，所以如果已经为 2 了，就直接等待；之后检查锁状态是否为 0，然后将其置 2，如果最开始状态非 0 则等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token keyword">void</span> <span class="token function">__lll_lock_wait</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span>futex<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token keyword">private</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">*</span>futex <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token function">lll_futex_wait</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Wait if *futex == 2. */</span>

  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">atomic_exchange_acq</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token function">lll_futex_wait</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* Wait if *futex == 2. */</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lll_futex_wait()%2Flll_futex_timed_wait()" tabindex="-1"><a class="header-anchor" href="#lll-futex-wait-lll-futex-timed-wait">#</a>lll_futex_wait()/lll_futex_timed_wait()</h4>
<p><code>lll_futex_wait</code> 这个宏走的是 <code>lll_futex_timed_wait()</code>。如果 lll_futex_wake 后 *futexp 值还是 val，则以 <strong>FUTEX_WAIT</strong> 执行系统调用 <code>futex()</code> 进行等待。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_futex_timed_wait</span><span class="token expression"><span class="token punctuation">(</span>futexp<span class="token punctuation">,</span> val<span class="token punctuation">,</span> timeout<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>     </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">lll_futex_syscall</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> futexp<span class="token punctuation">,</span>                                 </span><span class="token punctuation">\</span>
         <span class="token expression"><span class="token function">__lll_private_flag</span> <span class="token punctuation">(</span>FUTEX_WAIT<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">,</span>              </span><span class="token punctuation">\</span>
         <span class="token expression">val<span class="token punctuation">,</span> timeout<span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_futex_syscall</span><span class="token expression"><span class="token punctuation">(</span>nargs<span class="token punctuation">,</span> futexp<span class="token punctuation">,</span> op<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>                       </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                                    </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token function">INTERNAL_SYSCALL_DECL</span> <span class="token punctuation">(</span>__err<span class="token punctuation">)</span><span class="token punctuation">;</span>                                      </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">int</span> __ret <span class="token operator">=</span> <span class="token function">INTERNAL_SYSCALL</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> __err<span class="token punctuation">,</span> nargs<span class="token punctuation">,</span> futexp<span class="token punctuation">,</span> op<span class="token punctuation">,</span> </span><span class="token punctuation">\</span>
               <span class="token expression">__VA_ARGS__<span class="token punctuation">)</span><span class="token punctuation">;</span>                                            </span><span class="token punctuation">\</span>
    <span class="token expression"><span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span><span class="token function">INTERNAL_SYSCALL_ERROR_P</span> <span class="token punctuation">(</span>__ret<span class="token punctuation">,</span> __err<span class="token punctuation">)</span><span class="token punctuation">)</span>         </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token operator">?</span> <span class="token operator">-</span><span class="token function">INTERNAL_SYSCALL_ERRNO</span> <span class="token punctuation">(</span>__ret<span class="token punctuation">,</span> __err<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h3 id="lll_unlock()" tabindex="-1"><a class="header-anchor" href="#lll-unlock">#</a>lll_unlock()</h3>
<p>释放锁的核心函数。无条件将锁的状态置 0，如果旧状态值为 2，则还需要执行 <code>lll_futex_wake</code> 去唤醒等待的线程，此时第一个竞争成功的线程通过 <code>atomic_exchange_acq (futex, 2)</code> 将状态置 2 后成功获取到锁，如此往复。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">__lll_unlock</span><span class="token expression"><span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>                   </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>                                              </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                  </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">int</span> <span class="token operator">*</span>__futex <span class="token operator">=</span> <span class="token punctuation">(</span>futex<span class="token punctuation">)</span><span class="token punctuation">;</span>                           </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">int</span> __oldval <span class="token operator">=</span> <span class="token function">atomic_exchange_rel</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span><span class="token punctuation">\</span>
     <span class="token expression"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">__glibc_unlikely</span> <span class="token punctuation">(</span>__oldval <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>              </span><span class="token punctuation">\</span>
       <span class="token expression"><span class="token function">lll_futex_wake</span> <span class="token punctuation">(</span>__futex<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           </span><span class="token punctuation">\</span>
   <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span></span></span>

<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_unlock</span><span class="token expression"><span class="token punctuation">(</span>futex<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>    </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token function">__lll_unlock</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>futex<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h4 id="lll_futex_wake()" tabindex="-1"><a class="header-anchor" href="#lll-futex-wake">#</a>lll_futex_wake()</h4>
<p>以 <strong>FUTEX_WAKE</strong> 去执行系统调用 <code>futex()</code>。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name function">lll_futex_wake</span><span class="token expression"><span class="token punctuation">(</span>futexp<span class="token punctuation">,</span> nr<span class="token punctuation">,</span> <span class="token keyword">private</span><span class="token punctuation">)</span>            </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">(</span><span class="token punctuation">{</span>                                                   </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token function">INTERNAL_SYSCALL_DECL</span> <span class="token punctuation">(</span>__err<span class="token punctuation">)</span><span class="token punctuation">;</span>                 </span><span class="token punctuation">\</span>
        <span class="token expression"><span class="token keyword">long</span> <span class="token keyword">int</span> __ret<span class="token punctuation">;</span>                                </span><span class="token punctuation">\</span>
        <span class="token expression">__ret <span class="token operator">=</span> <span class="token function">INTERNAL_SYSCALL</span> <span class="token punctuation">(</span>futex<span class="token punctuation">,</span> __err<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span>     </span><span class="token punctuation">\</span>
                       <span class="token expression"><span class="token punctuation">(</span>futexp<span class="token punctuation">)</span><span class="token punctuation">,</span> FUTEX_WAKE<span class="token punctuation">,</span> <span class="token punctuation">(</span>nr<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span><span class="token punctuation">\</span>
        <span class="token expression">__ret<span class="token punctuation">;</span>                                         </span><span class="token punctuation">\</span>
  <span class="token expression"><span class="token punctuation">}</span><span class="token punctuation">)</span></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<h2 id="%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8" tabindex="-1"><a class="header-anchor" href="#并发应用">#</a>并发应用</h2>
<h3 id="%E6%97%A0%E9%94%81%E9%98%9F%E5%88%97(lockless-queue)" tabindex="-1"><a class="header-anchor" href="#无锁队列-Lockless-Queue">#</a>无锁队列(Lockless Queue)</h3>
<p>可参考<a target="_blank" rel="noopener" href="https://coolshell.cn/articles/8239.html">这篇文章</a>。</p>
<h3 id="%E7%BA%BF%E7%A8%8B%E6%B1%A0(thread-pool)" tabindex="-1"><a class="header-anchor" href="#线程池-Thread-Pool">#</a>线程池(Thread Pool)</h3>
<p>利用 <code>std::future</code> 和 <code>std::packaged_task</code>，我们可以实现一个支持异步返回结果的<strong>线程池</strong>。</p>
<p>和普通的仅支持<strong>执行但不返回结果</strong>的线程池相比，其核心在于一个 <code>ThreadPool::execute()</code> 执行函数。该函数为模板函数，允许传入一个可调用对象及其参数列表，内部通过 <code>std::packaged_task</code> 包装后交付给空闲线程执行，并将返回结果保存在其关联的 <code>std::future</code> 对象中。执行函数可以返回这个 future，并让用户通过 <code>std::future::get()</code> 等待执行结果。</p>
<pre class="line-numbers language-cpp" data-language="cpp"><div class="caption"><span>线程池</span></div><code class="language-cpp"><span class="token keyword">template</span><span class="token operator">&lt;</span><span class="token keyword">class</span> <span class="token class-name">F</span><span class="token punctuation">,</span> <span class="token keyword">class</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>Args<span class="token operator">&gt;</span>
<span class="token keyword">auto</span> <span class="token class-name">ThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">execute</span><span class="token punctuation">(</span>F<span class="token operator">&amp;&amp;</span> callable<span class="token punctuation">,</span> Args<span class="token operator">&amp;&amp;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>args<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">callable</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">using</span> returnType <span class="token operator">=</span> <span class="token keyword">decltype</span><span class="token punctuation">(</span><span class="token function">callable</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>packaged_task<span class="token operator">&lt;</span><span class="token function">returnType</span><span class="token punctuation">(</span>Args<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token operator">&gt;</span> <span class="token function">task</span><span class="token punctuation">(</span>callable<span class="token punctuation">)</span><span class="token punctuation">;</span>
  std<span class="token double-colon punctuation">::</span>future result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">get_future</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  taskQueue<span class="token punctuation">.</span><span class="token function">emplace</span><span class="token punctuation">(</span>std<span class="token double-colon punctuation">::</span><span class="token function">move</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 加入就绪队列，唤醒线程取出任务并执行</span>

  <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>

<span class="token keyword">int</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">&gt;</span> b <span class="token operator">?</span> a <span class="token operator">:</span> b<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  ThreadPool<span class="token operator">&amp;</span> tp <span class="token operator">=</span> <span class="token class-name">ThreadPool</span><span class="token double-colon punctuation">::</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 单例模式</span>
  <span class="token keyword">int</span> res <span class="token operator">=</span> tp<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  cout <span class="token operator">&lt;&lt;</span> res<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            <span class="chip bg-color">这个人太懒了，都不想加标签</span>
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="qq,wechat" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/c/c-smartptr/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="C++11 の 智能指针(Smart Pointer)">
                        
                        <span class="card-title">C++11 の 智能指针(Smart Pointer)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            C++ 不像 Java 那样有虚拟机动态的管理内存，如果使用裸指针，在程序运行过程中可能就会出现内存泄漏等问题，然而这种问题其实都可以通过 C++11 引入的智能指针来解决。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2023-02-02
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/c/c-init/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="C++11 の 列表初始化(List Initialize)">
                        
                        <span class="card-title">C++11 の 列表初始化(List Initialize)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            在 C++11 中，可以直接在变量名后面用 {初始化列表} 来进行对象的初始化。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2023-01-28
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/C/" class="post-category">
                                    C++
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>


  <!-- 是否加载使用自带的 prismjs. -->
  <script type="text/javascript" src="/libs/prism/prism.min.js"></script>


<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>


<script src="https://cdn.bootcss.com/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
    MathJax.Hub.Config({
        tex2jax: {inlineMath: [['$', '$'], ['\\(', '\\)']]}
    });
</script>



    <footer class="page-footer bg-color">
    

    <div class="container row center-align"
         style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2023-2025</span>
            
            <a href="/about" target="_blank">Leager</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            
                <span id="translate">|&nbsp;繁/简：</span><a id="translateLink" href="javascript:translatePage();">繁</a>
            
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
                <span id="sitetime"> Loading ...</span>
                <script>
                    var calcSiteTime = function () {
                        var seconds = 1000;
                        var minutes = seconds * 60;
                        var hours = minutes * 60;
                        var days = hours * 24;
                        var years = days * 365;
                        var today = new Date();
                        var startYear = "2023";
                        var startMonth = "8";
                        var startDate = "1";
                        var startHour = "0";
                        var startMinute = "0";
                        var startSecond = "0";
                        var todayYear = today.getFullYear();
                        var todayMonth = today.getMonth() + 1;
                        var todayDate = today.getDate();
                        var todayHour = today.getHours();
                        var todayMinute = today.getMinutes();
                        var todaySecond = today.getSeconds();
                        var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                        var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                        var diff = t2 - t1;
                        var diffYears = Math.floor(diff / years);
                        var diffDays = Math.floor((diff / days) - diffYears * 365);

                        // 区分是否有年份.
                        var language = 'zh-CN';
                        if (startYear === String(todayYear)) {
                            document.getElementById("year").innerHTML = todayYear;
                            var daysTip = 'This site has been running for ' + diffDays + ' days';
                            if (language === 'zh-CN') {
                                daysTip = '本站已运行 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                daysTip = '本站已運行 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = daysTip;
                        } else {
                            document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                            var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                + diffDays + ' days';
                            if (language === 'zh-CN') {
                                yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            } else if (language === 'zh-HK') {
                                yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                            }
                            document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                        }
                    }

                    calcSiteTime();
                </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/Leager-zju" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1004729740@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1004729740" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1004729740" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        <script type="text/javascript" src="/js/tw_cn.js"></script>
        <script type="text/javascript">
          var defaultEncoding = 2; //网站编写字体是否繁体，1-繁体，2-简体
          var translateDelay = 0; //延迟时间,若不在前, 要设定延迟翻译时间, 如100表示100ms,默认为0
          var cookieDomain = "http://Leager-zju.github.io"; //Cookie地址, 一定要设定, 通常为你的网址
          var msgToTraditionalChinese = "繁"; //此处可以更改为你想要显示的文字
          var msgToSimplifiedChinese = "简"; //同上，但两处均不建议更改
          var translateButtonId = "translateLink"; //默认互换id
          translateInitilization();
        </script>
    
    
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

    <script type="text/javascript">
        document.addEventListener('visibilitychange', function () {
            if (document.hidden) {
                document.title = '你会有一天后悔';
            } else {
                document.title = '欢迎来到 G8 北海道 洞爷湖 高峰会 博物馆';
            }
        });
    </script>

</body>

</html>
